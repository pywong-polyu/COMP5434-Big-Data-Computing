{"paper_id": "bbd1134ee4f2d109bdce6e9a4f4a5d8df5b5804a", "metadata": {"title": "Backward-Forward Sequence Generative Network for Multiple Lexical Constraints", "authors": [{"first": "Seemab", "middle": [], "last": "Latif", "suffix": "", "affiliation": {"laboratory": "", "institution": "National University of Sciences and Technology (NUST)", "location": {"settlement": "Islamabad", "country": "Pakistan"}}, "email": "seemab.latif@seecs.edu.pk"}, {"first": "Sarmad", "middle": [], "last": "Bashir", "suffix": "", "affiliation": {"laboratory": "", "institution": "National University of Sciences and Technology (NUST)", "location": {"settlement": "Islamabad", "country": "Pakistan"}}, "email": ""}, {"first": "Mir", "middle": [], "last": "Muntasar", "suffix": "", "affiliation": {}, "email": ""}, {"first": "Ali", "middle": [], "last": "Agha", "suffix": "", "affiliation": {"laboratory": "", "institution": "National University of Sciences and Technology (NUST)", "location": {"settlement": "Islamabad", "country": "Pakistan"}}, "email": ""}, {"first": "Rabia", "middle": [], "last": "Latif", "suffix": "", "affiliation": {"laboratory": "", "institution": "Prince Sultan University", "location": {"settlement": "Riyadh", "country": "Saudi Arabia"}}, "email": "rlatif@psu.edu.sa"}]}, "abstract": [{"text": "Advancements in Long Short Term Memory (LSTM) Networks have shown remarkable success in various Natural Language Generation (NLG) tasks. However, generating sequence from pre-specified lexical constraints is a new, challenging and less researched area in NLG. Lexical constraints take the form of words in the language model's output to create fluent and meaningful sequences. Furthermore, most of the previous approaches cater this problem by allowing the inclusion of pre-specified lexical constraints during the decoding process, which increases the decoding complexity exponentially or linearly with the number of constraints. Moreover, some of the previous approaches can only deal with single constraint. Additionally, most of the previous approaches only deal with single constraints. In this paper, we propose a novel neural probabilistic architecture based on backward-forward language model and word embedding substitution method that can cater multiple lexical constraints for generating quality sequences. Experiments shows that our proposed architecture outperforms previous methods in terms of intrinsic evaluation.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Recently, Recurrent Neural Networks (RNNs) and their variants such as Long Short Term Memory Networks (LSTMs) and Gated Recurrent Units (GRUs) based language models have shown promising results in generating high quality text sequences, especially when the input and output are of variable length. RNN based Language Models (LM) have the ability to capture the sequential nature of language, be it for words, characters or whole sentences. This allows them to outperform other language models in sequence prediction and classification tasks. To learn the distributed representation of data efficiently by RNNs, multiple methods have been proposed such as word embeddings. It mainly include Continuous Bag-Of-Words (CBOW) and Skip-Gram (SG) model [10, 12] . CBOW model predicts the word as vector at a current time step, given preceding and proceeding context word vectors. The SG model is opposite in approach to predict the representation of target word vector, but same in the architecture.", "cite_spans": [{"start": 746, "end": 750, "text": "[10,", "ref_id": "BIBREF9"}, {"start": 751, "end": 754, "text": "12]", "ref_id": "BIBREF11"}], "ref_spans": [], "section": "Introduction"}, {"text": "Existing methods to incorporate constraints in the output sentences or generating lexical constrained sentences have multiple limitations. [13] proposed variants of backward-forward generation approach which can not handle Out-of-Vocabulary (OOV) words and only generate sentences with single lexical constraint. Similarly, [8] proposed a synchronous training approach to generate lexical constrained sequences with Generative Adversarial Networks (GANs). Moreover, various lexical constrained decoding methods have been proposed for constrained sequence generation through the extension of beam search to allow the inclusion of constraints [1, 6] . Such lexical constrained decoding methods do not examine what specific words need to be included at the start of generation, but try to force specific words at each time step during the generation process at a cost of high computational complexity [14] .", "cite_spans": [{"start": 139, "end": 143, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 324, "end": 327, "text": "[8]", "ref_id": "BIBREF7"}, {"start": 641, "end": 644, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 645, "end": 647, "text": "6]", "ref_id": "BIBREF5"}, {"start": 898, "end": 902, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Introduction"}, {"text": "The remainder of this paper is organized as follows. We review the related work in Sect. 2. Section 3 describes our proposed architecture and Sect. 4 explains the dataset, experimental setup, comparison models and evaluation criteria. Section 5 gives in detail result analysis, finding and discussions about future directions. Finally, Sect. 6 concludes the paper.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "In general, the purpose of LM is to capture the regularities of a language as well as its morphological and distributional properties. LM aims to compute the probability of a word sequence in order to estimate the maximum likelihood of an upcoming word to be predicted in the sequence. LM learns the distributed representation of words to interpret semantic and syntactic relations between the sequence of words. In past, RNN has shown progressive success in language modeling over traditional methods based on statistical counts. The ability of RNN Language Model (RNNLM) to learn long term contextual dependency and capturing inherited sequential nature of language makes it better than other traditional methods [11] . Particularly in sentence generation task, RNNLM performed well because of its capability of learning highly complicated structures of language. RNNLM makes Maximum A Posteriori (MAP) estimation for predicting words in a sentence [17] .", "cite_spans": [{"start": 715, "end": 719, "text": "[11]", "ref_id": "BIBREF10"}, {"start": 951, "end": 955, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Literature Review"}, {"text": "Mou et al. first proposed multiple variants of Backward and Forward (B/F) language models based on GRUs for constrained sentence generation [13] . For training the B/F language models, sentences were split by choosing a word randomly. This resulted in the positional information of words getting smoothed out while generating sentences, and thus they lose the positional information of the word. This method of choosing a split word badly influences the joint probability estimation of a sentence. Liu et al. proposed an algorithmic framework dubbed as Backward and Forward Generative Adversarial Networks (BFGAN) for constrained sentence generation [8] . BFGAN constitutes three modules; a discriminator, LSTM based backward and a forward generator with attention mechanism. The purpose of discriminator is to distinguish the real sentences from constrained sentences generated by machine and to guide the joint training of both backward and forward generators by assigning them reward signals. The backward generator takes lexical constraint as an input, which can be a word, phrase or fragment and generate the first half of the sentence backwards. The Forward generator takes the input half sentence generated by backward generator to complete the sentence with the aim of fooling the discriminator. The sentences prepared for training of backward generator relies on random splitting of sentences and the proposed framework can tackle single lexical constrained sentence generation.", "cite_spans": [{"start": 140, "end": 144, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 498, "end": 508, "text": "Liu et al.", "ref_id": null}, {"start": 650, "end": 653, "text": "[8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Literature Review"}, {"text": "Another line of work tackles the problem of constrained sentence generation by sampling the sentences from search space. Su et al. proposed a Gibbs sampling method based on Markov Chain Monte Carlo (MCMC) method for decoding constrained sentences [16] . The proposed approach consists of a discriminator and a pure language model conditioned on a bi-directional RNN. Introducing discriminator in the proposed method caters the job for calculating probability of a sentence satisfying the constraints. Gibbs method samples the set of random variables x 1 ...n from a joint distribution, which takes the form of words to make a sentence. The shortcoming of Gibbs sampling is that it cannot change the length of sentences and hence not able to solve complicated tasks like directly generating sentences from constraints established in advance. Miao et al. extends Gibbs sampling by introducing Metropolis-Hastings for Constrained Sentence Generation (CGMH) [9] . The proposed method directly samples from the sentence space by defining local operations in the sentence space such as word replacement, insertion and deletion.", "cite_spans": [{"start": 247, "end": 251, "text": "[16]", "ref_id": "BIBREF15"}, {"start": 954, "end": 957, "text": "[9]", "ref_id": "BIBREF8"}], "ref_spans": [], "section": "Literature Review"}, {"text": "Hokamp et al. proposed Grid Beam Search (GBS) algorithm, an extension of beam search, for incorporating specified lexical constraints in the output sequences [6] . In Neural Machine Translation (NMT) task, the proposed algorithm ensures that all specified constraints must meet the hypothesis before they can be considered to be completed. To generalize image caption generative models for out-of-domain images constituting novel scenes or objects, Anderson et al. proposed a Constrained Beam Search (CBS) decoding method, which utilizes Finite-State Machine (FSM) [1] . The proposed search algorithm is capable of forcing certain image tags over resulting output sequences by recognizing valid sequences with FSM. Table 1 summarizes techniques for generating constrained sequences. It is evident that many of the architectures are designed for specific scenarios and have high computational complexity. Due to performance gaps and inability to handle multiple constraints efficiently, a method need to be addressed. Therefore, we have proposed a neural probabilistic Backward-Forward architecture that can generate high quality sequences, with word embedding substitution method to satisfy multiple constraints. ", "cite_spans": [{"start": 158, "end": 161, "text": "[6]", "ref_id": "BIBREF5"}, {"start": 565, "end": 568, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [{"start": 715, "end": 722, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Literature Review"}, {"text": "To begin with, we state the problem of constrained sequence generation as follows: given the constraint(s) c as input, the proposed B/F LM needs to generate a fluent sequence s = w 1 , \u00b7 \u00b7 \u00b7, w v , \u00b7 \u00b7 \u00b7, w m maximizing the conditional probability p(s|c). For this purpose, we need to select a split word in a sequence s to train the proposed B/F LM. As a sequence provides us an expression, the Parts-Of-Speech (POS) verb plays a vital role in placing the subject of a sequence into motion and offers more clarification about sequence. In this section, we first discuss the general seq2seq model for generation of sequences. After that, we discuss our proposed architecture to deal with constrained sequence generation. Conventionally, RNNLMs for text generation are trained to maximize the likelihood of a word w t or character c t at time step t while given the context of previous observations in the sequence. This type of learning technique for generating sequences is known as teacher forcing [4] . In such learning technique, input to the recurrent neural probabilistic language model is of fixed size. The training purpose is to predict only next token until a special stop sign is generated or specific constraint is satisfied in a sequence given the context of previous observations.", "cite_spans": [{"start": 1000, "end": 1003, "text": "[4]", "ref_id": "BIBREF3"}], "ref_spans": [], "section": "General Model"}, {"text": "In traditional seq2seq models we cannot satisfy lexical constraints, where disintegrating joint probability of a sentence y = y 1 , y 2 \u00b7 \u00b7 \u00b7y m for given input sentence x = x 1 , x 2 \u00b7 \u00b7 \u00b7x n is given by Thus, the output sentence y is predicted from y 1 to y m in sequence either by a greedy or beam decoder. Such decomposition is because of natural language's sequential nature.", "cite_spans": [], "ref_spans": [], "section": "General Model"}, {"text": "Our proposed approach consists of a neural probabilistic architecture that is an ensemble of two LSTM based B/F LM for generating lexical constrained sequences, which captures the statistical properties of text sequences effectively. In order to generate the coherent sequences from given multiple constraints as input, we first generate the sequence from verb constraint w v through B/F LM, and then we satisfy the other given constraints by word embedding substitution method during the inference process. The predicted verb v splits the sequence into two sub-sequences as:", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "If m denotes the length of words in a sequence s i.e. s = w 1 , \u00b7 \u00b7 \u00b7, w v , \u00b7 \u00b7 \u00b7, w m , then the joint conditional probability of remaining m words, given lexical constraint w v and training parameters \u03b8 can be calculated as:", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "Where p bw \u03b8 and p fw \u03b8 depict the probabilities of generated sub-sequences by backward and forward language models. The sub-sequences are generated asynchronously i.e. we first generate the half sequence s <v in reverse order given verb constraint w v , then generate the other half sequence s >v conditioned on backward sequence s 1 : w v . Therefore, following the spirit of ensemble models that are trained separately, joint probability factors in Eq. 2 becomes", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "Where 1 \u2264 j \u2264 v \u2212 1. Backward LM decodes the output in reverse order from w v\u22121 , w v\u22122 to w 1 , which is reversed again to input forward language model for decoding the complete sequence. Consequently,", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "As the output order of sub-sequence generated by backward LM is reversed again to decode the entire sequence from forward language model, therefore s 1:v is equal to w 1 , \u00b7 \u00b7 \u00b7, w v .", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "For learning the sequences, we used LSTM networks in proposed architecture. The LSTM networks have the capability of capturing sequential data effectively where the network transforms a sequence of given input word vectors x = x 1 , \u00b7 \u00b7 \u00b7, x n into the sequence of hidden states h = h 1 , \u00b7 \u00b7 \u00b7, h t by maintaining a history of inputs at each hidden state. The LSTM cell depends on gating mechanism for information processing.", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "LSTM network's hidden state h at time step t is dependent on the previous state h t\u22121 and current input x t word vectors. Particularly, in our scenario for generating variable length text sequences, the probability of an output word w out from both language models calculated as:", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "Where w bw out and w fw out are shared across all time steps in their respective LSTM models, which projects the hidden state vector h t into a fixed same size vector as target vocabulary in order to generate a sequence of outputs y t = w v\u2212t , \u00b7 \u00b7 \u00b7, w 1 for backward language model and y t = w v+t , \u00b7 \u00b7 \u00b7, w m for forward language model. The softmax function is in the final layer of LSTM network, applied to each word vector for calculating the probability distribution over vocabulary of distinct word vectors.", "cite_spans": [], "ref_spans": [], "section": "Proposed Architecture"}, {"text": "In order to satisfy the given lexical constraints c other than verb constraint w v , we have used a lexical substitution method based on word embedding substitution. SG model embeds both target words and their context in the same dimensional space. In this space, the vector representations of words are drawn closer together when they co-occur more frequently in a learning corpus. Thus, Cosine distance between them can be viewed as target-to-target distributional similarity measure. Our method relies on a natural assumption that a good lexical constraint substitution for a target word w instance in a generated sequence s = w 1 , \u00b7 \u00b7 \u00b7, w v , \u00b7 \u00b7 \u00b7, w m needs to be consistent with the given sequence and lexically similar to the target word w instance. During inference, we find the cosine similarity [2] of given input constraint c with every word w in a sequence s generated by the proposed B/F LM. After that, we replace the constraint c with the closest matching (least cosine distance) word w in a sequence s. Step 3 of Fig. 1 illustrates the concept. For this purpose, we have created word embedding vectorization from FastText.", "cite_spans": [{"start": 808, "end": 811, "text": "[2]", "ref_id": "BIBREF1"}], "ref_spans": [{"start": 1032, "end": 1038, "text": "Fig. 1", "ref_id": "FIGREF0"}], "section": "Word Embedding Substitution"}, {"text": "In this section, we introduced our experimental designs, containing the preparation of dataset for training and testing, experimental configuration, comparison architectures and evaluation criteria.", "cite_spans": [], "ref_spans": [], "section": "Experiments"}, {"text": "There are many benchmark datasets for evaluating pure LM consisting of seq2seq networks for text classification and generative models, but specifically there is no such benchmark corpus for evaluation of constrained sequence generation based on statistical language models. As far, we have used Stanford Natural Language Inference (SNLI) [3] dataset for evaluation and training of proposed architecture. As we target the domain of generating sequences from lexical constraints, we extracted unlabeled sequences within range of minimum 3 and maximum 25 tokens, resulting in 451k sequences for training of proposed architecture. The proposed architecture ensemble backward-forward LM, therefore, to prepare training sequences for backward LM, following steps have been carried out:", "cite_spans": [{"start": 338, "end": 341, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Dataset"}, {"text": "-Annotate the tokens with their lexical categories using POS Tagging.", "cite_spans": [], "ref_spans": [], "section": "Dataset"}, {"text": "-Split the sentences on verb category instead of random splitting.", "cite_spans": [], "ref_spans": [], "section": "Dataset"}, {"text": "-Sentences with more than one verb are broken up into multiple sequences.", "cite_spans": [], "ref_spans": [], "section": "Dataset"}, {"text": "-After splitting the sequence on verb category, invert the half sequences.", "cite_spans": [], "ref_spans": [], "section": "Dataset"}, {"text": "For the forward language model, the dataset contains complete sequences for training the network. Here, it should be noted that backward language model requires only half sequences till verb token for training the network.", "cite_spans": [], "ref_spans": [], "section": "Dataset"}, {"text": "We follow the work of Bojanowski et al. [2] to create dense representations of words in dataset. A word vector is represented by augmenting the character n-grams appearing in the word, where the scoring function s takes into consideration the internal structure information of words, which is ignored by conventional skip-gram models [10] . The proposed model represents each word w as a bag of character n-gram, where adding special boundary symbols <and> at the beginning and end of words for distinguishing prefixes and suffixes from other character sequences. In addition to character n-grams of word w, the word w is also included in its set of n-grams for learning representation of each word. For example, taking the word 'apple' and let n = 3, it will be represented by the character n-grams as <app, ppl, ple> and the special sequence <apple>.", "cite_spans": [{"start": 40, "end": 43, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 334, "end": 338, "text": "[10]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Word Vectorization"}, {"text": "Let a dictionary of n-grams with size G. Given a word w where L w \u2282 1, ...G is the set of n-grams appearing in word w. Vector z g represents the each n-gram g, therefore a word w is represented by the sum of vectors of its n-gram g. In this regard, scoring function of word w with surrounding set of word indices c is calculated by:", "cite_spans": [], "ref_spans": [], "section": "Word Vectorization"}, {"text": "This extension of skip-gram model for creating word embedding allow the sharing of word vector representations across all words, thus enabling the reliable representational learning of rare or Out-Of-Vocabulary (OOV) words.", "cite_spans": [], "ref_spans": [], "section": "Word Vectorization"}, {"text": "We have used extension of FastText's SG model to learn such data representations for both backward and forward language model given their respective data sets. In order to train the FastText model, the word embedding dimension set to 300. Min count value set to 2, which represents that all the word frequencies lower than 2 were ignored while learning the word representations. Window size set to 5, defining the maximum distance between a current and predicted word within a sequence. Workers parameter set to 16, explaining the worker threads for faster training of FastText SG model. Epochs value set to 30 iteration, over the whole data set.", "cite_spans": [], "ref_spans": [], "section": "Word Vectorization"}, {"text": "We performed different experiments on test set to get the most optimal hyperparameters and evaluate change in performance of the model. Table 2 shows the different experimental configurations and change in performance w.r.t perplexity metric. In the proposed architecture, we get the best results by employing 2-layers of LSTM in both backward and forward language model. Both the LSTM networks were trained with Adam algorithm [7] for stochastic optimization of networks. During training, the parameters were adjusted using Adam optimizer for minimizing the training loss function, also known as misclassification rate. For calculating optimization score, we used categorical cross entropy loss function between the actual y and predicted\u0177 word probability distribution [5] . In target of accurately capturing the regularities by the neural networks and preventing overfitting, we appended drop-out layer after every LSTM layer in both the networks. The idea of drop-out layer is to randomly drop units with their connections while training, thus preventing units from co-adapting too much. Dropping units significantly leads to major improvements than other regularization methods [15] . The epochs value was set to 50 and mini batch size was set to 128 in both the networks. Both the Backward and Forward models are trained on NVIDIA GTX 1080 Ti GPU. The LSTM based networks are developed in keras. Training took about 17 h approx. per model with this implementation and optimal hyper-parameter configuration.", "cite_spans": [{"start": 428, "end": 431, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 771, "end": 774, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 1183, "end": 1187, "text": "[15]", "ref_id": "BIBREF14"}], "ref_spans": [{"start": 136, "end": 143, "text": "Table 2", "ref_id": "TABREF1"}], "section": "Experimental Configuration"}, {"text": "We compared our proposed methodology with state-of-the art sampling method CGMH [9] for satisfying multiple constraints in a sequence. We also evaluated our methodology of verb based split generation with different variants [13] , which can only handle single lexical constraint. We have used intrinsic evaluation metric that allows to determine the quality of a LM without being associated or embedded to a particular application. The most conventional intrinsic evaluation metric is perplexity (PPL). PPL of a language model given a test set w = w 1 , w 2 , ...w m is the inverse probability of w where the probability is normalized by the number of words", "cite_spans": [{"start": 80, "end": 83, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 224, "end": 228, "text": "[13]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Comparison and Evaluation Metrics"}, {"text": "For intrinsic evaluation of our proposed methodology, we first make comparisons with variants such as separate B/F and asynchronous B/F language models proposed by [13] . As mentioned earlier, in our proposed methodology the given word is verb constraint w v through which we decode complete sequence whereas in variants of B/F, the complete sequence is decoded by random split word. We calculated PPL with both verb and random constraint as input to decode the complete sequences. Table 3 represents the comparison in terms of PPL, where the higher probability of a sequence results in the lower of perplexity, which is better. Separate B/F variant yields worse sequences with huge perplexity score because both the B/F LM were enforced to output separately with the input constraint and concatenated after decoding of sequences. This is due to the fact that forward LM does not have the context of half sequence decoded by backward LM. Our proposed approach is more similar to asynchronous B/F LM, but technically very different as we are satisfying multiple constraints while asynchronous approach can deal with only single constraint. The results clearly shows that decoding a sequence on specific verb constraint can make use of the positional information of words in a sequence, that is smoothed out when we generate a sequence with random constraint. Table 4 shows the comparison of our proposed approach for catering multiple constraints with CGMH [9] . Our proposed approach shows lower perplexity than CGMH sampling method for sentence generation through keywords/constraints 1 to 3, while with 4 constraints as input CGMH shows slightly better result than our approach of generating sequence with verb constraint and during inference replacing the words in sequence with closest embedding similarity. The decoding complexity of CGMH increases linearly with the number of constraints, while there is no such factor in our approach for catering multiple constraints. There is always a trade-off between fluency of sequence and decoding complexity. In practice, the downside of CGMH sampling methods is that we are not sure of which sampling step size is best for proposal distribution.", "cite_spans": [{"start": 164, "end": 168, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 1456, "end": 1459, "text": "[9]", "ref_id": "BIBREF8"}], "ref_spans": [{"start": 482, "end": 489, "text": "Table 3", "ref_id": "TABREF2"}, {"start": 1358, "end": 1365, "text": "Table 4", "ref_id": null}], "section": "Results and Discussions"}, {"text": "To validate our proposed architecture of generating sequence, we performed a series of experiments. Results of intrinsic evaluation confirms that our proposed approach for sequence generation given constraint(s) outperforms previous methods. Splitting and generating a sequence on verb constraint makes use of positional information, which is smoothed out in breaking down a sequence with random word. We observe that decoding a sequence given random word as input in proposed B/F LM even performs better when the backward LM is trained over half sequences till verb. Moreover, in future we would like to explore about the constraint-to-target context similarity, indicating their syntagmatic compatibility for improving the word embedding substitution method. Introducing attention mechanism as context vectors for constraints would be an interesting side in the proposed architecture.", "cite_spans": [], "ref_spans": [], "section": "Discussion"}, {"text": "In this paper, we have proposed a novel method, dubbed Neural Probabilistic Backward-Forward language model and word embedding substitution method to address the issue of lexical constrained sequence generation. Our proposed system can generate constrained sequences given multiple lexical constraints as input. To the best of our knowledge, this is the first time that multiple constraints have been handled through LSTM based backward-forward LM and word embedding substitution of the sequences. The proposed method contains a backward language model based on LSTM network, which learns the half representation of a sentence until the verb splitting word and forward language model constitute LSTM Network, learning the complete representation of a sequence. Moreover, word embedding substitution method satisfy other constraints by substituting the target word in the sequence with given constraints based on similar context in an embedding space.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Guided open vocabulary image captioning with constrained beam search", "authors": [{"first": "P", "middle": [], "last": "Anderson", "suffix": ""}, {"first": "B", "middle": [], "last": "Fernando", "suffix": ""}, {"first": "M", "middle": [], "last": "Johnson", "suffix": ""}, {"first": "S", "middle": [], "last": "Gould", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1612.00576"]}}, "BIBREF1": {"ref_id": "b1", "title": "Enriching word vectors with subword information", "authors": [{"first": "P", "middle": [], "last": "Bojanowski", "suffix": ""}, {"first": "E", "middle": [], "last": "Grave", "suffix": ""}, {"first": "A", "middle": [], "last": "Joulin", "suffix": ""}, {"first": "T", "middle": [], "last": "Mikolov", "suffix": ""}], "year": 2017, "venue": "Trans. Assoc. Comput. Linguist", "volume": "5", "issn": "", "pages": "135--146", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "A large annotated corpus for learning natural language inference", "authors": [{"first": "S", "middle": ["R"], "last": "Bowman", "suffix": ""}, {"first": "G", "middle": [], "last": "Angeli", "suffix": ""}, {"first": "C", "middle": [], "last": "Potts", "suffix": ""}, {"first": "C", "middle": ["D"], "last": "Manning", "suffix": ""}], "year": 2015, "venue": "Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing", "volume": "", "issn": "", "pages": "632--642", "other_ids": {"DOI": ["10.18653/v1/D15-1075"]}}, "BIBREF3": {"ref_id": "b3", "title": "A comparison of MLP, RNN and ESN in determining harmonic contributions from nonlinear loads", "authors": [{"first": "J", "middle": [], "last": "Dai", "suffix": ""}, {"first": "P", "middle": [], "last": "Zhang", "suffix": ""}, {"first": "J", "middle": [], "last": "Mazumdar", "suffix": ""}, {"first": "R", "middle": ["G"], "last": "Harley", "suffix": ""}, {"first": "G", "middle": [], "last": "Venayagamoorthy", "suffix": ""}], "year": 2008, "venue": "34th Annual Conference of IEEE Industrial Electronics", "volume": "", "issn": "", "pages": "3025--3032", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "A tutorial on the crossentropy method", "authors": [{"first": "P", "middle": ["T"], "last": "De Boer", "suffix": ""}, {"first": "D", "middle": ["P"], "last": "Kroese", "suffix": ""}, {"first": "S", "middle": [], "last": "Mannor", "suffix": ""}, {"first": "R", "middle": ["Y"], "last": "Rubinstein", "suffix": ""}], "year": 2005, "venue": "Ann. Oper. Res", "volume": "134", "issn": "1", "pages": "19--67", "other_ids": {"DOI": ["10.1007/s10479-005-5724-z"]}}, "BIBREF5": {"ref_id": "b5", "title": "Lexically constrained decoding for sequence generation using grid beam search", "authors": [{"first": "C", "middle": [], "last": "Hokamp", "suffix": ""}, {"first": "Q", "middle": [], "last": "Liu", "suffix": ""}], "year": 2017, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1704.07138"]}}, "BIBREF6": {"ref_id": "b6", "title": "Adam: a method for stochastic optimization", "authors": [{"first": "D", "middle": ["P"], "last": "Kingma", "suffix": ""}, {"first": "J", "middle": [], "last": "Ba", "suffix": ""}], "year": 2014, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "BFGAN: backward and forward generative adversarial networks for lexically constrained sentence generation", "authors": [{"first": "D", "middle": [], "last": "Liu", "suffix": ""}, {"first": "J", "middle": [], "last": "Fu", "suffix": ""}, {"first": "Q", "middle": [], "last": "Qu", "suffix": ""}, {"first": "J", "middle": [], "last": "Lv", "suffix": ""}], "year": 2019, "venue": "IEEE/ACM Trans. Audio Speech Lang. Process", "volume": "27", "issn": "12", "pages": "2350--2361", "other_ids": {"DOI": ["10.1109/TASLP.2019.2943018"]}}, "BIBREF8": {"ref_id": "b8", "title": "CGMH: constrained sentence generation by metropolis-hastings sampling", "authors": [{"first": "N", "middle": [], "last": "Miao", "suffix": ""}, {"first": "H", "middle": [], "last": "Zhou", "suffix": ""}, {"first": "L", "middle": [], "last": "Mou", "suffix": ""}, {"first": "R", "middle": [], "last": "Yan", "suffix": ""}, {"first": "L", "middle": [], "last": "Li", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Efficient estimation of word representations in vector space", "authors": [{"first": "T", "middle": [], "last": "Mikolov", "suffix": ""}, {"first": "K", "middle": [], "last": "Chen", "suffix": ""}, {"first": "G", "middle": [], "last": "Corrado", "suffix": ""}, {"first": "J", "middle": [], "last": "Dean", "suffix": ""}], "year": 2013, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1301.3781"]}}, "BIBREF10": {"ref_id": "b10", "title": "Recurrent neural network based language model", "authors": [{"first": "T", "middle": [], "last": "Mikolov", "suffix": ""}, {"first": "M", "middle": [], "last": "Karafi\u00e1t", "suffix": ""}, {"first": "L", "middle": [], "last": "Burget", "suffix": ""}, {"first": "J", "middle": [], "last": "\u010cernock\u1ef3", "suffix": ""}, {"first": "S", "middle": [], "last": "Khudanpur", "suffix": ""}], "year": 2010, "venue": "Eleventh Annual Conference of the International Speech Communication Association", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Distributed representations of words and phrases and their compositionality", "authors": [{"first": "T", "middle": [], "last": "Mikolov", "suffix": ""}, {"first": "I", "middle": [], "last": "Sutskever", "suffix": ""}, {"first": "K", "middle": [], "last": "Chen", "suffix": ""}, {"first": "G", "middle": ["S"], "last": "Corrado", "suffix": ""}, {"first": "J", "middle": [], "last": "Dean", "suffix": ""}], "year": 2013, "venue": "Advances in Neural Information Processing Systems", "volume": "", "issn": "", "pages": "3111--3119", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Backward and forward language modeling for constrained sentence generation", "authors": [{"first": "L", "middle": [], "last": "Mou", "suffix": ""}, {"first": "R", "middle": [], "last": "Yan", "suffix": ""}, {"first": "G", "middle": [], "last": "Li", "suffix": ""}, {"first": "L", "middle": [], "last": "Zhang", "suffix": ""}, {"first": "Z", "middle": [], "last": "Jin", "suffix": ""}], "year": 2015, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1512.06612"]}}, "BIBREF13": {"ref_id": "b13", "title": "Fast lexically constrained decoding with dynamic beam allocation for neural machine translation", "authors": [{"first": "M", "middle": [], "last": "Post", "suffix": ""}, {"first": "D", "middle": [], "last": "Vilar", "suffix": ""}], "year": 2018, "venue": "Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies", "volume": "1", "issn": "", "pages": "1314--1324", "other_ids": {"DOI": ["10.18653/v1/N18-1119"]}}, "BIBREF14": {"ref_id": "b14", "title": "Dropout: a simple way to prevent neural networks from overfitting", "authors": [{"first": "N", "middle": [], "last": "Srivastava", "suffix": ""}, {"first": "G", "middle": [], "last": "Hinton", "suffix": ""}, {"first": "A", "middle": [], "last": "Krizhevsky", "suffix": ""}, {"first": "I", "middle": [], "last": "Sutskever", "suffix": ""}, {"first": "R", "middle": [], "last": "Salakhutdinov", "suffix": ""}], "year": 2014, "venue": "J. Mach. Learn. Res", "volume": "15", "issn": "1", "pages": "1929--1958", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Incorporating discriminator in sentence generation: a Gibbs sampling method", "authors": [{"first": "J", "middle": [], "last": "Su", "suffix": ""}, {"first": "J", "middle": [], "last": "Xu", "suffix": ""}, {"first": "X", "middle": [], "last": "Qiu", "suffix": ""}, {"first": "X", "middle": [], "last": "Huang", "suffix": ""}], "year": 2018, "venue": "Thirty-Second AAAI Conference on Artificial Intelligence", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Sequence to sequence learning with neural networks", "authors": [{"first": "I", "middle": [], "last": "Sutskever", "suffix": ""}, {"first": "O", "middle": [], "last": "Vinyals", "suffix": ""}, {"first": "Q", "middle": ["V"], "last": "Le", "suffix": ""}, {"first": "Z", "middle": [], "last": "Ghahramani", "suffix": ""}, {"first": "M", "middle": [], "last": "Welling", "suffix": ""}, {"first": "C", "middle": [], "last": "Cortes", "suffix": ""}, {"first": "N", "middle": ["D"], "last": "Lawrence", "suffix": ""}], "year": 2014, "venue": "Advances in Neural Information Processing Systems", "volume": "27", "issn": "", "pages": "3104--3112", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "An illustration of proposed system architecture", "latex": null, "type": "figure"}, "TABREF0": {"text": "Comparison of different constrained sequence generation techniques.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>Multiple constraints\n</td><td>Computational time\n</td><td>Decoding complexity\n</td><td>Decoder </td><td>Target domain\n</td></tr><tr><td>Mou et al. [13] </td><td>x </td><td>Low </td><td>O(Nk) </td><td>- </td><td>Research titles\n</td></tr><tr><td>Anderson et al. [1] </td><td> </td><td>High </td><td>O(Nk2C) </td><td>CBS </td><td>Image captioning\n</td></tr><tr><td>Su et al. [16] </td><td> </td><td>High </td><td>O(N +\ndNM)\n</td><td>GSM </td><td>Product sentiments\n</td></tr><tr><td>Liu et al. [8] </td><td>x </td><td>- </td><td>- </td><td>Beam search </td><td>Product reviews\n</td></tr><tr><td>Hokamp et al. [6] </td><td> </td><td>High </td><td>O(Nk2C) </td><td>GBS </td><td>NMT\n</td></tr><tr><td>Post et al. [14] </td><td> </td><td>Low </td><td>O(Nk) </td><td>DBA </td><td>NMT\n</td></tr><tr><td>Miao et al. [9] </td><td> </td><td>High </td><td>O(N +\ndNM)\n</td><td>MH </td><td>Generic\n</td></tr><tr><td>Proposed technique </td><td> </td><td>Low </td><td>O(Nk) </td><td>Greedy search </td><td>Generic\n</td></tr></table></body></html>"}, "TABREF1": {"text": "Hyper-parameter tuning and model performance", "latex": null, "type": "table", "html": "<html><body><table><tr><td>LSTM layers </td><td>Hidden units </td><td>LR </td><td>Drop-out </td><td>PPL score\n</td></tr><tr><td>1 </td><td>256 </td><td>0.01 </td><td>0.2 </td><td>35.48\n</td></tr><tr><td>1 </td><td>512 </td><td>0.001 </td><td>0.3 </td><td>33.15\n</td></tr><tr><td>2 </td><td>256 </td><td>0.01 </td><td>0.2 </td><td>27.48\n</td></tr><tr><td>2 </td><td>512 </td><td>0.001 </td><td>0.3 </td><td>24.20\n</td></tr></table></body></html>"}, "TABREF2": {"text": "Intrinsic evaluation", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Model </td><td>Perplexity\n</td></tr><tr><td>Input constraint </td><td>Verb </td><td>Random\n</td></tr><tr><td>Separate B/F </td><td>74.56 </td><td>80.43\n</td></tr><tr><td>Asynchronous B/F </td><td>26.63 </td><td>28.32\n</td></tr><tr><td>Proposed B/F approach </td><td>24.20 </td><td>27.84\n</td></tr></table></body></html>"}, "TABREF3": {"text": "Table 4. CGMH vs proposed\nConstraints Perplexity (PPL)", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>CGMH </td><td>Proposed B/F\n</td></tr><tr><td>1 </td><td>19.34 </td><td>18.04\n</td></tr><tr><td>2 </td><td>19.71 </td><td>18.92\n</td></tr><tr><td>3 </td><td>21.36 </td><td>20.13\n</td></tr><tr><td>4 </td><td>20.87 </td><td>21.63\n</td></tr></table></body></html>"}}, "back_matter": []}