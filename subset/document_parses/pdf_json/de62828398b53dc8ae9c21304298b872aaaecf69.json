{
    "paper_id": "de62828398b53dc8ae9c21304298b872aaaecf69",
    "metadata": {
        "title": "Embedding gene trees into phylogenetic networks by conflict resolution algorithms",
        "authors": [
            {
                "first": "Marcin",
                "middle": [],
                "last": "Wawerka",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Dawid",
                "middle": [],
                "last": "D\u0105bkowski",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Natalia",
                "middle": [],
                "last": "Rutecka",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Agnieszka",
                "middle": [],
                "last": "Mykowiecka",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Pawe\u0142",
                "middle": [],
                "last": "G\u00f3recki",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Background: Phylogenetic networks are mathematical models of evolutionary processes involving reticulate events such as hybridization, recombination, or horizontal gene transfer. One of the crucial notions in phylogenetic network modelling is displayed tree, which is obtained from a network by removing a set of reticulation edges. Displayed trees may represent an evolutionary history of a gene family if the evolution is shaped by reticulation events.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "We address the problem of inferring an optimal tree displayed by a network, given a gene tree G and a treechild network N, under the deep coalescence and duplication costs. We propose an O(mn)-time dynamic programming algorithm (DP) to compute a lower bound of the optimal displayed tree cost, where m and n are the sizes of G and N, respectively. In addition, our algorithm can verify whether the solution is exact. Moreover, it provides a set of reticulation edges corresponding to the obtained cost. If the cost is exact, the set induces an optimal displayed tree. Otherwise, the set contains pairs of conflicting edges, i.e., edges sharing a reticulation node. Next, we show a conflict resolution algorithm that requires 2 r+1 \u2212 1 invocations of DP in the worst case, where r is the number of reticulations. We propose a similar O(2 k mn)-time algorithm for level-k tree-child networks and a branch and bound solution to compute lower and upper bounds of optimal costs. We also extend the algorithms to a broader class of phylogenetic networks. Based on simulated data, the average runtime is \ufffd(2 0.543k mn) under the deep-coalescence cost and \ufffd(2 0.355k mn) under the duplication cost.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Despite exponential complexity in the worst case, our algorithms perform significantly well on empirical and simulated datasets, due to the strategy of resolving internal dissimilarities between gene trees and networks. Therefore, the algorithms are efficient alternatives to enumeration strategies commonly proposed in the literature and enable analyses of complex networks with dozens of reticulations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Evolutionary networks are mathematical models of evolutionary processes with reticulate events such as hybridization, recombination, or horizontal gene transfer [1, 2] . Hybridization is a common phenomenon in plants and is often used in agriculture to create new breeds [3] . Recombination and reassortment are two shuffling processes in which variants of genetic material are created from pairs of highly similar DNA sequences. For example, many viruses have segmented genomes, including influenza viruses and rotaviruses [4] , while horizontal gene transfer is common in bacteria [5] . In the last decades, mathematical and computational properties of phylogenetic networks have been intensively studied (see books [2, 6] ). One of the most classic notions is a tree displayed by a network, obtained from a network by removing a set of reticulation edges. Displayed trees may represent an evolutionary history of a gene family [2] , if the evolution of Page 17:11 genes and their species is shaped by reticulation events. Alternative approaches include embedding a gene tree into a displayed tree [7] [8] [9] or using a parental species tree as a generalization of a displayed tree [9] [10] [11] . The pioneering work by Maddison [12] introduced the deep coalescence (DC) cost, which measures the extra gene lineages of a gene tree when embedded into a species tree. When a gene is embedded into its species tree, each edge of the species contains several mapped gene lineages. For example, when both trees have the same topology, there are no extra gene lineages in the perfect situation. DC and general coalescent-based methods are popular in classical problems of computational biology, e.g., estimation of species trees [13] [14] [15] , tree reconciliation [15] [16] [17] [18] [19] , or gene tree error correction [20] .",
            "cite_spans": [
                {
                    "start": 161,
                    "end": 164,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 165,
                    "end": 167,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 271,
                    "end": 274,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 524,
                    "end": 527,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 583,
                    "end": 586,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 718,
                    "end": 721,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 722,
                    "end": 724,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 930,
                    "end": 933,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 956,
                    "end": 960,
                    "text": "Page",
                    "ref_id": null
                },
                {
                    "start": 961,
                    "end": 966,
                    "text": "17:11",
                    "ref_id": null
                },
                {
                    "start": 1100,
                    "end": 1103,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1104,
                    "end": 1107,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1108,
                    "end": 1111,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1185,
                    "end": 1188,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1189,
                    "end": 1193,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1194,
                    "end": 1198,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1233,
                    "end": 1237,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1727,
                    "end": 1731,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1732,
                    "end": 1736,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1737,
                    "end": 1741,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1764,
                    "end": 1768,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1769,
                    "end": 1773,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1774,
                    "end": 1778,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1779,
                    "end": 1783,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1784,
                    "end": 1788,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1821,
                    "end": 1825,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "Goodman et al. [21] introduced a duplication model more than 40 years ago to explain potential discordance between the gene tree and the species tree originating from complex histories of gene duplication and loss events. This approach is based on embedding the gene tree into the species tree using a mapping [22] that relates every gene in the gene tree to its host species that is the most recent species that could have contained the gene. Consequently, the mapping relates every leaf-gene of the gene tree to the species from which it has been sampled. Based on this mapping, evolutionary events such as gene duplications are identified. A node in a gene tree denotes a gene duplication when it has a child with the same host species. While many embeddings are possible [23] , the classic mapping describes the most parsimonious embedding in terms of the number of gene duplication and loss events [23, 24] . The gene duplication model has many theoretical and practical applications [15, 18, [25] [26] [27] .",
            "cite_spans": [
                {
                    "start": 15,
                    "end": 19,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 310,
                    "end": 314,
                    "text": "[22]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 775,
                    "end": 779,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 903,
                    "end": 907,
                    "text": "[23,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 908,
                    "end": 911,
                    "text": "24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 989,
                    "end": 993,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 994,
                    "end": 997,
                    "text": "18,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 998,
                    "end": 1002,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 1003,
                    "end": 1007,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 1008,
                    "end": 1012,
                    "text": "[27]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "There are two main general approaches to embed a gene tree into a network using the parsimony principle: (1) choosing the tree displayed by the network with the lowest cost, i.e. solving the optimal displayed tree (ODT) problem, in which a reticulation node can be reached only from one fixed parent, or (2) a direct treenetwork embedding, without the above constraint. These approaches are present in relevant articles concerning inferences of networks under Robinson-Foulds (RF) embedding cost [8] , the duplication-loss cost [9] , and the deep coalescence cost [7] . The latter includes the general parsimony framework using the concept of parental species trees [10] . Alternative studies are based on minimizing deep coalescence criterion [25] or on probabilistic models on coalescent histories [28] . Model-based approaches are usually computationally demanding since they often require enumeration of all possible coalescence histories [28, 29] . Finally, perhaps one of the most prominent applications of the above methods is the problem of network inference (e.g. [2, 8-10, 29, 30] ).",
            "cite_spans": [
                {
                    "start": 496,
                    "end": 499,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 528,
                    "end": 531,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 564,
                    "end": 567,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 666,
                    "end": 670,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 744,
                    "end": 748,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 800,
                    "end": 804,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 943,
                    "end": 947,
                    "text": "[28,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 948,
                    "end": 951,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 1073,
                    "end": 1090,
                    "text": "[2, 8-10, 29, 30]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "From the theoretical point of view, ODT under deep coalescence (or duplication cost) corresponds to NPhard problems: (1) best switching (i.e., choosing the set of reticulation edges) for the duplication-loss model [9] , and (2) the computation of RF-embedding cost [8] . In [9] , the problem is solved in O(|N | + p2 k |G|) time, where G is a gene tree and p is the number of biconnected components in a level-k network N. [8] proposed an O(2 r |N |) -time optimized algorithm to compute RF-embedding cost, where r is the number of reticulations in N. Another relevant contribution is from [7] with an O(4 k |G||N | 2 ) -time tree vs. level-k network reconciliation algorithm under DC events. However, the latter cannot be directly compared to ours since we solve a different problem. In all of the above contributions, the complexity related to 2 r (or 2 k ) is reached due to exhaustive enumeration strategies. In this article, we show how to avoid such strategies by proposing an efficient in practice method to infer optimal displayed trees despite the theoretical intractability of ODT in general.",
            "cite_spans": [
                {
                    "start": 214,
                    "end": 217,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 265,
                    "end": 268,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 274,
                    "end": 277,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 423,
                    "end": 426,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 590,
                    "end": 593,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "Our contribution: We address the problem of inference of an optimal tree displayed by a tree-child network (ODT), given a gene tree G and a tree-child network N under the deep coalescence (DC) and duplication (D) costs. We propose a novel approach in which we define scenarios for embedding G into N using sets of reticulation edges from N, with a property that the score of a scenario approximates the displayed tree cost. In particular, we prove that the score of a scenario is a lower bound of the cost of the optimal displayed tree. In a specific case, when a scenario induces a non-conflicting set of reticulation edges, we provide the correspondence between a score of this scenario and a cost of a displayed tree. Next, we propose an O(|G||N|) time dynamic programming (DP) algorithm to compute an optimal scenario. We show that an optimal scenario with no conflicts corresponds to a solution of ODT. Based on DP, we design a recursive algorithm to ODT by resolving conflicts in sets of reticulation edges. This algorithm has exponential time complexity O(2 r |G||N |) , where r is the number of reticulation nodes in N. We propose a similar O(2 k |G||N |)-time algorithm for level-k tree-child networks. We also show how the algorithms can be extended to a broader class of phylogenetic networks defined by the property: each node has at most one reticulation child. Finally, we show experimental studies on random, simulated, and empirical datasets. We show that our algorithm has significantly improved runtime on simulated datasets by reducing the exponent from r to nearly half of r on average.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "In this section, we present the main theoretical and algorithmic methods on the inference of an optimal tree displayed by a network problem (ODT). We mainly focus on the details related to the variant of the problem under the deep coalescence cost (ODT-DC). At the end of the section, we show how the theory can be adopted to solve the problem under the duplication cost (ODT-DUP).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Methods"
        },
        {
            "text": "A network on a set of species X is a directed acyclic graph N = (V (N ), E(N )) with a single root such that: (1) its leaves, i.e., nodes of indegree 1 and outdegree 0, are labeled by the species from X, and (2) there is a directed path from the root to any other vertex. A network is binary if its leaves, root, and the remaining nodes have degrees 1, 2 and 3, respectively. A node is called a reticulation if it has indegree two and outdegree one, and a tree node if it has indegree at most one and outdegree two. A network is semi-binary, if additionally, it may contain semi-binary nodes of indegree at most one and outdegree one, which includes the root having exactly one child. We can contract a semi-binary node v of indegree one as follows: (1) remove v, (2) remove both edges incident with v, and (3) insert a new directed edge connecting the unique parent of v with the only child of v. Similarly, if v has indegree zero we remove v, and the child of v becomes a new root. If a directed graph G \u2032 is obtained from a graph G by a sequence of contract operations, then G is called a subdivision of G \u2032 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Trees and networks"
        },
        {
            "text": "If \ufffdv, w\ufffd \u2208 E(N ) , then v is a parent of w and w is a child of v, denoted w.parent = v if w is a non-root tree node or a leaf. We write v.sibling = w if v = w have the same parent. We write v w if there is a directed path from v to w, and v \u227b w if v w and v = w . The set of all leaves in a network is denoted L(N), by R(N ) \u2282 V (N ) we denote the set of reticulation nodes in N, by T (N ) \u2282 V (N ) we denote the set of all tree nodes in N, and by E R (N ) \u2282 E(N ) we denote the set of all reticulation edges in N, that is, edges \ufffdv, r\ufffd \u2208 E(N ) with r \u2208 R(N ) . We say that a reticulation edge e is a sibling of a reticulation edge e \u2032 if they share the same bottom reticulation node. By deg N (v) we denote the outdegree of v in N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Trees and networks"
        },
        {
            "text": "A phylogenetic network is a binary network on X in which the leaves are labeled one-to-one with the species from X 1 . A species tree is a phylogenetic network without reticulation nodes. A gene tree, or in short a tree, is a binary network without reticulation nodes. Note that the leaf labeling in a gene tree does not have to be one-to-one. Such labelled trees are called multi-labelled trees or MUL-trees [31] . A phylogenetic network is treechild network, if each non-leaf node has a child that is either a tree node or a leaf [32] [33] [34] [35] .",
            "cite_spans": [
                {
                    "start": 409,
                    "end": 413,
                    "text": "[31]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 532,
                    "end": 536,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 537,
                    "end": 541,
                    "text": "[33]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 542,
                    "end": 546,
                    "text": "[34]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 547,
                    "end": 551,
                    "text": "[35]",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "Trees and networks"
        },
        {
            "text": "Given a gene tree G and a species tree S on X, the lcamapping M : V (G) \u2192 V (S) is defined as follows: (1) if g is a leaf labeled x \u2208 X then M(g) is the unique leaf labeled x in S, and (2) if g has two children g \u2032 and g \u2032\u2032 , then M(g) is the lowest common ancestor of M(g \u2032 ) and M(g \u2032\u2032 ) in S. Embedding G into S is performed by mapping each edge \ufffdv, w\ufffd \u2208 E(G) to a path connecting M(v) and M(w) in S. We say that the gene edge visits edges from that path. Let ||v, w|| denote the number of edges on the path connecting v and w. Then, the visited edges contribute to the deep coalescence cost, denoted DC(G, S) , as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence cost: embedding a tree into a (displayed) tree"
        },
        {
            "text": "Given a phylogenetic network N on X, we say that a species tree T on X is displayed by N, if N contains a subgraph T \u2032 that is a subdivision of T [36] .",
            "cite_spans": [
                {
                    "start": 146,
                    "end": 150,
                    "text": "[36]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Deep coalescence cost: embedding a tree into a (displayed) tree"
        },
        {
            "text": "We now define the Optimal Displayed Tree under Deep Coalescence problem (ODT-DC) in the parsimony framework:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence cost: embedding a tree into a (displayed) tree"
        },
        {
            "text": "Problem 1 (ODT-DC) Given a tree G and a phylogenetic network N. Find an optimal tree S * displayed by N that minimizes DC(G, S) in the set of all trees S displayed by N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence cost: embedding a tree into a (displayed) tree"
        },
        {
            "text": "The cost of an optimal displayed tree, we denote DC(G, N ) . While the complexity of ODT-DC remains unknown for the class of tree-child networks, we claim that the problem is NP-hard in a general class of networks. The proof is similar to the NP-hardness proof of the best switching problem from [9] . See also [8] for the related problem of RF-embedding. Figure 1 depicts an example of DC costs.",
            "cite_spans": [
                {
                    "start": 296,
                    "end": 299,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 311,
                    "end": 314,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [
                {
                    "start": 356,
                    "end": 364,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Deep coalescence cost: embedding a tree into a (displayed) tree"
        },
        {
            "text": "In the previous Section, we showed how a gene tree is embedded into a species tree. Here, we propose to embed a gene tree into a phylogenetic network using a more general approach than embedding through a displayed tree. We start with the notion of unfolded network (see also [37, 38] ), then we define scenarios between gene trees and unfolded networks.",
            "cite_spans": [
                {
                    "start": 276,
                    "end": 280,
                    "text": "[37,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 281,
                    "end": 284,
                    "text": "38]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [],
            "section": "Scenarios between gene trees and phylogenetic networks"
        },
        {
            "text": "For a phylogenetic network N on X with k reticulations, the unfolded network N is the tree N k obtained from N by a sequence of k unfolding operations defined on pairs (N i , \u03c3 i ) , such that N i is a semi-binary network on X and \u03c3 i : V (N i ) \u2192 V (N ) defines the origin of a node from N i . Let (N 0 , \u03c3 0 ) be a pair such that N 0 = N and \u03c3 0 (v) = v for each v \u2208 V (N ) . Then, for a sequence of all reticulation nodes r 1 , r 2 , . . . , r k from N in a reversed topological order, (N i , \u03c3 i ) is obtained from (N i\u22121 , \u03c3 i\u22121 ) by unfolding the reticulation r i as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Scenarios between gene trees and phylogenetic networks"
        },
        {
            "text": "\u2022 Let S i be a copy of the subtree of N i\u22121 rooted at r i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Scenarios between gene trees and phylogenetic networks"
        },
        {
            "text": "if v is a copy of t from N i\u22121 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Scenarios between gene trees and phylogenetic networks"
        },
        {
            "text": "Informally, for each reticulation node, we copy its subtree, detach the original subtree from one parent, and attach the copy to the same parent, without changing the labels. To avoid using k directly, we set \u03c3 to be \u03c3 k . Proof The proof follows by induction on i = 0, 1, . . . , k , by showing that N i is a semi-binary network on X with the reticulation nodes r i+1 , . . . , r k such that there is no reticulation node below r i+1 in N i . For i = 0 the above statement holds trivially. For each i > 0 , N i is obtained from N i\u22121 by unfolding r i . Next, it follows from the topological order, and the inductive assumption, that there is no reticulation below r i , thus the set of all nodes below r i induces a rooted subtree in N i\u22121 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Scenarios between gene trees and phylogenetic networks"
        },
        {
            "text": "Let a root-leaf path be a directed path connecting the root with a leaf in a network.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Scenarios between gene trees and phylogenetic networks"
        },
        {
            "text": "Proof The bijection is established by \u03c3 , i.e., if P = p 1 , p 2 , . . . , p m is a root-leaf path in N , then \u03c3 (P) = \u03c3 (p 1 ), \u03c3 (p 2 ), . . . , \u03c3 (p m ) is the corresponding root-leaf path in the network N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3 (Unfolding Soundness) There is a one-to-one correspondence between root-leaf paths in N and root-leaf paths in N ."
        },
        {
            "text": "It follows from Theorem 3 that N and N have the same structure of root-leaf paths. A scenario for G and N is a function \u03be : L(G) \u2192 L(N ) that preserves the leaf labeling: for every g \u2208 L(G) , the labels of g and \u03be(g) are equal. A scenario \u03be can be extended to the lca-mapping",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3 (Unfolding Soundness) There is a one-to-one correspondence between root-leaf paths in N and root-leaf paths in N ."
        },
        {
            "text": "Top left: a gene tree G and a phylogenetic network N with two reticulations. Top right: four trees displayed by N. Bottom: lca-mappings between G and S i 's, visualization of embeddings of G into S i 's. Here, S 1 is the optimal tree displayed by N with the DC cost of 0. 2 We also use \u03c3 with edges, e.g., \u03c3 ( v, w ) denotes \u03c3 (v), \u03c3 (w) . the lowest node v in N such that \u03be(g \u2032 ) \ufffd v , for each leaf g \u2032 \ufffd g . Note that M \u03be (g) is either a leaf or a tree node.",
            "cite_spans": [
                {
                    "start": 272,
                    "end": 273,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 3 (Unfolding Soundness) There is a one-to-one correspondence between root-leaf paths in N and root-leaf paths in N ."
        },
        {
            "text": "Having the lca-mapping determined by a scenario, we are ready to define the deep coalescence score, denoted D C , to approximate deep coalescence events induced by scenarios in phylogenetic networks. Our first goal is to deduce properties allowing us to approximate the DC cost to solve ODT-DC in the class of tree-child networks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "In particular, our approach differs from the approaches from [7, 9, 10] , e.g., in the way in which a cost of a path is defined, although the general concept of mapping a gene tree into a network is analogous. For a scenario \u03be for G and N, we say that \ufffdv, w\ufffd \u2208 E(G) visits \ufffda, b\ufffd \u2208 E(N ) if M \u03be (v) \ufffd a \u227b b \ufffd M \u03be (w) . Then, a, b has exactly one of the following types.",
            "cite_spans": [
                {
                    "start": 61,
                    "end": 64,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 65,
                    "end": 67,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 68,
                    "end": 71,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "\u2022 Type I: M \u03be (v) = a , i.e., it is the first edge.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "\u2022 Type II: M \u03be (v) \u227b a , degN (a) = 2 and \u03c3 (b.sibling) / \u2208 R(N ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "\u2022 Type III: M \u03be (v) \u227b a , degN (a) = 2 and \u03c3 (b.sibling) \u2208 R(N ) ; we say that \u03be bypasses the reticulation edge \u03c3 ( a, b.sibling ). \u2022 Type IV: degN (a) = 1 (only if \u03c3 (a) \u2208 R(N )).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "In the above definition, type (I) is only for the first (i.e., the closest to the root) edge visited by a given edge from G, while for the remaining visited edges from N an edge has: Type (II) if the sibling of its bottom node is a tree node, Type (III) if the sibling of its bottom node is a reticulation, and Type (IV) if the top node of the edge is a reticulation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "By \u03ba \u03be (v, w) we denote the set of all edges of Type I or II visited by v, w . Then, the deep coalescence score for G, N and a scenario \u03be is ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "dp dp 0 dp p p dp 0 p dp dp 0 p dp p dp 0 dp dp dp p 1 dp dp dp p 1 d -directly used, p -potentially used ). Problem 4 (DC-MinRec) Given a gene tree G and a phylogenetic network N. Find an optimal scenario \u03be * that minimizes D C(G, N , \u03be) in the set of all scenarios \u03be for G and N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "In the next sections, we propose a dynamic programming algorithm that solves DC-MinRec in O(|G||N|) time where N is a tree-child network. Note that the time complexity depends on the size of N (not on the potentially exponential size of N ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "In a trivial case, the solution to DC-MinRec is induced by the classical DC cost.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deep coalescence score of scenarios"
        },
        {
            "text": "Proof N is a species tree and the scenario is determined by \u03be := M| L(N ) . In this case, M \u03be = M , all visited edges in N are of Type I or II. Thus, |\u03ba \u03be (v, w)| = ||M(v), M(w)|| and the proof is straightforward from (1) and (2).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5 If N is a phylogenetic network with no reticulation node, there is only one scenario \u03be for G and N."
        },
        {
            "text": "Here, we present several important properties of displayed trees in tree-child networks. Given a tree-child network N on X, a set Y \u2286 E R (N ) is called perfect if, for each r \u2208 R(N ) , Y contains exactly one edge whose bottom node is r. Given a perfect Y, the graph denoted N \\ Y , obtained from N by removing all edges from E R (N ) \\ Y is a semi-binary tree on X, i.e., semi-binary network with no reticulations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Displayed trees in tree-child networks"
        },
        {
            "text": "Proof (\u21d2 ) In a tree-child network a node cannot have all descendands being reticulations. Therefore, N \\ Y contains no unlabelled leaf. Next, every reticulation node r from N has exactly one parent in N \\ Y . Also, N \\ Y is a connected graph on X, which follows by showing that each node is connected with the root. We omit easy inductive proof. ( \u21d0 ) Let r \u2208 R(N ) . Then, Y must contain exactly one reticulation edge whose bottom node is r.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 6 Let N be a tree-child network on X and"
        },
        {
            "text": "Since N \\ Y is a semi-binary tree on X, contracting all semi-binary nodes from N \\ Y yields a species tree N Y on X. Next, the subgraph N \\ Y of N is a subdivision of a tree N Y on X. We conclude that N Y is a displayed tree of N. We also have the following property.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 6 Let N be a tree-child network on X and"
        },
        {
            "text": ". It remains to show that Y is perfect. Note that T \u2032 is a semi-binary tree on X and the rest follows similarly to the case (\u21d0) from Lemma 6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 6 Let N be a tree-child network on X and"
        },
        {
            "text": "We say that the perfect set Y is induced by a tree T displayed by N if N Y = T . Note that different perfect sets may induce the same displayed tree. E.g., a tree child network with one reticulation and two leaves has two perfect sets each one inducing the same displayed tree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 6 Let N be a tree-child network on X and"
        },
        {
            "text": "Note that in more general cases of networks (see relaxed networks in Section Beyond tree-child networks) additional removal of non-labeled vertices with out-degree zero (i.e., unlabelled leaves) from N \\ Y is required to obtain a semi-binary tree on X.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 6 Let N be a tree-child network on X and"
        },
        {
            "text": "This section presents several theoretical results connecting our scoring functions in the class of tree-child networks. Note that the notion of a cost will be used only with the DC cost defined in (1) for trees and for phylogenetic networks in Problem 1, while for scenarios, we will use the notion of a (DC) score.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DC scores of scenarios vs. DC costs of displayed trees"
        },
        {
            "text": "To establish the correspondence between DC scores and DC costs, we first show that each perfect set Y determines a scenario. Recall that N Y is obtained from N\\Y by contracting semi-binary nodes. Let N Y be the graph obtained from N by removing all edges e such that \u03c3 (e) \u2208 E R (N ) \\ Y and all subtrees whose root is the bottom node of e.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DC scores of scenarios vs. DC costs of displayed trees"
        },
        {
            "text": "Proof The proof is by induction with unfolding steps. Using the same notation, we construct N/Y iteratively using the sequence of reticulation nodes from the construction of N .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 Let N be a tree-child network and"
        },
        {
            "text": "N Y can be equivalently obtained by modification of the original unfolding step by removing the copy S i or the original subtree rooted at r i depending on whether the corresponding reticulation edge is in Y. For a tree-child network N, a gene tree G and a perfect set Y \u2286 E R (N ) , we define a scenario \u03be Y for G and N, such that for each gene leaf g labeled Figure 1 . Moreover, for G = ((a, (b, c) ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 361,
                    "end": 369,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 390,
                    "end": 401,
                    "text": "((a, (b, c)",
                    "ref_id": null
                }
            ],
            "section": "Lemma 8 Let N be a tree-child network and"
        },
        {
            "text": "We say that e \u2208 E R (N ) is directly used by scenario \u03be if there is a visited edge e \u2032 of Type I or II such that \u03c3 (e \u2032 ) = e . Similarly, we say that reticulation edge e is potentially used by \u03be if the sibling edge of e is bypassed by \u03be . By \u03d2 \u03be \u2286 E R (N ) we denote the set of reticulation edges used directly or potentially by \u03be (see Fig. 2 ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 337,
                    "end": 343,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Lemma 8 Let N be a tree-child network and"
        },
        {
            "text": "We say that Y \u2286 E R (N ) has a conflict if Y contains two sibling edges. We say that \u03be is regular if \u03d2 \u03be has no conflict. For instance, \u03d2 E 4 for E 4 from Fig. 2 has two possible conflicts in N. Observe that \u03d2 \u03be may not be perfect in general, even if \u03be is regular. For instance, if G = (c, d) and \u03be maps c to c 3 in the network from Fig. 2 , then \u03d2 \u03be = {\ufffdy, q\ufffd}. Now, we can state the crucial proposition that establishes a correspondence between regular scenarios and embedding to trees displayed by a tree-child network.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 155,
                    "end": 161,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 333,
                    "end": 339,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Lemma 8 Let N be a tree-child network and"
        },
        {
            "text": "Proof (\u21d0 .) If \u03d2 \u03be is a subset of a perfect set Y, then \u03d2 \u03be has no conflict. Thus, \u03be is regular. ( \u21d2 ). If \u03be is regular, then there is at least one perfect Y such that \u03d2 \u03be \u2286 Y . Based on the definitions of DC and D C , it is sufficient to prove for every edge \ufffdv, w\ufffd \u2208 E(G) , where M is the lca-mapping between G and the species tree N Y , for one fixed perfect set Y \u2287 \u03d2 \u03be .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 9 (Scenario-Displayed Tree Correspondence) Let N be a tree-child network and let G be a gene tree. A scenario \u03be for G and N is regular, if and only if for every perfect set Y such that"
        },
        {
            "text": "Note that no removed edge from N is visited by scenario \u03be , we conclude that \u03c3 (M \u03be (g)) = M(g) for every g. If ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 9 (Scenario-Displayed Tree Correspondence) Let N be a tree-child network and let G be a gene tree. A scenario \u03be for G and N is regular, if and only if for every perfect set Y such that"
        },
        {
            "text": "an edge e i = \ufffdp i , p i+1 \ufffd , with 0 < i < m we have, the following types of edges:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 9 (Scenario-Displayed Tree Correspondence) Let N be a tree-child network and let G be a gene tree. A scenario \u03be for G and N is regular, if and only if for every perfect set Y such that"
        },
        {
            "text": "\u2022 Type I: the edge exists since m > 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 9 (Scenario-Displayed Tree Correspondence) Let N be a tree-child network and let G be a gene tree. A scenario \u03be for G and N is regular, if and only if for every perfect set Y such that"
        },
        {
            "text": "and only if i > 1 and e i has Type II. Moreover, the directed path contains one edge of Type I. Thus, |\u03ba \u03be (v, w)| = d . This completes the proof of (3) and ( \u21d2 ) implication.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 9 (Scenario-Displayed Tree Correspondence) Let N be a tree-child network and let G be a gene tree. A scenario \u03be for G and N is regular, if and only if for every perfect set Y such that"
        },
        {
            "text": "In the following proposition, we show that the cost of a tree displayed by a network using a perfect set is bounded from below by the cost of its corresponding scenario.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 9 (Scenario-Displayed Tree Correspondence) Let N be a tree-child network and let G be a gene tree. A scenario \u03be for G and N is regular, if and only if for every perfect set Y such that"
        },
        {
            "text": "Proof The proof is similar to the proof of Proposition 9, with the difference that we show",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 10 Let N be a tree-child network and let G be a gene tree. If"
        },
        {
            "text": "where M is the lca-mapping between G and N Y . The only difference is in the edges of Type III in the last part of the proof. Here, we have degN (p i ) = 2 and e i bypasses the reticulation edge e \u2032 . As we do not have the assumption that Y \u03be \u2286 Y , e \u2032 may be present in Y. In such a case, degN (p i ) = 2 . Thus, the node \u03c3 (p i ) has outdegree 2 in N Y . We conclude that ||M(v), M(w)|| \u2212 |\u03ba \u03be Y (v, w)| is the number of edges of Type III on the directed path from M \u03be (v) to M \u03be (w) that bypass an edge from Y. This completes the first part of the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 10 Let N be a tree-child network and let G be a gene tree. If"
        },
        {
            "text": "Finally, we show that the equality between the score and the cost holds only if the induced scenario is regular.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 10 Let N be a tree-child network and let G be a gene tree. If"
        },
        {
            "text": "Proof (\u21d0 ). It follows from Proposition 9. ( \u21d2 ). From the proof of Proposition 10, we conclude that equality holds only if there is no edge in Y bypassed by \u03be Y . Thus, each edge potentially used by \u03be Y must be in Y. As every directly used edge is also in Y, by the construction of \u03be Y , we have \u03d2 \u03be \u2286 Y . Thus, \u03d2 \u03be is regular. The next theorem states that the cost of an optimal tree displayed by a network is bounded from below by the score of an optimal scenario. Theorem 12 (Lower Bound Property) Let N be a treechild network and let G be a gene tree. If S * is an optimal tree displayed by N, and \u03be * is an optimal scenario for G and N then DC(G, S * ) \u2265DC(G, N , \u03be * ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 11 Let N be a tree-child network and let G be a gene tree. If"
        },
        {
            "text": "Proof If S * is a tree displayed by N then there is a perfect Y such that S * = N Y . Thus Finally, we present a crucial theoretical property used to solve ODT-DC in class of tree-child networks using solutions to instances of DC-MinRec.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 11 Let N be a tree-child network and let G be a gene tree. If"
        },
        {
            "text": "Dynamic programming algorithms are commonly used in tree reconciliation, including models based on directed acyclic graphs (DAGs) [7, 9, 17, 23, 27] , where a gene tree is mapped to a tree or a DAG through the lca-mapping or general mapping based on concepts close to our scenarios. Such approaches often lead to polynomial time solutions with square time complexity in the best case. Here, we present two dynamic programming solutions to Problem 4 by providing formulas to compute the score of an optimal scenario. We start with a simplified and computationally demanding DP formulation. Then, we show an efficient approach running in square time.",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 133,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 134,
                    "end": 136,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 137,
                    "end": 140,
                    "text": "17,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 141,
                    "end": 144,
                    "text": "23,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 145,
                    "end": 148,
                    "text": "27]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Dynamic programming (DP) algorithms to solve DC-MinRec"
        },
        {
            "text": "Additional notation: By v \u2032 and v \u2032\u2032 , we denote the children of v \u2208 T (N ) , and by r \u2032 the child of a reticulation node r. For simplicity, instead of \u03c3 (M \u03be (g)) for a gene tree node g, we write \u03be g (i.e., \u03be [.] is a mapping from G to N).",
            "cite_spans": [
                {
                    "start": 210,
                    "end": 213,
                    "text": "[.]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Dynamic programming (DP) algorithms to solve DC-MinRec"
        },
        {
            "text": "We can express the formula for \u03b4 in the following way:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "where, for s t in N,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "Here \u1e59 and r denote the parents of a reticulation node r.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "The correctness of the above formulas follows from the following two Lemmas.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "Lemma 14 (Correctness of \u03c0) For s t , \u03c0(s, t) is the minimal number of Type I or II edges between two nodes a b in N such that \u03c3 (a) = s and \u03c3 (b) = t.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "Proof It follows from Theorem 3, that \u03c0 can be computed directly from N. The proof is by induction on the length of the directed path. The cases in \u03c0 formulas correspond directly to the types of edges (see comments in (5)), where we add/set 1 if the visited edge has Type I or II. Note that there is only one branching when t \u2208 R(N ) .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "(4) \u03b4(g, s) := \uf8f1 \uf8f2 \uf8f3 min s\ufffdt,u \u03b4(g \u2032 , t) + \u03c0(s, t) + \u03b4(g \u2032\u2032 , u) + \u03c0(s, u) g \u2208 T (G) and s / \u2208 R(N ), 0 g, s are leaves with the same label, +\u221e otherwise,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "||s, t|| \u2264 1 (the empty path or Type I), 1 + \u03c0(s, t.parent) {t, t.sibling, t.parent} \u2229 R(N ) = \u2205 (Tp. II), 1 + min(\u03c0(s,\u1e6b), \u03c0(s,\u1e97)) t \u2208 R(N ) (Type II), \u03c0(s, t.parent) t.sibling or t.parent \u2208 R(N ) (Type III/IV), +\u221e otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dynamic programming formulation in O(|G||N 3 |) time: the first approach"
        },
        {
            "text": "Proof (\u21d0 ). Take any perfect set Y such that Y \u03be * \u2286 Y and S := N Y . The equality follows from Proposition 11. ( \u21d2 ). By Theorem 12, S is an optimal tree displayed by N, since d is a lower bound for the cost of a displayed tree. Now, we take the perfect set Y induced by S. The scenario \u03be Y has score d. Hence, it is optimal. By Proposition 11, \u03be Y is also regular. In such a case, the formula will choose the directed path to s with the lower cost. We omit technical details.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 13 (Regularity) Let d be the score of an optimal scenario of a gene tree G and a tree-child network N. A tree S displayed by N with DC(G, S) = d exists, if and only if there is an optimal regular scenario of G and N."
        },
        {
            "text": "For g and s, \u03b4(g, s) from Equation (4) is the minimal number of Type I/II edges visited by edges from E(G|g) in a scenario \u03be, in the set of all scenarios \u03be between G and N such that \u03be g = s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 15 (Correctness of \u03b4)"
        },
        {
            "text": "Proof The proof follows by the induction on the structure of G and N, where Lemma 14 is applied to prove the induction hypothesis in each step. We omit easy details.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 15 (Correctness of \u03b4)"
        },
        {
            "text": "Computing \u03b4 using the above formulas requires O(|N | 2 + |G||N | 3 ) time and O(|G||N | + |N | 2 ) space. Therefore, this approach is rather prohibitive for larger instances.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 15 (Correctness of \u03b4)"
        },
        {
            "text": "By G|g, we denote the subtree of G rooted at g. The main component of dynamic programming is \u03b4 such that for g \u2208 V (G) and s \u2208 V (N ) , \u03b4(g, s) is the minimum score for G|g in the set of all scenarios \u03be between G|g and N such that \u03be g = s . For simplicity, we ignore \u22121 from the D C formula in the partial costs in \u03b4 as this yields a constant term dependent on the size of G.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Efficient DP solution in O(|G||N|) time"
        },
        {
            "text": "Let \u03c4 (s) be 0 if s is a reticulation, and 1 otherwise. Then, we have the following dynamic programming formula that solves DC-MinRec:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Efficient DP solution in O(|G||N|) time"
        },
        {
            "text": "In the next Lemma, we express properties satisfied by the above formulas.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Efficient DP solution in O(|G||N|) time"
        },
        {
            "text": "Let g \u2208 V (G) , s \u2208 V (N ) and all scenarios below are for G and N. D1 \u03b4(g, s) is equal to minimum number of Type I/II edges visited by edges from E(G|g) among scenarios \u03be satisfying \u03be g = s. D2 If c is a child of g and t is not a reticulation. Then, \u03b4 \u2191 (c, t) is equal to minimum number of Type I/ II edges visited by edges from E(G|c) plus the number of edges e \u2032 = \ufffda, b\ufffd of Type II visited by {\ufffdc, g\ufffd} with t \u03c3 (a) among scenarios \u03be such that \u03be g = s \u227b t \ufffd \u03be c . D3 If c is a child of g and s is a tree node. Then, \u03b4 f (c, s) is equal to minimum number of Type I/II edges visited by edges from E(G|c) \u222a {\ufffdc, g\ufffd} among scenarios \u03be satisfying \u03be g = s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16"
        },
        {
            "text": "Proof We follow with D1, where the proofs for D2-D3 are included as internal statements. The proof is by induction on the structure of G and N. The base is when g and s are leaves, for which D1 is obvious. Inductive assumption: D1 holds, for every x, y such that g x , s y , and either x = g or y = s . Inductive hypothesis: D1 holds for g and s, where at least one of g and s is not a leaf. The proof for D2. Let \u03be be the scenario having the minimal number of I/II-edges as defined in D2 and let k be the number of these edges. We follow by induction by assuming that \u03b4 \u2191 (c, u) satisfies D2 for all u, such that t \u227b u / \u2208 R(N ) . We prove D2 for t. The base step is when \u03be c = t . Then, k = \u03b4(c, t) and D2 follows from the induction assumption for D1 with cases (11) (the first expression when t is a tree node) and (13) (when t is a leaf ). Assume that t \u227b \u03be c , then g, c visits the edge e = \ufffda, b\ufffd such that \u03c3 (e) = \ufffdt, t \u2032 \ufffd . We have three cases. (Case D2.i) If both children of t are tree nodes, then e has Type II. Note that \u03be also has the minimal number of edges satisfying the inductive assumption with nodes c and t \u2032 . Otherwise, if there is a scenario \u03be \u2032 with a score < k \u2212 1 for c and t \u2032 then by visiting e, we will have a scenario with < k edges for D2. This contradicts the assumption that k is minimal. Thus, k = 1 + \u03b4 \u2191 (c, t \u2032 ) , by the inductive assumption. As \u03c4 (t \u2032 )\u03c4 (t \u2032\u2032 ) = 1 , this matches the second expression in (11) . (Case D2.ii) If t \u2032 is a tree node and t \u2032\u2032 is a reticulation then \u03be bypasses the reticulation edge \ufffdt, t \u2032\u2032 \ufffd . Similarly to the previous case, we show that \u03be satisfies inductive assumption with c and t \u2032 (we omit details). Thus, k = \u03b4 \u2191 (c, t \u2032 ) and \u03c4 (t \u2032 )\u03c4 (t \u2032\u2032 ) = 0 , again this matches the second expression in (11) . (Case D2.iii) If t \u2032 is a tree node and t \u2032 is a reticulation then \u03be directly uses reticulation edge \ufffdt, t \u2032 \ufffd , i.e., e has Type II. Again, we show that \u03be satisfies inductive assumption with c and a tree node v being the child of reticulation t \u2032 (we omit details). By the inductive assumption, we have k = 1 + \u03b4 \u2191 (c, v) , which equals \u03b4 \u2191 (c, t \u2032 ) = 1 + \u03b4 \u2191 (c, v) , by (11) with \u03c4 (t \u2032 )\u03c4 (t \u2032\u2032 ) = 0 , then by (12) .",
            "cite_spans": [
                {
                    "start": 1447,
                    "end": 1451,
                    "text": "(11)",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1775,
                    "end": 1779,
                    "text": "(11)",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 2156,
                    "end": 2160,
                    "text": "(11)",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 2198,
                    "end": 2202,
                    "text": "(12)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 16"
        },
        {
            "text": "The proof for D3. Let \u03be be the scenario having the minimal number of I/II-edges as defined in D3 and let k be the number of these edges. If \u03be c = s , then there is no edge visited by c, g . Thus, k = \u03b4(c, s) by the induction assumption, which is the first expression in min of (6). Otherwise, assume that for a child s \u2032 of s, s \u2032 \ufffd \u03be c = t . Then, there is one edge of Type I visited by c, g . We have two cases. (Case D3.i) If s \u2032 is a reticulation, then \u03c4 (s \u2032 ) = 0 and k = \u03b4 \u2191 (g, s \u2032 ) = 1 + \u03b4 \u2191 (g, t) where t is the child of s \u2032 . The latter follows from (12) and D2 (with s := t ). Note that \u03be has the minimal number of edges k \u2212 1 satisfying the corresponding assumptions of D2 (see a similar argument in the proof of case D2.i). (Case D3.ii) If s \u2032 is a tree node or a leaf then k = 1 + \u03b4 \u2191 (g, s \u2032 ) by D2 (with s \u2032 ). In both cases Type I edge is included. The rest is similar to case D3.i. This completes the proof of D3.",
            "cite_spans": [
                {
                    "start": 563,
                    "end": 567,
                    "text": "(12)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 16"
        },
        {
            "text": "The proof of D1. It follows from D3, that \u03b4 f (c, s) = min s\ufffdt \u03b4(c, t) + \u03c0(s, t)) (see def. of \u03c0 in section Dynamic programming formulation in O(|G||N 3 |) time: the first approach), for a child c of g. Thus, if g and s are tree nodes we show that \u03b4(g, s) = (min s\ufffdt \u03b4(g \u2032 , t) + \u03c0(s, t)) + (min s\ufffdu \u03b4(g \u2032\u2032 , u) + \u03c0(s, u)) . The proof follows similarly to the previous cases by analysing \u03be with the minimal number of edges satisfying constraints from D1 (see also the recursion from (4) and Lemma 15) . The case relates to (6) . We skip details. Finally, we have two remaining cases. If g is a leaf and s is a tree node, then there is no scenario \u03be satisfying \u03be g = s . Then, the number is +\u221e (case (9)). If s is a leaf and g is a tree node, we have \u03b4(g, s) = 0 if all leaves below g are labeled by the label of s, and +\u221e otherwise. This agrees with the number of visited Type I/II edges, where, in the second case, the set of scenarios satisfying the assumptions is empty.",
            "cite_spans": [
                {
                    "start": 483,
                    "end": 486,
                    "text": "(4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 491,
                    "end": 500,
                    "text": "Lemma 15)",
                    "ref_id": null
                },
                {
                    "start": 523,
                    "end": 526,
                    "text": "(6)",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 16"
        },
        {
            "text": "The optimal score is given by the following theorem, whose proof follows immediately from the definitions of \u03b4 , D C and Lemma 16.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16"
        },
        {
            "text": "To infer an optimal scenario, we apply standard backtracking based on values of \u03b4 array. Since there are three arrays, each of size |G||N| and every cell of an array can be computed in O(1) time, DP has O(|G||N|) time and space complexity. Note that in implementation \u03b4 f can be embedded into \u03b4 computation. Thus, the space may be reduced to two arrays.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 17 Given a gene tree G and a tree-child network N. The score of an optimal scenario"
        },
        {
            "text": "An optimal scenario can be inferred from DP formulas using standard backtracking. However, this scenario may not be perfect. To further utilize the results of DP, we infer the set of used reticulation edges. For two nodes v and w, let \u03c1(v, w) = {\ufffdv, w\ufffd} denote the one-element set with v, w if this edge is a reticulation edge in N, and \u03c1(v, w) = \u2205 otherwise. Similarly, by \u03c1(v, w) we denote the one-element set with the sibling edge of e = \ufffdv, w\ufffd if e is a reticulation edge in N, and \u03c1(v, w) = \u2205 , otherwise. Then, DP components \u03b4 , \u03b4 f and \u03b4 \u2191 are associated with reticulation edge usage rules u, u f , and u \u2191 , resp., as follows: The correctness of above formulas follows from the next lemma.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Inferring used reticulations edges from DP"
        },
        {
            "text": "If the backtracking of DP results in a scenario \u03be, then \u03d2 \u03be = u(G. root , \u03be G. root ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 18"
        },
        {
            "text": "The proof follows by analysis of cases when reticulation edges are directly or potentially used by \u03be and it is based on the details from the proof of Lemma 16. There are three main cases when a reticulation edge is inserted using \u03c1 or \u03c1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof"
        },
        {
            "text": "Case I. When the first edge (Type I) on the visited, directed path is a reticulation edge, then, its corresponding reticulation edge from N is inserted in u f (g, s) using \u03c1(s, c) in the second case. See also (D3.ii) in the proof of Lemma 16.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof"
        },
        {
            "text": "Case II. When the visited reticulation edge has Type II, then the corresponding reticulation edge is inserted in u \u2191 (g, s) using \u03c1(s, c) in the last case. See also (D2.iii) in the proof of Lemma 16.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof"
        },
        {
            "text": "Case III. When the scenario bypasses a reticulation edge e, then e inserted in u \u2191 (g, s) using \u03c1(s, c.sibling) in the last case. See also (D2.ii) in the proof of Lemma 16. (6), \u2205 in (7)- (9),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof"
        },
        {
            "text": "in (12),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof"
        },
        {
            "text": "for some c \u2208 {s \u2032 , s \u2032\u2032 } in (11) .",
            "cite_spans": [
                {
                    "start": 30,
                    "end": 34,
                    "text": "(11)",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Proof"
        },
        {
            "text": "In this Section, we propose algorithms to solve ODT-DC in the class of tree-child networks. We also show how to adopt the solution to use structural properties of tree-child networks (e.g., level-k tree-child networks).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Inferring optimal displayed trees under deep coalescence cost"
        },
        {
            "text": "Also, we answer whether the problem can be analogously solved when the class of networks is broader than tree-child.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Inferring optimal displayed trees under deep coalescence cost"
        },
        {
            "text": "Theorem 13 motivates the following general branching algorithm to solve ODT-DC. Suppose DP returns a solution with a conflict. Then, such a conflict can be resolved by branching and solving two sub-instances of the problem with phylogenetic networks induced from the input phylogenetic network by removing exactly one edge from the conflict. Let N e be the tree-child network obtained from N /{e} by contracting all semi-binary nodes 3 . Algorithm 1 details the procedure to infer an optimal tree displayed by a given network. Here, branching occurs when there is a conflict in the set of used reticulation edges. Thus, if the number of conflicts is low, e.g., when G and N are similar, we expect a small number of DP invocations. Wawerka et al. Algorithms for Molecular Biology (2022) 17:11 Correctness of Algorithm 1 follows from Theorem 13 and the following theorem.",
            "cite_spans": [
                {
                    "start": 786,
                    "end": 791,
                    "text": "17:11",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Solution to ODT-DC in the class of tree-child networks"
        },
        {
            "text": "If e, e \u2032 \u2208 E R (N ) are sibling edges then DC (G, N ) = min{DC(G, N e ) , DC(G, N e \u2032 )}. Moreover, T is an optimal tree displayed by N if and only if T is an optimal tree displayed by a network N e or N e \u2032 with minimum cost.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 47,
                    "end": 72,
                    "text": "(G, N ) = min{DC(G, N e )",
                    "ref_id": null
                }
            ],
            "section": "Theorem 19"
        },
        {
            "text": "Proof Let \ufffd(N ) be the set of all trees displayed by N. Then, the first statement follows from the fact that for tree-child networks, \ufffd(N ) = \ufffd(N e ) \u222a \ufffd(N e \u2032 ) and \ufffd(N e ) \u2229 \ufffd(N e \u2032 ) = \u2205 . The second statement follows easily from the above observation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 19"
        },
        {
            "text": "In the worst case, we need to branch for every reticulation twice, which gives 2 r+1 \u2212 1 invocations of DP. Thus, Algorithm 1 has time complexity O(2 r |G||N |) in the worst case. However, as mentioned previously, we expect Algorithm 1 to behave better than worst complexity in practice. See also our experimental evaluation in Section Results. [3] Recall that N/X is the network obtained from N by removing all edges from X. In applications where only the optimal cost is needed, for instance, in problems of network inference, we can use the Lower Bound Theorem 12. As the cost of an optimal displayed tree is bounded below by the score from DP, we can also compute the upper bound using regular scenarios returned from multiple invocations of DP. See details in Algorithm 2. bounds are correct for N e and N e \u2032 . For the lower bound of N, we have to take a minimum of l and l \u2032 , as there may exist the optimal scenario for the network N e or N \u2032 e with the cost min(l, l \u2032 ) in the \"worst\" case. Such a scenario is optimal for N. Similarly, we proceed with the upper bound. ",
            "cite_spans": [
                {
                    "start": 345,
                    "end": 348,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 19"
        },
        {
            "text": "Our results can also be extended to level-k tree-child networks. The definition and properties are adopted from [9, 39, 40] . A level-k network is a phylogenetic network in which every biconnected component has at most k reticulation nodes [39] . If B is a biconnected component of N, then by B. root we denote the unique node in B with no ancestors in B. Using the notation from [9] , by bc(N) we denote the tree obtained from N by contracting all its biconnected components. Let Lab(N ) denote the set of species present in N as leaf labels.",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 115,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 116,
                    "end": 119,
                    "text": "39,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 120,
                    "end": 123,
                    "text": "40]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 240,
                    "end": 244,
                    "text": "[39]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 380,
                    "end": 383,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Inferring optimal trees displayed by level-k tree-child networks"
        },
        {
            "text": "In Algorithm 3, edges visited by subtrees of G have to be connected in the embedding. Therefore, for each non-root component B in b(N), we minimize the score using the additional costs of a path to the root of B. Formally, DC \u2191 (G, N ) is the minimum value of DC(G, S) + ||M(G. root ), S. root || in the set of all displayed trees S of N. Computing the value (almost) does not require modification of our algorithms. Here, instead of the formula from Theorem 17, we compute DC \u2191 (G, N ) using \u2212|E(G)| + \u03b4 \u2191 (G. root , S. root ) . The correctness follows from Lemma 16 case D2. The formula can be easily embedded into Algorithm 1. The time complexity of Algorithm 3 is O(2 k |G||N |).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Inferring optimal trees displayed by level-k tree-child networks"
        },
        {
            "text": "DP can be extended to analyse a broader class of networks, which is more beneficial from a practical point of view. Assume that instead of a tree-child network condition, our class of networks satisfies a relaxed condition: each node has at most one reticulation child. This assumption admits the child of reticulation to be a reticulation, which is not allowed in tree-child networks. Such networks, we call relaxed. We did not find an equivalent class in the literature. Note that the relaxed class is incomparable with a well-known class of Tree-Sibling networks (see networks N 1 and N 2 in Fig. 3 ), characterized by the condition: each reticulation has a tree-node sibling. Also, relaxed networks are not stable [41] in general, since the relaxed condition admits non-compressed networks (see Theorem 1 from [38] ). For example, N 1 from Fig. 3 is not stable.",
            "cite_spans": [
                {
                    "start": 718,
                    "end": 722,
                    "text": "[41]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 814,
                    "end": 818,
                    "text": "[38]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [
                {
                    "start": 595,
                    "end": 601,
                    "text": "Fig. 3",
                    "ref_id": null
                },
                {
                    "start": 844,
                    "end": 850,
                    "text": "Fig. 3",
                    "ref_id": null
                }
            ],
            "section": "Beyond tree-child networks"
        },
        {
            "text": "For the relaxed class, we modify DP in (12): \u03c4 (s \u2032 ) + \u03b4 \u2191 (g, s \u2032 ) , and in usage rules in the 2nd case of u \u2191 referring to (12) : u \u2191 (g, s) \u222a \u03c1(s, c) , which is needed when the child is also a reticulation. Under this modification, Algorithm 1 returns a correct optimal displayed tree. We omit details for brevity.",
            "cite_spans": [
                {
                    "start": 127,
                    "end": 131,
                    "text": "(12)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Beyond tree-child networks"
        },
        {
            "text": "We also analysed a general class of binary networks, i.e., in which a tree node may have two reticulation children. However, DP cannot correctly analyse such networks. When embedding a gene tree (a, b) into the network N 3 from Fig. 3 , we see that the optimal displayed tree is S = ((a, b) , c) with the cost 0. Here, S is constructed by removing a node x and all three incident edges, and a tree node x.parent with two children is also contracted. In the current DP, when a gene edge a.parent, a from G visits x.parent DP will increase the cost. Therefore, the lower bound property is not satisfied in this case unless a solution in which such removed tree nodes are detected is implemented. It remains open whether it can be done in polynomial time without checking all variants of displayed trees. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 228,
                    "end": 234,
                    "text": "Fig. 3",
                    "ref_id": null
                },
                {
                    "start": 283,
                    "end": 290,
                    "text": "((a, b)",
                    "ref_id": null
                }
            ],
            "section": "Beyond tree-child networks"
        },
        {
            "text": "Algorithms presented in the previous Section can naturally by modified to operate on cost functions such as gene duplication or gene duplication and loss [16] . The main difference is the way an optimal scenario is computed. Here, we present a dynamic programming solution for optimal scenario problem under duplication cost.",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 158,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Optimal displayed trees under gene duplication cost (ODT-DUP)"
        },
        {
            "text": "Since the results are analogous to the deep coalescence cost, we omit most of the theoretical details for brevity. Given previously defined lca-mapping between a gene tree G and a species tree S, M : V (G) \u2192 V (S) , we define duplication contribution of vertex g \u2208 V (G) , which has two children g \u2032 , g \u2032\u2032 as If g is a leaf, then dup(g) = 0 . Then, the duplication cost between G and S (denoted by DUP(G, S) ) is defined as DUP(G, S) = g\u2208T (G) dup(g) [22] .",
            "cite_spans": [
                {
                    "start": 452,
                    "end": 456,
                    "text": "[22]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Optimal displayed trees under gene duplication cost (ODT-DUP)"
        },
        {
            "text": "In this section we solve the following problem. Similarly to deep coalescence score, given a scenario \u03be : V (G) \u2192 V (S) , we define duplication score contribution of a vertex g \u2208 V (G) as follows. If there is a child g \u2032 of g such that M \u03be (g) = M \u03be (g \u2032 ) , then d up(g) = 1 . Otherwise, d up(g) = 0 . Then, the duplication score for G, N and a scenario \u03be is defined as D UP(G, N , \u03be) = g\u2208T (G)d up(g) . Duplication score has analogous properties to the ones proved in Theorem 12 and Theorem 13, thus the score can be applied in our branch-and-bound framework. We omit details for brevity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal displayed trees under gene duplication cost (ODT-DUP)"
        },
        {
            "text": "Similar to the DC case, we have two dynamic programming arrays, \u03b4 and \u03b4 \u2191 . Recall, that \u03b4(g, s) is the minimum score for G|g in the set of all scenarios \u03be between G|g and N such that \u03be g = s , and \u03b4 \u2191 (g, s) is the minimum score for G|g in the set of all scenarios \u03be between G|g and N such that \u03be g = y , where s y . Dynamic programming formulation is as follows Distance between the simulated displayed trees and the corresponding gene trees for six sets of simulation parameters. For visualisation purposes we smoothed out the obtained histogram using a Gaussian kernel density estimate calculated by [59] with bandwidth set to 0.03. DP components \u03b4 and \u03b4 \u2191 are associated with usage rules u, u \u2191 respectively, as follows:",
            "cite_spans": [
                {
                    "start": 604,
                    "end": 608,
                    "text": "[59]",
                    "ref_id": "BIBREF59"
                }
            ],
            "ref_spans": [],
            "section": "Optimal displayed trees under gene duplication cost (ODT-DUP)"
        },
        {
            "text": "In this section, we present the experimental evaluation using our prototype implementation of DP, Algorithm 1 and Algorithm 2 called EmbRetNet written in Python 3. The algorithms were extended to analyse the class of networks in which a node has at most one reticulation child (see discussion in the previous sections). The software package is available from the bitbucket repository.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "We show the performance of our algorithm where the gene tree is simulated using its network. Since both the gene tree and its network are topologically related, we expect better performance than in the worst case scenario. We summarize the results of several experiments to compare the performance of our implementation of Algorithm 1 to the na\u00efve implementation in which all trees displayed by a given network are generated, and then, the costs are computed using a linear time solution from [15] . Note that both algorithms have exponential time complexity; however, the na\u00efve algorithm always has the same number of steps, proportional to 2 r (|G| + |N |) , where r is the number of reticulations in N. Experiments were conducted on a Ubuntu server with Intel(R) Xeon(R) CPU E5-2698 v4@2.20GHz (80 cores) and 500 GB of RAM.",
            "cite_spans": [
                {
                    "start": 493,
                    "end": 497,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Performance of inferring optimal displayed trees"
        },
        {
            "text": "Data preparation: To generate random tree-child phylogenetic networks, we used an algorithm from [42] and its implementation in Python from GitHub with a slight modification to generate only binary networks. Random gene trees with one-to-one labeling of leaves were generated using the Yule-Harding model. Then, we generated datasets R1, R2, and R3, each consisting of 2 \u00b7 10 \u00b7 100 pairs of random gene trees and networks. For each n \u2208 {12, 20} and r \u2208 {1, 2, . . . , 10} , we generated 100 pairs G, N , such that N is a network with n leaves and r reticulations and in dataset R1 |L(G)| = n , in R2 the number",
            "cite_spans": [
                {
                    "start": 97,
                    "end": 101,
                    "text": "[42]",
                    "ref_id": "BIBREF42"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on random datasets"
        },
        {
            "text": "for second case in (15) ,",
            "cite_spans": [
                {
                    "start": 19,
                    "end": 23,
                    "text": "(15)",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on random datasets"
        },
        {
            "text": "in (16)- (18),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation on random datasets"
        },
        {
            "text": "in (20),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation on random datasets"
        },
        {
            "text": "of leaves in G is sampled uniformly from the interval [2, n] , and in R3 G is a randomly chosen tree displayed by N.",
            "cite_spans": [
                {
                    "start": 54,
                    "end": 60,
                    "text": "[2, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on random datasets"
        },
        {
            "text": "Discussion: In Figs. 4 and 6 , we summarize the experimental evaluation results of R1, R2 and R3 with our solution to ODT-DC, where G and N were generated independently. Since R1 and R3 represent extremes, in which G and N are highly different, our algorithm frequently infers conflicted sets of reticulation edges by visiting almost every possible scenario, thus achieving nearly the pessimistic exponential complexity. In consequence, it is noticeably slower than the na\u00efve one for R1. On the contrary, with data from R3 the algorithm rarely branches, and its average runtime matches the complexity of DP, i.e., O(|G||N|). Even with a larger constant factor, we outperform the na\u00efve algorithm for r > 4 , achieving > 15 times speedup for r = 10.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 15,
                    "end": 28,
                    "text": "Figs. 4 and 6",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Evaluation on random datasets"
        },
        {
            "text": "Our simulation procedure can be divided into three major phases: (i) simulating tree-child phylogenetic networks, (ii) simulating gene trees, and (iii) introducing errors to the gene trees. The selection of the parameters 17:11 in all three phases is mainly based on the simulation study conducted by Molloy and Warnow [43] , which uses parameters derived from a fungal dataset presented by Rasmussen and Kellis [44] .",
            "cite_spans": [
                {
                    "start": 222,
                    "end": 227,
                    "text": "17:11",
                    "ref_id": null
                },
                {
                    "start": 319,
                    "end": 323,
                    "text": "[43]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 412,
                    "end": 416,
                    "text": "[44]",
                    "ref_id": "BIBREF44"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "(i) Simulating tree-child phylogenetic networks. First, we simulated species trees using a general sampling approach implemented in R package TreeSim version 2.4 [45] with the parameters from [43] . Specifically, we ran sim.bd.taxa.age function with the following parameters: tree height = 1800000337.5 years, speciation rate = 1.8 * 10 \u22129 events/year and extinction rate = 0 events/ year. The number of leaves was set to 12 or 20.",
            "cite_spans": [
                {
                    "start": 162,
                    "end": 166,
                    "text": "[45]",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 192,
                    "end": 196,
                    "text": "[43]",
                    "ref_id": "BIBREF43"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "After simulating each species tree, we assigned a time value to all of its nodes, corresponding to a length of a path connecting the root with the node. Note that the general sampling approach produces ultrametric species trees, therefore time values assigned to the leaves were equal.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "Next, we inferred a network with k reticulations from each of the simulated species trees, where k was uniformly sampled from [1, 10] . We added k reticulations one by one, following a popular study by Solis-Lemus and An\u00e9 [46] . Similarly to [8] we constrained the networks to a tree-child class. To add a reticulation edge to a species tree/network, we started by randomly choosing a pair of distinct non-reticulation edges and subdivided them, making two new vertices. We then sampled a time value for each of the vertices from uniform(vertex.parent.time, vertex.child.time). Finally, we added a reticulation edge from the vertex with the lower time value t l to the vertex with the higher time value t h , creating a tree-based network [47] . If the addition disturbed the tree-child property, we deleted the reticulation edge and contracted the vertices. Otherwise, we set the length of the reticulation edge to t h -t l . The above procedure was repeated until k reticulations were successfully added.",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 129,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 130,
                    "end": 133,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 222,
                    "end": 226,
                    "text": "[46]",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 242,
                    "end": 245,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 739,
                    "end": 743,
                    "text": "[47]",
                    "ref_id": "BIBREF47"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "Note that this way of introducing reticulation edges does not change time values of the leaves, hence all displayed trees of the resulting network are ultrametric and have equal heights.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "(ii) Simulating gene trees. For each phylogenetic network, we randomly chose one of its base trees [47] , obtaining one of the possible trees, along which gene families evolve. We simulated one gene tree per each base tree using SimPhy version 1.0.2 [48] with the following command: where<tree>is a nexus file containing the randomly chosen base tree, $ps is the effective population size and $dl is a duplication/loss rate. Similarly to [43] , we used three rates of duplication/loss (DL) {10 \u221210 , 2 \u00b7 10 \u221210 , 5 \u00b7 10 \u221210 } and two values of the effective population size {10 7 , 5 \u00b7 10 7 } , corresponding respectively to a low and a medium level of incomplete lineage sorting (ILS). Altogether, we used six sets of simulation parameters, which allowed us to obtain a diversified set of gene trees. Note that low DL and ILS parameters were obtained based on biological data of Saccharomycetales fungi [44] , whilst higher parameters were used to test the performance of the algorithms in a more challenging environment.",
            "cite_spans": [
                {
                    "start": 99,
                    "end": 103,
                    "text": "[47]",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 250,
                    "end": 254,
                    "text": "[48]",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 438,
                    "end": 442,
                    "text": "[43]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 904,
                    "end": 908,
                    "text": "[44]",
                    "ref_id": "BIBREF44"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "(iii) Simulating sequences and estimating gene trees. To introduce errors to the generated gene trees, we simulated sequences and estimated gene trees from multiple sequence alignments using the maximum-likelihood method (MLE). DNA sequences were simulated by INDELible v1.03 [49] by running a perl script INDEL-ible_wrapper.pl included in SimPhy [48] . Again, we followed the parameters proposed in [43] . We used GTR model with substitution rates (AC, AG, AT, CG, CT and GT respectively) sampled for each gene tree from Dirichlet (12.776722, 20.869581, 5.647810, 9.863668, 30.679899, 3.199725 [50] using GTR+\u0174 model. Finally, to obtain a rooted gene tree from an unrooted ML-tree, we conducted midpoint-plateau rooting implemented in URec [51] using the corresponding displayed tree inferred in step (ii) of our pipeline.",
            "cite_spans": [
                {
                    "start": 276,
                    "end": 280,
                    "text": "[49]",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 347,
                    "end": 351,
                    "text": "[48]",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 400,
                    "end": 404,
                    "text": "[43]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 532,
                    "end": 594,
                    "text": "(12.776722, 20.869581, 5.647810, 9.863668, 30.679899, 3.199725",
                    "ref_id": null
                },
                {
                    "start": 595,
                    "end": 599,
                    "text": "[50]",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 741,
                    "end": 745,
                    "text": "[51]",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "Finally, for each set of parameters of duplication-loss rates, population sizes, reticulation values, and leaf-set sizes we simulated 100 networks and 100 corresponding gene trees.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "Then, we examined the impact of duplication-loss rates and population sizes on the results of the simulation. We calculated a distance between the displayed tree used to simulate a gene tree in step (ii) of our simulation pipeline and the rooted ML gene tree for each sample. We used a strict metric implemented in [52] , which was designed to compare species trees with gene trees in the presence of duplication events. The results are depicted in Fig. 5 . We observe that the distances are significantly higher for high and medium DL rates than for the low DL rate. It suggests that increasing the parameter resulted in more demanding datasets for our algorithms than average empirical data. Interestingly, we see little difference between the dataset simulated using low and medium ILS parameters, suggesting that incomplete lineage sorting rarely changed the tree topology during our simulation study. The simulations were run in parallel on ten cores and the total simulation time was under 8 h. The algorithm took 2 h to process all datasets, and it took, on average, 45 s to run 100 instances with 20 leaves and 10 reticulations for low ILS and low DL.",
            "cite_spans": [
                {
                    "start": 315,
                    "end": 319,
                    "text": "[52]",
                    "ref_id": "BIBREF52"
                }
            ],
            "ref_spans": [
                {
                    "start": 449,
                    "end": 455,
                    "text": "Fig. 5",
                    "ref_id": null
                }
            ],
            "section": "Evaluation on simulated datasets"
        },
        {
            "text": "Discussion. In Figs. 7 and 8, we present diagrams showing the results of evaluations for our datasets. The way we simulated data makes trees and networks more similar to each other. Thus, we can see significant improvements vs. random datasets. Regardless of parameter choices, we start to outperform the na\u00efve solution for r > 9 . For simulated data closest to reality (low ILS, low DL), we achieved better results for r > 7 . The results suggest a hybrid approach in Algorithm 1: enumerate all displayed trees to compute DC costs directly if the network has a low number of reticulations (e.g., r < 9).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results for deep coalescence cost"
        },
        {
            "text": "To estimate the average runtime of our algorithm, we first calculated the depths d of the recursive calls as log 2 of the number of DP invocations from each experiment. Then, we found that for all points r, d from our experiments, d = 0.543r \u2212 0.1135 is the fitted least squares regression line having the standard error of .011 (see Figs. 9, 10). We conclude that, despite the worst case theoretical complexity, i.e., O((2 r+1 \u2212 1)|G||N |) , the real runtime of our implementation on simulated data is proportional to 2 0.543r |G||N | and outperforms the na\u00efve approach starting from small r's. We claim that a similar statement holds for the algorithm with level-k networks. In other words, it is possible to analyse empirical networks even with r = k = 40 , since the exponent can be reduced by half.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results for deep coalescence cost"
        },
        {
            "text": "We also have conducted analogous experiments on the same datasets under the duplication cost and the implementation of dynamic programming formulas (15)- (21) . In summary, our implementation outperforms na\u00efve Fig. 11 Average number of DP invocations necessary to calculate an answer for duplication cost, for datasets with low ILS. The blue line represents coefficients calculated by linear regression for data with low and medium ILS combined.",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 158,
                    "text": "(21)",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [
                {
                    "start": 210,
                    "end": 217,
                    "text": "Fig. 11",
                    "ref_id": null
                }
            ],
            "section": "Results for duplication cost"
        },
        {
            "text": "Average number of DP invocations necessary to calculate an answer for duplication cost, for datasets with medium ILS. Recall that blue line represents coefficients calculated by linear regression for data with low and medium ILS combined. approach for r > 5 . Using the same method to calculate the least squares regression line, we conclude that the average complexity for duplication is proportional to 2 0.355r |G||N | (see Figs. 11, 12; we omit the rest of the diagrams for brevity). Despite the same theoretical complexity of computing duplication and deep coalescence costs, dynamic programming formulas, and branch and bound strategies, we observe that the duplication cost has improved performance in practice in terms of the runtime and the exponent obtained in the regression formula. We claim that these improvements come directly from technically simpler formulas present in our algorithms under the duplication cost.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 12"
        },
        {
            "text": "Our final experiment was conducted using real data. We revisited research presented in [53] concerning coronavirus (CoV) phylogeny. In the cited paper, the authors investigated the origins of the SARS-CoV-2 virus, which causes severe respiratory disease. They validated the hypothesis that the appearance of this new coronavirus is a consequence of several recombination events that Table 1 List of the full names and database accession numbers of coronavirus species used in our research. Species were chosen from the dataset studied in [53] ",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 91,
                    "text": "[53]",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 538,
                    "end": 542,
                    "text": "[53]",
                    "ref_id": "BIBREF53"
                }
            ],
            "ref_spans": [
                {
                    "start": 383,
                    "end": 390,
                    "text": "Table 1",
                    "ref_id": null
                }
            ],
            "section": "Empirical tests"
        },
        {
            "text": "In this work, we have investigated the problem of inferring an optimal tree displayed by a network under the deep coalescence and duplication costs. For each cost function, we proposed a new score function to approximate the cost. We have shown that these score functions have nice mathematical and computational properties allowing us to bound the cost of an optimal displayed tree from below. We have proposed a polynomial-time dynamic programming (DP) algorithm to compute the score together with the set of used reticulation edges that yielded the score. Then, we have proposed a new way to infer a displayed tree by a recursive procedure resolving conflicts detected in multiple invocations of DP. In the worst case, our algorithm to infer an optimal tree requires 2 r+1 -1 DP invocations, where r is the number of reticulations. However, numerous tests on simulated data have indicated that the exponent may be reduced by half on average. This phenomenon is explained by similarity, i.e., we expect a low number of conflicts if a gene tree is more congruent with its network. In other words, the average runtime of \ufffd(2 0.543r |G||N |) for the DC cost and \ufffd(2 0.355r |G||N |) for the duplication cost can compete on empirical datasets with exhaustive enumeration strategies (either on the level of a whole network or each",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Networks: expanding evolutionary thinking",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Bapteste",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Van Iersel",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Janke",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kelchner",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kelk",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "O"
                    ],
                    "last": "Mcinerney",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Trends Genet",
            "volume": "29",
            "issn": "8",
            "pages": "439--480",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Phylogenetic networks: concepts algorithms and applications",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "H"
                    ],
                    "last": "Huson",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Rupp",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Hybridization in plants: old ideas",
            "authors": [
                {
                    "first": "B",
                    "middle": [
                        "E"
                    ],
                    "last": "Goulet",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Roda",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Hopkins",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "New Techniq Plant Physiol",
            "volume": "173",
            "issn": "1",
            "pages": "65--78",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Reassortment in segmented RNA viruses: mechanisms and outcomes",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "M"
                    ],
                    "last": "Mcdonald",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "I"
                    ],
                    "last": "Nelson",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "E"
                    ],
                    "last": "Turner",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "T"
                    ],
                    "last": "Patton",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Nat Rev Microbiol",
            "volume": "14",
            "issn": "7",
            "pages": "448--60",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Horizontal gene transfer in evolution: facts and challenges",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Boto",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Proc R Soc B Biol Sci",
            "volume": "277",
            "issn": "",
            "pages": "819--846",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "ReCombinatorics: the Algorithmics of ancestral recombination graphs and explicit phylogenetic networks",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "A polynomial-time algorithm for minimizing the deep coalescence cost for level-1 species networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lemay",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Libeskind-Hadas",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [
                        "C"
                    ],
                    "last": "Wu",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Robinson-Foulds reticulation networks",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Markin",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "K"
                    ],
                    "last": "Anderson",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "S"
                    ],
                    "last": "Vadali",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Eulenstein",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 10th ACM International Conference on Bioinformatics",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Efficient algorithms for reconciling gene trees and species networks via duplication and loss events",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "H"
                    ],
                    "last": "To",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "BMC Genomics",
            "volume": "16",
            "issn": "S10",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Improved maximum parsimony models for phylogenetic networks",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "V"
                    ],
                    "last": "Iersel",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jones",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Syst Biol",
            "volume": "67",
            "issn": "3",
            "pages": "518--560",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "In the light of deep coalescence: revisiting trees within networks",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Zhu",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "BMC Bioinformat",
            "volume": "17",
            "issn": "S14",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Gene trees in species trees",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "P"
                    ],
                    "last": "Maddison",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Syst Biol",
            "volume": "46",
            "issn": "3",
            "pages": "523--559",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "ASTRAL-II: coalescent-based species tree estimation with many hundreds of taxa and thousands of genes",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mirarab",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Warnow",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Bioinformatics",
            "volume": "31",
            "issn": "12",
            "pages": "44--52",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Species tree inference by minimizing deep coalescences",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Than",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "PLoS Comput Biol",
            "volume": "5",
            "issn": "9",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "From gene trees to species trees II: species tree inference by minimizing deep coalescence events",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "IEEE/ACM Trans Comput Biol Bioinf",
            "volume": "8",
            "issn": "6",
            "pages": "1685--91",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Unrooted tree reconciliation: a unified approach",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "G\u00f3recki",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Eulenstein",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tiuryn",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IEEE/ACM Trans Comput Biol Bioinf",
            "volume": "10",
            "issn": "2",
            "pages": "522--558",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "EUCALYPT: efficient tree reconciliation enumerator",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Donati",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Baudet",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Sinaimeri",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Crescenzi",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "F"
                    ],
                    "last": "Sagot",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Alg Mol Biol",
            "volume": "10",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Most parsimonious reconciliation in the presence of gene duplication, loss, and deep coalescence using labeled coalescent trees",
            "authors": [
                {
                    "first": "Y",
                    "middle": [
                        "C"
                    ],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "D"
                    ],
                    "last": "Rasmussen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "S"
                    ],
                    "last": "Bansal",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kellis",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Genome Res",
            "volume": "24",
            "issn": "3",
            "pages": "475--86",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Maximizing deep coalescence cost",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gorecki",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Eulenstein",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "IEEE/ACM Trans Comput Biol Bioinf",
            "volume": "11",
            "issn": "1",
            "pages": "231--273",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Efficient error correction algorithms for gene tree reconciliation based on duplication, duplication and loss, and deep coalescence",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Chaudhary",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "G"
                    ],
                    "last": "Burleigh",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Eulenstein",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "BMC Bioinformatics",
            "volume": "13",
            "issn": "",
            "pages": "1--10",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Fitting the gene lineage into its species lineage, a parsimony strategy illustrated by cladograms constructed from globin sequences",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Goodman",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "",
            "volume": "28",
            "issn": "",
            "pages": "132--163",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "GeneTree: comparing gene and species phylogenies using reconciled trees",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "D"
                    ],
                    "last": "Page",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Bioinformatics",
            "volume": "14",
            "issn": "9",
            "pages": "819--839",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "DLS-trees: a model of evolutionary scenarios",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "G\u00f3recki",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tiuryn",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Theoret Comput Sci",
            "volume": "359",
            "issn": "1-3",
            "pages": "378--99",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Reconciling a gene tree to a species tree under the duplication cost model",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bonizzoni",
                    "suffix": ""
                },
                {
                    "first": "Della",
                    "middle": [],
                    "last": "Vedova",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Dondi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Theoret Comput Sci",
            "volume": "347",
            "issn": "1-2",
            "pages": "36--53",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Algorithms for MDC-based multi-locus phylogeny inference: beyond rooted binary gene trees on single alleles",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Warnow",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "J Comput Biol",
            "volume": "18",
            "issn": "11",
            "pages": "1543--59",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Genomic duplication problems for unrooted gene trees",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Paszek",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "G\u00f3recki",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "BMC Genomics",
            "volume": "17",
            "issn": "S1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Fast algorithm for the reconciliation of gene trees and LGT networks",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                },
                {
                    "first": "Jcp",
                    "middle": [],
                    "last": "Mayol",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cardona",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "J Theor Biol",
            "volume": "418",
            "issn": "",
            "pages": "129--166",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "The probability of a gene tree topology within a phylogenetic network with applications to hybridization detection",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "H"
                    ],
                    "last": "Degnan",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "PLoS Genet",
            "volume": "8",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "PhyloNet: a software package for analyzing and reconstructing reticulate evolutionary relationships",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Than",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Ruths",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "BMC Bioinformat",
            "volume": "9",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Parsimonious inference of hybridization in the presence of incomplete lineage sorting",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "M"
                    ],
                    "last": "Barnett",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Syst Biol",
            "volume": "62",
            "issn": "5",
            "pages": "738--51",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Reconciling event-labeled gene trees with MUL-trees and species networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hellmuth",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "T"
                    ],
                    "last": "Huber",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Moulton",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "J Math Biol",
            "volume": "79",
            "issn": "5",
            "pages": "1885--925",
            "other_ids": {
                "DOI": [
                    "10.1007/s00285-019-01414-8"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Comparison of tree-child phylogenetic networks",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cardona",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Rossell\u00f3",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Valiente",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "IEEE/ACM Trans Comput Biol Bioinf",
            "volume": "6",
            "issn": "4",
            "pages": "552--69",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Comparison of tree-child phylogenetic networks",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cardona",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Rossello",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Valiente",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "IEEE/ACM Trans Comput Biol Bioinf",
            "volume": "6",
            "issn": "4",
            "pages": "552--69",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Counting and enumerating tree-child networks and their subclasses",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cardona",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "J Comput Syst Sci",
            "volume": "114",
            "issn": "",
            "pages": "84--104",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Reconstructing tree-child networks from reticulate-edge-deleted subnetworks",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Murakami",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Van Iersel",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Janssen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jones",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Moulton",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Bull Math Biol",
            "volume": "81",
            "issn": "10",
            "pages": "3823--63",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Phylogenetic networks from multi-labelled trees",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "T"
                    ],
                    "last": "Huber",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Moulton",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J Math Biol",
            "volume": "52",
            "issn": "5",
            "pages": "613--645",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Folding and unfolding phylogenetic trees and networks",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "T"
                    ],
                    "last": "Huber",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Moulton",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Steel",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "J Math Biol",
            "volume": "73",
            "issn": "6-7",
            "pages": "1761--80",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Computing the maximum agreement of phylogenetic networks",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Choy",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jansson",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sadakane",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "K"
                    ],
                    "last": "Sung",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Theoret Comput Sci",
            "volume": "335",
            "issn": "1",
            "pages": "93--107",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "On computing the maximum parsimony score of a phylogenetic network",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Fischer",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Van Iersel",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kelk",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "SIAM J Discret Math",
            "volume": "29",
            "issn": "1",
            "pages": "559--85",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Phylogenetic networks that are their own fold-ups",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "T"
                    ],
                    "last": "Huber",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "E"
                    ],
                    "last": "Scholz",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "Linear time algorithm for tree-child network containment",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Janssen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Murakami",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "International Conference on Algorithms for Computational Biology",
            "volume": "",
            "issn": "",
            "pages": "93--107",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "FastMulRFS: fast and accurate species tree estimation under generic gene duplication and loss models",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "K"
                    ],
                    "last": "Molloy",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Warnow",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Bioinformatics",
            "volume": "36",
            "issn": "Supplement1",
            "pages": "57--65",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "Unified modeling of gene duplication, loss, and coalescence using a locus tree",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "D"
                    ],
                    "last": "Rasmussen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kellis",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Genome Res",
            "volume": "22",
            "issn": "4",
            "pages": "755--65",
            "other_ids": {}
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Sampling trees from evolutionary models",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Hartmann",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wong",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Stadler",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Syst Biol",
            "volume": "52",
            "issn": "4",
            "pages": "465--76",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sol\u00eds-Lemus",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "An\u00e9",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "PLoS Genet",
            "volume": "12",
            "issn": "3",
            "pages": "1--21",
            "other_ids": {}
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "Which phylogenetic networks are merely trees with additional arcs?",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Francis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Steel",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Syst Biol",
            "volume": "64",
            "issn": "5",
            "pages": "768--77",
            "other_ids": {}
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "SimPhy: phylogenomic simulation of gene, locus, and species trees",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Mallo",
                    "suffix": ""
                },
                {
                    "first": "De",
                    "middle": [],
                    "last": "Oliveira Martins",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Posada",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Syst Biol",
            "volume": "65",
            "issn": "2",
            "pages": "334--378",
            "other_ids": {}
        },
        "BIBREF49": {
            "ref_id": "b49",
            "title": "INDELible: a flexible simulator of biological sequence evolution",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Fletcher",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Mol Biol Evol",
            "volume": "26",
            "issn": "8",
            "pages": "1879--88",
            "other_ids": {}
        },
        "BIBREF50": {
            "ref_id": "b50",
            "title": "New algorithms and methods to estimate maximum-likelihood phylogenies: assessing the performance of PhyML 3.0",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Guindon",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "F"
                    ],
                    "last": "Dufayard",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Vincent",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Anisimova",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Hordijk",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Gascuel",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Syst Biol",
            "volume": "59",
            "issn": "3",
            "pages": "307--328",
            "other_ids": {}
        },
        "BIBREF51": {
            "ref_id": "b51",
            "title": "URec: a system for unrooted reconciliation. Bioinformatics",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "G\u00f3recki",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tiuryn",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "23",
            "issn": "",
            "pages": "511--513",
            "other_ids": {}
        },
        "BIBREF52": {
            "ref_id": "b52",
            "title": "TreeKO: a duplication-aware algorithm for the comparison of phylogenetic trees",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Marcet-Houben",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Gabald\u00f3n",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Nucleic Acids Res",
            "volume": "39",
            "issn": "10",
            "pages": "66--66",
            "other_ids": {}
        },
        "BIBREF53": {
            "ref_id": "b53",
            "title": "Horizontal gene transfer and recombination analysis of SARS-CoV-2 genes helps discover its close relatives and shed light on its origin",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Makarenkov",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Mazoure",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Rabusseau",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Legendre",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "BMC Ecol Evol",
            "volume": "21",
            "issn": "1",
            "pages": "1--18",
            "other_ids": {}
        },
        "BIBREF55": {
            "ref_id": "b55",
            "title": "GISAID: global initiative on sharing all influenza datafrom vision to reality",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Shu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mccauley",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Eurosurveillance",
            "volume": "22",
            "issn": "13",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF56": {
            "ref_id": "b56",
            "title": "MUSCLE: a multiple sequence alignment method with reduced time and space complexity",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "C"
                    ],
                    "last": "Edgar",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "BMC Bioinformat",
            "volume": "5",
            "issn": "1",
            "pages": "1--19",
            "other_ids": {}
        },
        "BIBREF57": {
            "ref_id": "b57",
            "title": "Selection of conserved blocks from multiple alignments for their use in phylogenetic analysis",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Castresana",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Mol Biol Evol",
            "volume": "17",
            "issn": "4",
            "pages": "540--52",
            "other_ids": {}
        },
        "BIBREF58": {
            "ref_id": "b58",
            "title": "RAxML-VI-HPC: maximum likelihood-based phylogenetic analyses with thousands of taxa and mixed models",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Stamatakis",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Bioinformatics",
            "volume": "22",
            "issn": "21",
            "pages": "2688--90",
            "other_ids": {}
        },
        "BIBREF59": {
            "ref_id": "b59",
            "title": "mwaskom/seaborn: v0",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Waskom",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "8",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.5281/zenodo.883859"
                ]
            }
        },
        "BIBREF60": {
            "ref_id": "b60",
            "title": "Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "||M(v), M(w)|| \u2212 1).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Correctness of unfolding) The unfolded network N of N is a semi-binary tree.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "DC(G, N , \u03be) = \ufffdv,w\ufffd\u2208E(G) (|\u03ba \u03be (v, w)| \u2212 1).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Top left: The unfolded network N of N fromFig. 1is shown with \u03c3 values attached to nodes, where for the leaves, the index is inserted to distinguish leaves with the same labels/mappings. Bottom: 6 scenarios for G =((a, (b, c)), d) shown as embeddings of G to N . Numbers I-IV denote the type of a visited edge. Only E 1 is regular, while E 1 \u2212 E 4 are optimal. Top right: DC score and types of used reticulation edges for each scenario ( \u03d2[.]",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": ", we have DC(G, N Y ) \u2265DC(G, N , \u03be Y ) from Proposition 10 and D C(G, N , \u03be Y ) \u2265DC(G, N , \u03be * ) from the definition of \u03be * . In our example from Figs. 1 and 2, the cost of S 1 and the score of E 1 are equal. However, in general, a regular scenario may not exist. For instance, if G = (a, d) , there is only one scenario \u03be for N from Fig. 2, where a and d are mapped to a 1 and d 1 , respectively. Then, \u03be is not regular, and 0 =DC(G, N , \u03be) < DC(G, N ) = 1 (for S 1 or S 2 ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "For a gene tree G and a tree-child network N, Algorithm 2 returns l and u such that l \u2264 DC(G, N ) \u2264 u.ProofThe proof follows by induction on the number of reticulation nodes in a network. If N is a tree, then the statement is obvious, as the scenario has no conflicts l = u = DC(G, N ) . Otherwise, we have several cases. If the scenario from DP has no conflict, then we have the exact solution (seeLine 4). Otherwise, there is a conflict, and if the recursion depth is reached, then the computation is completed in Line 5 with proper bounds (see Theorem 12). In the final case, we have two pairs of bounds from two invocations. By the inductive assumption, the Left: A relaxed network N 1 which is not tree-sibling. Middle: A tree-sibling network N 2 which is not relaxed network. Right: A non tree-child network N 3 (also non-relaxed).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "M(g) = M(g \u2032 ) or M(g) = M(g \u2032\u2032 ), 0 otherwise. Problem 21 (DUP-ODT) Given a rooted tree G and a phylogenetic network N. Find a tree S displayed by N with the minimum DUP(G, S).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Performance of Algorithm 1 vs na\u00efve approach for random datasets R1, R2 and R3. Each dot represents the average speedup computed from the runtimes of 100 pairs of gene trees and phylogenetic networks.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Average number of DP invocations necessary to calculate an answer for random datasets R1, R2 and R3.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Performance of Algorithm 1 vs na\u00efve approach for three simulated datasets with low ILS 1 \u00b7 10 7 .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Performance of Algorithm 1 vs na\u00efve approach for three simulated datasets with medium ILS 5",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Average number of DP invocations necessary to calculate an answer for deep coalescence cost, for datasets with low ILS. The blue line represents coefficients calculated by linear regression for data with low and medium ILS combined.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Average number of DP invocations necessary to calculate an answer for deep coalescence cost, for datasets with medium ILS. Recall that blue line represents coefficients calculated by linear regression for data with low and medium ILS combined.",
            "latex": null,
            "type": "figure"
        },
        "TABREF5": {
            "text": ") . Note that d equals one plus the number of nodes of outdegree 2 located strictly between M(v) and M(w) in N Y . The same statement holds in N/Y. We show that d equals the number of Type I and II edges in N . For",
            "latex": null,
            "type": "table"
        },
        "TABREF14": {
            "text": "). The nucleotide frequencies (T, C, A and G respectively) were sampled from Dirichlet (113.48869, 69.02545, 78.66144, 99.83793), whilst \u03b1 parameter was sampled from Lognormal (\u22120.470703916, 0.348667224). The alignment length was set to 1000 bp. To estimate gene trees, we used a true alignment returned by INDELible. Then, we inferred ML-trees by PhyML v.3.1",
            "latex": null,
            "type": "table"
        },
        "TABREF15": {
            "text": "Page 19 of 23 Wawerka et al. Algorithms for Molecular Biology (2022) 17:11",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "The authors would like to thank the anonymous reviewers for their valuable suggestions and comments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgements"
        },
        {
            "text": "Organism name Accession Number (GenBank/ GISAID) occurred between some evolutionarily close CoV species. The results showed that both intergenic and intragenic recombination played a significant role in the SARS-CoV-2 evolution. The goal of our study was to test whether scenarios with the lowest DC cost inferred for the phylogenetic network from [53] and individual gene trees confirm recombinations identified in the cited paper. In our experiment, we focused on intergenic recombinations, in which a whole gene is transferred from one species and integrated into another species genome.",
            "cite_spans": [
                {
                    "start": 348,
                    "end": 352,
                    "text": "[53]",
                    "ref_id": "BIBREF53"
                }
            ],
            "ref_spans": [],
            "section": "Abbreviated name"
        },
        {
            "text": "Data preparation: In the gene trees inference step, we followed the cited work. We selected 15 out of 25 examined coronavirus species, omitting a few species to avoid multifurcations. As representatives of SARS-Cov-2, two variants were used. One was sampled from a patient from Wuhan (Hu-Wuhan), the origin of the pandemic spread of coronavirus, and the other was collected in Italy (Hu-Italy). Other selected species were RaTG13 bat CoV from R. affinis which, at first, was considered the only close relative of SARS-CoV-2, bat CoV ZC45 and ZXC21 strains from Zhejiang province of China (Bat-CoVZC45, and Bat-CoVZXC21), bat coronaviruses collected from species found in several provinces of China and from Bulgaria (Rf1, HKU3-12, BatCoV273, BatCoV279, and BM48-31 BGR), two CoV strains from Guangdong and Guangxi pangolins (Guangdong-Png, Guangxi-Png-P2V), and three SARS CoV related species (SARS, SARS-BJ182-4, and Rs3367). For the list of full names and database accession numbers, please refer to Table 1 .Coronavirus sequences were obtained from GenBank [54] and GISAID [55] databases. In the studied phylogenetic network, recombinations were found in the case of the genes M, ORF1ab, ORF3a, ORF6, ORF8, and ORF10; therefore, our research was focused on this set of genes. Multiple sequence alignments for the gene families were performed with MUSCLE [56] and corrected by GBlocks [57] with a less stringent correction option. The ML gene trees were inferred using RAxML [58] with parameters described in [53] . All species were present in all gene families except ORF8, which lacks the BM48-31-BGR species.Phylogenetic networks: The coronavirus tree with marked intergenic recombinations (H1-H7) identified in [53] is depicted in Fig. 13 . Since the direction of three out of seven recombinations was not certain, we prepared 8 networks corresponding to all combinations of the directions of gene transfers. Each network is named with three letters L/R responding to the direction of H5, H6, and H7, respectively, i.e. in the LRL network, H5 and H7 are directed left, and H6 is directed right. Please note that the inferred networks are not tree-child, and therefore, in this experiment, we use the extended version of our algorithm described in Sect. Beyond tree-child networks.Discussion: The results of the experiment are depicted in Fig. 14. For each gene family, we checked whether the expected reticulation edge was used by the inferred scenario with the lowest DC cost. We can distinguish three possibilities for reticulation edge e: 1. e was used by the expected gene, 2. e was used by one or more extra genes, and 3. the expected gene didn't use e. We were able to confirm most of the reticulations except two: H2 that was reported in [53] with the lowest support wasn't confirmed by any of the networks, and H7 was confirmed only by networks with H6 directed right. The most extra uses were found for H5 and gene ORF10, which gene tree had low support values. Further research might be performed for these cases. The least extra uses were present in RLL (5) and LLL (6) , which may be some lead when investigating the direction of H6 and H7.We observed that, for a fixed gene tree, the set of optimal displayed trees inferred by our algorithm and their cost, is independent of the network variant. This phenomenon needs further theoretical investigation. Costs for each gene tree have the following values: ORF3a: 0, ORF10: 5, ORF6: 1, M: 3, ORF8: 2, ORF1ab: 2. This observation may lead to discovering some important property and can be a subject for further investigation. biconnected component independently) commonly used in alternative approaches to scoring tree-network pairs [7, 9, 10] . We also claim that the statement holds for level-k networks by replacing r by k in the formula. We conclude that our conflict resolution algorithm enables analyses of complex networks with dozens of reticulation events. We also claim that resolving conflicts returned by dynamic programming is a new alternative towards designing efficient algorithms that utilize internal similarities of empirical datasets.Resolving conflicts in the usage of reticulation edges can be naturally generalized to other cost functions, e.g., gene duplication and loss cost. Also, it is not difficult to extend DP to analyze unrooted gene trees. Another critical question is whether the runtime exponent can be further reduced, e.g., by choosing optimal scenarios with the smallest possible sets of conflicted reticulation edges. Also, the experimental results on the na\u00efve approach justify the usage of a hybrid solution: when the recursion reaches networks with small number of reticulations, apply the brute force method instead of DP. Here, additional optimizations of the na\u00efve approach could be applied; for instance, by improving displayed tree generator by adopting novel theoretical characterizations of stable networks [41] .Furthermore, we would like to test the efficiency and accuracy of the branch and bound algorithm to approximate the optimal cost. Also, we plan to apply the methods in computationally demanding problems of network inference from sets of gene trees, which may require reimplementation in a low-level programming language (e.g., C/C++). Authors contributions MW and PG developed and implemented the algorithms. NR and MW performed the simulations and computational tests. AM performed the empirical evaluation. DD contributed to the development of the software, and all authors contributed to the writing. All authors reviewed and approved the manuscript. All authors read and approved the final manuscript.",
            "cite_spans": [
                {
                    "start": 1060,
                    "end": 1064,
                    "text": "[54]",
                    "ref_id": null
                },
                {
                    "start": 1076,
                    "end": 1080,
                    "text": "[55]",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 1357,
                    "end": 1361,
                    "text": "[56]",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 1387,
                    "end": 1391,
                    "text": "[57]",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 1477,
                    "end": 1481,
                    "text": "[58]",
                    "ref_id": "BIBREF58"
                },
                {
                    "start": 1511,
                    "end": 1515,
                    "text": "[53]",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 1717,
                    "end": 1721,
                    "text": "[53]",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 2751,
                    "end": 2755,
                    "text": "[53]",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 3071,
                    "end": 3074,
                    "text": "(5)",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 3083,
                    "end": 3086,
                    "text": "(6)",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 3699,
                    "end": 3702,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 3703,
                    "end": 3705,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 3706,
                    "end": 3709,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 4921,
                    "end": 4925,
                    "text": "[41]",
                    "ref_id": "BIBREF40"
                }
            ],
            "ref_spans": [
                {
                    "start": 1002,
                    "end": 1009,
                    "text": "Table 1",
                    "ref_id": null
                },
                {
                    "start": 1737,
                    "end": 1744,
                    "text": "Fig. 13",
                    "ref_id": null
                },
                {
                    "start": 2344,
                    "end": 2352,
                    "text": "Fig. 14.",
                    "ref_id": null
                }
            ],
            "section": "Host organism"
        },
        {
            "text": "The support was provided by National Science Centre grant #2019/33/B/ ST6/00737.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Funding"
        },
        {
            "text": "The software package and the simulated datasets are available at https://bitbucket.org/pgor17/embretnet.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Availability of data and materials"
        },
        {
            "text": "Ethics approval and consent to participate Not applicable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Declarations"
        },
        {
            "text": "Not applicable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Consent for publication"
        },
        {
            "text": "The authors declare that they have no competing interests. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Competing interests"
        }
    ]
}