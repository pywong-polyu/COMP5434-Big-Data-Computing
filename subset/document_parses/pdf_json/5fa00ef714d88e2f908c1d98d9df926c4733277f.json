{
    "paper_id": "5fa00ef714d88e2f908c1d98d9df926c4733277f",
    "metadata": {
        "title": "Searching k-Optimal Goals for an Orienteering Problem on a Specialized Graph with Budget Constraints",
        "authors": [
            {
                "first": "Abhinav",
                "middle": [],
                "last": "Sharma",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Melbourne Parkville Campus Victoria",
                    "location": {
                        "postCode": "3010",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Advait",
                "middle": [],
                "last": "Deshpande",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Melbourne Parkville Campus Victoria",
                    "location": {
                        "postCode": "3010",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Yanming",
                "middle": [],
                "last": "Wang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Melbourne Parkville Campus Victoria",
                    "location": {
                        "postCode": "3010",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Xinyi",
                "middle": [],
                "last": "Xu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Melbourne Parkville Campus Victoria",
                    "location": {
                        "postCode": "3010",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Prashan",
                "middle": [],
                "last": "Madumal",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Melbourne Parkville Campus Victoria",
                    "location": {
                        "postCode": "3010",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Anbin",
                "middle": [],
                "last": "Hou",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Melbourne Parkville Campus Victoria",
                    "location": {
                        "postCode": "3010",
                        "country": "Australia"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "We propose a novel non-randomized anytime orienteering algorithm for finding k-optimal goals that maximize reward on a specialized graph with budget constraints. This specialized graph represents a real-world scenario which is analogous to an orienteering problem of finding k-most optimal goal states.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Orienteering Problem (OP) is a special case of the Informative Path Planning (IPP) problem where rewards at different nodes are calculated independently of each other. However, the OP is considered to be NP-hard and mostly solved with heuristic-based search strategies and customized algorithms (Wei and Zheng 2020) . We aim to solve a domain-related orienteering problem which can be formalized for a specialized directed weighted graph. First, we initialize a specialized graph for mapping the Parkville campus of the University of Melbourne. We then use this graph to formalize our problem of finding the most optimal nearest building from a starting building such that the reward can be maximized within the provided travelling budget constraint. The proposed non-randomized algorithm is applied to find k-most optimal nearest buildings inside the campus from a given starting building, discussed in the results section. We also show how COVID-19 lock-down restrictions can be incorporated into our algorithm to solve our defined orienteering problem.",
            "cite_spans": [
                {
                    "start": 295,
                    "end": 315,
                    "text": "(Wei and Zheng 2020)",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We formulate our domain-related optimal building finding problem into a generic orienteering problem (OP) for a specialized graph below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "Let us assume a weighted directed specialized graph G s = (V, E) for n number of nodes where v s \u2208 V is the pre-defined start node such that V = {v 1 , v 2 , v 3 , ..., v n } and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "Here, v s is having n out-degree with 0 in-degree (i.e. v s is connected to every other node in V ) and v i \u2200 i \u2208 [1, n] \\ v s is connected to only v s with 1 in-degree and 0 out-degree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "Let v g be the set of k-optimal goal nodes s.t. v g \u2208 V and k \u2264 n. These goals are attained in the decreasing order of Copyright \u00a9 2021, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved. their gained rewards after respecting budget constraints (i.e. v g1 > v g2 > ... > v gk ). Let r be the set of nodes which we can visit such that r \u2286 V \\ v s . Let B be the travelling budget which will enable the budget constraints. Let O be the generic objectives and F be the generic factors which can be used to tweak the reward function of the problem. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "Using above notations, the hard-constraint problem can then be defined by equation 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "We can relax the above hard-constraint by introducing a hyper-parameter \u03b4 to formulate a soft-constraint problem as shown in equation 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "where \u03b4 \u2208 IR + 0 \u222a {\u221e}. Informally, the solution to our stated problem is a set of ordered k-optimal goal nodes, such that the reward obtained by visiting the node is maximized while the path cost stays within a specified travelling budget B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "In this section, we propose a novel way of solving the problem formulation shown in equation 2 which is inspired by the general randomized algorithm for IPP problems (Arora and Scherer 2017) .",
            "cite_spans": [
                {
                    "start": 166,
                    "end": 190,
                    "text": "(Arora and Scherer 2017)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Non-randomized Anytime Orienteering"
        },
        {
            "text": "The algorithm starts with a priority queue and creates r subset s.t. r \u2286 V \\ v s . Then, for each node in r, path cost C(r) and node reward I(r) is calculated. It is then ensured that the budget constraint is satisfied and the selected node is pushed into the priority queue with negative reward as the priority. We can pop the queue item with minimum priority k-times to find the k-most optimal goal nodes. This process is described in Algorithm 1. Time Complexity. If we assume a standard binary heap implementation of the priority queue, then the insertion and deletion time complexity is O(log n), where n is the size of the input (Atkinson et al. 1986) . This can be further optimized by several customizations (Edelkamp, Elmasry, and Katajainen 2017) . Hence, the time complexity of our proposed algorithm for the best and the worst case can be stated as O(n \u2212 1 * log n) + O(k * log n) \u2264 O(n log n).",
            "cite_spans": [
                {
                    "start": 635,
                    "end": 657,
                    "text": "(Atkinson et al. 1986)",
                    "ref_id": null
                },
                {
                    "start": 716,
                    "end": 756,
                    "text": "(Edelkamp, Elmasry, and Katajainen 2017)",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Non-randomized Anytime Orienteering"
        },
        {
            "text": "Space Complexity. If we again assume a heap data structure implementation of the priority queue, then the space complexity of storing n elements in the priority queue is O(n) (Atkinson et al. 1986) . Hence, the best and worst case space complexity of our proposed algorithm is O(n).",
            "cite_spans": [
                {
                    "start": 175,
                    "end": 197,
                    "text": "(Atkinson et al. 1986)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Non-randomized Anytime Orienteering"
        },
        {
            "text": "Limitations. Our algorithm relies on the assumption that the graph is a specialized weighted directed graph with one central node (0 in-degree and n out-degree) and n isolated nodes connected with only one central node. Due to this assumption, the algorithm is efficient and applicable only for such versions of the specialized graph and cannot be extended implicitly to any general weighted directed graph.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-randomized Anytime Orienteering"
        },
        {
            "text": "In this section, we show experimental results for a domainspecific orienteering problem solved using our proposed algorithm. Here, our goal is to find the k-most optimal nearest building inside the Parkville campus of the University of Melbourne. These buildings should be within a specific radius (B) that maximises the chances (reward) of either booking a meeting room or using a toilet facility based on supply, demand and other preferences or factors. A specific scenario is shown in Figure 1 where R(.) are the rewards given by the buildings with no factors and R(COVID) are the rewards based on COVID-19 lock-down restrictions. Table 1 shows the results for the stated scenario for 3optimal nearest buildings using our proposed algorithm. In Figure 1 : Finding k = 3 most optimal nearest building from v s = 220 that maximises the chances (reward) of booking a meeting room within B = 200 meters and \u03b4 = 50 meters addition, we were also able to simulate a COVID-19 restriction scenario by enhancing the reward function R(r, o, f ), obtaining results as shown in the Table 2 . ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 488,
                    "end": 496,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 634,
                    "end": 641,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 748,
                    "end": 756,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 1072,
                    "end": 1079,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Experimental Results"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Randomized algorithm for informative path planning with budget constraints",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Arora",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Scherer",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "2017 IEEE International Conference on Robotics and Automation (ICRA)",
            "volume": "",
            "issn": "",
            "pages": "4997--5004",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Heaps and Generalized Priority Queues",
            "authors": [
                {
                    "first": "Min-Max",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Commun. ACM",
            "volume": "29",
            "issn": "10",
            "pages": "996--1000",
            "other_ids": {
                "DOI": [
                    "10.1145/6617.6621"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Optimizing Binary Heaps. Theory of Computing Systems 61",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Edelkamp",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Elmasry",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Katajainen",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s00224-017-9760-2"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Informative Path Planning for Mobile Sensing with Reinforcement Learning",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Wei",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "For each r, let R(r, o, f ) be the reward function where R : (r, o, f ) \u2192 IR + 0 \u222a {\u221e} calculates the reward based on the provided set of factors f \u2286 F and objective o \u2208 O. Let I(r) = R(r, o, f ) be the reward gained by visiting each node in r. Let the cost of traversal be given by C",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Gs = (V, E), vs, B, L, k, \u03b4, o \u2208 O, f \u2286 F Output: vg = {vg1, .., v gk } s.t. vg1 > ... > v gk queue := new priority queue vg = \u2205 r := r \u2286 V \\ vs for vi in r do I(r) = R(vi, o, f ) //node reward C(r) = C(vs, vi) //path cost if C(r) \u2264 B + \u03b4 \u2264 L then priority = \u22121 * I(r) queue.insert(vi, priority) end end while not queue.empty() do \u03c1 := queue.pop-min() //best node if len(vg) < k then vg := vg \u222a \u03c1 end end",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "k = 3 most optimal nearest buildings without any factors with B = 200 m hard-constraint (left) and B + \u03b4 = 250 m soft-constraint (right) Goals Cost R(COVID) v g1 = 110 124.13 126 v g2 = 102 246.39 117 v g3 = 105 130.83 111",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "k = 3 most optimal nearest buildings in COVID lockdown situation with B = 200 m hard-constraint (left) and B + \u03b4 = 250 m soft-constraint (right)",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}