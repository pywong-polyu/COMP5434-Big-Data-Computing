{
    "paper_id": "46244ddd0210fe70cff66360171b271319ec9090",
    "metadata": {
        "title": "The R Package knnwtsim: Nonparametric Forecasting With a Tailored Similarity Measure",
        "authors": [
            {
                "first": "Matthew",
                "middle": [],
                "last": "Trupiano",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Rochester Institute of Technology",
                    "location": {}
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "The R package knnwtsim provides functions to implement k nearest neighbors (KNN) forecasting using a similarity metric tailored to the forecasting problem of predicting future observations of a response series where recent observations, seasonal or periodic patterns, and the values of one or more exogenous predictors all have predictive value in forecasting new response points. This paper will introduce the similarity measure of interest, and the functions in knnwtsim used to calculate, tune, and ultimately utilize it in KNN forecasting. This package may be of particular value in forecasting problems where the functional relationships between response and predictors are non-constant or piece-wise and thus can violate the assumptions of popular alternatives. In addition both real world and simulated time series datasets used in the development and testing of this approach have been made available with the package.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The motivation in creating knnwtsim is to provide an additional method to the space of forecasting univariate time series where all or some combination of recent observations, seasonal or periodic patterns, and the values of one or more exogenous predictors provide value in the estimation of future observations of the series. knnwtsim accomplishes this by providing functions to generate a weighted similarity measure, referred to as S w throughout this paper, which has the ability to account for all three of these components and tune their contribution to the overall similarity ultimately used in the identification of nearest neighbors. Once the similarity matrix is calculated the package provides functionality to use S w in k nearest neighbors (KNN) regression to forecast future points. This paper will introduce the formulation of this measure and how KNN forecasting is implemented in knnwtsim.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In terms of the current forecasting landscape, a popular and often excellent alternative method used in this forecasting scenario is regression with autoregressive integrated moving average (ARIMA) errors.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Where y t represents the value of the response series of interest at time order t, b a vector of coefficients, x t a vector of the values at time order t of exogenous predictors, and \u03b7 t represents an ARIMA error, see (Hyndman and Athanasopoulos 2021, Chapter 10.4 ). In R R Core Team (2021) this technique is implemented in packages such as forecast Hyndman and Khandakar (2008) and fable O'Hara-Wild, Hyndman, and Wang (2021) . In this paper an example with simulated data of a situation where the use of KNN forecasting with knnwtsim is better suited than regression with ARIMA errors is explored in Section 6.",
            "cite_spans": [
                {
                    "start": 218,
                    "end": 264,
                    "text": "(Hyndman and Athanasopoulos 2021, Chapter 10.4",
                    "ref_id": null
                },
                {
                    "start": 351,
                    "end": 379,
                    "text": "Hyndman and Khandakar (2008)",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 403,
                    "end": 427,
                    "text": "Hyndman, and Wang (2021)",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Also in R is an alternative package for KNN forecasting, tsfknn Martinez, Frias, Charte, and Rivera (2019) . This package also provides functions for univariate forecasting with KNN, however knnwtsim differs in providing the functions to develop S w , see Equation 2 in Section 2, as well as providing a knn.forecast function which can take any similarity matrix regardless of the exact method used to create it. This makes knnwtsim more tailored to situations where exogenous predictors are involved.",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 106,
                    "text": "Martinez, Frias, Charte, and Rivera (2019)",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The key to tailoring KNN to the specific time series problem at hand is the similarity measure used to determine the neighborhood, formulated in Equation 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Similarity formulation"
        },
        {
            "text": "S t , S p , and S x are all separate component similarity measures used to compare a given point y t to other previous points, y i for i < t, based on different aspects of the time series of interest. S t measures similarity in the sense of time order, i.e., the closest prior point to y t in terms of S t should be y t\u22121 . If this metric was used alone to determine the neighborhood in KNN regression, the estimate of y t would simply be a rolling average of the k most recent points prior to time t. S p measures similarity in terms of periodicity, meaning if a time series represented monthly data which typically follow a yearly cycle, p would take a value between 1-12, and the points closest to y t should be the y i where i = (t \u2212 ap max ) = (t \u2212 a12). where a is an integer greater than 1 that represents the number of years back in the series. This means all prior points which fall in the same month of any prior year would be considered equally similar by this component of S w . Finally, to incorporate the information provided by exogenous predictors which could be valuable in forecasting future points in the series, there is S x . For a given point of interest y t this similarity metric compares a vector of predictors at time t, x t , associated with y t , to each vector of predictors x i associated with each prior point in the series, y i . \u03b1, \u03b2, and \u03b3 represent the three weights that can be tuned as hyperparameters. It is recommended to normalize these so that they sum to 1, which allows for a rough physical interpretation of these weights as measures of the relative importance of each of these three aspects of the series targeted by the component similarity measures in determining the future values of the series of interest.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Similarity formulation"
        },
        {
            "text": "In principle there is no strict requirement on the similarity metric used to compute each of the component similarities which combine to form S w . However here I detail the metrics implemented in the knnwtsim. In this package each of the three similarity metrics: S t , S p , and S x , are first calculated as a dissimilarity metric: D t , D p , D x . These dissimilarities are then transformed into the final similarity measures by 1 1+D i for i \u2208 t, p, x, see (Bajorski 2012, Chapter 10.2.1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implemented component similarity calculation methods"
        },
        {
            "text": "The measure implemented for D t to calculate the dissimilarity between a point y t and another point y i , at time orders t and i respectively is shown in Equation 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implemented component similarity calculation methods"
        },
        {
            "text": "Which is equivalent the standard Euclidean distance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implemented component similarity calculation methods"
        },
        {
            "text": "The metric used for dissimilarity in terms of periodicity, D p , is formulated as follows. Between a point y t and another point y i with respective periods p t and p i , for example in a monthly series taking on values between 1-12, we have Equation 4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implemented component similarity calculation methods"
        },
        {
            "text": "Where p min is the minimum value the period can take on, and p max the maximum, 1 and 12 respectively in the monthly example. This formulation is based on the idea that generally the periods at the very end and very beginning of a cycle should be fairly similar. To clarify through an example, in a monthly cycle where 1 represents January and 12 represents December, these two months are generally more similar to each-other than either are to July at period 7. Continuing with this monthly example, if we have three points which occur in January, March, and November: p i = 1, p j = 3, p k = 11 with p max = 12, and p min is assumed to always be 1, matching the behavior of knnwtsim.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implemented component similarity calculation methods"
        },
        {
            "text": "For D x , the metric used to determine the dissimilarity between two points y t and y i based on the values of associated exogenous predictors x t and x i , any commonly known and appropriate distance metric taking the two vectors of predictors as input would work. For example, in situations where predictors are binary, such as holiday indicators, one could use binary distance as implemented in the R package stats R Core Team (2021) function dist. In situations where predictors are numeric, using Euclidean or Mahalanobis distance may be preferred, again see (Bajorski 2012 , Chapter 10.2.1) for additional details.",
            "cite_spans": [
                {
                    "start": 564,
                    "end": 578,
                    "text": "(Bajorski 2012",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Implemented component similarity calculation methods"
        },
        {
            "text": "Once a final similarity matrix is calculated, not necessarily using the measures listed above, that matrix can be used in KNN regression to forecast future observations of a response series.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "KNN forecasting"
        },
        {
            "text": "The model for KNN regression as used in knnwtsim can be formulated as shown in Equation 5, see (Clarke, Fokou\u00e9, and Zhang 2009, Chapter 2.4) .",
            "cite_spans": [
                {
                    "start": 95,
                    "end": 140,
                    "text": "(Clarke, Fokou\u00e9, and Zhang 2009, Chapter 2.4)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "KNN forecasting"
        },
        {
            "text": "Where k is the number of nearest neighbors considered, and a hyperparameter which will generally need to be tuned. K (y t ) is the \"neighborhood\" consisting of the k observations of y i with the highest similarity (or lowest dissimilarity/distance) to y t of all prior members of the time series, meaning i < t. t is an error term to capture the remaining unexplained random component, which has not been required to follow any particular distributional form.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "KNN forecasting"
        },
        {
            "text": "Naturally we may want to forecast an arbitrarily long forecast horizon, h, where h \u2265 1. The estimate for any given future point is shown below as Equation 6. With i < t and t being in this example the last observed actual observation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "KNN forecasting"
        },
        {
            "text": "To date in knnwtsim previously estimated points have not been included as potential candidates for the neighborhood, only actual observations. To elaborate with an example, if the latest observation is at time t and one is interested in forecasting out to time t + h, with h > 1, then\u0177 t+1 would not be a viable option to include in K (\u0177 t+h ) based on the behavior programmed in the function knn.forecast in the knnwtsim package.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "KNN forecasting"
        },
        {
            "text": "This section provides an overview to the key functions within knnwtsim a user may need when working through a forecasting exercise with the package.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The knnwtsim Package"
        },
        {
            "text": "Each of of the three component similarity measures used in generating S w has a corresponding function in knnwtsim to generate a similairty matrix using that measure as defined in Section 2.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "1. StMatrixCalc produces a similarity matrix using S t when provided with a vector of time orders corresponding to the values of the response series. The only argument is:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "\u2022 v: A numeric vector with the time order corresponding to each point in the response series.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "2. SpMatrixCalc produces a similarity matrix using S p when provided a vector of seasonal periods corresponding to the values of the response series and the total number of periods in a full cycle, 12 for monthly data as an example. The arguments are:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "\u2022 v: A numeric vector with the seasonal periods corresponding to each point in the response series. \u2022 nPeriods: A numeric value representing the maximum value v can take on.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "3. SxMatrixCalc given a numeric vector or matrix of the values of exogenous predictors corresponding to the response series and a distance calculation method, SxMatrixCalc calls the stats package's dist function using the method provided and transforms the resulting matrix into a similarity measure which is the returned to the user. The arguments are:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "\u2022 A: A numeric vector or matrix where the columns represents exogenous predictor variables and the rows correspond to the points in the response series. \u2022 XdistMetric: A string describing the method the stats package's dist function should use. This must be one of \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\", or \"minkowski\".",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "All of the matrices returned by these functions will be of dimension n x n where n is the length of the input vector or row count of the input matrix in the case of SxMatrixCalc. The final of the similarity matrix functions calls each of these components.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "4. SwMatrixCalc given all of the arguments to the component matrix functions plus a vector of weights, calls StMatrixCalc, SpMatrixCalc, and SxMatrixCalc to generate each component matrix, then the first weight in the provided vector is multplied by the matrix using S t , the second weight is multiplied by the matrix generated using S p , and the third weight is multiplied by the matrix generated using S x . Finally, the three weighted component matrices are added to produce a single matrix which is returned. Each element of this matrix will then have been calculated as per Equation 2. The arguments are:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "\u2022 t.in: A numeric vector with the time order corresponding to each point in the response series. \u2022 p.in: A numeric vector with the seasonal periods corresponding to each point in the response series. \u2022 nPeriods.in: A numeric value representing the maximum value p.in can take on. \u2022 X.in: A numeric vector or matrix where the columns represents exogenous predictor variables and the rows correspond to the points in the response series. \u2022 XdistMetric.in: A string describing the method the stats package's dist function should use. This must be one of \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\", or \"minkowski\". \u2022 weights: A numeric vector where first value represents weight for S t , second value the weight for S p , and the third value the weight for S x .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functions for similarity matrices"
        },
        {
            "text": "The core user facing function for forecasting using KNN regression as defined in Equation 6 is knn.forecast. This function takes a similarity matrix as input, along with an index corresponding to which time orders of the response series should be estimated, the number of nearest neighbors, k, to be used in estimation, and the response series for which the forecast is being generated. This function uses the input forecasting index to identify the columns of the similarity matrix which should be sorted to identify the nearest neighbors, and also removes the rows at this same index to exclude observations in the forecast index from consideration as neighbors. Naturally with this construction the index in terms of both rows and columns of the similarity matrix should be aligned to the index of response series. Next it applies the function NNReg to each column of interest, which sorts the provided column by greatest to least similarity, identifies the indices of the nearest neighbors, and returns the mean of the points in the response series at the nearest neighbor indices. The knn.forecast function returns this value provided by NNReg for each point in the forecast index as a numeric vector. This vector is the KNN regression forecast. The arguments are:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Function for KNN forecasting"
        },
        {
            "text": "\u2022 Sim.Mat.in: A numeric matrix of similarities .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Function for KNN forecasting"
        },
        {
            "text": "\u2022 f.index.in: A numeric vector indicating the indices of Sim.Mat.in and y.in which correspond to the time order of the points to be forecast.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Function for KNN forecasting"
        },
        {
            "text": "\u2022 k.in: An integer value indicating the the number of nearest neighbors to be considered in forecasting. \u2022 y.in: A numeric vector of the response series to be forecast.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Function for KNN forecasting"
        },
        {
            "text": "There is one function included with the package for the tuning of the weights, \u03b1, \u03b2, and \u03b3 used to create S w , and the number of neighbors k. This is knn.forecast.randomsearch.tuning which takes as input the number of hyperparameter sets to generate and test, the three component matrices calculated using S t , S p , and S x , the response series, an integer value for the number of points used to estimate and evaluate a test forecast, a maximum value which k can take on, and finally the number of points at the end of the series which should be held out for later validation. In this case the arguments are listed before the function's behavior to help clarify the explanation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tuning the hyperparameters"
        },
        {
            "text": "\u2022 grid.len: An integer value representing the number of hyperparameter sets to generate and test. \u2022 St.in: A numeric matrix of similarities, can be generated with StMatrixCalc. \u2022 Sp.in: A numeric matrix of similarities, can be generated with SpMatrixCalc. \u2022 Sx.in: A numeric matrix of similarities, can be generated with SxMatrixCalc.. \u2022 y.in: A numeric vector of the response series to be forecast. \u2022 test.h: An integer value representing the number of points to include in the test forecast. \u2022 max.k: An integer value representing the maximum value of k, knn.forecast should use, this will be set to min(floor((length(y.in)) * .4), 50) if NA is passed. \u2022 val.holdout.len: An integer value representing the number of observations at the end of the series to be removed before the test forecast points are decided if desired to leave a validation set after tuning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tuning the hyperparameters"
        },
        {
            "text": "The function starts by creating grid.len randomly generated hyperparameter sets, {k, \u03b1, \u03b2, \u03b3}, where the weights \u03b1, \u03b2, and \u03b3 are normalized to sum to 1. In generating values for k this function will draw a random integer between 1 and the max.k argument supplied, or the default maximum k if max.k is not supplied. An index indicating the points to estimate and use as a test set is created by taking the final test.h observations in the response series y.in remaining after the final val.holdout.len have been removed. Then for each set of hyperparameters a new similarity matrix using S w is produced and used in a call to knn.forecast to forecast the points in the test index. Each estimated point for the response series at the test index is compared to the actual value of y.in at the corresponding time order using average percent error (APE). Defined for a given point y t+h , h steps ahead of the latest time order where an observation could be considered a valid neighbor, t, below in Equation 7.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tuning the hyperparameters"
        },
        {
            "text": "Where\u0177 t+h represents the estimate of y t+h from knn.forecast. Each of the test.h APE values are then averaged to calculate the mean average percent error (MAPE) over the test points for the forecast estimated using a given set of hyperparameters. After testing all hyperparameter sets knn.forecast.randomsearch.tuning finds the set with the lowest associated MAPE value in forecasting the points of the response series in the test set and deems them the \"optimum\" set to use. These top performing weights are returned as part of a list including the following components:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tuning the hyperparameters"
        },
        {
            "text": "\u2022 weight.opt: A numeric vector of the three weights to generate S w in \u03b1, \u03b2, \u03b3 order which achieved the best performance in terms of MAPE. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tuning the hyperparameters"
        },
        {
            "text": "In addition to the functions used to implement KNN regression forecasting using S w , knnwtsim contains some time series data sets which can be used to experiment with this package or any other time series methodology one wishes. Three of the datasets are stored as data frames of count data derived from files on the city open data portal for Boston, MA, USA.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data included with the package"
        },
        {
            "text": "1. boston_fire_incidents_weekly",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data included with the package"
        },
        {
            "text": "Two are derived from the same source, boston_fire_incidents_weekly which contains a weekly sum of fire incidents in the City of Boston, and boston_fire_incidents_monthly which contains a monthly sum of fire incidents in Boston, both with data from the start of 2017 to the end of July, 2021 Department of Innovation and Technology, City of Boston (2021b). The final Boston based data set is boston_911dispatch_weekly which contains the number of 911 dispatches by the City of Boston public safety agencies between November 1, 2010 and April 21, 2014 Department of Innovation and Technology, City of Boston (2021a). There are three potential response series in this data set with columns for BPD, EMS, and BFD. Both boston_fire_incidents_weekly and boston_911dispatch_weekly contain a series of holiday indicators relevant to the state Massachusetts. Additionally, both boston_fire_incidents_weekly and boston_fire_incidents_monthly contain an indicator for the weeks which occurred during a COVID-19 state of emergency in the state. Finally, as well as holiday indicators boston_911dispatch_weekly contains a series of month indicators as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "In addition to the data frames based on Boston's open data, the package contains simulated data. This data is stored as simulation_master_list, which is a list of 20 sub-lists each containing four categories of simulated time series and 31 total elements which also contain the randomly drawn components used to create the four series. The only difference between the four time series in a given sub-list is the relationship between response and predictors, and that one category, series.mvnormx, uses a different set of predictors than the other three.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "Here the simulation procedure is described. Unless otherwise specified all distribution based sampling is performed using stats's functions: rnorm for univariate normal distributions, rpois for Poisson distributions, and runif for continuous uniform distributions. The first of these four categories of response series, series.mvnormx, was formulated as follows in Equation 8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "Breaking down the components we have:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "\u2022 c : This term represents and randomly chosen constant from a continuous uniform distribution over the range [\u221220, 20] \u2022 x t : A d x 1 vector corresponding the t th row in a matrix X with d columns, representing exogenous predictors. These observations are drawn from a multivariate normal distribution using the MASS package's mvrnorm function Venables and Ripley (2002) with mean vector, \u00b5 x = 0, and variance-covariance matrix \u03a3 x , which for each simulated series is a randomly generated correlation matrix using the clusterGeneration package's rcorrmatrix function Qiu and Joe. (2020).",
            "cite_spans": [
                {
                    "start": 110,
                    "end": 119,
                    "text": "[\u221220, 20]",
                    "ref_id": null
                },
                {
                    "start": 346,
                    "end": 372,
                    "text": "Venables and Ripley (2002)",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "\u2022 b : Is a d x 1 vector of coefficients where each of the d elements are randomly pulled from a continuous uniform distribution over the range [\u22125, 5] \u2022 \u03b2 sin sin 2\u03c0t s +\u03b2 cos cos 2\u03c0t s : Is a combination of terms to simulate a constant seasonal effect. s represents the periodicity of the series, randomly sampled from the set [4, 7, 12]. \u03b2 sin and \u03b2 cos are both drawn from the same continuous uniform distribution as b.",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 150,
                    "text": "[\u22125, 5]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "\u2022 \u03b7 t : Represents a simulated ARIMA(p, d, q) term meant to potentially induce some serial correlation into the simulated series. The orders p, d, q are sampled from the set [0, 1, 2]. Orders beyond 2 were not considered as the constraints for the coefficient vectors \u03a6 and \u0398 of AR(p) and MA(q) processes with p or q > 2 become much more complex. Both the p coefficients, \u03a6, for the AR(p) process and the q coefficients, \u0398, for the MA(q) process are generated randomly (when required). For processes which are AR(1) or MA(1) the single coefficient is drawn from a continuous uniform distribution over the range [\u22121, 1]. For AR(2) and MA (2) there are more complex constraints and so the two necessary coefficients are drawn from the same continuous uniform distribution on the range [\u22121, 1] until the set of coefficients meets the constraints for that process.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "\u2022 t : Is a term to add additional random noise, it is drawn from either a N \u00b5 = 0, \u03c3 2 or P oisson (\u03bb ) distribution depending on the result of a single Bernoulli trial with equal probability to either type of noise, where the parameters \u03c3 and \u03bb are sampled from a continuous uniform distribution on the range [.1, 20]. The reason for allowing the inclusion of a P oisson (\u03bb ) error term was to induce some right skewed behavior into the series, which is common in many real-world series.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "The other three categories are built in similar fashion, series.lin.to.sqrt.x, series.lin.coef.chng.x, and series.quad.to.cubic.x are described by the following more general Equation 9. In these series all components which are common with those shown in Equation 8 remain the same.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "However, instead of a set of predictors with a simple linear relationship to the response, we have f (x) which describes some piece-wise functional relationship between the response y and a single predictor x. In these series realizations of the single predictor x are drawn from a N (\u00b5 x , \u03c3 x ) distribution where \u00b5 x and \u03c3 x are both drawn from continuous uniform distributions over the ranges [\u22125, 5] where m is a scalar coefficient simulated from a continuous uniform distribution over the range [\u22125, 5] , and bp is also some scalar numeric value simulated from a continuous uniform distribution on the range [\u00b5 x \u2212 \u03c3 x , \u00b5 x + \u03c3 x ], however for the series.lin.to.sqrt.x series specifically the minimum bp is .001 to ensure the square root function is defined.",
            "cite_spans": [
                {
                    "start": 397,
                    "end": 404,
                    "text": "[\u22125, 5]",
                    "ref_id": null
                },
                {
                    "start": 501,
                    "end": 508,
                    "text": "[\u22125, 5]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "Moving to the series.lin.coef.chng.x category of series, the f (x) is component is defined as Equation 11 , where m 1 is the same coefficient as m in Equation 10, and m 2 is a separately drawn coeficient also from a continuous uniform distribution over the range [\u22125, 5] . .",
            "cite_spans": [
                {
                    "start": 263,
                    "end": 270,
                    "text": "[\u22125, 5]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 94,
                    "end": 105,
                    "text": "Equation 11",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "boston_911dispatch_weekly"
        },
        {
            "text": "In order to demonstrate this method alongside regression with ARIMA errors on a \"realworld\" example, we can use the boston_fire_incidents_weekly data set included with knnwtsim. This data set contains 239 observations of the weekly count of fire incidents in the City of Boston, MA, USA, as well as a series of holiday indicators relevant to the U.S. state Massachusetts, and an indicator for the weeks which occurred during a COVID-19 state of emergency in the state. As mentioned in Section 4.4 this data set was derived from raw incident data sourced from Boston's open data portal. The data is accessed as follows, and the head of the data frame's first 5 columns are printed. Once the data is loaded it can be used to generate the necessary information for forecasting with knnwtsim. A vector of time orders, df$t, and a vector of periods, df$p, as well as a variable for the maximum period value, p.max, are created for use in StMatrixCalc and SpMatrixCalc. This data provides a good opportunity to point out the seasonal level used does not necessarily need to be on the same grain as the response data. In this case we use monthly seasonality in the construction of the similarity matrix using S p while the response observations are on a weekly level. Then the response series is captured in the vector y, and the matrix of exogenous predictors for use in SxMatrixCalc is stored in X. A separate version of the response series using the ts class is captured as y.ts for use in the forecast package's function auto.arima which willl be used later for comparison.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Real world data example"
        },
        {
            "text": "R> df <-boston_fire_incidents_weekly R> df$t <-c(1:nrow(df)) R> p.max <-12 R> df$p <-lubridate::month(df$week) R> y <-df$incidents R> Xcols <-names(boston_fire_incidents_weekly[, + 3:ncol(boston_fire_incidents_weekly)]) R> X <-as.matrix(df[, names(df) %in% Xcols]) R> y.ts <-ts(df$incidents, frequency = 52)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Real world data example"
        },
        {
            "text": "Next the time frames to be used for tuning and validation are established. The weights \u03b1, \u03b2, and \u03b3, as well as the number of neighbors k will be tuned with the latest 52 weeks data, test.len, after the 26 most recent points, val.len, are removed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Real world data example"
        },
        {
            "text": "R> test.len <-52 R> val.len <-26 R> n <-nrow(df) R> val.index <-as.vector(c((n -val.len + 1):(n))) At this stage each of the component similarity matrices used in S w are calculated using StMatrixCalc, SpMatrixCalc, and SxMatrixCalc. These matrices are then provided as input to the knn.forecast.randomsearch.tuning function, along with the number of randomly generated hyperparameter sets to be tested, the response series, the test horizon to be used to assess forecast accuracy, and the number of points which should be held out for validation, using the grid.len, y.in, test.h, and val.holdout.len arguments respectively. After the tuning is complete the similarity matrix using S w generated with the hyperparameter set which achieved the lowest MAPE result over the points in the test set is returned as part of list and can be accessed for later forecasting, as are the hyperparameters of this 'optimum' set. The hyperparameter set of interest is printed below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Real world data example"
        },
        {
            "text": "R> St.ts <-knnwtsim::StMatrixCalc(v = df$t) R> Sp.ts <-knnwtsim::SpMatrixCalc(v = df$p, nPeriods = p.max) R> Sx.ts <-knnwtsim::SxMatrixCalc(A = X, XdistMetric = binary ) R> set.seed (10) We then produce a baseline forecast for comparison over the same time frame using the auto.arima function from the forecast package. First fitting a model, arima.model, using the y.arima.train and X.arima.train objects which remove the validation points for later forecasting, and printing the model coefficients for reference. Forecasting on the validation data is then performed using with the forecast function and the result is stored in the variable arima.forecast.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Real world data example"
        },
        {
            "text": "R> y.arima.train <-y.ts [-(val.index The results as shown in Table 1 indicate that the ensemble forecast was the most accurate in terms of MAPE over the forecast horizon at 7.96%, followed by the forecast from knn.forecast at 8.14%, and finally the auto.arima forecast at 8.60%. Visually this comparison can be viewed as Figure 1 , where the series after week 190 is plotted and lines corresponding to the forecasts of the final 26 points from knn.forecast, auto.arima, and the ensemble of the two are plotted alongside their actual observations.",
            "cite_spans": [
                {
                    "start": 24,
                    "end": 36,
                    "text": "[-(val.index",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 61,
                    "end": 68,
                    "text": "Table 1",
                    "ref_id": null
                },
                {
                    "start": 321,
                    "end": 329,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Real world data example"
        },
        {
            "text": "We can continue with a demonstration of knnwtsim on an example using one of the simulated series included with the package. To get started we access simulation_master_list, which was described in Section 4.4, and select the necessary components for forecasting. In this case using the sub-list at index 19 of the overall list, and focus on the series which has a piece-wise functional relationship between response and predictor as indicated in Equation 12. Again as in Section 5 storing the vector of time orders in df$t, the vector of seasonal periods in df$p, the response series in y and the exogenous predictor in X, while also creating a copy of the response series with the ts class in y.ts for use in auto.arima from forecast. We then plot the full time series of interest for reference in Figure 2 . As one can see because of the nature of the f (x) component of the series there can be major shocks in the the response series based on the value of the predictor variable. With the similarity matrix calculated we can set the index we wish to forecast as val.index, which in this case will be the final two seasonal cycles each of consisting of four periods. Then call knn.forecast to return the forecast for those points. As in Section 5 we are interested in the performance of this forecast relative to auto.arima, so next the regression with ARIMA errors forecast is produced and the performance results KNN regression Regression with ARIMA errors 1 79.07 1298.65 Table 2 : Simulated data MAPE results by forecast method.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 798,
                    "end": 806,
                    "text": "Figure 2",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 1476,
                    "end": 1483,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Demonstration on simulated data"
        },
        {
            "text": "for both methods are captured following the approach used in Section 5, thus only a subset of that code is shown below. Additionally, we forego the use of an ensemble forecast. In terms of the reference forecast, in this case auto.arima returns a simple linear regression with all ARIMA orders set to 0. Table 2 shows the MAPE result over the final 8 points for both methods, and Figure 3 shows the same series as Figure 2 but only from time order 85 and on where the magnitude of observations are less extreme than at certain earlier points in the series, along with the forecasts from both methods. From both it is clear that for this forecast KNN regression is the better performing method. In this situation the more local nature of estimation in KNN regression is helpful, in that unless a point large in absolute magnitude is included in the neighborhood for a point y t which is to be estimated, those high magnitude results will not effect the estimate\u0177 t . While in the case of regression with ARIMA errors, or in this case simple linear regression alone, the estimates of model parameters are determined more globally, based on the entire series and so high magnitude points will influence the forecasts of all points, even when this is not desired. While as mentioned previously regression with ARIMA errors is often an excellent solution to univariate forecasting, this series presents a case where a nonparametric approach like KNN regression with S w may be preferred.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 304,
                    "end": 311,
                    "text": "Table 2",
                    "ref_id": null
                },
                {
                    "start": 380,
                    "end": 388,
                    "text": "Figure 3",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 414,
                    "end": 422,
                    "text": "Figure 2",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Demonstration on simulated data"
        },
        {
            "text": "The knnwtsim package provides an alternative to existing software for those interested in univariate forecasting with KNN regression. In this article the similarity metric S w was introduced as well as all of of its components, which could themselves be used alone in KNN regression if desired, as was KNN regression based forecasting more generally as implemented in knnwtsim in Sections 2 and 3 respectively. Additionally, the functions and data contained in knnwtsim are detailed in Section 4, and demonstrated through examples in Sections 5 and 6. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "I would like to thank Ernest Fokoue for his contribution to this package and article, he has been an immensely helpful advisor throughout the development of knnwtsim and there would not be a package without his advice and support.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgements"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "simulation_master_list\") R> series.index <-19",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "$series.quad.to.cubic.x R> df <-data.frame(y) R> df$t <-c(1:nrow(df))",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "R&gt; Y &lt;-Simulation_Master_List",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "$seasonal.periods R> df$p <-rep(1:p.max, length.out = nrow",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "R&gt; P.Max &lt;-Simulation_Master_List",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Statistics for Imaging, Optics, and Photonics",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bajorski",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Principles and Theory for Data Mining and Machine Learning",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Clarke",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Fokou\u00e9",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "H"
                    ],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Daily Dispatch Count by Agency",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Fire Incident Reporting",
            "authors": [],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Forecasting: Principles and Practice",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Hyndman",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Athanasopoulos",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Australia. knnwtsim: Nonparametric Forecasting With a Tailored Similarity Measure",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Automatic Time Series Forecasting: The forecast Package for R",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "J"
                    ],
                    "last": "Hyndman",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Khandakar",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Journal of Statistical Software",
            "volume": "26",
            "issn": "3",
            "pages": "1--22",
            "other_ids": {
                "DOI": [
                    "10.18637/jss.v027.i03"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Time Series Forecasting with KNN in R: The tsfknn Package",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Martinez",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "P"
                    ],
                    "last": "Frias",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Charte",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Rivera",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "The R Journal",
            "volume": "11",
            "issn": "2",
            "pages": "229--242",
            "other_ids": {
                "DOI": [
                    "10.32614/RJ-2019-004"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "fable: Forecasting Models for Tidy Time Series",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "O&apos;hara-Wild",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Hyndman",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "clusterGeneration: Random Cluster Generation (with Specified Degree of Separation)",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Qiu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Joe",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "R Core Team",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Modern Applied Statistics with S. Fourth edition",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "N"
                    ],
                    "last": "Venables",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "D"
                    ],
                    "last": "Ripley",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "\u2022 k.opt: An integer value of the number of neighbors used in knn.forecast which achieved the best performance in terms of MAPE. \u2022 Test.MAPE: A numeric value of the MAPE result for the optimum hyperparamter set achieved on the test points. \u2022 MAPE.all: A numeric vector of all MAPE results, each observation corresponds to the row in Grid of the same index. \u2022 Grid: A data frame of all hyperparameter sets tested in the tuning. \u2022 Sw.opt: A numeric matrix of similarities calculated using S w , with the best performing set of hyperparameters.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Finally the last category of time series in simulation_master_list are those stored as series.quad.to.cubic.x. Which have a f (x) component based on Equation 12, where m is again the same coeficient from Equation 10",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "R> data(\"boston_fire_incidents_weekly\") R> head(boston_fire_incidents_weekly[, 1:5])",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Full simulated data series with a peice-wise functional relationship to predictor.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Simulated data forecast comparison using KNN regression and regression with ARIMA errors",
            "latex": null,
            "type": "figure"
        },
        "TABREF1": {
            "text": "Sw.ts <-tuning.list$Sw.opt R> k.ts <-tuning.list$k.opt R> weights.ts <-tuning.list$weight.optWith the final tuned similarity matrix and value of k, the knn.forecast function can be called to generate a forecast for the points of the response series in the validation set, the last 26 weekly observations, and print the result.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Figure 1: Boston fire incidents forecast comparison using KNN regression and regression with ARIMA errors. R> X <-as.matrix(simulation_master_list[[series.index]]$x.chng) R> y.ts <-ts(y, frequency = p.max )Next, in this case we can assume the hyperparameters we want to use to calculate S_w and for the number of nearest neighbors to use in KNN are known in order to illustrate the use of SwMatrixCalc, and assign them to the variables pre.tuned.wts for the component similarity weights and pre.tuned.k for the number of nearest neighbors. To use this function we pass the time orders as the t.in argument, the seasonal periods and the maximum seasonal period as the p.in and nPeriods.in arguments respectively, the exogenous predictor used in the calculation of S x as X.in, and finally the vector of pre-tuned weights to the weights argument. This will call each of the component matrix calculation functions, apply the given vector of weights, and return a similarity matrix calculated using Equation 2.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "R> val.len <-p.max * 2 R> val.index <-c((length(y) -val.len + 1):length(y)) R> final.forecast <-knnwtsim::knn.forecast( + Sim.Mat.in = Sw.ts, + f.index.in = val.index,",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "R> y.arima.train <-y.ts[-(val.index)] R> X.arima.train <-as.nrow(y.arima.train)) R> arima.model <-forecast::auto.arima( + y.arima.train, + xreg = X.arima.train, + allowdrift = T) R> summary(arima.model)$coef intercept xreg -53.99516 -24.97937",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}