{
    "paper_id": "6df4a2f57c8d7c64405d9ace99de11b06c96dbc9",
    "metadata": {
        "title": "Building Trust for Smart Connected Devices: The Challenges and Pitfalls of TrustZone",
        "authors": [
            {
                "first": "Nikolaos",
                "middle": [],
                "last": "Koutroumpouchos",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Christoforos",
                "middle": [],
                "last": "Ntantogian",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Ionian University",
                    "location": {
                        "postCode": "49100",
                        "settlement": "Corfu",
                        "country": "Greece"
                    }
                },
                "email": ""
            },
            {
                "first": "Christos",
                "middle": [],
                "last": "Xenakis",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [],
    "body_text": [
        {
            "text": "Due to the emergence and adaptation of smart connected devices as a platform for interaction with an ever-expanding number of digital services and systems, security has emerged as a major design goal for these smart connected devices. The ability to connect, manage, and control a device from anywhere and at any time leads such devices to generate, process, and exchange vast amounts of security-critical and privacy-sensitive data, turning them into attractive cyberattack targets. The strong intra and inter-connectivity of smart connected devices requires a holistic, end-to-end security approach, addressing security and privacy risks at all levels.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Security by isolation is a well-established strategy for achieving security goals such as data confidentiality, integrity, and availability. Several software-based approaches such as microkernels, sandboxes, and virtualizations have been used, but these methods fail in providing the desired security level [1, 2] . Smart connected devices must be fortified with new security-oriented technologies that guarantee security from the outset.",
            "cite_spans": [
                {
                    "start": 307,
                    "end": 310,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 311,
                    "end": 313,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Among existing security-oriented technologies, TrustZone is gaining particular attention due to the massive presence of ARM processors in the embedded market [3] . TrustZone technology is an implementation of a Trusted Execution Environment (TEE), which is a hardware and software based isolated, secure container of state and data that functions in parallel to the main OS of the system. In TrustZone-based TEEs, security-sensitive applications and sensitive data can be offloaded with the purpose of enhancing their protection and assurance of their integrity and confidentiality. The need for a TEE is derived by the realization that the standard operating system of the platform is incapable of safeguarding the integrity of the applications and their data. The design goal of TEE is to be able to host a wide variety of security-sensitive applications and to be able to protect -mainly by hardware driven isolation-their own internal state's integrity as also that of the serving applications, from malicious modification.",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 161,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "ARM TrustZone have been researched and proposed as providers of security sensitive solutions in various application domains of smart connected devices including sensors [4] , Industry 4.0 and IoTs [5] , Vehicular communications [6] , drones [7] and wearables [8] . However, an ever-expanding number of discovered vulnerabilities and developed attacks against the most widely used TEE implementations, poses a question on the ability of current designs to achieve the standing of the most secure element on the platform, as they are been heavily promoted of from the side of both platform designers and integrators [9] [10] [11] [12] [13] [14] .",
            "cite_spans": [
                {
                    "start": 169,
                    "end": 172,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 197,
                    "end": 200,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 241,
                    "end": 244,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 259,
                    "end": 262,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 614,
                    "end": 617,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 618,
                    "end": 622,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 623,
                    "end": 627,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 628,
                    "end": 632,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 633,
                    "end": 637,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 638,
                    "end": 642,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This paper illuminates this reality and projects the requirement for a more extensive security awareness from the perspective of their design and implementation as well. More specifically, first we provide essential information about the TrustZone security extensions, TEE implementations and types of services they host. Next, we elaborate on the discovered vulnerabilities and related attacks using a taxonomy that classifies them into three main categories: (a) software, (b) architectural, and (c) side channel attacks. The presentation of the attacks is comprehensive providing a set of critical observations that carry out the most important outcomes of each attack for pedagogical purposes. We pinpoint that an attacker with the ability to execute code in the context of the secure world can fully compromise the system, while also have access to secrets stored within the secure world. Furthermore, an attacker that has kernel rights within TrustZone can manipulate resources from other trusted applications. We also provide generic attack paths to visually demonstrate all possible vectors that attackers can exploit to compromise the security of TrustZone. Next, we perform a critical appraisal of the discovered vulnerabilities to shed light on the roots of these subtle security flaws. Finally, we provide important security guidelines and solutions both for application developers and TEE implementors to remedy and improve the overall security posture of TrustZone. In summary, this work provides the following contributions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Proposes a taxonomy of the currently known public attacks against TEE implementations and conducts an in-depth analysis of them.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "1."
        },
        {
            "text": "Provides high-level attack paths to describe how vulnerabilities in different architectural components can result in partial or complete takeover of the TrustZone. 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "Provides insights into the possible reasons behind the security weaknesses. 4 .",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 77,
                    "text": "4",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "Proposes guidelines that developers and security practitioners should follow in order to enhance the security status of TrustZone and suggests future research directions. 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "Draws attention in a very relevant area of research since trusted computing is one of the key factors for applying security and trust in next generation IoT and sensor networks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "There are various works that investigate TEEs and their provided security guarantees, compare their capabilities with other related technologies and analyze their shortcomings [15] [16] [17] [18] [19] [20] [21] . In [15] researchers developed a theoretical model for TEEs, analyze its core components and propose a more precise definition of it. Although they are referencing some of the public attacks on TEEs, they do not analyze the impact of them nor the reasons that may lead to their existence. In [16] Arfaoui et al. provide a view of the various existing TEE technologies according to GlobalPlatform standards. [17] Presents a survey of trust computing in mobile devices. Moreover, in [18] there is a comparative security analysis of the TrustZone and the SGX technologies while in [19] [20] [21] the researchers provide a comprehensive analysis of the TrustZone technology in general with no emphasis on the attacks against it. The focus of the above papers is different from our approach, as none of the three exposes the degree of vulnerability and the importance of the various TrustZonebased TEE solutions used in market deployed devices, while they fail to pinpoint common design flaws that lead to these vulnerabilities. Finally, concurrent to our work, Cerdeira et al. [22] presented and provided a comprehensive taxonomy of TrustZone-based TEE vulnerabilities. The results of this paper are complementary to our research and analysis. tween the two worlds and manages switching between the two and the transitions and transfers of state in a secure way [15] .",
            "cite_spans": [
                {
                    "start": 176,
                    "end": 180,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 181,
                    "end": 185,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 186,
                    "end": 190,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 191,
                    "end": 195,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 196,
                    "end": 200,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 201,
                    "end": 205,
                    "text": "[20]",
                    "ref_id": null
                },
                {
                    "start": 206,
                    "end": 210,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 216,
                    "end": 220,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 504,
                    "end": 508,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 619,
                    "end": 623,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 693,
                    "end": 697,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 790,
                    "end": 794,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 795,
                    "end": 799,
                    "text": "[20]",
                    "ref_id": null
                },
                {
                    "start": 800,
                    "end": 804,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1285,
                    "end": 1289,
                    "text": "[22]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1570,
                    "end": 1574,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "World switching between the two execution environments is facilitated via the Secure Monitor Call (SMC) instruction. In normal operation the non-secure operating system processes tasks in the standard way. When a non-privileged REE process requires services of a trusted application running in the secure execution environment, it requests an execution state transfer to the privileged non-secure kernel. The non-secure kernel through a device driver, by use of the SMC instruction, calls the secure monitor to undertake the switch to the secure world. [40, 41] Apart from the software SMC call, a subset of hardware exception mechanisms containing the IRQs, FIQs, external data abort and external prefetch abort are able to modify the current state of execution and cause a world switch.",
            "cite_spans": [
                {
                    "start": 553,
                    "end": 557,
                    "text": "[40,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 558,
                    "end": 561,
                    "text": "41]",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "Furthermore, the ARMv8 architecture follows an exception model that is divided in four different privilege levels that follows the classic software segregation between application and operating system/kernel privileges [42] . In this way, it separates the system into relatively privileged abstractions. Each privilege level is denoted by its associated Exception Level (EL0, EL1, EL2, EL3) with EL0 being the lowest privileged while EL3 the highest. This model propagates throughout the normal and the secure world, affecting their applications and operating systems. More specifically, the unprivileged level of execution EL0 is where the user space applications reside like trusted and normal world applications, while the normal world and secure world operating systems and their kernels belong to EL1. The various hypervisors used for virtualization of the normal world or the secure world EL1 operating systems [43, 44] reside in EL2 and can essentially allow the parallel execution of multiple EL1 operating systems but they cannot manage or manipulate the secure state of the system; that is, a transition between the secure and the normal world. This privilege is only allowed to the final and most privileged EL3 where the secure monitor (trusted firmware) is the only entity allowed in this exception level.",
            "cite_spans": [
                {
                    "start": 219,
                    "end": 223,
                    "text": "[42]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 917,
                    "end": 921,
                    "text": "[43,",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 922,
                    "end": 925,
                    "text": "44]",
                    "ref_id": "BIBREF42"
                }
            ],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "The secure monitor typically provides a basic set of functionalities [45] that include: a Power State Coordination Interface (PSCI) for coordinated power management [46] , a Trusted Board Boot Requirements CLIENT (TBBR-CLIENT) for the trusted boot process and the isolation between the normal and secure world [47] , an SMC Calling Convention for SMC handling [48] , a System Control and Management Interface (SCMI) for coordinated system control and management tasks [49] and a Software Delegated Exception Interface (SDEI) for registering and servicing system events [50] . Finally, EL0-EL2 are separated in two states, secure and non-secure which are usually denoted with NS.EL [0-2] and S.EL [0-2] and they are used to provide a distinction between the normal and the secure world; the EL3 is always in the secure state. The secure state of the processor is managed by the SCR_EL3.NS bit. A depiction of this exception level architecture can be found in Figure 1 . In Figure 2 , there is a demonstration of how the two worlds are divided between them and their respective kernels. Each world includes its user-space and kernel-space for internal operations with the secure monitor being a part of the secure world. The communication between the two worlds can be implementation-dependent with three options being the most common which can be seen in Figure 2 : (C1), a library is provided which directly communicates with the underlying TEE driver, (C2) the user application directly communicates with the TEE driver and (C3) there is a running daemon responsible for managing and forwarding requests to the TEE driver. Regardless of the chosen normal world implementation, the TEE driver will undergo any required procedures in order to Sensors 2021, 21, 520 5 of 46 create an SMC system call, which in turn hand over the execution to the secure monitor. Then, the secure monitor will assess the SMC and pass the execution to the trusted world kernel that will finally call the appropriate trusted application. It should be noted here that the two worlds, in order to communicate properly, have methods for sharing data either through small variables or shared memory objects. them and their respective kernels. Each world includes its user-space and kernel-space for internal operations with the secure monitor being a part of the secure world. The communication between the two worlds can be implementation-dependent with three options being the most common which can be seen in Figure 2 : (C1), a library is provided which directly communicates with the underlying TEE driver, (C2) the user application directly communicates with the TEE driver and (C3) there is a running daemon responsible for managing and forwarding requests to the TEE driver. Regardless of the chosen normal world implementation, the TEE driver will undergo any required procedures in order to create an SMC system call, which in turn hand over the execution to the secure monitor. Then, the secure monitor will assess the SMC and pass the execution to the trusted world kernel that will finally call the appropriate trusted application. It should be noted here that the two worlds, in order to communicate properly, have methods for sharing data either through small variables or shared memory objects. The sharing of memory between the secure and the normal world is implemented with two different SMC calls: the fast call and the yield call (defined in the ARM trusted firmware reference implementation as SMC_TYPE_FAST and SMC_TYPE_YIELD) [51] . The fast call provides a fast register-based information exchange, where only up to four variables can be used to transfer limited data between the two worlds. These variables can be used by both the normal and the secure world to transfer function parameters, operational results, and any other required data. On the other hand, the yield call allocates a memory location of the normal world to be shared with the secure world, this call is useful for scenarios where large amounts of data need to be transferred or when there is a need for synchronous trusted applications like DRM protected video streaming.",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 73,
                    "text": "[45]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 165,
                    "end": 169,
                    "text": "[46]",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 310,
                    "end": 314,
                    "text": "[47]",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 360,
                    "end": 364,
                    "text": "[48]",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 468,
                    "end": 472,
                    "text": "[49]",
                    "ref_id": null
                },
                {
                    "start": 569,
                    "end": 573,
                    "text": "[50]",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 3523,
                    "end": 3527,
                    "text": "[51]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 958,
                    "end": 966,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 972,
                    "end": 980,
                    "text": "Figure 2",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 1354,
                    "end": 1362,
                    "text": "Figure 2",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 2486,
                    "end": 2494,
                    "text": "Figure 2",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "2."
        },
        {
            "text": "Additionally, TrustZone facilitates two components for memory management and protection, the TrustZone Memory Adapter (TZMA) and the TrustZone Address Space Controller (TZASC), respectively. These components implement protection schemes through static partitioning of the on-chip memory (TZMA) and through dynamic partitioning of the off-chip memory. The memory management units are configured by early bootloaders to only allow specific execution environments to access specific memory locations. If the normal world environment attempts to read or write the memory that is configured in a memory controller for the TrustZone kernel, the CPU will abort and, depending on configuration, reboot the device due to the violation. The sharing of memory between the secure and the normal world is implemented with two different SMC calls: the fast call and the yield call (defined in the ARM trusted firmware reference implementation as SMC_TYPE_FAST and SMC_TYPE_YIELD) [51] . The fast call provides a fast register-based information exchange, where only up to four variables can be used to transfer limited data between the two worlds. These variables can be used by both the normal and the secure world to transfer function parameters, operational results, and any other required data. On the other hand, the yield call allocates a memory location of the normal world to be shared with the secure world, this call is useful for scenarios where large amounts of data need to be transferred or when there is a need for synchronous trusted applications like DRM protected video streaming.",
            "cite_spans": [
                {
                    "start": 966,
                    "end": 970,
                    "text": "[51]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "Additionally, TrustZone facilitates two components for memory management and protection, the TrustZone Memory Adapter (TZMA) and the TrustZone Address Space Controller (TZASC), respectively. These components implement protection schemes through static partitioning of the on-chip memory (TZMA) and through dynamic partitioning of the off-chip memory. The memory management units are configured by early bootloaders to only allow specific execution environments to access specific memory locations. If the normal world environment attempts to read or write the memory that is configured in a memory controller for the TrustZone kernel, the CPU will abort and, depending on configuration, reboot the device due to the violation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "On top of these TrustZone features, ARM also implements an access permission scheme that defines whether memory access is allowed or not, based on special permission characteristics assigned to each memory page. For instance, a read and execute-only page (which usually are code pages) cannot be modified, while other memory regions that will hold dynamic data should be assigned writeable permissions too. This is enforced through an access control mechanism that utilizes the Domain Access Control Register or DACR. The MMU checks if the bits corresponding to the given memory region in the DACR register (of the ARM specification) are set; If so, the access is allowed. The DACR is a 32-bit register, which specifies the access properties of 16 memory domains (2 bits for each domain, see Figure 3 ). The possible values are [52] : page (which usually are code pages) cannot be modified, while other memory regions that will hold dynamic data should be assigned writeable permissions too. This is enforced through an access control mechanism that utilizes the Domain Access Control Register or DACR. The MMU checks if the bits corresponding to the given memory region in the DACR register (of the ARM specification) are set; If so, the access is allowed. The DACR is a 32-bit register, which specifies the access properties of 16 memory domains (2 bits for each domain, see Figure 3 ). The possible values are [52] :",
            "cite_spans": [
                {
                    "start": 828,
                    "end": 832,
                    "text": "[52]",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 1413,
                    "end": 1417,
                    "text": "[52]",
                    "ref_id": "BIBREF50"
                }
            ],
            "ref_spans": [
                {
                    "start": 792,
                    "end": 800,
                    "text": "Figure 3",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1377,
                    "end": 1385,
                    "text": "Figure 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "2."
        },
        {
            "text": "\u2022 00: Access is denied. Any access generates a domain fault. Thus, if the value of the DACR register bits of the corresponding memory domain are set to 11, the MMU will enable access to any memory address of that domain for both writing and reading without generating any faults.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "For bus management, two interfaces exist: the advanced extensible Interface (AXI) and the Advanced Peripheral Bus (APB), both acting under the AMBA3 [53] specifications. The first implements the bus interface for the main SoC level system and the second is a low bandwidth simple peripheral bus interface, which is attached to the system using an AXI-to-APB bridge. The primary interface has the capability -through an extended signaling system and the insertion of a 33rd flag bit named NS-bit-to separate peripherals based on a secure or normal world division schema. The APB bus has no capabilities of this nature and the responsibility of managing security must be handled by the aforementioned intermediate bridge interconnect. Additionally, the system can have both secure and non-secure hardware peripherals that respective secure and non-secure device drivers control, from each mode independently through the provided buses [40] .",
            "cite_spans": [
                {
                    "start": 149,
                    "end": 153,
                    "text": "[53]",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 933,
                    "end": 937,
                    "text": "[40]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "2."
        },
        {
            "text": "Regarding standardization activities, GlobalPlatform is the main organization creating and publishing specifications for the TEE technology. Initially focusing on TEE system architecture specifications and on standardization of the interface between the TEE and the REE (client API), a specification for the interface between the TEE applications and the Secure OS (internal API) was later provided. They have also published a TEE protection profile that targets threats to the TEE assets that arise during the end-usage phase and can be achieved by software means [26] . Most ARM TrustZone-based TEEs which are available in commodity devices, strictly conform to these standards.",
            "cite_spans": [
                {
                    "start": 565,
                    "end": 569,
                    "text": "[26]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "GlobalPlatform Specification & Protection Profile"
        },
        {
            "text": "In the protection profile specification of GlobalPlatform, multiple attributes and requirements are defined that provide the scope of the security protection that a TEE should provide. That is what security guarantees are mandatory for TEE implementors. This document presents: (i) the target of evaluation for the main security features and intended uses of a TEE device, (ii) the conformity of the document to common criteria, (iii) the security problem definition, (iv) the security objectives and (v) the security requirements. Furthermore, in the appendix of the document there is a description of potential attacks Thus, if the value of the DACR register bits of the corresponding memory domain are set to 11, the MMU will enable access to any memory address of that domain for both writing and reading without generating any faults.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GlobalPlatform Specification & Protection Profile"
        },
        {
            "text": "For bus management, two interfaces exist: the advanced extensible Interface (AXI) and the Advanced Peripheral Bus (APB), both acting under the AMBA3 [53] specifications. The first implements the bus interface for the main SoC level system and the second is a low bandwidth simple peripheral bus interface, which is attached to the system using an AXI-to-APB bridge. The primary interface has the capability -through an extended signaling system and the insertion of a 33rd flag bit named NS-bit-to separate peripherals based on a secure or normal world division schema. The APB bus has no capabilities of this nature and the responsibility of managing security must be handled by the aforementioned intermediate bridge interconnect. Additionally, the system can have both secure and nonsecure hardware peripherals that respective secure and non-secure device drivers control, from each mode independently through the provided buses [40] .",
            "cite_spans": [
                {
                    "start": 149,
                    "end": 153,
                    "text": "[53]",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 932,
                    "end": 936,
                    "text": "[40]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "GlobalPlatform Specification & Protection Profile"
        },
        {
            "text": "Regarding standardization activities, GlobalPlatform is the main organization creating and publishing specifications for the TEE technology. Initially focusing on TEE system architecture specifications and on standardization of the interface between the TEE and the REE (client API), a specification for the interface between the TEE applications and the Secure OS (internal API) was later provided. They have also published a TEE protection profile that targets threats to the TEE assets that arise during the end-usage phase and can be achieved by software means [26] . Most ARM TrustZone-based TEEs which are available in commodity devices, strictly conform to these standards.",
            "cite_spans": [
                {
                    "start": 565,
                    "end": 569,
                    "text": "[26]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "GlobalPlatform Specification & Protection Profile"
        },
        {
            "text": "In the protection profile specification of GlobalPlatform, multiple attributes and requirements are defined that provide the scope of the security protection that a TEE should provide. That is what security guarantees are mandatory for TEE implementors. This document presents: (i) the target of evaluation for the main security features and intended uses of a TEE device, (ii) the conformity of the document to common criteria, (iii) the security problem definition, (iv) the security objectives and (v) the security requirements. Furthermore, in the appendix of the document there is a description of potential attacks to TEEs with varying profiles and scenarios that also include hardware attacks (side channel attacks and fault injection attacks) which the TEE should be able to defend against to some extent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GlobalPlatform Specification & Protection Profile"
        },
        {
            "text": "The part of the document that we focused on is the security objectives which will allow us to assess each attack by investigating which security objective is violated through it. In the following list we shortly describe each mandatory TEE objective and in how many attacks we found a violation of it. In Section 3.4 which is analyzed after the attacks presentation in Section 3.4 we will showcase exactly which of those objectives is violated by each attack.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GlobalPlatform Specification & Protection Profile"
        },
        {
            "text": "O.CA_TA_IDENTIFICATION: Protection for the identity of each trusted application from being used from other trusted applications. Also, assurance for the distinction of normal world applications and trusted applications. (Violations: 0) ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Inside the TEE, Platform/OEM engineers in collaboration with third parties, can implement several security oriented and security sensitive services utilizing its assurance and secure storage capabilities, aiming for integrity and confidentiality of their assets. In current implementations a centralized provision model is used, with the developer of the corresponding TEE acting as the central authority that will allow or deny a service to be installed on its TEE. The capabilities a TEE offers can be generalized into the below categories:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "TEE Capabilities and Types of Trusted Applications"
        },
        {
            "text": "Utilizing the above core capabilities, TrustZone TEEs can provide a wide range of functionalities such as: verification of kernel integrity, access to secure credential generation, secure storage (Android Keystore, dm-verity), secure element emulation for secure mobile payments, enforcement of corporate policies, implementation and verification of secure boot, content protection, digital rights management solutions (PlayReady, Widevine, etc.) and device integrity attestation in the scope of IoT and ARM Cortex-M; although its performance could be optimized for low powered devices with novel attestation schemes [54] .",
            "cite_spans": [
                {
                    "start": 617,
                    "end": 621,
                    "text": "[54]",
                    "ref_id": "BIBREF52"
                }
            ],
            "ref_spans": [],
            "section": "TEE Capabilities and Types of Trusted Applications"
        },
        {
            "text": "From the scope of what is targeted by each solution, we can divide them into three categories: services that enhance platform and normal world security, services that provide functionalities to the user and enhance user security, and services towards third parties. In the first category, solutions like Samsung's TIMA (a proprietary solution limited to Samsung devices) [55] , secure boot [56] and Sprobes [57] provide real-time protection, integrity verification and introspection mechanisms for the security enhancement of the normal world kernel/OS. Secure key storage, software TPM [58] [59] [60] , trusted peripherals and sensors [4] are other paradigms of solutions that can fit this category. Towards user functionality and security enhancement, a wide variety of implemented solutions exist. Online prepaid mobile payments [61, 62] , online transactions confirmations [63] , ticketing services [64] , cloud storage access authentication [65, 66] , two factor authentication [67, 68] are some examples. In the third category, solutions like [69, 70] provide protection for media content and smart contract execution respectively.",
            "cite_spans": [
                {
                    "start": 371,
                    "end": 375,
                    "text": "[55]",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 390,
                    "end": 394,
                    "text": "[56]",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 407,
                    "end": 411,
                    "text": "[57]",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 587,
                    "end": 591,
                    "text": "[58]",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 592,
                    "end": 596,
                    "text": "[59]",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 597,
                    "end": 601,
                    "text": "[60]",
                    "ref_id": "BIBREF58"
                },
                {
                    "start": 636,
                    "end": 639,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 832,
                    "end": 836,
                    "text": "[61,",
                    "ref_id": "BIBREF59"
                },
                {
                    "start": 837,
                    "end": 840,
                    "text": "62]",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 877,
                    "end": 881,
                    "text": "[63]",
                    "ref_id": "BIBREF61"
                },
                {
                    "start": 903,
                    "end": 907,
                    "text": "[64]",
                    "ref_id": "BIBREF62"
                },
                {
                    "start": 946,
                    "end": 950,
                    "text": "[65,",
                    "ref_id": "BIBREF63"
                },
                {
                    "start": 951,
                    "end": 954,
                    "text": "66]",
                    "ref_id": "BIBREF64"
                },
                {
                    "start": 983,
                    "end": 987,
                    "text": "[67,",
                    "ref_id": "BIBREF65"
                },
                {
                    "start": 988,
                    "end": 991,
                    "text": "68]",
                    "ref_id": "BIBREF66"
                },
                {
                    "start": 1049,
                    "end": 1053,
                    "text": "[69,",
                    "ref_id": "BIBREF67"
                },
                {
                    "start": 1054,
                    "end": 1057,
                    "text": "70]",
                    "ref_id": "BIBREF68"
                }
            ],
            "ref_spans": [],
            "section": "TEE Capabilities and Types of Trusted Applications"
        },
        {
            "text": "In this section, we further elaborate on QSEE architecture, due to the fact that the majority of the devices and documented attacks are based on this solution. QSEE is the TrustZone-based TEE implementation that Qualcomm has installed in its SoCs. Like all TEEs, QSEE includes user-mode applications in normal world that may require communicating with trusted applications of the secure world in the TEE. For instance, the Android process in charge of handling cryptographic keys named \"KeyStore\", needs to be able to communicate with a special trusted application (named \"KeyMaster\") which provides secure management of cryptographic keys using the capabilities offered by TrustZone (e.g., secure storage, isolation, etc.). However, user-mode applications cannot perform SMC calls to enter the secure world, since they require kernel-space privileges. Qualcomm TEE implementations solve this problem by using a Linux kernel driver (Figure 2 , C2), called \"qseecom\", which enables user-space processes to perform a wide range of TrustZonerelated operations, such as loading trusted applications into the secure environment and communicating with loaded trusted applications. The qseecom driver provides an ioctl system call interface to perform SMC calls from the kernel-space in place of the normal world application that needs the TEE functionality. The interface between the normal and secure world through the qseecom driver is named Secure Channel Manager (SCM). This channel is the largest attack surface to the TEE, as it provides one of the few handles that the outside world can use to communicate with the trusted world.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 932,
                    "end": 941,
                    "text": "(Figure 2",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "Because of the security concern outlined above, the access to qseecom driver is restricted to the minimal set of processes that require it. For example, in the implementation discussed in [71] , only four processes of the normal world are able to access \"qseecom\":",
            "cite_spans": [
                {
                    "start": 188,
                    "end": 192,
                    "text": "[71]",
                    "ref_id": "BIBREF69"
                }
            ],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "\u2022 SurfaceFlinger (running with \"system\" user-ID): an Android system service, responsible for compositing all the application and system surfaces into a single buffer that is finally to be displayed by display controller. \u2022 DrmServer (running with \"drm\" user-ID): which is responsible for digital rights management. \u2022 MediaServer (running with \"media\" user-ID): that handles the media services of Android. \u2022 KeyStore (running with \"keystore\" user-ID): a service that is responsible for storing, generating, and handling cryptographic keys in Android.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "The aforementioned four processes and any process that can access the QSEE should not be vulnerable, otherwise, if an attacker manages to exploit any of them, then he can directly access any trusted application bypassing the Linux kernel in the process (depending on the vulnerability found). To make things worse, trusted applications are not written in memory safe languages (typically they are written in the C language) which can allow attackers to propagate the exploitation to the secure world. As we will see, QSEE lacks or has weak implementations of common security mechanisms such as ASLR, stack cookies and guard pages [9] .",
            "cite_spans": [
                {
                    "start": 630,
                    "end": 633,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "Qualcomm implements the TrustZone fast and yield TEE communication commands (presented in Sections 2.1 and 2.4) by defining two distinct calls named scm_call() (yield) and scm_call_atomic [1] [2] [3] [4] () (fast). The scm_call() function is used to create and share a common memory region to be used for the communication between the two worlds and it populates a structure which defines the size of the shared buffer, the headers section of the Sensors 2021, 21, 520 9 of 46 buffer, the offset of the data to be sent and the offset of the receiving data. On the other hand, the scm_call_atomic [1] [2] [3] [4] () functions are used to initiate a communication that uses 1 to 4 variables (depending on the name of the function call) and is mainly used for one-off sessions where the data exchange between the two worlds is relatively small.",
            "cite_spans": [
                {
                    "start": 188,
                    "end": 191,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 192,
                    "end": 195,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 196,
                    "end": 199,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 200,
                    "end": 203,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 596,
                    "end": 599,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 600,
                    "end": 603,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 604,
                    "end": 607,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 608,
                    "end": 611,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "Due to the fact that the memory allocated by the scm_call() function might not be within writable or readable regions; it is first validated by the TrustZone kernel before it is used by the trusted application. The validation is done in order to make sure the physical address is within an allowed range, and is not for example, within the TrustZone kernel memory range because as we analyze below, any modification to TrustZone kernel pages is prohibited. The first line of defense is the ARM DACR mechanism analyzed in Section 2.1. We will see that an attacker can potentially send pointers to the secure world bypassing their sanitization.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "TrustZone enabled Qualcomm SoCs on top of DACR implement another hardwarebased memory access control mechanism in newer devices. More specifically, some predefined memory regions are flagged by the manufacturer as write protected, a policy which is enforced by a hardware memory protection unit (MPU). In Qualcomm, these units are called XPUs and are configured by the OEM during the manufacturing process. XPUs do not only prevent access from normal word to secure world but it also controls the access rights on any physical memory region defined by the manufacturer. For example, the TrustZone kernel code segments are mapped with read-only access permissions by utilizing the XPU mechanism and are verified during the secure boot process. This means that once TrustZone kernel code is loaded into memory, it theoretically cannot (and should not) be subject to any change.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "Another important implementation detail is how loading of trusted applications and their revocation is performed during the secure boot process of Qualcomm. Qualcomm's signed images are regular ELF files which are supplemented by a single special \"Hash Table Segment \". This segment includes three distinct components: the SHA-256 digest of each ELF segment, a signature blob, and a certificate chain. The signature is verified over the concatenated blob of SHA-256 hashes, using the public key of the last certificate in the certificate chain (Attestation Cert). Moreover, the root certificate is hashed and validated against a \"Root Key Hash\" which is stored in the device's ROM or fused into one-timeprogrammable memory on the SoC. This way a chain of trust is created, beginning from a hardware-bound key, each certificate in the chain is validated with the binary signature finally being validated by the last certificate (see Figure 4 ). Furthermore, it appears that Qualcomm has elected to add unique OU fields to the signature of the binary, denoting several attributes relating to specific attributes that will improve the security of the images loaded. These attributes are:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 253,
                    "end": 266,
                    "text": "Table Segment",
                    "ref_id": null
                },
                {
                    "start": 932,
                    "end": 940,
                    "text": "Figure 4",
                    "ref_id": "FIGREF9"
                }
            ],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "The software version that this signature belongs to. This acts as a version access control system where its value is compared to an internal eFuse (registers which can only be incremented). If the eFuse comparison indicates that the binary to be loaded is older than the last loaded binary, then it is rejected. \u2022 HW_ID: Attribute to bind the binary to a specific r device family, model, and OEM. Finally, it is important to mention that Qualcomm TEEs and TEEs in general are considered high privileged entities. While the secure world can secure its own memory, there is no inherent mechanism for the secure world to guarantee the safety of operations on the normal world memory. This lack of information about the non-secure world from within the secure world places a great deal of responsibility on the untrusted OS to sanitize any inputs, especially pointers, that are passed into the secure world. The trusted world can manipulate any memory address of the normal world that is not protected by the DACR or XPUs without taking into consideration the province of that address. Therefore, a compromised TEE can easily be used to attack the normal world kernel even if the kernel had no vulnerabilities to begin with (simply by directly modifying the kernel's code from the \"Secure World\").",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "\u2022 SW_ID: The software version that this signature belongs to. This acts as a version access control system where its value is compared to an internal eFuse (registers which can only be incremented). If the eFuse comparison indicates that the binary to be loaded is older than the last loaded binary, then it is rejected. Finally, it is important to mention that Qualcomm TEEs and TEEs in general are considered high privileged entities. While the secure world can secure its own memory, there is no inherent mechanism for the secure world to guarantee the safety of operations on the normal world memory. This lack of information about the non-secure world from within the secure world places a great deal of responsibility on the untrusted OS to sanitize any inputs, especially pointers, that are passed into the secure world. The trusted world can manipulate any memory address of the normal world that is not protected by the DACR or XPUs without taking into consideration the province of that address. Therefore, a compromised TEE can easily be used to attack the normal world kernel even if the kernel had no vulnerabilities to begin with (simply by directly modifying the kernel's code from the \"Secure World\").",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implementation Details of QSEE"
        },
        {
            "text": "The ARM SoCs include a CPU cache that is utilized to improve data and instruction fetch times. This cache is shared by both the secure and the non-secure world while it incorporates the TrustZone NS-bit mechanism to ensure that each world is separated and has proper access rights to its resources. More specifically each cache entry is tagged with the NS-bit so that if a non-secure access attempt is made against a secure entry a cache miss will occur [72] . This might lead to the belief that the cache is safe to be used by the trusted world but recent attacks [73] [74] [75] [76] have shown that there is a major problem in this shared cache design.",
            "cite_spans": [
                {
                    "start": 454,
                    "end": 458,
                    "text": "[72]",
                    "ref_id": "BIBREF70"
                },
                {
                    "start": 565,
                    "end": 569,
                    "text": "[73]",
                    "ref_id": "BIBREF72"
                },
                {
                    "start": 570,
                    "end": 574,
                    "text": "[74]",
                    "ref_id": "BIBREF73"
                },
                {
                    "start": 575,
                    "end": 579,
                    "text": "[75]",
                    "ref_id": "BIBREF74"
                },
                {
                    "start": 580,
                    "end": 584,
                    "text": "[76]",
                    "ref_id": "BIBREF75"
                }
            ],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "The main problem here is the fact that the cache is shared between the two worlds and besides the fact that it is protected by TrustZone, an attacker might find indirect ways to infer secrets from the trusted domain. This kind of attack is called a side channel attack ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "The ARM SoCs include a CPU cache that is utilized to improve data and instruction fetch times. This cache is shared by both the secure and the non-secure world while it incorporates the TrustZone NS-bit mechanism to ensure that each world is separated and has proper access rights to its resources. More specifically each cache entry is tagged with the NS-bit so that if a non-secure access attempt is made against a secure entry a cache miss will occur [72] . This might lead to the belief that the cache is safe to be used by the trusted world but recent attacks [73] [74] [75] [76] have shown that there is a major problem in this shared cache design.",
            "cite_spans": [
                {
                    "start": 454,
                    "end": 458,
                    "text": "[72]",
                    "ref_id": "BIBREF70"
                },
                {
                    "start": 565,
                    "end": 569,
                    "text": "[73]",
                    "ref_id": "BIBREF72"
                },
                {
                    "start": 570,
                    "end": 574,
                    "text": "[74]",
                    "ref_id": "BIBREF73"
                },
                {
                    "start": 575,
                    "end": 579,
                    "text": "[75]",
                    "ref_id": "BIBREF74"
                },
                {
                    "start": 580,
                    "end": 584,
                    "text": "[76]",
                    "ref_id": "BIBREF75"
                }
            ],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "The main problem here is the fact that the cache is shared between the two worlds and besides the fact that it is protected by TrustZone, an attacker might find indirect ways to infer secrets from the trusted domain. This kind of attack is called a side channel attack and its basic characteristic is that the attacking entity tries to measure specific parameters of the victim process that will ultimately provide the attacker with enough data to recover the information targeted in the first place.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "In the case of caches an attacker can measure two basic things, the execution time of the victim process and which cache lines where accessed. The basic assumption for a cache-based side channel attack is that the attacker needs to be able to manipulate the cache in some way so as to achieve a known state of the cache before it lets the victim process to take control. There are three basic techniques for cache-based side channel attacks:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "\u2022 Evict + Time [77] : Initially the execution time of the victim program is measured without any changes. Afterwards specific cache sets are evicted that were previously used by the victim program so that in the next execution of the program the time will potentially change. These changes in execution time are correlated to the changes that are made to the cache so that useful information can be extracted which can lead up to secret cryptographic key exposure in the case of AES. \u2022 Prime + Probe [77] : The entire cache is first filled (primed) with known and controlled data by the attacking process. Then the victim process executes while the attacker closely monitors how the initial known state of the cache is changing. Depending on the cache changes that he detects he can obtain information of the victim operation and the nature of its behavior. The main benefit of this technique is that it does not require a shared memory map between the victim and the attacker, making it optimal for targeting the trusted world. \u2022 Flush(Evict) + Reload [74] : For this attack to work the attacker and the victim need to share an identical read-only memory object. The attacker first flushes (or evicts if flush is not available) any cache lines that map to the shared memory object and allows the victim process to run. Afterwards the attacker measures the time it takes to run its own instance of the program so that he can tell what parts of the shared memory object where already loaded in the cache. This is a powerful attack because the attacker can learn exactly what data were loaded in the cache. \u2022 Flush + Flush [78] : This attack is the reverse version of the flush + reload attack. The attacker initially flushes the cache lines that map to the shared object (like before) and then he lets the victim program to run. In the next step, instead of running the program, he flushes the cache once again while measuring the flushing time. Depending on what cache lines were loaded during the victim execution the timing of the flushing operation will change and the attacker will be able to infer information about the victim process. The main benefit of this attack is that it is stealthier from the previous ones because it does not cause any cache misses during its execution something that many attack detection mechanisms seek to identify a cache-based attack.",
            "cite_spans": [
                {
                    "start": 15,
                    "end": 19,
                    "text": "[77]",
                    "ref_id": "BIBREF76"
                },
                {
                    "start": 500,
                    "end": 504,
                    "text": "[77]",
                    "ref_id": "BIBREF76"
                },
                {
                    "start": 1053,
                    "end": 1057,
                    "text": "[74]",
                    "ref_id": "BIBREF73"
                },
                {
                    "start": 1621,
                    "end": 1625,
                    "text": "[78]",
                    "ref_id": "BIBREF77"
                }
            ],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "Aside from the cache-based side-channel attacks we have seen this far, there is another major category of side-channel attacks named fault attacks. The target of these attacks is to induce faults during specific operations so that the process is manipulated in producing results that expose secret information. The main application of fault attacks can be found in differential fault analysis, which is a technique that specifically targets cryptographic algorithms, but it is also used in attacking programs in order to force them down specific control branches during their execution. Faults can be induced with techniques that utilize electromagnetic radiation [76] , operation voltage change [79] and operation frequency change [10] . This list is not complete, but its aim is to show the diversity of the possible attack paths and the difficulty of the defense against them.",
            "cite_spans": [
                {
                    "start": 664,
                    "end": 668,
                    "text": "[76]",
                    "ref_id": "BIBREF75"
                },
                {
                    "start": 696,
                    "end": 700,
                    "text": "[79]",
                    "ref_id": "BIBREF78"
                },
                {
                    "start": 732,
                    "end": 736,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "A recent popular fault attack is the rowhammer attack that targeted the RAM of the victim device [80] . The RAM is composed of capacitors that can store an electric charge, if a capacitor has a charge then it represents a logical one, if not it represents a zero, this way the RAM can store binary data. In recent RAM implementations (after DDR3) these capacitors have shrunken down so that more of them can be installed in the same die, something that has made each capacitor susceptible to interference from neighboring capacitor electromagnetic radiation. This is the attack model of rowhammer, capacitors neighboring to the victim RAM line that contains data to be faulted, are rapidly activated (recharged so that they do not lose their charge) so that the target row will be altered (faulted).",
            "cite_spans": [
                {
                    "start": 97,
                    "end": 101,
                    "text": "[80]",
                    "ref_id": "BIBREF79"
                }
            ],
            "ref_spans": [],
            "section": "Hardware Attacks"
        },
        {
            "text": "In this section, we elaborate on the discovered vulnerabilities and exploits. We will focus mainly on QSEE, since it the most widely deployed TEE implementation [81] and most vulnerabilities have been discovered for this platform. An exception is the analysis of a set of discovered attacks for the Kinibi TEE implementation (see Section 3.1.2) and attacks on the TrustedCore of Huawei (see Section 3.1.3). Moreover, the presented attacks are solely based on Cortex-A TrustZone, as Cortex-M is still in its early stages of growth and it is not widely deployed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Attacks on Current Implementations"
        },
        {
            "text": "We have developed a taxonomy that aims to provide a better understanding of the analyzed TrustZone attacks. The taxonomy firstly differentiates each attack based on three generic categories, software attacks, architectural attacks, and hardware attacks. Software attacks are focused on exploiting the software stack of the implementation, including the different operating systems and the applications that run on the system. The architectural attacks are based on the general architecture of the system that is comprised of both the design of the underlying hardware and the software that runs on the system. The main difference that architectural attacks have is that they exploit a fundamental design flaw of the system and not a specific bug found by accident. Finally, hardware attacks utilize any possible side channel as well as fault injection to transfer information from the trusted world to the normal world, these channels include execution times, cache timing attacks and power usage. For each one of the above three generic categories, the proposed taxonomy makes the following subcategorization (see Figure 5 ):",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1115,
                    "end": 1123,
                    "text": "Figure 5",
                    "ref_id": "FIGREF13"
                }
            ],
            "section": "Attacks on Current Implementations"
        },
        {
            "text": "(1) Software Attacks First, we describe a set of attacks that target the QSEE and come from the same re- First, we describe a set of attacks that target the QSEE and come from the same researcher [82] [83] [84] . The feasibility of these attacks has been demonstrated through the development of exploitation code. The first attack was published on [82] and is composed of three basic steps as shown in Figure 6 . In the first step, the attacker, with zero permissions, exploits a vulnerable implementation of the MediaServer Android application running in the normal world. As mentioned previously, MediaServer has the privilege of accessing the qseecom driver in order to communicate with the TEE and in turn with the WineDive trusted application. In the second step the attacker, through MediaServer, gains control of the Linux kernel by exploiting a vulnerability in the qseecom driver (which runs in the context of the normal world kernel). At this stage, he could perform direct SMC calls to the secure world through the privileged standpoint of the normal world kernel. Finally, in the third step, the attacker achieved arbitrary code execution in the context of a trusted application that he exploited by having direct access to it through SMC calls. While the first two steps and their vulnerabilities were not related to TEE (and hence we do not analyze them), the third step exploits a vulnerability in the QSEE. By disabling this operation, the attacker is able to exploit other SMC calls in order to create different kinds of primitives. In particular, after the invalidation of the control mechanisms, the attacker now is able to utilize SMC calls to upgrade the zero-write primitive to arbitrary write and read primitive. Now that the attacker has arbitrary write capabilities, the problem is to identify executable memory regions to write his own shellcode in. TrustZone kernel code pages are mapped as read-only, thus no modification is possible without first circumventing this protection. A specific register within the ARM MMU, the Domain Access Control Register (DACR) is responsible for the protection of TZ memory, by controlling which memory regions are accessible for reading and/or writing. By utilizing the aforementioned arbitrary write primitives, a modification to the value of the DACR is made (the entire DACR is set to 1, see Section 2.1) that enables read and write capabilities to all controlled memory regions effectively nullifying the mechanism. With this done, the attacker can now write on any memory region that is not protected with the XPU mechanism. To finally achieve execution, he wrote his shellcode in some identified \"code caves\" within the kernel which are executable allocated memory regions that are unused by the kernel and altering them will not affect it. ",
            "cite_spans": [
                {
                    "start": 196,
                    "end": 200,
                    "text": "[82]",
                    "ref_id": "BIBREF81"
                },
                {
                    "start": 201,
                    "end": 205,
                    "text": "[83]",
                    "ref_id": "BIBREF82"
                },
                {
                    "start": 206,
                    "end": 210,
                    "text": "[84]",
                    "ref_id": "BIBREF83"
                },
                {
                    "start": 348,
                    "end": 352,
                    "text": "[82]",
                    "ref_id": "BIBREF81"
                }
            ],
            "ref_spans": [
                {
                    "start": 402,
                    "end": 410,
                    "text": "Figure 6",
                    "ref_id": "FIGREF14"
                }
            ],
            "section": "Attacks on Current Implementations"
        },
        {
            "text": "The TEE can be directly accessed from kernel privileged applications through SMC system calls. This provides a significant attack vector since privilege escalation attacks are abundant allowing for potential exploitation of the trusted world.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 1:"
        },
        {
            "text": "More specifically, in the third step, first the attacker discovers that one of the several available SMC calls, does not perform memory checking allowing to write a zero DWORD in any specific memory address (zero write primitive). This vulnerability stemmed to the fact that the attacker was able to call a trusted application that uses a shared memory through an scm_call_atomic() function. More specifically, the trusted application expected to write the (zero DWORD) result of its operation to a specific memory location which is now controllable by the attacker as it is a parameter in the scm_call_atomic() function. This zero write primitive is used to disable the memory address checking mechanism that is used to validate each memory address that is passed to the secure world.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 1:"
        },
        {
            "text": "By disabling this operation, the attacker is able to exploit other SMC calls in order to create different kinds of primitives. In particular, after the invalidation of the control mechanisms, the attacker now is able to utilize SMC calls to upgrade the zero-write primitive to arbitrary write and read primitive. Now that the attacker has arbitrary write capabilities, the problem is to identify executable memory regions to write his own shellcode in. TrustZone kernel code pages are mapped as read-only, thus no modification is possible without first circumventing this protection. A specific register within the ARM MMU, the Domain Access Control Register (DACR) is responsible for the protection of TZ memory, by controlling which memory regions are accessible for reading and/or writing. By utilizing the aforementioned arbitrary write primitives, a modification to the value of the DACR is made (the entire DACR is set to 1, see Section 2.1) that enables read and write capabilities to all controlled memory regions effectively nullifying the mechanism. With this done, the attacker can now write on any memory region that is not protected with the XPU mechanism. To finally achieve execution, he wrote his shellcode in some identified \"code caves\" within the kernel which are executable allocated memory regions that are unused by the kernel and altering them will not affect it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 1:"
        },
        {
            "text": "The second published attack [71, 83] by the same researcher, provided an exploitation chain that could let the attacker reach TrustZone kernel privileges. The researcher followed a different path and chain of exploits than the previous attack, as he skipped the Linux kernel exploitation altogether and escalated his privileges in the TrustZone from user to kernel. In particular, the attack is composed of three stages, ranked by the level of privileges the attacker achieved (see Figure 7 . The first two stages are identical to the previous attack with the only difference being that instead of exploiting the user-space kernel through the MediaServer application, he directly used the qseecom driver since this application is privileged to access it (see Section 2.4). ",
            "cite_spans": [
                {
                    "start": 28,
                    "end": 32,
                    "text": "[71,",
                    "ref_id": "BIBREF69"
                },
                {
                    "start": 33,
                    "end": 36,
                    "text": "83]",
                    "ref_id": "BIBREF82"
                }
            ],
            "ref_spans": [
                {
                    "start": 482,
                    "end": 490,
                    "text": "Figure 7",
                    "ref_id": "FIGREF17"
                }
            ],
            "section": "TrustZone Kernel Exploitation"
        },
        {
            "text": "The TEE can be indirectly accessed through the privileged applic tions that can communicate with the TEE driver and in turn with the TEE itself. Thes applications must be bug-free and well protected.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "The MediaServer application can only communicate with the Widevine trusted ap plication which is responsible for DRM media playback. The exploitation of the Widevin trusted application was based on a memory copy buffer overflow in an unused functio named PRDiagVerifyProvisioning(). Due to the buffer overflow, an arbitrary write prim tive is achieved, which allows the execution of arbitrary code within the context of th ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "The TEE can be indirectly accessed through the privileged applications that can communicate with the TEE driver and in turn with the TEE itself. These applications must be bug-free and well protected.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "The MediaServer application can only communicate with the Widevine trusted application which is responsible for DRM media playback. The exploitation of the Widevine trusted application was based on a memory copy buffer overflow in an unused function named PRDiagVerifyProvisioning(). Due to the buffer overflow, an arbitrary write primitive is achieved, which allows the execution of arbitrary code within the context of the trusted application.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "Observation 3: The TEE does not implement classic security measures such as ASLR. This allows for common code execution and privilege escalation attacks that could have been avoided.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "Since the executable code segments of the trusted application are mounted as read only, the attacker had to resort to a ROP chain to run his code, something that turned out to be infeasible. To bypass this problem, he segmented the code execution in two parts, the normal world part, and the secure world part. Any piece of code logic that did not need QSEE privileges was emulated within the normal world, and only when the intended functionality needed to be run within the QSEE, then small ROP chains were invoked to execute these special cases, this is depicted in Figure 8 . The only functionalities that needed these elevated privileges were only two:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 569,
                    "end": 577,
                    "text": "Figure 8",
                    "ref_id": "FIGREF19"
                }
            ],
            "section": "Observation 2:"
        },
        {
            "text": "(1) Reading and writing memory (QSEE Memory Access) (2) Calling system calls exposed by the TrustZone kernel (QSEE System Call Invocation) Similar to the normal world applications, trusted applications running in secure world user-space can invoke system calls exposed by the TrustZone kernel, by issuing a specific instruction named SVC. In the normal world when a system call is performed the code execution is transferred to the Linux kernel. Similarly, when a trusted application performs a system call the execution flow is transferred from the user space trusted application to the TrustZone kernel to handle the SVC request. In particular, when an SVC instruction is called the TrustZone kernel uses the VBAR register to handle the SVC requests and find the address of the appropriate kernel exception vector. The system call handling in the TrustZone kernel accepts as input the arguments of the system call as it was issued by the user space trusted application running in QSEE. However, a critical observation here was that the TrustZone kernel does not perform any kind of checks on the validity of the provided input buffers, meaning that it accepts all provided arguments in system calls coming from legitimate trusted applications as valid, despite the fact that there exist some basic sanity checks of the input.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "With this in hand, the researcher identified an exploit that allowed him to force the kernel to use an attacker-made exception vector table (instead of the legitimate one) and thus the attacker was able to overwrite any exception address with a pointer to any other function (system call hijacking). The only objective remaining, is to find a writable and executable memory region to write the shellcode that the hijacked function pointer will point to. The trusted application code segments are perfect candidates, besides the fact that they are write protected by the DACR mechanism since it can conveniently be disabled with the system call bug from the Privilege Escalation to TrustZone attack described previously. With the DACR memory protection disabled, the researcher was able to write Practically, what the researcher did here, is that instead of creating large and possibly infeasible ROP gadgets, he divided his exploitation code into a simple execution segment which included common ARM opcodes and a QSEE segment which included opcodes that could only run within the QSEE environment. This way he only needed to write ROP gadget chains for the QSEE functionality of his exploit, the rest was run in the normal world where he could execute any command without resorting to ROP. At this stage, he was limited to code execution in QSEE user-space but had no TrustZone kernel privileges. The only attack surface to the kernel appeared to be through the system call functions exposed by the TrustZone kernel to the trusted applications. For this reason, in the third step the attacker exploits the WideVine Trusted application to pivot and exploit the TrustZone kernel.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "Similar to the normal world applications, trusted applications running in secure world user-space can invoke system calls exposed by the TrustZone kernel, by issuing a specific instruction named SVC. In the normal world when a system call is performed the code execution is transferred to the Linux kernel. Similarly, when a trusted application performs a system call the execution flow is transferred from the user space trusted application to the TrustZone kernel to handle the SVC request. In particular, when an SVC instruction is called the TrustZone kernel uses the VBAR register to handle the SVC requests and find the address of the appropriate kernel exception vector. The system call handling in the TrustZone kernel accepts as input the arguments of the system call as it was issued by the user space trusted application running in QSEE. However, a critical observation here was that the TrustZone kernel does not perform any kind of checks on the validity of the provided input buffers, meaning that it accepts all provided arguments in system calls coming from legitimate trusted applications as valid, despite the fact that there exist some basic sanity checks of the input.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "With this in hand, the researcher identified an exploit that allowed him to force the kernel to use an attacker-made exception vector table (instead of the legitimate one) and thus the attacker was able to overwrite any exception address with a pointer to any other function (system call hijacking). The only objective remaining, is to find a writable and executable memory region to write the shellcode that the hijacked function pointer will point to. The trusted application code segments are perfect candidates, besides the fact that they are write protected by the DACR mechanism since it can conveniently be disabled with the system call bug from the Privilege Escalation to TrustZone attack described previously. With the DACR memory protection disabled, the researcher was able to write any shellcode in any code segment of the trusted application and invoke it in the context of the TrustZone kernel by calling the modified system call handling function and thus achieving arbitrary code execution with secure world kernel privileges.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "Observation 4: The TEE kernel in many cases blindly trusts the trusted applications since they are considered to be untampered and secure. This could provide an attack vector if a trusted application is successfully exploited.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 2:"
        },
        {
            "text": "The final attack that was described by the same researcher [84] extends the previous ones and demonstrates the ultimate impact that an attack to the secure world can potentially have in an Android system. This attack is a chain of exploits utilizing the capabilities that were gained from the previous two attacks described in Sections 3.1.1 and 3.1.2. It allows the extraction of any TEE protected key, such as the Full Disk Encryption (FDE) key of Android, thus allowing the decryption of any device encrypted disk that contains a vulnerable version of the WideVine trusted application.",
            "cite_spans": [
                {
                    "start": 59,
                    "end": 63,
                    "text": "[84]",
                    "ref_id": "BIBREF83"
                }
            ],
            "ref_spans": [],
            "section": "Extraction of Master Keys"
        },
        {
            "text": "By reverse engineering the KeyMaster trusted application, the researcher discovered that the FDE key (i.e., a symmetric key used for disk encryption) is not protected by a hardware-bound key but instead from a key which is derived from a hardware-bound key and stored in the global buffer of the KeyMaster trusted application. This means, that it is protected from other trusted applications (trusted application isolation), but it is accessible from the TrustZone kernel. Based on this observation, the researcher was able to execute code inside TrustZone kernel (with the primitives established from the previous sections) that would extract the FDE key from the KeyMaster trusted application, breaking this way the security of the full disk encryption scheme in Android.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extraction of Master Keys"
        },
        {
            "text": "Observation 5: Even with the security guarantees of TrustZone, critical components such as the FDE key can be extracted if the kernel of the secure world is compromised.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extraction of Master Keys"
        },
        {
            "text": "The researcher has noted that this attack was possible because the encryption of the disk was not based on a hardware-bound key but on a software key. This, in combination with the already achieved TrustZone kernel exploit, enabled this attack which ultimately broke the FDE scheme of Android. A key remark that the researcher makes, is that the full disk encryption system of the android is only as strong as the security of the TrustZone kernel or the KeyMaster trusted application, as a problem with any of them will potentially leak the master key of the FDE. Finally, an overview of all the aforementioned attacks is depicted in Figure 9 . As it can be seen each attack is building upon the previous attacks in order to achieve higher privileges within QSEE.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 634,
                    "end": 642,
                    "text": "Figure 9",
                    "ref_id": "FIGREF21"
                }
            ],
            "section": "Extraction of Master Keys"
        },
        {
            "text": "with the already achieved TrustZone kernel exploit, enabled this attack which ultimate broke the FDE scheme of Android. A key remark that the researcher makes, is that the fu disk encryption system of the android is only as strong as the security of the TrustZon kernel or the KeyMaster trusted application, as a problem with any of them will pote tially leak the master key of the FDE. Finally, an overview of all the aforementioned a tacks is depicted in Figure 9 . As it can be seen each attack is building upon the previo attacks in order to achieve higher privileges within QSEE. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 457,
                    "end": 465,
                    "text": "Figure 9",
                    "ref_id": "FIGREF21"
                }
            ],
            "section": "Extraction of Master Keys"
        },
        {
            "text": "Until now we have seen a set of attacks on a TrustZone-based Qualcomm impleme tation of a TEE. A security researcher [11, 85, 86 ] discovered a set of major vulnerabiliti ",
            "cite_spans": [
                {
                    "start": 117,
                    "end": 121,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 122,
                    "end": 125,
                    "text": "85,",
                    "ref_id": "BIBREF84"
                },
                {
                    "start": 126,
                    "end": 128,
                    "text": "86",
                    "ref_id": "BIBREF85"
                }
            ],
            "ref_spans": [],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "Until now we have seen a set of attacks on a TrustZone-based Qualcomm implementation of a TEE. A security researcher [11, 85, 86 ] discovered a set of major vulnerabilities that affect another widely adopted TEE, the Kinibi TEE developed by Trustonic, which is also based on the TrustZone technology. Like the previous attacks, the problem is rooted in the code implementation of a trusted application, but it was made available to the attacker due to inadequate protection of the communication between the normal world and the trusted world. More specifically, Trustonic has implemented an overlay named TLC (trustlet connector) that acts as a gatekeeper to Kinibi. The TLC exposes an interface to the normal world userland, that in turn will expose an interface to the normal world to use via UNIX domain sockets (see Figure 10 ). These domain sockets make sanity checks on TEE requests, enforce access control through MAC/DACs schemes and are further protected through selinux with the only entities having access to them being some Samsung implemented proxy applications. The proxy application that the attacker targeted is called \"tlc_server\" and it handles the communication for five supported trusted applications.",
            "cite_spans": [
                {
                    "start": 117,
                    "end": 121,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 122,
                    "end": 125,
                    "text": "85,",
                    "ref_id": "BIBREF84"
                },
                {
                    "start": 126,
                    "end": 128,
                    "text": "86",
                    "ref_id": "BIBREF85"
                }
            ],
            "ref_spans": [
                {
                    "start": 820,
                    "end": 829,
                    "text": "Figure 10",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "(trustlet connector) that acts as a gatekeeper to Kinibi. The TLC exposes an interface to the normal world userland, that in turn will expose an interface to the normal world to use via UNIX domain sockets (see Figure 10 ). These domain sockets make sanity checks on TEE requests, enforce access control through MAC/DACs schemes and are further protected through selinux with the only entities having access to them being some Samsung implemented proxy applications. The proxy application that the attacker targeted is called \"tlc_server\" and it handles the communication for five supported trusted applications. First, the researcher identified an authentication bypass in the tlc_server binary by finding out that all commands exposed by this application implemented a way to verify the caller's permissions except for one command that did not include such a security mechanism (Vuln 0). This way any user-space application could use this handle to open a session to a trusted application and send arbitrary commands to it. Through this authentication bypass, the attacker gained access to the ESECOMM trusted application that implements a secure interface to an embedded secure element with the use of the \"SCP03 Global Platform Secure Channel Protocol\". The messages that are sent through this protocol are APDUs (application protocol data units) which are encoded in TLVs (typelength-value). There is a utility function in this trusted application that parses these TLVs that although makes some sanity checks on the TLVs themselves, it fails to check if the number of TLVs exceed the number of max TLVs that can be stored on each structure. By sending a number of TLVs that exceeded the capacity of the structure, the researcher was able to orchestrate an overflow attack (Vuln 1). Moreover, these structures are allocated on both the stack and the heap, providing a variety of available attack paths. Additionally, the TLV parser fails to properly bound check the reading from the input buffer that contains the TLVs (it checks if the offset is equal to the end of the buffer instead of if it is lower than it) and it can be trivially be bypassed to read beyond it (Vuln 2).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 211,
                    "end": 220,
                    "text": "Figure 10",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "Another stack buffer overflow is present within the ESECOMM trusted application in a function called \"parse_ca_cert()\". This function contains a textbook buffer overflow, as it fails to check the length of an input value from a TLV and it copies it to a 32-byte buffer. Although there is a restriction that TLVs should not exceed 0 \u00d7 400 bytes in size, it is not enough to mitigate this attack as the buffer is only 32 bytes in size (Vuln 3). There is a similar vulnerability in another function named \"parse_scp_param\" which is used to parse the secure channel parameters in order to establish a secure channel between Kinibi and the secure element. This function parses and copies several parameters for the Diffie-Hellman key exchange functionality. All of these parameters are sanity checked except for one parameter that is partially checked that allowed the attacker to establish another overflow attack (Vuln 4).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "In contrast with the previous attacks, the next attack requires that the user has root privileges in the normal world, but it provides by far the largest attack surface as it can be exploited from many places within the code. In order to exploit this bug, the attacker must First, the researcher identified an authentication bypass in the tlc_server binary by finding out that all commands exposed by this application implemented a way to verify the caller's permissions except for one command that did not include such a security mechanism (Vuln 0). This way any user-space application could use this handle to open a session to a trusted application and send arbitrary commands to it. Through this authentication bypass, the attacker gained access to the ESECOMM trusted application that implements a secure interface to an embedded secure element with the use of the \"SCP03 Global Platform Secure Channel Protocol\". The messages that are sent through this protocol are APDUs (application protocol data units) which are encoded in TLVs (type-length-value). There is a utility function in this trusted application that parses these TLVs that although makes some sanity checks on the TLVs themselves, it fails to check if the number of TLVs exceed the number of max TLVs that can be stored on each structure. By sending a number of TLVs that exceeded the capacity of the structure, the researcher was able to orchestrate an overflow attack (Vuln 1). Moreover, these structures are allocated on both the stack and the heap, providing a variety of available attack paths. Additionally, the TLV parser fails to properly bound check the reading from the input buffer that contains the TLVs (it checks if the offset is equal to the end of the buffer instead of if it is lower than it) and it can be trivially be bypassed to read beyond it (Vuln 2).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "Another stack buffer overflow is present within the ESECOMM trusted application in a function called \"parse_ca_cert()\". This function contains a textbook buffer overflow, as it fails to check the length of an input value from a TLV and it copies it to a 32-byte buffer. Although there is a restriction that TLVs should not exceed 0 \u00d7 400 bytes in size, it is not enough to mitigate this attack as the buffer is only 32 bytes in size (Vuln 3). There is a similar vulnerability in another function named \"parse_scp_param\" which is used to parse the secure channel parameters in order to establish a secure channel between Kinibi and the secure element. This function parses and copies several parameters for the Diffie-Hellman key exchange functionality. All of these parameters are sanity checked except for one parameter that is partially checked that allowed the attacker to establish another overflow attack (Vuln 4).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "In contrast with the previous attacks, the next attack requires that the user has root privileges in the normal world, but it provides by far the largest attack surface as it can be exploited from many places within the code. In order to exploit this bug, the attacker must bypass the tlc_server since it includes input sanitization that prevents this attack and should use the block device driver (/dev/mobicore) directly by exploiting one of the many applications that have access to it. The problematic behavior lies on the parameter that is used to specify the memory offsets of the request and response messages within a common buffer that the two worlds share (named TCI). This TCI buffer contains a field named \"envelope_len\" that defines the offset within the buffer that the response message should start. This field is set by the tlc_server or any other valid applications and it is inherently trusted by most trusted applications, if an attacker obtained root privileges, he could set this field to any value he wanted and thus force a trusted application to write or read on any given memory (Vuln 5).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "The researcher exploited this bug by setting arbitrary envelope_len values in order to specify the offset that he wants to write to, even if this offset is beyond the limits of this buffer. This way a semi-controlled (only the address offset is controlled, not the data to be written) write primitive to the secure world is found, that could be fully controlled if a trusted application that has user-controlled output is found amongst the trusted applications residing in the TEE.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "As it can be seen in Table 1 , the researcher managed to find six vulnerabilities in total that where all documented and submitted as SVEs. This number of vulnerabilities should be indicative of the attack paths that an adversary might be able to take when he targets a TEE. All these vulnerabilities where available due to software bugs that could have been avoided with proper coding techniques. Buffer Overflow of the \"envelop_len\" of the TCI shared buffer.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 21,
                    "end": 28,
                    "text": "Table 1",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Unbox Your Phone (Buffer Overflow and Overread-Based/Logic-Based)"
        },
        {
            "text": "Code bugs are abundant in applications. Special care must be taken when developing applications that belong either to the trusted or world or to the normal world.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 6:"
        },
        {
            "text": "Observation 7: Since code bugs cannot be completely avoided, critical applications must not contain a single point of failure. On each application layer there should be security and sanity checks that will cripple an attacker if he manages to bypass any previous layers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 6:"
        },
        {
            "text": "Software attacks are common against TEE implementations, for example, the attack documented in [87] (Logic-based) demonstrates how a failed memory validation leads to an arbitrary read and write exploit in the secure world. Similarly, in [13] (Logic-based) a flawed SMC memory checking mechanism allowed a kernel-privileged attacker to write controlled data to arbitrary secure world memory. On another occasion [88] (Buffer Overflow and Overread-based) an overflow attack allowed the researcher to achieve arbitrary code execution within the secure word. Besides software bugs, there are other attack vectors such as bad usage of cryptographic algorithms, in [89] (Bad Use of Crypto) the researcher discovered that the secure boot process used in a TEE protected device was only based on SHA256 to verify the integrity of the system which allowed him to modify and load any piece of software completely bypassing the secure boot.",
            "cite_spans": [
                {
                    "start": 95,
                    "end": 99,
                    "text": "[87]",
                    "ref_id": "BIBREF86"
                },
                {
                    "start": 238,
                    "end": 242,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 412,
                    "end": 416,
                    "text": "[88]",
                    "ref_id": "BIBREF87"
                },
                {
                    "start": 660,
                    "end": 664,
                    "text": "[89]",
                    "ref_id": "BIBREF88"
                }
            ],
            "ref_spans": [],
            "section": "Other Software Attacks"
        },
        {
            "text": "In [90] (Logic-based) another vulnerable SMC function exposed by QSEE was discovered. Because of a vulnerability in the handling of input of SMC calls again -in the specific case a signed comparison on unsigned user input bug -an attacker could write zeros (0) to a secure memory region of his choice, bypassing that way security mechanisms and finally gaining arbitrary read/write capabilities in the context of the TrustZone kernel. This vulnerability affected at current time all devices that used the Snapdragon 805 SoC and utilized QSEE for TEE. On another occasion, Di Shen [29] (Logic-based) published an attack affecting HiSilicon's TEE, another implementation less widespread than QSEE found in found in Huawei devices. The researcher discovered a vulnerability that allowed him to issue arbitrary SMC calls which led him to a secure world arbitrary write gadget. By subverting security protections that were in place he managed to achieve code execution in the context of the secure world. This attack enabled him to gather sensitive fingerprint data from the secure memory region.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 7,
                    "text": "[90]",
                    "ref_id": null
                },
                {
                    "start": 580,
                    "end": 584,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Other Software Attacks"
        },
        {
            "text": "On another occasion [91] (Buffer Overflow and Overread-based), the researcher managed to find serious security bugs within the ARM trusted firmware image installed in a commodity Android smartphone. This has allowed him to run code in ARM Exception Level 3 (supervisor) which has higher privileges than the TrustZone TEE. With this in hand he was able to completely bypass the face ID authentication mechanism that runs within the TEE by patching the binary of the trusted application so that it accepts any face as a valid authenticated user.",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 24,
                    "text": "[91]",
                    "ref_id": "BIBREF90"
                }
            ],
            "ref_spans": [],
            "section": "Other Software Attacks"
        },
        {
            "text": "In [92] (Buffer Overflow and Overread-based/Logic-based), several security flaws were identified in the Huawei TrustedCore which used easily bypassed white-box AES for the encryption of the trusted applications which allowed the researchers to decrypt them and reverse engineer them. Through further analysis, they discovered a design flaw in the KeyMaster trusted application that used a constant key to encrypt the master key and extract it. Finally, they discovered a buffer overflow in the KeyMaster trusted application, which allowed them to execute code within the context of the TEE kernel.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 7,
                    "text": "[92]",
                    "ref_id": "BIBREF91"
                }
            ],
            "ref_spans": [],
            "section": "Other Software Attacks"
        },
        {
            "text": "This class of vulnerabilities [14] arises due to a fundamental flaw in the design of the communication between the rich and the trusted operating system (OS). The impact of BOOMERANG is that an attacker can gain arbitrary read and write capabilities, on any memory location in the rich OS, by using the high privileged trusted OS as a proxy. With these gadgets available, the attacker can bypass the sand-boxed memory of the Android system and retrieve data from other applications, obtain root privileges, and potentially gain full control of the rich OS. The research has shown that this problem extends through hundreds of millions of devices that are currently on the market.",
            "cite_spans": [
                {
                    "start": 30,
                    "end": 34,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Boomerang Vulnerability (Unused Security Features)"
        },
        {
            "text": "The exploitation is possible due to the fact that the trusted OS can read and write any memory address of the rich OS, without taking into consideration its access rights properties due to its high privileges. In more detail, both operating systems have mechanisms in place to sanitize memory addresses and protect them from unauthorized access from within the OS, the rich OS protects its memory from normal world applications and the trusted OS from trusted (and normal) applications. The problem arises when the system performs cross OS memory access, the untrusted environment has no authorization to act upon trusted memory, as expected. The trusted environment, on the other hand, can access any memory address given to it and has no way of determining the security properties that exist in the normal OS or the provenance of this address. As a result, the trusted OS, since it does not check the privileges of the rich OS caller, will perform any action on any memory address blindly. The method used to avoid the security measures in place is implementation dependent, the researchers have successfully attacked a variety of device architectures that cover a large proportion of the available devices on the market.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boomerang Vulnerability (Unused Security Features)"
        },
        {
            "text": "The actual attack is performed from the non-secure world, where an application or user passes the malicious address as a variable to a secure world call. Due to the lack of message exchange standardization, not all addresses passed to the trusted application are monitored and as a result, not sanitized. This way an attacker can read or write on any memory inside the non-secure world and depending on the available trusted applications, he can create gadgets that will write specific data which can potentially lead to full exposure of the normal world. The attack, according to the paper, was successful against the QSEE trusted execution environment by using widely deployed trusted applications, such as the KeyMaster, WideVine, and PlayReady. When vendor-specific trusted applications are taken into consideration the attacker is provided with many more trusted applications to choose from. The researchers, using a Huawei device, have gained root access on the device by using arbitrary read and write functionality gained this way. Figure 11 explains the attack in a high level. The attacker wants to transfer the malicious pointer to the trusted application (C4). In order to do that, he populates a structure with the pointer without annotating it to avoid the sanitation process. The data is then passed to the underlying supervisor mode by using three possible routes: a TEE Daemon (C3) that runs on the background and also handles pointer sanitation, an API that can be used directly from within the application (C2) and the most implemented way that uses a library to provide the aforementioned API (C1). In the cases of C1 and C2, the pointer sanitation is done in the normal world kernel instead of the TEE daemon. The normal world kernel will now make an SMC call to change worlds and transfer the data structure to the secure monitor which in turn will pass them to the trusted world kernel. The data structure is now in the trusted kernel which will check if the pointers within the structure refer to memory inside the secure world. Since the malicious pointer's provenance is the non-secure world, it passes the test besides the fact that it can potentially point to normal-world kernel memory. Finally, the trusted kernel passes the structure to the trusted application which will act on the given non-secure world address without any further checks. It is obvious that by the time the attacker passes the normal world pointer sanitation, there are no other security checks in the way and since the secure world has absolute privileges on normal world memory, it can access and manipulate any given pointer. to implement a malware that can control the whole system and be unable to be detected in doing so. Furthermore, in [94] the researchers also investigated the possibility of concealing and checking the integrity of a hardware-assisted rootkit. Figure 11 . Boomerang attack architecture.",
            "cite_spans": [
                {
                    "start": 2745,
                    "end": 2749,
                    "text": "[94]",
                    "ref_id": "BIBREF93"
                }
            ],
            "ref_spans": [
                {
                    "start": 1040,
                    "end": 1049,
                    "text": "Figure 11",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2873,
                    "end": 2882,
                    "text": "Figure 11",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Boomerang Vulnerability (Unused Security Features)"
        },
        {
            "text": "This kind of attack was found to be effective against many ARM TrustZone-based TEEs that are widely deployed [95] . The root of the problematic behavior is in the trusted application verification by the secure world and on how the TEE checks for the version of the trusted application. This research has presented that an attacker could potentially load older versions of a trusted application to the system and execute them instead of the already installed ones. This way, a system is vulnerable to any past found and fixed problems that might have occurred since the attacker can just load the vulnerable trusted application and exploit it.",
            "cite_spans": [
                {
                    "start": 109,
                    "end": 113,
                    "text": "[95]",
                    "ref_id": "BIBREF94"
                }
            ],
            "ref_spans": [],
            "section": "Downgrade Attack (Unused Security Features)"
        },
        {
            "text": "When a vendor is aware of a flaw in one of his trusted applications, he can issue an update that will fix the problematic behavior. The new application is accepted into the system since it is signed with a private key and verified with a corresponding public key trusted by the TEE. The presumed behavior is that the system, after the update, will not accept an old version of the trusted application, contrary to that, the system will accept any version of the trusted application as legitimate and let it run, since it is also signed with a correct private key. It is noteworthy that most of the TEEs have mechanisms to version control their trusted applications (and thus fix this vulnerability), but according to a blog post by Gal Beniamini [9] all the trusted application binary images (45 different firmware images) that he analyzed had a version number of zero, even the updated ones. It is obvious that if the version number is not incremented, the TEE will accept any version ",
            "cite_spans": [
                {
                    "start": 746,
                    "end": 749,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Downgrade Attack (Unused Security Features)"
        },
        {
            "text": "The TEE can be utilized as a primitive for attacking the untrusted world due to its high privileges. Even without exploiting the secure world, it can be misguided into modifying memory zones in the normal world which otherwise would be inaccessible due to the high privileges of the TEE.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Observation 8:"
        },
        {
            "text": "The privileged standpoint of TrustZone TEEs has been identified from 2013, in [93] , where the researcher proposed a powerful rootkit installed in the secure word. The secure world has total access to all memory, allowing modification of the normal world kernel structures providing the basis for a rootkit that has access to every part of the system. Additionally, TrustZone is able to isolate its state and block access from the normal world to its own memory, effectively concealing the existence of the rootkit. Although the researcher does not present a specific implementation, he proposes the use of various techniques to cloak the visibility of the code running in the secure world and make its detection even harder. Essentially the secure world provides all the requirement for an attacker to implement a malware that can control the whole system and be unable to be detected in doing so. Furthermore, in [94] the researchers also investigated the possibility of concealing and checking the integrity of a hardware-assisted rootkit.",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 82,
                    "text": "[93]",
                    "ref_id": "BIBREF92"
                },
                {
                    "start": 915,
                    "end": 919,
                    "text": "[94]",
                    "ref_id": "BIBREF93"
                }
            ],
            "ref_spans": [],
            "section": "Observation 8:"
        },
        {
            "text": "This kind of attack was found to be effective against many ARM TrustZone-based TEEs that are widely deployed [95] . The root of the problematic behavior is in the trusted application verification by the secure world and on how the TEE checks for the version of the trusted application. This research has presented that an attacker could potentially load older versions of a trusted application to the system and execute them instead of the already installed ones. This way, a system is vulnerable to any past found and fixed problems that might have occurred since the attacker can just load the vulnerable trusted application and exploit it.",
            "cite_spans": [
                {
                    "start": 109,
                    "end": 113,
                    "text": "[95]",
                    "ref_id": "BIBREF94"
                }
            ],
            "ref_spans": [],
            "section": "Downgrade Attack (Unused Security Features)"
        },
        {
            "text": "When a vendor is aware of a flaw in one of his trusted applications, he can issue an update that will fix the problematic behavior. The new application is accepted into the system since it is signed with a private key and verified with a corresponding public key trusted by the TEE. The presumed behavior is that the system, after the update, will not accept an old version of the trusted application, contrary to that, the system will accept any version of the trusted application as legitimate and let it run, since it is also signed with a correct private key. It is noteworthy that most of the TEEs have mechanisms to version control their trusted applications (and thus fix this vulnerability), but according to a blog post by Gal Beniamini [9] all the trusted application binary images (45 different firmware images) that he analyzed had a version number of zero, even the updated ones. It is obvious that if the version number is not incremented, the TEE will accept any version of the trusted application believing it is in the same version.",
            "cite_spans": [
                {
                    "start": 746,
                    "end": 749,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Downgrade Attack (Unused Security Features)"
        },
        {
            "text": "With that in mind, it is obvious that an attacker that has access to older and vulnerable versions of trusted applications, in conjunction with the necessary root privileges (not always required), can overwrite the up to date and secure trusted applications and exploit flaws that existed before the fixes. With this attack available, it is mandatory that trusted application developers should employ the version control mechanisms that the TEE manufacturers provide.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Downgrade Attack (Unused Security Features)"
        },
        {
            "text": "Observation 9: Developers are not fully utilizing the security features of the TEE. Even if most TEE implementations provide version-based blocking for their trusted applications, it was found that the developers did not use this functionality. This has led to a major architectural vulnerability that allowed attackers to load old versions of trusted applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Downgrade Attack (Unused Security Features)"
        },
        {
            "text": "From 2000 until today companies have anticipated the need for more advanced FPGA functionality that could come from integrating SoCs in their model. A heterogeneous SoC is a system that combines a FPGA, a SoC and other intellectual properties (IP) and devices. Having the security of TrustZone in hand was very important for FPGAs since they are actively used to handle sensitive data in cloud infrastructures. For example, FPGA-based SoCs are used for secure data processing, to implement internet protocol security (IPSec), to secure communication in software radio systems, to secure cyber-physical infrastructures, industrial control systems and safety-critical systems [96] . The question raised by the paper [97] is whether the security provided by the TrustZone is propagated through the variety of IPs in the system and illustrated by a number of theoretical examples. The communication between the various devices and the IPs within the programmable logic partition of the FPGA is established through a programmable interconnect called Advanced eXtensible Interface (AXI) that multiplexes the communication between the IPs and the devices. The IPs are divided into secure and non-secure and depending on the access rights of the requestor, the AXI allows or prevents him from accessing the IP. All the attacks are based on the ability of the attacker to modify the design of the FPGA and the AXI, there are six attacks demonstrated:",
            "cite_spans": [
                {
                    "start": 674,
                    "end": 678,
                    "text": "[96]",
                    "ref_id": "BIBREF95"
                },
                {
                    "start": 714,
                    "end": 718,
                    "text": "[97]",
                    "ref_id": "BIBREF96"
                }
            ],
            "ref_spans": [],
            "section": "Vulnerabilities in a Heterogeneous SoC (TrustZone Implementation-Based)"
        },
        {
            "text": "The first attack changes the design in order to modify the security bits of the request and make the AXI think that the requestor is a secure application and as such has access to all IPs regardless of their security level.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "The second attack is a DoS attack that is the reverse of the previous attack, it sets the security bit of every request to non-secure so that any legal request from the secure side to a secure IP is denied from the AXI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Like the previous attack, the third attack forces to programmable logic (PL) part to always have a positive response to IP requests. Any non-secure request to a secure IP will have a false positive response when the process should have stopped with an error.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "In the fourth attack the PL is configured to return an error on every access, so that all the IPs connected to the specific AXI will be unusable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "The fifth attack is different from the previous, as it does not incorporate message manipulation. A FIFO buffer is injected inside the AXI interconnect within the PL and configured to spy on any transaction the AXI handles, especially secure transactions between secure components. \u2022",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "In the final attack, a malicious IP with a memory mapped master port is designed into the FPGA. With the master port, the IP will have direct access to secure memory with sensitive data. In order for the attack to work, the mapping of the master port should cover the memory containing the information to be extracted.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "In [96] , the researchers have extended the research around these attacks with a more detailed analysis of these security issues. Furthermore, they propose possible mitigations that could be applied across the system (SoC, FPGA and AXI) while they underlined the need for the integration of security in the FPGA design process.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 7,
                    "text": "[96]",
                    "ref_id": "BIBREF95"
                }
            ],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "On another occasion [98, 99] , the debugging feature of ARM named CoreSight was the enabler of a series of attack not only to the SoC in general but also in the TrustZone TEE installed in the system. More specifically, the researchers managed to extract fine grained information from the trusted world that allowed them to completely reverse the AES encryption process that was executed in the TEE. This way, the key of each AES round was discovered which ultimately exposed the core encryption key that was used in the process. Additionally, the researchers were also able to reconstruct images of the fingerprints stored in the TEE, exposing very sensitive and non-revocable authentication data.",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 24,
                    "text": "[98,",
                    "ref_id": "BIBREF97"
                },
                {
                    "start": 25,
                    "end": 28,
                    "text": "99]",
                    "ref_id": "BIBREF98"
                }
            ],
            "ref_spans": [],
            "section": "Other Architectural Attacks (TrustZone Implementation-Based)"
        },
        {
            "text": "Additionally, a fundamental of architectural attack [100] [101] [102] was made publicly available against the gaming console Nintendo Switch. The main issue of this vulnerability is a core architectural design that affected the deep sleep state of the console which failed to validate the saved state of TrustZone in the device memory. This way the attackers were able to change the saved state while also changing the MAC and the key used in the MAC process. As a result, the device would wake up with a changed but valid TrustZone state leading to a complete compromise of the trusted world.",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 57,
                    "text": "[100]",
                    "ref_id": "BIBREF99"
                },
                {
                    "start": 58,
                    "end": 63,
                    "text": "[101]",
                    "ref_id": "BIBREF100"
                },
                {
                    "start": 64,
                    "end": 69,
                    "text": "[102]",
                    "ref_id": "BIBREF101"
                }
            ],
            "ref_spans": [],
            "section": "Other Architectural Attacks (TrustZone Implementation-Based)"
        },
        {
            "text": "Side channel attacks [75] , are a family of attacks that gather leaked hardware information in order to gain sensitive data from a system. In essence, as their name indicates, they utilize a side channel to obtain information instead of the standard channel that might contain security roadblocks. When a process is running a cryptographic operation, an attacker can measure and accumulate information such as: cache access attempts, timing computations, power consumption, electromagnetic leakage and even the sound produced during a computation. It is through that hardware information that an attacker can gain sensitive data and expose cryptographic keys.",
            "cite_spans": [
                {
                    "start": 21,
                    "end": 25,
                    "text": "[75]",
                    "ref_id": "BIBREF74"
                }
            ],
            "ref_spans": [],
            "section": "Side Channel Attacks"
        },
        {
            "text": "The cache timing attack is a side channel attack and consists of two phases, the timing phase where the attacker sends plain text, known or unknown, to a cryptographic implementation and then measures the time it takes for each encryption. In the second phase, after enough plain texts have been encrypted, the attacker correlates the measurements and ends up with a much shorter key space that can be brute forced easily or even the key itself.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Side Channel Attacks"
        },
        {
            "text": "The attack is based on a core CPU architectural design, the use of the cache. More specifically, the CPU uses the cache to store data for quick access, if the data it needs are contained within the cache, then we have a cache hit, if not a cache miss. Depending on how many cache hits or misses happen during the execution of a sensitive operation, the total run time could be affected greatly. After enough samples are collected, an attacker can correlate the inputs with the time taken for each execution and deduce the key. This method is the simplest, there are more advanced methods like, evict + time and prime + probe, that actively manipulate the cache in order to produce data with more entropy that can provide results with a smaller data set.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Side Channel Attacks"
        },
        {
            "text": "There are many cases where these attacks were successful against Intel x86 CPUs but three cases [12, 73, 75] , have shown that ARM-based CPUs are affected just as much. Wei\u00df et al. [75] implemented an attack on a virtualized ARM system that contained two isolated worlds, although it was not a TEE, they have proven that cross-isolation attacks are possible. On the other hand, Lipp et al. [12] have successfully attacked consumer Android devices with advanced cache timing attacks and have shown that TrustZone technology does not protect the system from cache timing attacks. Finally, Zhang et al. [73] were also successful in applying their attack named \"TruSpy\" against a TrustZone implementation and have proven that it is possible for an attacker coming from the real world to steal secret information from the secure world isolation using a timing-based cache side-channel. We will analyze the core concepts of side channel attacks found in the literature.",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 100,
                    "text": "[12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 101,
                    "end": 104,
                    "text": "73,",
                    "ref_id": "BIBREF72"
                },
                {
                    "start": 105,
                    "end": 108,
                    "text": "75]",
                    "ref_id": "BIBREF74"
                },
                {
                    "start": 181,
                    "end": 185,
                    "text": "[75]",
                    "ref_id": "BIBREF74"
                },
                {
                    "start": 390,
                    "end": 394,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 600,
                    "end": 604,
                    "text": "[73]",
                    "ref_id": "BIBREF72"
                }
            ],
            "ref_spans": [],
            "section": "Side Channel Attacks"
        },
        {
            "text": "The attack presented by Weiss et al. [75] is the first indication that cache-based timing attacks could be utilized to break virtualization barriers. That is why the researchers have emulated a TEE by creating a virtualization environment where two worlds exist just like we have seen in the TEE so far. They have installed an AES based mutual authentication protocol that is resistant to replay attacks with all the encryption being done on the secure side. This authentication scheme is the target of the side channel attack that will ultimately reduce the key space so much that brute forcing the key will be trivial.",
            "cite_spans": [
                {
                    "start": 37,
                    "end": 41,
                    "text": "[75]",
                    "ref_id": "BIBREF74"
                }
            ],
            "ref_spans": [],
            "section": "Cache Timing Attack"
        },
        {
            "text": "The attack that the researchers have decided to implement is a basic timing attack as it is the most general possible attack that could be applied to almost all devices. They have separated the attack in two stages, the offline and the online phase. They first begin with the offline phase, where they proceed to collect timings of multiple encryptions using a known, all zero key. This phase will produce data that will later be correlated with the data collected from the online data set. In the next phase, the same procedure takes place but this time the key is unknown. After enough timing data is collected, the two compiled data sets are correlated with the final product being the possible values for each byte of the key. These values are generated based on a probability threshold, that is, if a byte of the key has a chance higher than the threshold to hold a specific value, then this value is added to the list of possible key values, if not then it is left outside of the list (see Figure 12) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 996,
                    "end": 1006,
                    "text": "Figure 12)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Cache Timing Attack"
        },
        {
            "text": "The attack was implemented on an ARM-based development board named Beagleboard with an L4 microkernel as a virtualization layer. The board has an ARM Cortex-A8 which has been used widely in smartphones when the research paper was being developed. The researchers have timed the execution time of each encryption precisely with the usage the ARM CCNT register, which holds the total clock cycles of the CPU since the last reset. With all these in hand, they applied the attack to several AES implementations with most of them being vulnerable to some degree. data collected from the online data set. In the next phase, the same procedure takes pla but this time the key is unknown. After enough timing data is collected, the two compil data sets are correlated with the final product being the possible values for each byte the key. These values are generated based on a probability threshold, that is, if a byte the key has a chance higher than the threshold to hold a specific value, then this value added to the list of possible key values, if not then it is left outside of the list (s Figure 12 ). The attack was implemented on an ARM-based development board named Beag board with an L4 microkernel as a virtualization layer. The board has an ARM Cortexwhich has been used widely in smartphones when the research paper was being dev oped. The researchers have timed the execution time of each encryption precisely with t usage the ARM CCNT register, which holds the total clock cycles of the CPU since the l reset. With all these in hand, they applied the attack to several AES implementations w most of them being vulnerable to some degree.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1089,
                    "end": 1098,
                    "text": "Figure 12",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Cache Timing Attack"
        },
        {
            "text": "The prime + count attack is quite different from the previous attacks, as it is not fine grained, but it promises reduced noise levels introduced by the TrustZone wo switching mechanism and pseudo-random cache replacement policies. The proof of co cept presented in the research [103] is a data exfiltration scenario and it is composed o sender that encodes a message and writes it accordingly to a shared cache and a receiv that primes the cache beforehand and reads the message that was written from the send The attack has two versions, the single-core, and the multi-core, with each of them bei applied to a different cache level. There is a L1 cache for each core of the CPU and it is n shared by other cores, while the L2 cache is much larger and it is shared amongst all co (see Figure 13 ). ",
            "cite_spans": [
                {
                    "start": 279,
                    "end": 284,
                    "text": "[103]",
                    "ref_id": "BIBREF102"
                }
            ],
            "ref_spans": [
                {
                    "start": 786,
                    "end": 795,
                    "text": "Figure 13",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Prime + Count"
        },
        {
            "text": "The prime + count attack is quite different from the previous attacks, as it is not as fine grained, but it promises reduced noise levels introduced by the TrustZone world switching mechanism and pseudo-random cache replacement policies. The proof of concept presented in the research [103] is a data exfiltration scenario and it is composed of a sender that encodes a message and writes it accordingly to a shared cache and a receiver that primes the cache beforehand and reads the message that was written from the sender. The attack has two versions, the single-core, and the multi-core, with each of them being applied to a different cache level. There is a L1 cache for each core of the CPU and it is not shared by other cores, while the L2 cache is much larger and it is shared amongst all cores (see Figure 13 ). We will first focus on the steps of the single-core scenario first. In the first step of the attack, the receiver primes the cache by invalidating all its entries and loading specific data to fill the entire L1 cache. After that, the control is given to the sender application in the trusted world where it encodes the message to be sent and proceeds to invalidate entries and write data to the L1 cache according to the encoded message. Then the normal world takes back the control and counts the number of the cache accesses that happened during the trusted world execution time and through that information it infers the message that the sender application sent. The multi-core attack is quite similar as the only difference is that the prime phase fills all the L1 and L2 caches while the sender writes its messages on the L2 cache. It is obvious that the second attack is much more difficult to apply, as the L2 cache is a global cache and as such it will introduce noise from parallel applications that execute in other cores.",
            "cite_spans": [
                {
                    "start": 285,
                    "end": 290,
                    "text": "[103]",
                    "ref_id": "BIBREF102"
                }
            ],
            "ref_spans": [
                {
                    "start": 807,
                    "end": 816,
                    "text": "Figure 13",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Prime + Count"
        },
        {
            "text": "The messages are encoded according to the number of cache accesses, for example if the sender wanted to send the number 20 it might have been agreed that 40 cache accesses should be made. To clear any noise on the channel, a method that the researchers named \"bucket\" was used that practically is a more flexible decoder. If the decoder received a number of cache accesses in the range of 40-50 then it would understand that the sender intended to make just 40 accesses and translate that to the number 20. We will first focus on the steps of the single-core scenario first. In the first step of the attack, the receiver primes the cache by invalidating all its entries and loading specific data to fill the entire L1 cache. After that, the control is given to the sender application in the trusted world where it encodes the message to be sent and proceeds to invalidate entries and write data to the L1 cache according to the encoded message. Then the normal world takes back the control and counts the number of the cache accesses that happened during the trusted world execution time and through that information it infers the message that the sender application sent. The multi-core attack is quite similar as the only difference is that the prime phase fills all the L1 and L2 caches while the sender writes its messages on the L2 cache. It is obvious that the second attack is much more difficult to apply, as the L2 cache is a global cache and as such it will introduce noise from parallel applications that execute in other cores.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prime + Count"
        },
        {
            "text": "The messages are encoded according to the number of cache accesses, for example if the sender wanted to send the number 20 it might have been agreed that 40 cache accesses should be made. To clear any noise on the channel, a method that the researchers named \"bucket\" was used that practically is a more flexible decoder. If the decoder received a number of cache accesses in the range of 40-50 then it would understand that the sender intended to make just 40 accesses and translate that to the number 20.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prime + Count"
        },
        {
            "text": "The prime + count attack cannot be used as an as is attack to spy on the TrustZone, as it is not able to access sensitive information and deduce the exact values that were written to the cache. This attack is basically a proof of concept that there could be a side channel established between the normal and the secure world just by encoding messages using the number of cache accesses as a primitive. According to the research paper, the bandwidth could be as high as 27 KB/s in the single-core scenario and 95 B/s in the cross-core scenario.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prime + Count"
        },
        {
            "text": "In this work [12] there is a demonstration of how side channel attacks could be implemented using only unprivileged applications. The researchers have presented effective ways to apply many cache-based attacks like Flush + Reload (which is used in a similar manner in [104] ), Flush + Flush and Evict + Reload on commodity ARM based Android devices. The main challenges that were tackled are the following:",
            "cite_spans": [
                {
                    "start": 13,
                    "end": 17,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 268,
                    "end": 273,
                    "text": "[104]",
                    "ref_id": "BIBREF103"
                }
            ],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "The fact that the last level caches (L2 for ARM) of ARM-based CPUs are not inclusive. That means that entries on lower levels of the cache are not guaranteed to also exist on the last level caches that is shared amongst all the cores of the CPU. This fact introduces a problem when cross-core attacks are to be made, as the last level shared cache is the only means the attacker has available to access and manipulate data from other cores of the CPU. The paper presents a novel way that exploits cache coherency protocols and transfers between L1 and L2 in order to \"patch\" the last level cache non inclusiveness problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "Furthermore, modern devices employ multiple CPUs on their design that do not share a common cache between them. However, the cache coherency protocols are used to fetch lines cache entries between different CPUs quicker than from the main memory. The researchers exploited this design to mount attacks that are effective even in cross-CPU environments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "Another problem was that most of the ARM CPUs do not support the flush command on which the Flush + Reload and Flush + Flush attacks are based on. The researchers have investigated over 4200 cache eviction strategies based on Rowhammer techniques in order to find the best alternative for the missing flush command.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "Additionally, ARM CPUs employ a pseudo-random cache replacement policy that makes predicting which cache line will be replaced difficult. This fact produces needless noise in the measurements of the cache during an attack. The researchers proposed a methodology that reduces the effects of erroneous prediction of replaced lines in the overall performance of the attacks they implemented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "Accurate timings of execution require access to functions that are only available to the kernel, since the attack model that the researchers chose does not include a rooted device, they had to find alternatives that provided timings that were capable to allow the attacks to happen. They proposed three different solutions: a performance monitoring system call which was available to the user-space, the POSIX function that returns the time and a dedicated function developed by the attacker. All of those methods where successful in identifying cache hits and misses and thus are viable for side channel attack implementations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "The presented attacks were made against three off the shelf devices with each one having different CPU ARM-based architectures. They first created a sender and receiver that utilized the attacks in order to pass messages and measure the throughput of their implementation in a data exfiltration scenario. Their attacks had a minimum transmission rate of 12.5 kbps and a maximum of 1140 kbps depending on the attack implementation and the underlying hardware. Furthermore, they implemented actual attacks to spy on other processes that use shared libraries of the system or android applications that run on the android runtime ART. They have also shown classic attacks on cryptographic primitives such as AES with a t-table implementation. Finally, they show that their attacks can also be applied over the boundaries of TrustZone although they implemented very simple proof of concept attacks against it. This shows once again that the TrustZone technology is susceptible to cache-based side channel attacks since the cache is shared amongst the secure and the normal world.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "Observation 10: The TrustZone TEE since it is implemented on top of the main CPU and it does not utilize separate hardware, shares the cache of the CPU with the normal world. This has created the possibility of side channel attacks which could produce devastating attack vectors such as private key leakage.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ARMageddon"
        },
        {
            "text": "The TruSpy attack [73, 105] was the first that provided an actual proof of concept for a cross world side channel attack. The researchers have presented two separate attacks that both achieved to break the word separation barrier with each attack having different privilege requirements in the normal world (i.e., kernel and user privileges). The kernel privileged attack is easy to implement since the attacker will have access to the virtual-tophysical mapping of the memory and highly accurate clock cycle timers that will enable him to prime and probe the cache with ease and deploy the attack. On the other hand, the user-space attack has no access to neither of the aforementioned functionalities, so the researchers have proposed and implemented two replacements that although not as accurate, can be used to carry out successful unprivileged attacks.",
            "cite_spans": [
                {
                    "start": 18,
                    "end": 22,
                    "text": "[73,",
                    "ref_id": "BIBREF72"
                },
                {
                    "start": 23,
                    "end": 27,
                    "text": "105]",
                    "ref_id": "BIBREF104"
                }
            ],
            "ref_spans": [],
            "section": "TruSpy"
        },
        {
            "text": "Both attacks are implemented as prime + probe cache attacks since it does not require memory sharing between the attacking and the victim process. This attack consists of five steps, first the attacker finds what memory addresses should be used for the priming of the cache by working out the mapping from the virtual address space to cache sets. In the second step the attacker fills the cache with its own memory so as to force any future cache access attempts from the victim process to fail. This step is the prime phase that will provide the attacker with a known state of the cache before he hands the execution to the victim process. Moving forward, the victim process from the trusted world takes over and changes the state of the cache during its execution which cannot be interrupted due to the fact that it resides in the trusted world. During the fourth step, the attacking process takes back control and measures the difference between the known cache state and the new cache state after the execution of the victim process. The attacker then stores the difference and proceeds to the second step again. The steps two to four are followed in a loop until enough data are recorded. In the last step the collected data are analyzed to recover any targeted secret information from the trusted world. The entire process is depicted in Figure 14 . back control and measures the difference between the known cache state and the new cache state after the execution of the victim process. The attacker then stores the difference and proceeds to the second step again. The steps two to four are followed in a loop until enough data are recorded. In the last step the collected data are analyzed to recover any targeted secret information from the trusted world. The entire process is depicted in Figure 14 . ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1344,
                    "end": 1353,
                    "text": "Figure 14",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1800,
                    "end": 1809,
                    "text": "Figure 14",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "TruSpy"
        },
        {
            "text": "The main problem with side channel attacks is their temporal and spatial resolution which are terms that define the granularity of the attack, that is, how detailed are the data extracted from the attack. These resolutions practically define the performance and the capability of an attack to extract the data required for the reconstruction of the targeted ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Other Side-Channel Attacks"
        },
        {
            "text": "The main problem with side channel attacks is their temporal and spatial resolution which are terms that define the granularity of the attack, that is, how detailed are the data extracted from the attack. These resolutions practically define the performance and the capability of an attack to extract the data required for the reconstruction of the targeted secret. Cachegrab [106] is a tool specifically developed for optimizing side-channel attacks against TEEs. This tool is designed to be analogous to an oscilloscope. It is capable of collecting trace data on multiple cache structures per execution, similar to the probes on an oscilloscope being connected to multiple contacts on a target board. With this tool, researchers from nccgroup (production company of Cachegrab) where able to recover 224 and 256-bit ECDSA keys from a Nexus 5X device. [107] In this attack they utilized not only the shared cache but also branch predictors to leak information about the nonce used in the ECDSA encryption procedure that where enough to completely recover the private key used.",
            "cite_spans": [
                {
                    "start": 376,
                    "end": 381,
                    "text": "[106]",
                    "ref_id": null
                },
                {
                    "start": 852,
                    "end": 857,
                    "text": "[107]",
                    "ref_id": "BIBREF106"
                }
            ],
            "ref_spans": [],
            "section": "Other Side-Channel Attacks"
        },
        {
            "text": "Additionally, in [107] the researchers attacked implementations of AES-256 and AES-256 GCM that were found within the TrustZone TEE of a Samsung Galaxy S6. The attack followed the prime + probe method and through the usage of GPU parallelization in the analysis phase, the keys were recovered in a matter of minutes. (8 min for AES-256 and 70 min for AES-256 GCM)",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 22,
                    "text": "[107]",
                    "ref_id": "BIBREF106"
                }
            ],
            "ref_spans": [],
            "section": "Other Side-Channel Attacks"
        },
        {
            "text": "In contrast with the previous side channel attacks that were based on the cache, the rowhammer attack exploits the physical design of the RAM. This attack [108] aims to induce errors to RAM entries within its capacitors by utilizing the fact that if many access and write attempts are made to neighboring RAM capacitors, then the contents of the target capacitor row can be altered. Like the name of the attack indicates, this attack cannot be applied on a per RAM capacitor level, but on a RAM row level with each row being composed of multiple capacitors. The attack is presented in Figure 15 , where each RAM module is composed of multiple RAM Banks with each one of them containing multiple rows of RAM cell capacitors. The attacking rows are activated (and thus discharged) very frequently in order for this attack to work, the discharging of the capacitors in the attacking rows may cause the capacitors of the victim row to also discharge faster than normal. This will ultimately lead to memory corruptions in the victim row within the RAM, something that can affect RAM rows that contain TrustZone data, even if they are protected by the NS bit mechanism. module is composed of multiple RAM Banks with each one of them containing multiple rows of RAM cell capacitors. The attacking rows are activated (and thus discharged) very frequently in order for this attack to work, the discharging of the capacitors in the attacking rows may cause the capacitors of the victim row to also discharge faster than normal. This will ultimately lead to memory corruptions in the victim row within the RAM, something that can affect RAM rows that contain TrustZone data, even if they are protected by the NS bit mechanism. The attacker had to find a way to pinpoint the exact rows that were next to the desired victim rows. He developed a program that accessed the RAM row by row and timed each access attempt. Depending on this time he could deduce and map the entire RAM in its banks and rows. The final step to overcome was to bypass the cache usage that would cripple his attack as it would reduce the number of RAM activations frequency. This was trivially bypassed by adding to his assumptions the ability to execute code in kernel privileges that would disable the cache usage.",
            "cite_spans": [
                {
                    "start": 155,
                    "end": 160,
                    "text": "[108]",
                    "ref_id": "BIBREF107"
                }
            ],
            "ref_spans": [
                {
                    "start": 585,
                    "end": 594,
                    "text": "Figure 15",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Fault Injection Attacks Rowhammer on TrustZone (Electromagnetic)"
        },
        {
            "text": "The attacker targeted the RSA CRT implementation, which is susceptible to the Bellcore attack, that existed in the TrustZone portion of the system. This attack is a differential fault analysis attack that requires only one faulty signature to be entirely broken in a CRT implementation, as long as no DFA countermeasures are in use. The attacker proceeded The attacker had to find a way to pinpoint the exact rows that were next to the desired victim rows. He developed a program that accessed the RAM row by row and timed each access attempt. Depending on this time he could deduce and map the entire RAM in its banks and rows. The final step to overcome was to bypass the cache usage that would cripple his attack as it would reduce the number of RAM activations frequency. This was trivially bypassed by adding to his assumptions the ability to execute code in kernel privileges that would disable the cache usage. The attacker targeted the RSA CRT implementation, which is susceptible to the Bellcore attack, that existed in the TrustZone portion of the system. This attack is a differential fault analysis attack that requires only one faulty signature to be entirely broken in a CRT implementation, as long as no DFA countermeasures are in use. The attacker proceeded to monitor the execution of the RSA CRT as it signed content and when the timing was right, he began the attack. To that end, he developed a kernel module to specify the attacking rows that he used in order to attack rows adjacent to the sensitive memory rows. After he successfully corrupted the signature, it was easy to proceed to the next steps of the Bellcore attack that ultimately fully exposed the private key of the RSA.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fault Injection Attacks Rowhammer on TrustZone (Electromagnetic)"
        },
        {
            "text": "CLKscrew [10] is a fault attack that is based on a modern device feature that allows software components to control CPU frequency and voltage for power management. By pushing the CPU to its operational limits, faults are induced in the computations of sensitive operations and through that, an attacker could obtain vital information for deducing sensitive data used in these operations. This attack can be done remotely, since it is software based and there is no need for physical access to the device. With a malicious kernel driver, a low privileged application can induce CLKscrew and extract cryptographic keys from inside the TrustZone TEE and can also manipulate the TrustZone trusted application validation into accepting self-signed code.",
            "cite_spans": [
                {
                    "start": 9,
                    "end": 13,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "CLKscrew (Voltage and Frequency)"
        },
        {
            "text": "In this particular demonstration, the Dynamic Voltage and Frequency Scaling (DVFS) power management system is used to manipulate both the operating voltages and frequencies of each thread of the CPU. With the use of the DVFS the CPU can be overclocked and simultaneously undervolted in order to pass the fault inducing borders of the CPU. The attack is possible due to the fact that there are no safeguards to protect the CPU from operating in faulty frequency-voltage combinations and that hardware regulators operate across the TEE separation, allowing the attack to take place even during the execution of the trusted world. With faulty behavior frequency-voltage combinations identified the attacker needs to be assured that the attack will not self-fault the malicious code or any other non-targeted code. For that a custom kernel driver is used in order to bind the victim thread to a specific core and all the other applications to the rest of the cores, removing thus the threat of collateral damage during the attack. The kernel driver also disables interrupts during the fault injection in order to avoid any context switch that could happen.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CLKscrew (Voltage and Frequency)"
        },
        {
            "text": "The attack preparation begins by clearing any cache residue since in the next steps there will be use of a cache-based profiling to identify when the victim execution begins (step 1). In the next step, the attacker profiles the execution of the victim thread to identify a consistent point of execution just before the target code to be faulted, this point is named \"Timing Anchor\" (steps 2, 3). In some attack scenarios the timing anchor is not accurate enough and there will be a need to better fine tune the exact attack timing; this is implemented by trapping the attacking thread in a no-op loop until a predefined amount of time has passed by which the attack will start (step 4). During the attack, the frequency of the victim core will be raised to a specific value for a specific amount of time and then restore it to normal operating conditions (steps 5, 6) as shown in in Figure 16 . a consistent point of execution just before the target code to be faulted, this point is named \"Timing Anchor\" (steps 2,3). In some attack scenarios the timing anchor is not accurate enough and there will be a need to better fine tune the exact attack timing; this is implemented by trapping the attacking thread in a no-op loop until a predefined amount of time has passed by which the attack will start (step 4). During the attack, the frequency of the victim core will be raised to a specific value for a specific amount of time and then restore it to normal operating conditions (steps 5,6) as shown in in Figure 16 . The attacker using this technique has managed to attack an AES implementation that he run in the trusted world. The application was a simple decryption tool that took as input encrypted messages and replied with the decrypted plain text given a stored secret key. By sending encrypted text to the application and inducing faults during specific rounds of the AES decryption phase he managed to infer the AES secret key by using a differential fault attack technique. The researchers have also been able to bypass the firmware verification mechanism of the device secure boot mechanism. This mechanism is an RSA based authentication that checked a signature on the hash of the firmware to be loaded with a hardware bound secret key stored in the trusted world. The researchers managed to fault the signature decryption process in order to force it to produce a hash that is equal to the hash of their own firmware so that the verification mechanism will accept this new firmware as a component signed by a trusted entity.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 883,
                    "end": 892,
                    "text": "Figure 16",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1505,
                    "end": 1514,
                    "text": "Figure 16",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "CLKscrew (Voltage and Frequency)"
        },
        {
            "text": "In a similar manner, VoltJockey [79] , in an effort to additionally cover the tracks of a DVFS based attack, generates faulty behavior by just manipulating the voltage of the processor. This provides an increased difficulty due to the enforced restrictions which will undoubtedly create fewer effective faults than CLKscrew, but the resulting attack will be stealthier since the defender will not be able to detect the abnormal behavior by monitoring the frequency of the CPU.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 36,
                    "text": "[79]",
                    "ref_id": "BIBREF78"
                }
            ],
            "ref_spans": [],
            "section": "CLKscrew (Voltage and Frequency)"
        },
        {
            "text": "Like the CLKscrew, BADFET [76] is a fault attack, that employs electromagnetic radiation to induce faults. Performing Electromagnetic Fault Injection (EMFI) attacks [109, 110] is considered more challenging nowadays, due to the increase in CPU speeds and decrease of the component size in modern systems. BADFET proposes a solution, by defining the second order EMFI attacks, that targets a new attack surface for the EMFI based attacks. Instead of targeting the processor during sensitive operations, a second order EMFI attack, can target any component that the processor utilizes during the target operation (the memory, the system bus, various controllers etc.). With this technique the The attacker using this technique has managed to attack an AES implementation that he run in the trusted world. The application was a simple decryption tool that took as input encrypted messages and replied with the decrypted plain text given a stored secret key. By sending encrypted text to the application and inducing faults during specific rounds of the AES decryption phase he managed to infer the AES secret key by using a differential fault attack technique. The researchers have also been able to bypass the firmware verification mechanism of the device secure boot mechanism. This mechanism is an RSA based authentication that checked a signature on the hash of the firmware to be loaded with a hardware bound secret key stored in the trusted world. The researchers managed to fault the signature decryption process in order to force it to produce a hash that is equal to the hash of their own firmware so that the verification mechanism will accept this new firmware as a component signed by a trusted entity.",
            "cite_spans": [
                {
                    "start": 26,
                    "end": 30,
                    "text": "[76]",
                    "ref_id": "BIBREF75"
                },
                {
                    "start": 165,
                    "end": 170,
                    "text": "[109,",
                    "ref_id": "BIBREF108"
                },
                {
                    "start": 171,
                    "end": 175,
                    "text": "110]",
                    "ref_id": "BIBREF109"
                }
            ],
            "ref_spans": [],
            "section": "BADFET (Electromagnetic)"
        },
        {
            "text": "In a similar manner, VoltJockey [79] , in an effort to additionally cover the tracks of a DVFS based attack, generates faulty behavior by just manipulating the voltage of the processor. This provides an increased difficulty due to the enforced restrictions which will undoubtedly create fewer effective faults than CLKscrew, but the resulting attack will be stealthier since the defender will not be able to detect the abnormal behavior by monitoring the frequency of the CPU.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 36,
                    "text": "[79]",
                    "ref_id": "BIBREF78"
                }
            ],
            "ref_spans": [],
            "section": "BADFET (Electromagnetic)"
        },
        {
            "text": "Like the CLKscrew, BADFET [76] is a fault attack, that employs electromagnetic radiation to induce faults. Performing Electromagnetic Fault Injection (EMFI) attacks [109, 110] is considered more challenging nowadays, due to the increase in CPU speeds and decrease of the component size in modern systems. BADFET proposes a solution, by defining the second order EMFI attacks, that targets a new attack surface for the EMFI based attacks. Instead of targeting the processor during sensitive operations, a second order EMFI attack, can target any component that the processor utilizes during the target operation (the memory, the system bus, various controllers etc.). With this technique the spatial and temporal resolution requirements are effectively reduced since the targeted components are less dense and they store exploitable information for more time.",
            "cite_spans": [
                {
                    "start": 26,
                    "end": 30,
                    "text": "[76]",
                    "ref_id": "BIBREF75"
                },
                {
                    "start": 165,
                    "end": 170,
                    "text": "[109,",
                    "ref_id": "BIBREF108"
                },
                {
                    "start": 171,
                    "end": 175,
                    "text": "110]",
                    "ref_id": "BIBREF109"
                }
            ],
            "ref_spans": [],
            "section": "BADFET (Electromagnetic)"
        },
        {
            "text": "The attack described in the paper, consists of two phases, in the first stage the BADFET platform is used to apply electromagnetic radiation on the RAM of the system (Cisco 8861 VoIP phone) during the boot in a specific time. A microcontroller is used to fine-tune the timing and the position of the emitter to increase the effectiveness of the attack. The faults induced in the memory, triggers a condition that exposes the debug CLI of the uBoot to the attackers. In the second stage, with the CLI available, a buffer overflow based trusted world vulnerability is found that allowed the researchers to attain read, write and execution capabilities in the secure world. Finally, the researchers have obtained a new CLI that run entirely in the secure world. This vulnerability exists due to the lack of user input validation in the TEE and the exposure of a function that can trigger a world change in the uBoot CLI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "BADFET (Electromagnetic)"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "The most common primitives achieved in the documented attacks are the read primitive (21 achieved-3 possible), the write primitive (14 achieved-2 possible) and the information extraction primitive (12 achieved-6 possible). This is an expected outcome given the fact that reading and writing to memory is one of the most common initial pivots for attacks and a relatively easier to achieve primitive; as for information extraction it is a logic next step from the read primitive with side channel and fault injection attacks being the most common attacks that achieved this primitive. The least achieved primitives are the execute primitive (8 achieved-5 possible) and kernel execute primitive (7 achieved-4 possible). Table 2 . A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. ( Not achieved GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 718,
                    "end": 725,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "Method mation was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Attack"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. specify the GlobalPlatrform protection profile objectives violated by each attack. achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. ously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. ously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. ously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. [95] Failed Usage of Version Control of TAs to the attackers. In the second stage, with the CLI available, a buffer overflow based trusted world vulnerability is found that allowed the researchers to attain read, write and execution capabilities in the secure world. Finally, the researchers have obtained a new CLI that run entirely in the secure world. This vulnerability exists due to the lack of user input validation in the TEE and the exposure of a function that can trigger a world change in the uBoot CLI.",
            "cite_spans": [
                {
                    "start": 5046,
                    "end": 5050,
                    "text": "[95]",
                    "ref_id": "BIBREF94"
                }
            ],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. to the attackers. In the second stage, with the CLI available, a buffer overflow based trusted world vulnerability is found that allowed the researchers to attain read, write and execution capabilities in the secure world. Finally, the researchers have obtained a new CLI that run entirely in the secure world. This vulnerability exists due to the lack of user input validation in the TEE and the exposure of a function that can trigger a world change in the uBoot CLI.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. to the attackers. In the second stage, with the CLI available, a buffer overflow based trusted world vulnerability is found that allowed the researchers to attain read, write and execution capabilities in the secure world. Finally, the researchers have obtained a new CLI that run entirely in the secure world. This vulnerability exists due to the lack of user input validation in the TEE and the exposure of a function that can trigger a world change in the uBoot CLI.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. to the attackers. In the second stage, with the CLI available, a buffer overflow based trusted world vulnerability is found that allowed the researchers to attain read, write and execution capabilities in the secure world. Finally, the researchers have obtained a new CLI that run entirely in the secure world. This vulnerability exists due to the lack of user input validation in the TEE and the exposure of a function that can trigger a world change in the uBoot CLI.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. to the attackers. In the second stage, with the CLI available, a buffer overflow based trusted world vulnerability is found that allowed the researchers to attain read, write and execution capabilities in the secure world. Finally, the researchers have obtained a new CLI that run entirely in the secure world. This vulnerability exists due to the lack of user input validation in the TEE and the exposure of a function that can trigger a world change in the uBoot CLI.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "Based on the presentation of each attack we created a comparative table that aims at creating a synoptic view of each attack and what were the consequences with regards to the GlobalPlatform's Protection Profile objectives (as analyzed in Section 2.2). More specifically, in the first column of Table 2 there is the name of each attack presented previously. In the next five columns we defined basic primitives that the attacker achieved; namely: (i) read for when trusted world memory reading was achieved, (ii) write for when trusted world memory write was achieved, (iii) execute for when execution in the context of a trusted application was achieved, (iv) kernel execute for when execution in the context of the trusted world kernel and (v) information extraction for when actual sensitive information was pulled from the trusted world. Depending on whether each primitive was achieved in each attack we use a black-filled circle to indicate that the primitive was achieved, a half-filled circle to indicate that the primitive can be trivially achieved but was not formally documented on the report and a white circle to show that the primitive was not achieved and to the best of our knowledge is hard to attain. In the final column, we specify the GlobalPlatrform protection profile objectives violated by each attack. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 295,
                    "end": 302,
                    "text": "Table 2",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Attacks Overview and Comparison"
        },
        {
            "text": "A TrustZone TEE is a high-value target. It has a privileged standing point in the context of access, due to its position in the architecture. It can conceal its state and data from other non-privileged modes of the platform -normal world-and also hosts a number of important services, whose security modification or compromise would be considered crucial from an attacker's perspective. For the above reasons, a TrustZone TEE makes for a high-value target for someone with the required knowledge to exploit the weaknesses that exist in current implementations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discussion and Observations"
        },
        {
            "text": "Generally, an attacker with the ability to execute code in the context of the secure world can fully compromise the system in various ways depending on the privileges he has, while also have access to secrets stored within the secure world. As a normal trusted application, he can access any resource that the trusted application might have access to:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discussion and Observations"
        },
        {
            "text": "\u2022 By using the secure world's ability to map and write to all physical memory belonging to the normal world, an attacker can modify the kernel of the normal OS, thus infecting it even if no vulnerability is present in the normal world kernel.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discussion and Observations"
        },
        {
            "text": "As the attacker has trusted application privileges, it can uncover any private data that it may hold in its memory. Things like loaded keys, fingerprint data and other sensitive information could be extracted, depending on which application is compromised.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Furthermore, an attacker that has kernel rights within TrustZone can manipulate resources from other trusted applications as well as the integrity of the kernel and other security parameters of the trusted world:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "\u2022 Being able to access the secure file system available only to Secure World (SFS), he can extract cryptographic keys and other important data like fingerprints that the normal world is not privileged to access.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "The attacker's ability to modify secure world memory gives him also the ability to compromise the integrity of every Trusted application. \u2022 Lastly, the potential to modify qFuses, the one-time-programmable (OTP) elements that are used to enable and disable security and debug features is provided, thus bypassing the secure boot sequence, or enabling other capabilities that the vendor has chosen to disable on the platform.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Overall, the attack paths that an attacker could follow are depicted in Figure 17 . Every attack scenario begins from the normal world (1) which usually requires that the attacker has kernel privileges in the OS. From there, the next step is either the SMC communication channel (2) (3) (4) or the shared architectural components of the system (5) (6) (7) (8) . In the first case, the attacker takes advantage of the escalated privileges and issues direct SMC calls that allow him to probe the various trusted applications or the trusted OS directly so as to discover any software exploitable bugs within the trusted code base. On the other case, the shared CPU cache (5) or the shared RAM memory (6) or the shared CPU voltage and frequency settings (7) are used to induce faults in secure TEE operations and to ultimately expose information from the secure world through side channel analysis (8) . high-value target for someone with the required knowledge to exploit the weaknesses that exist in current implementations. Generally, an attacker with the ability to execute code in the context of the secure world can fully compromise the system in various ways depending on the privileges he has, while also have access to secrets stored within the secure world. As a normal trusted application, he can access any resource that the trusted application might have access to:",
            "cite_spans": [
                {
                    "start": 279,
                    "end": 282,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 283,
                    "end": 286,
                    "text": "(3)",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 287,
                    "end": 290,
                    "text": "(4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 344,
                    "end": 347,
                    "text": "(5)",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 348,
                    "end": 351,
                    "text": "(6)",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 352,
                    "end": 355,
                    "text": "(7)",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 356,
                    "end": 359,
                    "text": "(8)",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 697,
                    "end": 700,
                    "text": "(6)",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 894,
                    "end": 897,
                    "text": "(8)",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [
                {
                    "start": 72,
                    "end": 81,
                    "text": "Figure 17",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "\u2022"
        },
        {
            "text": "\u2022 By using the secure world's ability to map and write to all physical memory belonging to the normal world, an attacker can modify the kernel of the normal OS, thus infecting it even if no vulnerability is present in the normal world kernel.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "As the attacker has trusted application privileges, it can uncover any private data that it may hold in its memory. Things like loaded keys, fingerprint data and other sensitive information could be extracted, depending on which application is compromised.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Furthermore, an attacker that has kernel rights within TrustZone can manipulate resources from other trusted applications as well as the integrity of the kernel and other security parameters of the trusted world:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "\u2022",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Being able to access the secure file system available only to Secure World (SFS), he can extract cryptographic keys and other important data like fingerprints that the normal world is not privileged to access.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "The attacker's ability to modify secure world memory gives him also the ability to compromise the integrity of every Trusted application.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Lastly, the potential to modify qFuses, the one-time-programmable (OTP) elements that are used to enable and disable security and debug features is provided, thus bypassing the secure boot sequence, or enabling other capabilities that the vendor has chosen to disable on the platform.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Overall, the attack paths that an attacker could follow are depicted in Figure 17 . Every attack scenario begins from the normal world (1) which usually requires that the attacker has kernel privileges in the OS. From there, the next step is either the SMC communication channel (2) (3) (4) or the shared architectural components of the system (5) (6) (7) (8) . In the first case, the attacker takes advantage of the escalated privileges and issues direct SMC calls that allow him to probe the various trusted applications or the trusted OS directly so as to discover any software exploitable bugs within the trusted code base. On the other case, the shared CPU cache (5) or the shared RAM memory (6) or the shared CPU voltage and frequency settings (7) are used to induce faults in secure TEE operations and to ultimately expose information from the secure world through side channel analysis (8) . ",
            "cite_spans": [
                {
                    "start": 279,
                    "end": 282,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 283,
                    "end": 286,
                    "text": "(3)",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 287,
                    "end": 290,
                    "text": "(4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 344,
                    "end": 347,
                    "text": "(5)",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 348,
                    "end": 351,
                    "text": "(6)",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 352,
                    "end": 355,
                    "text": "(7)",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 356,
                    "end": 359,
                    "text": "(8)",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 697,
                    "end": 700,
                    "text": "(6)",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 894,
                    "end": 897,
                    "text": "(8)",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [
                {
                    "start": 72,
                    "end": 81,
                    "text": "Figure 17",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "\u2022"
        },
        {
            "text": "Most of the attacks against the TEE have a basic starting point in common; the communication system between the two worlds. This system provides the largest attack surface since the secure monitor calls (SMCs) provide a way for the user to pass potentially malicious input to the TEE. Since there is no default message authentication mechanism in TrustZone, an attacker with kernel privileges, can issue any custom SMC and perform fuzzing and man in the middle attacks in order to discover flaws in the trusted world and exploit them.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "The communication starts from the normal world application that places arguments in a shared memory or some specific registers and calls the TEE kernel driver to initialize a world change. Then, the normal world kernel sends the required SMC which will make the secure monitor give control to the TEE. In a normal case, the SMC is issued by a kernel driver that will also authenticate the calling application, although if an attacker gains kernel privileges he can issue his own SMCs utterly bypassing this authentication. After that, the TEE processes the arguments provided and calls the trusted application to perform the actions specified. Since the input is controlled by the attacker it can contain crafted arguments that will be passed to the TEE, which has very limited mechanisms to verify the validity of the message (at least in current implementations) aside from sanity checks that many times fail to catch some malicious inputs. The TEE has no other option than to act blindly, using the information provided in the message. Some might argue that there is a way to verify the calling application by using the universally unique identifier (UUID), but the UUID is part of the SMC, and as such, it can be replicated and consequently be nullified as a security measure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "Another crucial aspect that arises from the above cases is that when an OEM/platform designer extends a TEE with more services, the implementation of input validation mechanisms on these added SMC calls are not always coherent and of the same quality as that of the initial mechanisms designed by the TEE vendor [83] . From the above-published research, we can see that the OEM/platform vendor can either copy the TEE designer model of input sanitization or design their own validation checks on the implemented function calls of the added Trusted applications. This second option has the drawback that the chosen mechanisms may not address all scenarios of bad input, because of the non-expertise of the developer in security design, expanding probabilistically an attacker's ability to execute arbitrary code in the context of the TEE, as can be seen from the presented attacks.",
            "cite_spans": [
                {
                    "start": 312,
                    "end": 316,
                    "text": "[83]",
                    "ref_id": "BIBREF82"
                }
            ],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "Another issue that arises from the fact that manufacturers extend the secure world with new functionality is the dramatic increase in trusted code base. With the ever-increasing need for secure applications, it is hard to strike a good balance between what part of an application is implemented in the normal world and what in the secure world. This has led to an expansion of the secure world since developers choose to implement more parts of the application in the secure world, a fact that exposes it to greater danger since the newly introduced code might contain new and unforeseen vulnerabilities which could be exploited through the SMC mechanism.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "This problem has been identified in [111] where the researchers have identified the lack of a protection mechanism of the TrustZone communication system which could lead to man-in-the middle, fuzzing and denial of service attacks. They proposed a scheme which aims to alleviate this issue by restricting TrustZone access through access control lists and by encrypting and authenticating the communication with session keys.",
            "cite_spans": [
                {
                    "start": 36,
                    "end": 41,
                    "text": "[111]",
                    "ref_id": "BIBREF110"
                }
            ],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "Concluding, a basic design flaw of the trusted execution environment is its communication system, although there can be some security measures within the normal world, an attacker with root privileges can easily bypass them. There are some attacks that do not employ this communication channel, such as the aforementioned side channel and fault attacks, but the most widely documented method of attacking the TEE is through this communication channel using malicious crafted SMCs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "Finally, it should be considered that SMC calls are not the only mechanism with the ability to switch world context, thus not the only probable way of exploitation. Interrupt handling and bus signals from the corresponding controllers, shared memory interfaces found on some designs and data parsing of intentionally corrupt disk content from eMMC blocks are other possible avenues of exploitation, although no research has been published indicating vulnerabilities through the above mechanisms yet.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SMC Exploitation"
        },
        {
            "text": "Something to consider also is the impact and importance of GlobalPlatform's standardization that most of the current implementations of TEEs are compliant with. According to the official definition from GlobalPlatform: \"The TEE is an execution environment that runs alongside but isolated from the device main operating system. It protects its assets against general software attacks. It can be implemented using multiple technologies, and its level of security varies accordingly.\" [26] Comparing the official definition with the current situation we can deduce that problems in one of the crucial requirements exist. The ability of TEEs to withstand attacks from exposing an interface to the normal OS, which can be considered the most standard/general and the most exposed interface, is defective. Furthermore, most TEE implementations lack basic internal security mechanisms such as ASLRs and stack cookies [1, 29] .",
            "cite_spans": [
                {
                    "start": 483,
                    "end": 487,
                    "text": "[26]",
                    "ref_id": null
                },
                {
                    "start": 911,
                    "end": 914,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 915,
                    "end": 918,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Protection Mechanisms of Trusted OS"
        },
        {
            "text": "Modern rich OS include a set of security mechanisms that increases the difficulty of exploiting a software vulnerability. Furthermore, due to the closed nature of TEE OS, there is no public information regarding the support of security mechanisms. A recent article in [9] discovered that the two major TEE implementations (Qualcomm and Kinibi) have a limited number of security features implemented. In particular, Kinibi offers no form of ASLR and all trusted applications are loaded into a fixed address with Qualcomm TEEs offering only a weak ASLR implementation. That is, the amount of entropy offered by QSEE's ASLR implementation is limited by the size of the contiguous range of memory where trusted applications are loaded. According to [9] , the ASLR enabled by QSEE is limited approximately to 9 bits, which means that with 355 guesses, an attacker would have a 50% chance of correctly guessing the base address of a trusted application image. Another security mechanism called stack cookie, which prevents stack overflows has been implemented in QSEE but not in Trustonic's implementation. Finally, both QSEE and Trustonic do no support guard pages (i.e., a security mechanism to separate various memory segments and block overflows from one segment reaching to another segment).",
            "cite_spans": [
                {
                    "start": 268,
                    "end": 271,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 745,
                    "end": 748,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Protection Mechanisms of Trusted OS"
        },
        {
            "text": "A deduction from the above presented cases is that-at least on specific implementations as QSEE-the security boundary between Trusted applications and the TrustZone kernel is weak [83] . When the attacker has managed to break through to the secure world and has taken command of a Trusted application, the intermediate communication mechanism between the Trusted applications and the TrustZone kernel is designed such a way that no input validation takes place, thus allowing the attacker to compromise the kernel and other Trusted applications with ease.",
            "cite_spans": [
                {
                    "start": 180,
                    "end": 184,
                    "text": "[83]",
                    "ref_id": "BIBREF82"
                }
            ],
            "ref_spans": [],
            "section": "Protection Mechanisms of Trusted OS"
        },
        {
            "text": "When this weak security implementation is combined with the increasing number of trusted applications, it is apparent that the security of each one of these applications is compromised in an exploitation incident. This way, a need for a more effective solution arises in order to maintain the security of each trusted application. In [91, 112] , the researchers have identified this issue and they proposed a TEE virtualization (TEEv) architecture that supports multiple isolated and restricted TEE instances running under the same CPU with a minimal hypervisor. TEEv allows different TEE implementations to run in isolation on the same smartphone and to host their own set of trusted applications. Coincidentally, a compromised TEE in this architecture cannot affect its peers or the normal world. There are many similar virtualization research solutions such as [113] , PrOS [114] , TrustICE [115] , vTZ [116] and Sacntuary [117] .",
            "cite_spans": [
                {
                    "start": 334,
                    "end": 338,
                    "text": "[91,",
                    "ref_id": "BIBREF90"
                },
                {
                    "start": 339,
                    "end": 343,
                    "text": "112]",
                    "ref_id": "BIBREF111"
                },
                {
                    "start": 864,
                    "end": 869,
                    "text": "[113]",
                    "ref_id": "BIBREF112"
                },
                {
                    "start": 877,
                    "end": 882,
                    "text": "[114]",
                    "ref_id": "BIBREF113"
                },
                {
                    "start": 894,
                    "end": 899,
                    "text": "[115]",
                    "ref_id": "BIBREF114"
                },
                {
                    "start": 906,
                    "end": 911,
                    "text": "[116]",
                    "ref_id": "BIBREF115"
                },
                {
                    "start": 926,
                    "end": 931,
                    "text": "[117]",
                    "ref_id": "BIBREF116"
                }
            ],
            "ref_spans": [],
            "section": "Protection Mechanisms of Trusted OS"
        },
        {
            "text": "A crucial design flaw of all TEEs is the sharing of resources. TEEs were designed to provide an ad hoc security mechanism that required very little hardware adjustments to work without the need of extra hardware to be installed on the device. That is the reason why the CPU cores, the CPU caches, the storage, and the RAM of the device are all resources that are shared between the secure and the non-secure worlds. There are strong security mechanisms that protect the resources of each world such as the NS bit that taints each message and memory entry as secure or non-secure. With the support of mechanisms that enforce the NS bit policy, unauthorized entities cannot access sensitive resources, but although this architecture might seem sound, it does not account for side channel attacks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Shared Resources"
        },
        {
            "text": "As we have seen, the fact that these resources are shared between the two worlds has led to serious side channel vulnerabilities. These attacks range from basic sender and receiver side channels that can be used to secretly transfer data from one world to another, all the way to spying attacks that can steal sensitive data from trusted applications during their execution. That is why manufacturers should either reserve dedicated hardware for the TEE, something that will increase the production costs, or implement mechanisms that scramble the data that the side channel attacks collect [118, 119] , rendering them unusable. The latter method is the least expensive, but it includes the risk that it might not catch all attack cases, in contrast, the first method is expensive (due to the need for extra hardware) but it provides assurances that the data are safe from shared resource side channel attacks.",
            "cite_spans": [
                {
                    "start": 591,
                    "end": 596,
                    "text": "[118,",
                    "ref_id": "BIBREF117"
                },
                {
                    "start": 597,
                    "end": 601,
                    "text": "119]",
                    "ref_id": "BIBREF118"
                }
            ],
            "ref_spans": [],
            "section": "Shared Resources"
        },
        {
            "text": "Furthermore, just separating the hardware resources is not enough, as there are other side channel attacks that are not based on this architectural design. These side channel attacks are based on external physical measurements or manipulations of the device that the manufacturers cannot shield against. In this case, the only possible solution is through the software, that should be hardened in order to not leak sensitive data. More specifically, the software should be optimized to have fixed power consumption and runtime execution regardless of the configuration of the targeted application. This will be able to protect against passive side channel attacks that only measure these specific characteristics of each execution. Finally, the software should also be hardened against hardware fault injections that could lead to exposing secret data.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Shared Resources"
        },
        {
            "text": "Another very important aspect we should consider is the closed source nature of TEE implementations. Most designs are not public, resulting in an architecture that is not analyzed in an open manner for security defects. This closed box design and the non-disclosure agreement policies that follow it, hinders the ability of security researchers to investigate the products for existing vulnerabilities [120] . Only recently has Qualcomm released the specifications for the Qualcomm TEE secure boot procedure and trusted application image authentication.",
            "cite_spans": [
                {
                    "start": 402,
                    "end": 407,
                    "text": "[120]",
                    "ref_id": "BIBREF119"
                }
            ],
            "ref_spans": [],
            "section": "Other Issues"
        },
        {
            "text": "A TEE should provide assurance based on its secure design (verified microkernel, isolation between tasks, secure input validation, overflow protection etc.) and by hardware mechanisms that provide the ability to isolate its state from \"external\" sources, like code running in the REE. From the presented cases we can see that the design of the most widespread implementation in not optimally secured, allowing for exploitation primitives that can totally break the security design.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Other Issues"
        },
        {
            "text": "Given the severe security issues we have identified and analyzed, here we propose a set of possible solutions and improvements that could be adopted in TEE implementations so as to increase their security and ultimately mitigate to the highest possible degree the vulnerabilities we presented. Once again, we follow our vulnerability categorization to highlight the solutions that we propose for each type of vulnerability refereeing to Figure  17 when required.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 437,
                    "end": 447,
                    "text": "Figure  17",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Solutions and Future Work"
        },
        {
            "text": "When it comes to software attacks, the main identified issues are entirely based on basic software attacks (control flow graph manipulation through buffer overflows, malformed input etc.). Developers of trusted applications should be careful to maintain secure and bug-free code that does exactly what it is supposed to do, this can be achieved by keeping the trusted code base at the minimum, effectively reducing the chance that a bug will exist and making the debugging process easier. The solution here is identical to common software security development procedures that includes (i) integration of secure software development lifecycle functions such as static and dynamic code analysis, fuzzing etc. and (ii) open sourcing security critical software so as to allow close scrutiny of the source code from a wider range of experts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solutions for Software Vulnerabilities"
        },
        {
            "text": "Furthermore, as identified in [9] , common TrustZone-based TEEs lack common OSlevel security techniques (ASLR, stack canaries etc.) which allows software exploitation to manifest in vulnerable binaries, something that can be avoided if TEE implementors add these techniques to their solutions. In addition, drivers and software proxies that communicate with the TEE must properly sanitize all requests, authenticate, and verify the senders of these requests. These entities are the gatekeepers to the secure world and the first line of defense against attackers, that is why TEE implementors should pay attention to secure these elements in order to mitigate the largest attack surface against the TEE. This of course needs further research so as to compare the computational overhead in comparison to the additional security provided. The aforementioned solutions aim to fortify the \"Trusted Application\" and the (4) attack path of Figure 17 .",
            "cite_spans": [
                {
                    "start": 30,
                    "end": 33,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [
                {
                    "start": 933,
                    "end": 942,
                    "text": "Figure 17",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Solutions for Software Vulnerabilities"
        },
        {
            "text": "The architectural vulnerabilities stem from the building block concepts of common TrustZone TEE implementation with a central part being the SMC communication channel witch attackers use to gain probing capabilities to the internals of the TEE that allows them to gain an initial foothold within the secure world. As proposed in [113] , an authenticated and encrypted channel will provide an additional layer of security to the SMC communications and prevent arbitrary SMC usage from kernel-privileged users. This of course only locks the door with better security and does not solve the software vulnerabilities that the attackers use to exploit the trusted applications (see Solutions for software vulnerabilities). On the other hand, there is a wide array of other architectural vulnerabilities (such as the downgrade attack) which are rooted in OS-level logic problems and unused TEE features. These issues can only be solved through more detailed and coherent implementation and usage of the TEEs in terms of security and bug searching. Once again, open sourcing parts of or entire TEE implementations will allow the code base to be thoroughly checked for issues by a wider array of experts. These solutions aim to secure the \"Trusted OS\" as well as the (2) ",
            "cite_spans": [
                {
                    "start": 329,
                    "end": 334,
                    "text": "[113]",
                    "ref_id": "BIBREF112"
                }
            ],
            "ref_spans": [],
            "section": "Solution for Architectural Vulnerabilities"
        },
        {
            "text": "Side channel attacks are enabled by the fact that the secure and normal world share common resources (CPU, cache, and RAM) which allow attackers to inject faults while also measuring execution times, power consumed and cache/RAM usage. As we have seen (Section 4.3) this core issue can only be solved by either adopting side channel resistant cryptographic algorithms (with constant execution times and constant power consumption) or changing the state of the shared resources by separating them (as in different hardware chips) or by changing how they work by introducing random noise that can halt these attacks [121, 122] . Choosing the optimal solution is a research topic that we propose and will require the cost/benefit analysis of adding new hardware to a SoC or having higher overhead side-channel-resistant algorithms. Furthermore, detection of side channel attack attempts is possible by orchestrating the shared CPU performance counters which are able to identify the number of cache-misses; a number that will spike during the attack. With this detection mechanism, the execution can stop when attacks are identified and thwart the attempt [123] . These solutions will block the attack paths (5-8) of Figure 17 .",
            "cite_spans": [
                {
                    "start": 614,
                    "end": 619,
                    "text": "[121,",
                    "ref_id": "BIBREF120"
                },
                {
                    "start": 620,
                    "end": 624,
                    "text": "122]",
                    "ref_id": "BIBREF121"
                },
                {
                    "start": 1153,
                    "end": 1158,
                    "text": "[123]",
                    "ref_id": "BIBREF122"
                }
            ],
            "ref_spans": [
                {
                    "start": 1214,
                    "end": 1223,
                    "text": "Figure 17",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Solution for Side Channel Vulnerabilities"
        },
        {
            "text": "Finally, a more generic guideline is that all TEE implementations should be made open to be publicly evaluated and improved. As it is widely recognized, security systems should be secure by design and not through the obscurity of their implementation. ARM TrustZone is no exception and the industry should avoid relying on the secrecy of the design or implementation as the main method of providing security.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solution for Side Channel Vulnerabilities"
        },
        {
            "text": "In this section we present the identified research directions. More specifically, in light of our analysis, we believe that the future work in this area should deal with one or more of the following research issues:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Future Directions"
        },
        {
            "text": "Currently there is no formal threat model for the TrustZone TEE. This kind of model would greatly benefit the development and security research of future TEEs as it will set the focus on the most important security threats that a TEE can be affected by.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "More tools are required to evaluate TEE implementations and discover security bugs. For example, custom fuzzers [42] (model based or coverage guided) and static analysis tools aware of TEE protocols that will be able to adapt to the unique requirements of secure-normal world communication. Another possible method is the use of symbolic execution for trusted applications such as [124] or dynamic analysis such as [125] .",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 116,
                    "text": "[42]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 381,
                    "end": 386,
                    "text": "[124]",
                    "ref_id": "BIBREF123"
                },
                {
                    "start": 415,
                    "end": 420,
                    "text": "[125]",
                    "ref_id": "BIBREF124"
                }
            ],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "As Cortex-M architecture has been optimized for low-power devices such as IoT, the underlying mechanisms of TrustZone technology for Cortex-M and Cortex-A processors are different. Therefore, research efforts must focus also on TEE implementations built for TrustZone Cortex-M variant such as [126] . \u2022 Development and widespread availability of TrustZone based hardware platforms is a crucial parameter (for both Cortex-A and Cortex-M) that will allow researchers to evaluate various TEE implementations. \u2022 Security is not the only aspect of TrustZone which requires attention. More works such as [127] are required to investigate TrustZone performance-wise and energy-wise.",
            "cite_spans": [
                {
                    "start": 293,
                    "end": 298,
                    "text": "[126]",
                    "ref_id": "BIBREF125"
                },
                {
                    "start": 598,
                    "end": 603,
                    "text": "[127]",
                    "ref_id": "BIBREF126"
                }
            ],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "Research efforts should focus on reducing the TCB size of the TEE OS and the optimal distribution of functionalities between the trusted and normal world applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "The security of the communication between various parts of a heterogeneous SoC is crucial. That is, novel solutions for the authentication and security of the communication channel between the secure and normal world should be investigated.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "A common use of TrustZone technology is data security such as DRM. However, the powerful capabilities of TEE technology can be leveraged to enable many more interesting privacy-enhancing solutions. Notable cases are the development of Private Contact Tracing (PCT) (e.g., to track COVID-19 contacts) [128] and privacy preserving machine learning at the level of devices [129] . More work is required to unleash the potential of TrustZone and showcase more interesting application scenarios. \u2022 Further investigations for underlying TEE vulnerabilities that are not based on trusted application vulnerabilities but on architectural issues of TEEs could shed light on how the TEE isolated environment could be better secured and also showcase its limitations.",
            "cite_spans": [
                {
                    "start": 370,
                    "end": 375,
                    "text": "[129]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "An example of such a research [130] implements vulnerable trusted applications that are exploited through memory corruptions on the OP-TEE platform.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u2022"
        },
        {
            "text": "From 2013 and on, research has surfaced that proves that the current implementations of ARM TrustZone implementations are not immune from attacks. The aim of this paper was to provide an analytical and educational analysis of TrustZone-based TEE vulnerabilities and related attacks. To this end, we created a taxonomy that divided them into three generic categories: (a) software, (b) architectural and (c) hardware attacks. We elaborated on each attack category focusing on subtle details that are important for the understanding of these attacks. Some of the presented exploits were highly complex and required skillful attackers (such as extraction of Master keys), while other ones (such as the downgrade attack) were rather trivial. Regardless of their complexity, all presented attacks are real-world with practical impact on the security of the underlying device. We conducted a root cause analysis of the said vulnerabilities to discover the underlying causes and pinpoint the nature of the security flaws. Our conjecture is that TrustZone based TEEs can be considered as still immature due to the previous evidence. However, they are a step to the right direction, with the TrustZone technology providing all the tools needed to develop a secure environment for next generation sensor and IoT networks. Most critically, this work showed that a more open and mature approach must be evaluated, with a more detailed attention to their design from the perspective of security.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        },
        {
            "text": "Author Contributions: Conceptualization, N.K. and C.N.; methodology, C.N.; validation, C.N. and C.X.; investigation, N.K. and C.X.; resources, N.K. and C.N.; writing-original draft preparation, N.K.; writing-review and editing, N.K. and C.N.; visualization, N.K.; supervision, C.N. and C.X.; project administration, C.X.; funding acquisition, C.X. All authors have read and agreed to the published version of the manuscript. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "SandPrint: Fingerprinting malware sandboxes to provide intelligence for sandbox evasion",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Yokoyama",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Ishii",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Tanabe",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Papa",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Yoshioka",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Matsumoto",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Kasama",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Inoue",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Brengel",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Backes",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "International Symposium on Research in Attacks, Intrusions, and Defenses",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Cross-VM side channels and their use to extract private keys",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Juels",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "K"
                    ],
                    "last": "Reiter",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Ristenpart",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 2012 ACM Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "16--18",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "IIoTEED: An enhanced, trusted execution environment for industrial IoT edge devices",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pinto",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Gomes",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pereira",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Cabral",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tavares",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IEEE Internet Comput",
            "volume": "21",
            "issn": "",
            "pages": "40--47",
            "other_ids": {
                "DOI": [
                    "10.1109/MIC.2017.17"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Software abstractions for trusted sensors",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Saroiu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wolman",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Raj",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 10th International Conference on Mobile Systems, Applications, and Services",
            "volume": "",
            "issn": "",
            "pages": "25--29",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Hardware-security technologies for industrial IoT: TrustZone and security controller",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lesjak",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hein",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the IECON 2015-41st Annual Conference of the IEEE Industrial Electronics Society",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Securing Intra-Vehicular Communication Using Trusted Execution",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Mishra",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Chantem",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gerdes",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Teecheck",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 28th International Conference on Real-Time Networks and Systems",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "PROTC: PROTeCting drone's peripherals through ARM trustzone",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Srivastava",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 3rd Workshop on Micro Aerial Vehicle Networks, Systems, and Applications",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Regulating arm trustzone devices in restricted spaces",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Brasser",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Liebchen",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Ganapathy",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Iftode",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Sadeghi",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 14th Annual International Conference on Mobile Systems, Applications, and Services",
            "volume": "",
            "issn": "",
            "pages": "25--30",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Trust Issues: Exploiting TrustZone TEEs, Project Zero",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beniamini",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Exposing the Perils of Security-Oblivious Energy Management",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sethumadhavan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Stolfo",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Clkscrew",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 26th USENIX Security Symposium USENIX Security",
            "volume": "17",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Unbox Your Phone-Part I",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Komaromy",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Cache attacks on mobile devices",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lipp",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gruss",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Spreitzer",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Maurice",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mangard",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Armageddon",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 25th USENIX Security Symposium USENIX Security 16",
            "volume": "",
            "issn": "",
            "pages": "16--18",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Reflections on trusting trustzone",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Rosenberg",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the BlackHat",
            "volume": "",
            "issn": "",
            "pages": "7--10",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "BOOMERANG: Exploiting the Semantic Gap in Trusted Execution Environments",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Machiry",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Gustafson",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Spensky",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Salls",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Stephens",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bianchi",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [
                        "R"
                    ],
                    "last": "Choe",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kruegel",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Vigna",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the NDSS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Trusted Execution Environment: What It is, and What It is Not",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sabt",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Achemlal",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bouabdallah",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 2015 IEEE Trustcom/BigDataSE/ISPA",
            "volume": "21",
            "issn": "",
            "pages": "520--562",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Trusted Execution Environments: A Look under the Hood",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Arfaoui",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Gharout",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Traor\u00e9",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the 2014 2nd IEEE International Conference on Mobile Cloud Computing, Services, and Engineering",
            "volume": "",
            "issn": "",
            "pages": "8--11",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Mobile Trusted Computing",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Asokan",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Ekberg",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Kostiainen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rajan",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rozas",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sadeghi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schulz",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Wachsmann",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proc. IEEE",
            "volume": "102",
            "issn": "",
            "pages": "1189--1206",
            "other_ids": {
                "DOI": [
                    "10.1109/JPROC.2014.2332007"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Architectures for Security: A comparative analysis of hardware security features in Intel SGX and ARM TrustZone",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Mukhtar",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "K"
                    ],
                    "last": "Bhatti",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Gogniat",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 2nd International Conference on Communication, Computing and Digital systems (C-CODE)",
            "volume": "",
            "issn": "",
            "pages": "6--7",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Trustzone explained: Architectural features and use cases",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Ngabonziza",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Martin",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bailey",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cho",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Martin",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the IEEE 2nd International Conference on Collaboration and Internet Computing (CIC)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Demystifying Arm TrustZone: A Comprehensive Survey",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pinto",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Santos",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM Comput. Surv. CSUR",
            "volume": "51",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3291047"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Understanding the prevailing security vulnerabilities in TrustZone-assisted TEE systems",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Cerdeira",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Santos",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fonseca",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pinto",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Sok",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the IEEE Symposium on Security and Privacy (S&P)",
            "volume": "",
            "issn": "",
            "pages": "23--27",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "OMAP\u2122 Platform Security Features, White Paper",
            "authors": [],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Mobile Security Technology, TI White Paper",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Srage",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Azema",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "M-Shield",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "TrustZone: Integrated hardware and software security",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "M"
                    ],
                    "last": "Alves",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Felton",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "3",
            "issn": "",
            "pages": "18--24",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Trusted Application Exploitation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Berard",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Kinibi",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Tee",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Exploring Qualcomm's Secure Execution Environment",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beniamini",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Exploiting TrustZone on Android",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Shen",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Your",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "On-board Credentials with Open Provisioning",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Kostiainen",
                    "suffix": ""
                },
                {
                    "first": "J.-E",
                    "middle": [],
                    "last": "Ekberg",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Asokan",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rantala",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the 4th International Symposium on Information, Computer, and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "An Exploration of ARM TrustZone Technology",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Cousson",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Open-TEE-An Open Virtual Trusted Execution Environment",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Mcgillion",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Dettenborn",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nyman",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Asokan",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the IEEE Trustcom/BigDataSE/ISPA",
            "volume": "",
            "issn": "",
            "pages": "20--22",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Dual operating system architecture for real-time embedded systems",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sangorrin",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Honda",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Takada",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proceedings of the 6th International Workshop on Operating Systems Platforms for Embedded Real-Time Applications (OSPERT)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Acceleration of dual os virtualization in embedded systems",
            "authors": [
                {
                    "first": "S.-C",
                    "middle": [],
                    "last": "Oh",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Koh",
                    "suffix": ""
                },
                {
                    "first": "C.-Y",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 2012 7th International Conference on Computing and Convergence Technology (ICCCT)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Using ARM TrustZone to build a trusted language runtime for mobile applications",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Santos",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Raj",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Saroiu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wolman",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "In ACM SIGARCH Computer Architecture News",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "ARM Security Technology Building a Secure System Using TrustZone\u00aeTechnology, ARM. 2005. Available online",
            "authors": [],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Technical Reference Manual-TrustZone Model ARM",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Arm1176jzf-S",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Learn the Architecture Exception Model",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Arm Ltd",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "An Introduction to Hypervisors and the Trusted Execution Environment (TEE)",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "posts/architecting-more-secure-world-with-isolation-and-virtualization (accessed on",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "ARM-Software/Arm-Trusted-Firmware. Available online",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "ARM Power State Coordination Interface",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Trusted Board Boot Requirements Client (TBBR-CLIENT) Armv8-A",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Available online",
            "authors": [],
            "year": 2020,
            "venue": "SMC CALLING CONVENTION (SMCCC)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "Software Delegated Exception Interface (SDEI)",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF50": {
            "ref_id": "b50",
            "title": "Cortex-A5 MPCore Technical Reference Manual, ARM. 2010. Available online",
            "authors": [],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF51": {
            "ref_id": "b51",
            "title": "AMBA 3 APB Protocol Specification, ARM. Available online",
            "authors": [],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF52": {
            "ref_id": "b52",
            "title": "Secure edge computing with lightweight control-flow property-based attestation",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Koutroumpouchos",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ntantogian",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "A"
                    ],
                    "last": "Menesidou",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Liang",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gouvas",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Xenakis",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Giannetsos",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Conference on Network Softwarization (NetSoft)",
            "volume": "",
            "issn": "",
            "pages": "84--92",
            "other_ids": {}
        },
        "BIBREF53": {
            "ref_id": "b53",
            "title": "Hypervision Across Worlds: Real-time Kernel Protection from the ARM TrustZone Secure World",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "M"
                    ],
                    "last": "Azab",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ning",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Shah",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bhutkar",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ganesh",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Ma",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Shen",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "3--7",
            "other_ids": {}
        },
        "BIBREF54": {
            "ref_id": "b54",
            "title": "Implementation aspects of mobile and embedded trusted computing",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Dietrich",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the International Conference on Trusted Computing",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF55": {
            "ref_id": "b55",
            "title": "Enforcing Kernel Code Integrity on the TrustZone Architecture. arXiv",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Ge",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Vijayakumar",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jaeger",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Sprobes",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1410.7747"
                ]
            }
        },
        "BIBREF56": {
            "ref_id": "b56",
            "title": "Trusted computing building blocks for embedded linux-based ARM trustzone platforms",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Proceedings of the 3rd ACM workshop on Scalable trusted computing",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF57": {
            "ref_id": "b57",
            "title": "Firmware-Based Trusted Platform Module for Arm Processor Architectures and Trustzone Security Extensions",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Thom",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Cox",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Linsley",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nystrom",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Raj",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Robinson",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Saroiu",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Spiger",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wolman",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "U.S. Patent US20130031374A1",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF58": {
            "ref_id": "b58",
            "title": "A Software-Only Implementation of a TPM Chip",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Raj",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Saroiu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wolman",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Aigner",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Cox",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "England",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fenner",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kinshumann",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Kinshumann",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Loeser",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 25th USENIX Security Symposium USENIX Security 16",
            "volume": "",
            "issn": "",
            "pages": "10--12",
            "other_ids": {}
        },
        "BIBREF59": {
            "ref_id": "b59",
            "title": "A framework for privacy-preserving mobile payment on security enhanced arm trustzone platforms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pirker",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Slamanig",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 2012 IEEE 11th International Conference on Trust, Security and Privacy in Computing and Communications",
            "volume": "",
            "issn": "",
            "pages": "25--27",
            "other_ids": {}
        },
        "BIBREF60": {
            "ref_id": "b60",
            "title": "Practical privacy preserving cloud resource-payment for constrained clients",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pirker",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Slamanig",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "International Symposium on Privacy Enhancing Technologies Symposium",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF61": {
            "ref_id": "b61",
            "title": "A cloud based dual-root trust model for secure mobile online transactions",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Huang",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Shen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bouzefrane",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the 2013 IEEE Wireless Communications and Networking Conference (WCNC)",
            "volume": "",
            "issn": "",
            "pages": "7--10",
            "other_ids": {}
        },
        "BIBREF62": {
            "ref_id": "b62",
            "title": "Identity verification schemes for public transport ticketing with NFC phones",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Tamrakar",
                    "suffix": ""
                },
                {
                    "first": "J.-E",
                    "middle": [],
                    "last": "Ekberg",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Asokan",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings of the sixth ACM workshop on Scalable trusted computing",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF63": {
            "ref_id": "b63",
            "title": "DFCloud: A TPM-based secure data access control method of cloud storage in mobile devices",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Shin",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 4th IEEE International Conference on Cloud Computing Technology and Science Proceedings",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF64": {
            "ref_id": "b64",
            "title": "Authenticated encryption primitives for size-constrained trusted computing",
            "authors": [
                {
                    "first": "J.-E",
                    "middle": [],
                    "last": "Ekberg",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Afanasyeva",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Asokan",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the International Conference on Trust and Trustworthy Computing",
            "volume": "",
            "issn": "",
            "pages": "13--15",
            "other_ids": {}
        },
        "BIBREF65": {
            "ref_id": "b65",
            "title": "Using trusted execution environments in two-factor authentication: Comparing approaches",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "M"
                    ],
                    "last": "Van Rijswijk",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Poll",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the Open Identity Summit",
            "volume": "",
            "issn": "",
            "pages": "9--11",
            "other_ids": {}
        },
        "BIBREF66": {
            "ref_id": "b66",
            "title": "Smartphones as Practical and Secure Location Verification Tokens for Payments",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Marforio",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Karapanos",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Soriente",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Kostiainen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Capkun",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the NDSS",
            "volume": "",
            "issn": "",
            "pages": "23--26",
            "other_ids": {}
        },
        "BIBREF67": {
            "ref_id": "b67",
            "title": "A path towards ubiquitous protection of media",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "T\u00f6gl",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pirker",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the Workshop on Web Applications and Secure Hardware, Series CEUR Workshop Proceedings",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF68": {
            "ref_id": "b68",
            "title": "Executing Smart Contracts with ARM TrustZone:(Practical Experience Report)",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Christina",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Brandenburger",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cachin",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Felber",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "G\u00f6ttel",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Schiavoni",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Tz4fabric",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 2020 International Symposium on Reliable Distributed Systems (SRDS)",
            "volume": "",
            "issn": "",
            "pages": "21--24",
            "other_ids": {}
        },
        "BIBREF69": {
            "ref_id": "b69",
            "title": "QSEE Privilege Escalation Vulnerability and Exploit (CVE-2015-6639)",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beniamini",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF70": {
            "ref_id": "b70",
            "title": "TrustZone Support in the Cache Controller. ARM",
            "authors": [],
            "year": 2007,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF72": {
            "ref_id": "b72",
            "title": "Cache Side-Channel Information Leakage from the Secure World on ARM Devices. IACR Cryptol. ePrint Arch",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sun",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Shands",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Lou",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [
                        "T"
                    ],
                    "last": "Hou",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Truspy",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF73": {
            "ref_id": "b73",
            "title": "A high resolution, low noise, L3 cache side-channel attack",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yarom",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Falkner",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Flush+",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Reload",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the 23rd USENIX Security Symposium (USENIX Security 14)",
            "volume": "",
            "issn": "",
            "pages": "20--22",
            "other_ids": {}
        },
        "BIBREF74": {
            "ref_id": "b74",
            "title": "A cache timing attack on AES in virtualization environments",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Wei\u00df",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Heinz",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Stumpf",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the International Conference on Financial Cryptography and Data Security",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF75": {
            "ref_id": "b75",
            "title": "BADFET: Defeating Modern Secure Boot Using Second-Order Pulsed Electromagnetic Fault Injection",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Cui",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Housley",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 11th USENIX Workshop on Offensive Technologies WOOT 17",
            "volume": "",
            "issn": "",
            "pages": "16--18",
            "other_ids": {}
        },
        "BIBREF76": {
            "ref_id": "b76",
            "title": "Cache attacks and countermeasures: The case of AES",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "A"
                    ],
                    "last": "Osvik",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shamir",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tromer",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the Cryptographers' Track at the RSA Conference",
            "volume": "",
            "issn": "",
            "pages": "1--20",
            "other_ids": {}
        },
        "BIBREF77": {
            "ref_id": "b77",
            "title": "Flush+ Flush: A fast and stealthy cache attack",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gruss",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Maurice",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Wagner",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mangard",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment",
            "volume": "",
            "issn": "",
            "pages": "7--8",
            "other_ids": {}
        },
        "BIBREF78": {
            "ref_id": "b78",
            "title": "Breaching trustzone by software-controlled voltage manipulation over multicore frequencies",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Pengfei",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Lyu",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Qu",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Voltjockey",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "11--15",
            "other_ids": {}
        },
        "BIBREF79": {
            "ref_id": "b79",
            "title": "Flipping bits in memory without accessing them: An experimental study of DRAM disturbance errors",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Daly",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Fallin",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "H"
                    ],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Wilkerson",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Lai",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Mutlu",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "In ACM SIGARCH Computer Architecture News",
            "volume": "",
            "issn": "",
            "pages": "361--372",
            "other_ids": {}
        },
        "BIBREF80": {
            "ref_id": "b80",
            "title": "Smartphone Apps Processor Market Share: Shipments Decline 11 Percent, says Strategy Analytics. Available on",
            "authors": [],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF81": {
            "ref_id": "b81",
            "title": "Full TrustZone Exploit for MSM8974",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beniamini",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "8",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF82": {
            "ref_id": "b82",
            "title": "TrustZone Kernel Privilege Escalation (CVE-2016-2431)",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beniamini",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF83": {
            "ref_id": "b83",
            "title": "Extracting Qualcomm's KeyMaster Keys-Breaking Android Full Disk Encryption",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beniamini",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF84": {
            "ref_id": "b84",
            "title": "Unbox Your Phone-Part II",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Komaromy",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF85": {
            "ref_id": "b85",
            "title": "Unbox Your Phone-Part III",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Komaromy",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF86": {
            "ref_id": "b86",
            "title": "Here Be Dragons: Vulnerabilities in TrustZone",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Keltner",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF87": {
            "ref_id": "b87",
            "title": "Unlocking the Motorola Bootloader",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Rosenberg",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF88": {
            "ref_id": "b88",
            "title": "Bypassing the (Not so) Secure Boot to dump the BootROM",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Basse",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Amlogic",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Soc",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF90": {
            "ref_id": "b90",
            "title": "Get The Ultimate Privilege of Android Phone",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Wen",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Tour",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the Infiltrate Security Conference",
            "volume": "",
            "issn": "",
            "pages": "2--3",
            "other_ids": {}
        },
        "BIBREF91": {
            "ref_id": "b91",
            "title": "Unearthing the TrustedCore: A Critical Review on Huawei's Trusted Execution Environment",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Busch",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Westphal",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Mueller",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 14th USENIX Workshop on Offensive Technologies (WOOT 20)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF92": {
            "ref_id": "b92",
            "title": "Next generation mobile rootkits",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Roth",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the Hack in Paris",
            "volume": "",
            "issn": "",
            "pages": "17--21",
            "other_ids": {}
        },
        "BIBREF93": {
            "ref_id": "b93",
            "title": "Hardware supported rootkit concealment",
            "authors": [
                {
                    "first": "F",
                    "middle": [
                        "M"
                    ],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "M"
                    ],
                    "last": "Chan",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Carlyle",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "H"
                    ],
                    "last": "Campbell",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Cloaker",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Proceedings of the IEEE Symposium on Security and Privacy",
            "volume": "",
            "issn": "",
            "pages": "18--21",
            "other_ids": {}
        },
        "BIBREF94": {
            "ref_id": "b94",
            "title": "Downgrade attack on trustzone",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wei",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1707.05082"
                ]
            }
        },
        "BIBREF95": {
            "ref_id": "b95",
            "title": "The Security of ARM TrustZone in a FPGA-Based SoC",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Bossuet",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Aubert",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Benhani",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Trans. Comput",
            "volume": "68",
            "issn": "",
            "pages": "1238--1248",
            "other_ids": {}
        },
        "BIBREF96": {
            "ref_id": "b96",
            "title": "On the security evaluation of the ARM TrustZone extension in a heterogeneous SoC",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Marchand",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Aubert",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Bossuet",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 30th IEEE International System-on-Chip Conference (SOCC)",
            "volume": "",
            "issn": "",
            "pages": "5--8",
            "other_ids": {}
        },
        "BIBREF97": {
            "ref_id": "b97",
            "title": "Understanding the Security of ARM Debugging Features",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Zhenyu",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Fengwei",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the IEEE Symposium on Security and Privacy (SP)",
            "volume": "",
            "issn": "",
            "pages": "20--22",
            "other_ids": {}
        },
        "BIBREF98": {
            "ref_id": "b98",
            "title": "Nailgun: Break the Privilege Isolation in ARM Devices",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Ning",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF99": {
            "ref_id": "b99",
            "title": "TrustZone Code Execution Exploit on the Nintendo Switch",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Scires",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF100": {
            "ref_id": "b100",
            "title": "Nintendo Switch nvservices Info Leak",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Brocious",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF101": {
            "ref_id": "b101",
            "title": "Methodically Defeating Nintendo Switch Security. arXiv 2019",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "T H G"
                    ],
                    "last": "Roussel-Tarbouriech",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Menard",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "True",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Vi",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1905.07643"
                ]
            }
        },
        "BIBREF102": {
            "ref_id": "b102",
            "title": "Prime+Count: Novel Cross-world Covert Channels on ARM TrustZone",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cho",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "C.-H",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Zhao",
                    "suffix": ""
                },
                {
                    "first": "G.-J",
                    "middle": [],
                    "last": "Doup&apos;e",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Ahn",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 34th Annual Computer Security Applications Conference",
            "volume": "",
            "issn": "",
            "pages": "3--7",
            "other_ids": {}
        },
        "BIBREF103": {
            "ref_id": "b103",
            "title": "Navigating the Samsung TrustZone and Cache-Attacks on the Keymaster Trustlet",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Lapid",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wool",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the European Symposium on Research in Computer Security",
            "volume": "",
            "issn": "",
            "pages": "3--7",
            "other_ids": {}
        },
        "BIBREF104": {
            "ref_id": "b104",
            "title": "Information Leakage from TrustZone",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sun",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Shands",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Lou",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "Y"
                    ],
                    "last": "Hou",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Trusense",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the IEEE Conference on Computer Communications (INFOCOM)",
            "volume": "",
            "issn": "",
            "pages": "15--19",
            "other_ids": {}
        },
        "BIBREF106": {
            "ref_id": "b106",
            "title": "Technical Advisory: Private Key Extraction from Qualcomm Hardware-backed Keystores, Nccgroup",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Keegan",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF107": {
            "ref_id": "b107",
            "title": "Attack TrustZone with Rowhammer",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Carru",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "GreHack",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF108": {
            "ref_id": "b108",
            "title": "Side channel attacks on smartphones and embedded devices using standard radio equipment",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Goller",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Sigl",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "International Workshop on Constructive Side-Channel Analysis and Secure Design",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF109": {
            "ref_id": "b109",
            "title": "ECDSA key extraction from mobile devices via nonintrusive physical side channels",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Genkin",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pachmanov",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Pipman",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tromer",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yarom",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "24--28",
            "other_ids": {}
        },
        "BIBREF110": {
            "ref_id": "b110",
            "title": "SeCReT: Secure Channel between Rich Execution Environment and Trusted Execution Environment",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "S"
                    ],
                    "last": "Jang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kong",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "B"
                    ],
                    "last": "Kang",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the NDSS",
            "volume": "",
            "issn": "",
            "pages": "8--11",
            "other_ids": {}
        },
        "BIBREF111": {
            "ref_id": "b111",
            "title": "Virtualizing trusted execution environments on mobile platforms",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Xia",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Lu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Zang",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Teev",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 15th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments",
            "volume": "",
            "issn": "",
            "pages": "13--17",
            "other_ids": {}
        },
        "BIBREF112": {
            "ref_id": "b112",
            "title": "Reconciling security with virtualization: A dual-hypervisor design for ARM TrustZone",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cicero",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Biondi",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Buttazzo",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Patel",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the IEEE International Conference on Industrial Technology (ICIT)",
            "volume": "",
            "issn": "",
            "pages": "19--22",
            "other_ids": {}
        },
        "BIBREF113": {
            "ref_id": "b113",
            "title": "PrOS: Light-weight Privatized Secure OSes in ARM TrustZone",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kwon",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Seo",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Cho",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Paek",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "IEEE Trans. Mob. Comput",
            "volume": "19",
            "issn": "",
            "pages": "1434--1447",
            "other_ids": {
                "DOI": [
                    "10.1109/TMC.2019.2910861"
                ]
            }
        },
        "BIBREF114": {
            "ref_id": "b114",
            "title": "Hardware-assisted isolated computing environments on mobile devices",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Sun",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sun",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jing",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Trustice",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 45th Annual IEEE/IFIP International Conference on Dependable Systems and Networks",
            "volume": "",
            "issn": "",
            "pages": "22--25",
            "other_ids": {}
        },
        "BIBREF115": {
            "ref_id": "b115",
            "title": "Virtualizing ARM TrustZone",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Hua",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gu",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Xia",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Zang",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Guan",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Vtz",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 26th USENIXSecurity Symposium USENIX Security",
            "volume": "17",
            "issn": "",
            "pages": "16--18",
            "other_ids": {}
        },
        "BIBREF116": {
            "ref_id": "b116",
            "title": "SANCTUARY: ARMing TrustZone with User-space Enclaves",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Brasser",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gens",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Jauernig",
                    "suffix": ""
                },
                {
                    "first": "A.-R",
                    "middle": [],
                    "last": "Sadeghi",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Stapf",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the NDSS",
            "volume": "",
            "issn": "",
            "pages": "24--27",
            "other_ids": {}
        },
        "BIBREF117": {
            "ref_id": "b117",
            "title": "Hybrid Side-Channel-Resilient Caches for Trusted Execution Environments. arXiv 2019",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Dessouky",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Frassetto",
                    "suffix": ""
                },
                {
                    "first": "A.-R",
                    "middle": [],
                    "last": "Sadeghi",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Hybcache",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1909.09599"
                ]
            }
        },
        "BIBREF118": {
            "ref_id": "b118",
            "title": "Countermeasure against side-channel attack in shared memory of trustzone",
            "authors": [
                {
                    "first": "N.-Y",
                    "middle": [],
                    "last": "Ahn",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "H"
                    ],
                    "last": "Lee",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1705.08279"
                ]
            }
        },
        "BIBREF119": {
            "ref_id": "b119",
            "title": "Experimenting with ARM TrustZone-Or: How I Met Friendly Piece of Trusted Hardware",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 2012 IEEE 11th International Conference on Trust, Security and Privacy in Computing and Communications",
            "volume": "",
            "issn": "",
            "pages": "25--27",
            "other_ids": {}
        },
        "BIBREF120": {
            "ref_id": "b120",
            "title": "Side-channel resistant crypto for less than 2,300 GE",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Poschmann",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Moradi",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Khoo",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ling",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "J. Cryptol",
            "volume": "24",
            "issn": "",
            "pages": "322--345",
            "other_ids": {
                "DOI": [
                    "10.1007/s00145-010-9086-6"
                ]
            }
        },
        "BIBREF121": {
            "ref_id": "b121",
            "title": "CaSym: Cache aware symbolic execution for side channel detection and mitigation",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Brotzman",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Tan",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kandemir",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 2019 IEEE Symposium on Security and Privacy (SP)",
            "volume": "",
            "issn": "",
            "pages": "20--22",
            "other_ids": {}
        },
        "BIBREF122": {
            "ref_id": "b122",
            "title": "The Road to Qualcomm Trustzone Apps Fuzzing",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Makkaveev",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF123": {
            "ref_id": "b123",
            "title": "Finding 1-Day Vulnerabilities in Trusted Applications using Selective Symbolic Execution",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Busch",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Dirsch",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 27th Annual Network and Distributed System Security Symposium (NDSS)",
            "volume": "",
            "issn": "",
            "pages": "23--26",
            "other_ids": {}
        },
        "BIBREF124": {
            "ref_id": "b124",
            "title": "Enabling dynamic analysis of real-world trustzone software using emulation",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Harrison",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Vijayakumar",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Padhye",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Grace",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Padhye",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Vijayakumar",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Partemu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 29th USENIX Security Symposium (USENIX Security 2020)",
            "volume": "",
            "issn": "",
            "pages": "12--14",
            "other_ids": {}
        },
        "BIBREF125": {
            "ref_id": "b125",
            "title": "On Runtime Software Security of TrustZone-M based IoT Devices. arXiv 2020",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Luo",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "C"
                    ],
                    "last": "Zou",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Shao",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Ling",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Fu",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:2007.05876"
                ]
            }
        },
        "BIBREF126": {
            "ref_id": "b126",
            "title": "On the performance of ARM TrustZone",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Amacher",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Schiavoni",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the IFIP International Conference on Distributed Applications and Interoperable Systems",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "ARMv8 exception level architecture.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "ARMv8 exception level architecture.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Communication Channels Between the Normal and the Secure world.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Communication channels between the normal and the secure world.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "The DACR register, each memory region is assigned 2 Bits.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "The DACR register, each memory region is assigned 2 Bits.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "\u2022 DEBUG: Indicates whether the binary should have enabled or disabled debugging features. \u2022 OEM_ID: The ID of the OEM from HW_ID. \u2022 SW_SIZE: The size of the signed data. (Hash Table Segment) \u2022 MODEL_ID: The ID of the model from HW_ID. \u2022 SHA256/SHA1: The hashing scheme used for signature verification.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "\u2022 HW_ID: Attribute to bind the binary to a specific r device family, model, and OEM.\u2022 DEBUG: Indicates whether the binary should have enabled or disabled debugging features. \u2022 OEM_ID: The ID of the OEM from HW_ID. \u2022 SW_SIZE: The size of the signed data. (Hash Table Segment) \u2022 MODEL_ID: The ID of the model from HW_ID. \u2022 SHA256/SHA1: The hashing scheme used for signature verification.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Architecture of a QSEE Trusted Application.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Architecture of a QSEE trusted application.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Buffer Overflow & Overread Based: Attacks that exploit common memory attacks (buffer overflows/overreads) (1.2) Logic Based: Attacks that exploit logical bugs such as faulty comparison branches, incompatible variable types etc. (1.3) Bad Use of Crypto: Insufficient strength of used cryptography such as usage of digest functions for authenticated secure integrity verification. (2) Architectural Attacks (2.1) Unused Security Features: Unused security features such as downgrade prevention functions or pointer sanitization utilities. (2.2) Underlying Architecture: Exploitation of underlying architectural features of the TrustZone implementation such as debugging functions, device sleep features and interconnects. (3) Hardware Attacks (3.1) Side Channel Attacks: Exfiltration of data from the device by passively monitoring hardware components (volatile memory) of the device and inferring data from them. (3.2) Fault Injection Attacks: Exfiltration of data from the device by monitoring hardware components while actively forcing faulty operations to execute.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Electromagnetic: Fault injection attacks that use electromagnetic means to induce faults. (3.2.2) Voltage & Frequency: Fault injection attacks that use voltage and/or the CPU frequency to induce faults. Sensors 2021, 21, x FOR PEER REVIEW 13 of TrustZone Attack Taxonomy.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "TrustZone attack taxonomy.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF14": {
            "text": "Privilege Escalation to TrustZone.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF15": {
            "text": "Privilege escalation to TrustZone.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF16": {
            "text": "21, x FOR PEER REVIEW 15 of",
            "latex": null,
            "type": "figure"
        },
        "FIGREF17": {
            "text": "Privilege Escalation to TrustZone Kernel.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF18": {
            "text": "Privilege escalation to TrustZone kernel.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF19": {
            "text": "Emulating QSEE Code and Partially Offloading it to QSEE.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF20": {
            "text": "Emulating QSEE code and partially offloading it to QSEE.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF21": {
            "text": "Three steps to complete TrustZone exploitation of the bits please attack.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF22": {
            "text": "Three steps to complete TrustZone exploitation of the bits please attack.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF23": {
            "text": "Kinibi TEE communication scheme.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF24": {
            "text": "Kinibi TEE communication scheme.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF25": {
            "text": "SVE-2017-8891 Buffer Overflow in parse_ca_cert() of a 32-bit buffer with a 400-bit input. Vuln 4: SVE-2017-8892 Buffer Overflow in the parsing of a Diffie-Hellman parameter in the parse_scp_param() function. Vuln 5: SVE-2017-8893",
            "latex": null,
            "type": "figure"
        },
        "FIGREF28": {
            "text": "Boomerang attack architecture.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF29": {
            "text": "Generating the list of possible values for each byte of the key.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF30": {
            "text": "Generating the list of possible values for each byte of the key.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF31": {
            "text": "21, x FOR PEER REVIEW 26 of L1 & L2 cache architecture.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF32": {
            "text": "L1 & L2 cache architecture.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF33": {
            "text": "21, x FOR PEER REVIEW 28 of 45",
            "latex": null,
            "type": "figure"
        },
        "FIGREF34": {
            "text": "Prime + probe process of TruSpy.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF35": {
            "text": "Prime + probe process of TruSpy.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF37": {
            "text": "21, x FOR PEER REVIEW 29 of 45",
            "latex": null,
            "type": "figure"
        },
        "FIGREF38": {
            "text": "RowHammer attack.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF39": {
            "text": "RowHammer attack.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF41": {
            "text": "The CLKscrew attack.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF42": {
            "text": "The CLKscrew attack.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF43": {
            "text": "21, x FOR PEER REVIEW 34 of 45",
            "latex": null,
            "type": "figure"
        },
        "FIGREF44": {
            "text": "TrustZone attack paths.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF45": {
            "text": "TrustZone attack paths.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF46": {
            "text": ",(3) and (4) attack paths ofFigure 17",
            "latex": null,
            "type": "figure"
        },
        "FIGREF47": {
            "text": ".",
            "latex": null,
            "type": "figure"
        },
        "FIGREF48": {
            "text": "This work was supported by the European Commission, under the CUREX, FutureTPM, and INCOGNITO projects; Grant Agreements no. 826404, 779391 and 824015, respectively. Institutional Review Board Statement: Not Applicable. Informed Consent Statement: Not Applicable. Data Availability Statement: Not Applicable.",
            "latex": null,
            "type": "figure"
        },
        "TABREF4": {
            "text": "Kinibi vulnerabilities of the unbox your phone attack reported as SVEs. Read of the TLV containing buffer sent to the ESECOMM trusted application.",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF11": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF12": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF13": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF14": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF15": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF16": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF17": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF18": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF19": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF20": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).",
            "latex": null,
            "type": "table"
        },
        "TABREF21": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF22": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF23": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).specify the GlobalPlatrform protection profile objectives violated by each attack.",
            "latex": null,
            "type": "table"
        },
        "TABREF24": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).specify the GlobalPlatrform protection profile objectives violated by each attack.",
            "latex": null,
            "type": "table"
        },
        "TABREF25": {
            "text": "A comparison of the analyzed attacks that showcases the methodology used, the primitives achieved, and the GlobalPlatform Protection Profile objectives violated by each attack. The Kernel Normal World (KNW) mark shows that the primitive targets the kernel of the normal world. (\u25cb Not achieved \u25d2 Not achieved but trivial \u2022 Achieved).Flush + Reload, Flush + Flush, Evict + Reload cache timing attacks",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "The authors declare no conflict of interest.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conflicts of Interest:"
        }
    ]
}