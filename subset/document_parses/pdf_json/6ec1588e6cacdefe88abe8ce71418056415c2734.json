{
    "paper_id": "6ec1588e6cacdefe88abe8ce71418056415c2734",
    "metadata": {
        "title": "An Ant Colony Optimization Algorithm Based Automated Generation of Software Test Cases",
        "authors": [
            {
                "first": "Saju",
                "middle": [],
                "last": "Sankar",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Government Polytechnic College",
                    "location": {
                        "settlement": "Punalur",
                        "country": "India"
                    }
                },
                "email": ""
            },
            {
                "first": "S",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "(",
                "middle": [
                    "B"
                ],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Vinod",
                "middle": [],
                "last": "Chandra",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Kerala",
                    "location": {
                        "postCode": "695581",
                        "settlement": "Thiruvananthapuram",
                        "country": "India"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Software testing is an important process of detecting bugs in the software product thereby a quality software product is developed. Verification and Validation (V & V) activities are the effective methods employed to achieve quality. Static and dynamic testing activities are performed during V & V. During static testing, the program code is not executed while in dynamic testing (Black Box and White Box), the execution of the program code is performed. Effective test cases are designed by both these methods. Tables are employed to represent test case documentation. The most beneficial representation -State table based testing, for generating test inputs is explained with the help of state graphs and state tables. This technique is mainly employed in embedded system software testing, real time applications and web application based software product testing where time constraints are a major criteria. Automatic generation of test cases will help to reduce time overhead in testing activities. Our study is to develop optimum test cases by a modified Ant Colony Optimization (ACO) technique in an automated method and it ensures maximum coverage. The prediction model used in this paper ensures better accuracy of the design of test inputs. A comparison of the similar optimization techniques was also discussed that is used in automated test case generation. A case study of the various states during the execution of a task in an operating system has been presented to illustrate our approach.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "A software product should be reliable and measurable. These qualities are evaluated by way of effective testing activities. Hence testing is an important stage of Software Development Life Cycle (SDLC). Like SDLC, Software Testing Life Cycle (STLC) is also a process which detects bugs or faults so as to rectify them before delivery of the software product to the customer. The testing of the various phases of STLC by way of manual testing is difficult due to the overhead of time, cost and schedule slippage. Hence automated testing is complemented for majority of the testing activities [1] . This automated generation of test cases is necessary when a set of tests are to be done repeatedly, compatibility testing, regression testing etc. For this purpose, artificial intelligence techniques are adopted with a Meta heuristic approach. The problem of generating sets of test cases for functional testing, structural testing etc. are achieved by automated test case generation techniques [2] .",
            "cite_spans": [
                {
                    "start": 591,
                    "end": 594,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 992,
                    "end": 995,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we propose an optimal algorithm for the automated generation of test cases based on Ant Colony Optimization (ACO). State table based testing -a black box testing technique is employed, which assures a higher level of functional testing of the individual modules. Here the process is categorized as -software environment modeling, test case selection, test case execution, test metrics and automated test suite reduction techniques [3] .",
            "cite_spans": [
                {
                    "start": 446,
                    "end": 449,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A software product can be optimized by various algorithms such as genetic algorithms, ACO, Particle Swarm Optimization (PSO), Artificial Bee Colony (ABC) etc. The ACO algorithm is a metaheuristic intelligent optimization method. The algorithm is used for finding the optimal path in a graph. ACO is also employed for the optimization of test case generation techniques namely functional testing, Structural testing, Regression testing etc. [4] . Praveen et al. proposed an ACO based automated software testing technique which shows the generation of optimal test cases in an automated environment [5] .",
            "cite_spans": [
                {
                    "start": 440,
                    "end": 443,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 597,
                    "end": 600,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This paper proposes an automated method of generating test cases in functional testing technique mainly state table based testing, optimized by an ACO algorithm. The results are compared with other optimization models for effectiveness [6] .",
            "cite_spans": [
                {
                    "start": 236,
                    "end": 239,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "State table based testing is defined as the black box testing technique in which changes in input conditions cause state changes in the application under test [7] . It is a convenient method for testing software systems where states and transitions are specified. Tables are used for representing information relating to the design of test cases. We have represented them using state transition diagrams and state tables. A state table representation has a) Finite State Machine (FSM), a model whose output is dependent on both previous and present inputs. An FSM model represents the software behavior and serves as a guide to design functional test cases. b) State transition diagram or state graph, is a software system which has different states depending on its input and time. The nodes in a state graph represent states. The nodes are connected by links denoted as transitions. With the help of nodes and transitions, a state graph is prepared. The pictorial representation of an FSM is depicted by a state graph and it represents the states that the system can assume. The state graph is converted to a tabular form known as state tables. They specify states, input events, transitions and outputs. The information contained in the state graph and the state table is converted into test cases.",
            "cite_spans": [
                {
                    "start": 159,
                    "end": 162,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "State Table Based Testing"
        },
        {
            "text": "The state table contains cells of valid and invalid inputs. Valid inputs causes a change of state and invalid inputs do not cause any change in transition in the state of a task. Due to the tremendous overhead of time and cost exhaustive testing is not possible. The solution is to formulate a strategy for test case reduction without affecting the functional coverage of the system under test. The genetic algorithms employed currently have to be modified for the above [8] .",
            "cite_spans": [
                {
                    "start": 471,
                    "end": 474,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "State Table Based Testing"
        },
        {
            "text": "The method of state table based testing is depicted with a case study, showing the different states of a task in an operating system. A task or job assigned to an operating system has the states -New, Ready, Running, Waiting, Terminated. The state graph is drawn as the first step. The state graph can be represented as a directed graph G = (N, E), where N denotes the states (nodes) of the system under test and E denotes the edges or transition between the states. As shown in Fig. 1 , there are two paths which satisfy rule b.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 479,
                    "end": 485,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "State Table Based Testing"
        },
        {
            "text": "ACO is a probabilistic technique which searches for optimal path in a graph. Ant behavior is looking a shortest path between their colony and location of food source. The path is discovered by pheromone deposits when the ants move at random. More pheromone deposits on a path increases the probability of the path being followed. The path is selected based on the maximum pheromone deposit from start node and the path is analyzed for optimality [9] . The behavior of ants can be used for solving the problem. Selection of paths depends upon the theory of probability. Ants generate pheromone and deposits on the paths for further remembrance and it is a heuristic technique. The path visibility is accomplished by the level of pheromone intensity and heuristic information. The feasible path is selected based on highest pheromone level and heuristic information. The algorithm needs four parameters for selecting the valid transitions of the state graph -Probability, Heuristic information, Pheromone intensity and Visibility of the path [10] .",
            "cite_spans": [
                {
                    "start": 446,
                    "end": 449,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1040,
                    "end": 1044,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "ACO Algorithm for Test Case Generation"
        },
        {
            "text": "Required (PTR) metric [6] . The metrics was evaluated by the case studies for triangle problem, quadratic equation problem etc. (Table 3) . The comparison shows that m-ACO algorithm shows better coverage than the other optimization algorithms.",
            "cite_spans": [
                {
                    "start": 22,
                    "end": 25,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 128,
                    "end": 137,
                    "text": "(Table 3)",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Kamna et al. evaluated the performances of genetic algorithm (GA), Bee Colony optimization (BCO), ACO and modified ACO (m-ACO) for test case prioritization in terms of Average Percentage of Faults Detected (APFD) and Percentage of Test Cases"
        },
        {
            "text": "In order to classify or to select the valid test cases, we used the modified algorithm 'Comprehensive Improved Ant Colony Optimization (ACIACO) for finding the effective optimization path and this path model is used to achieve highest coverage and reduce the number of iterations [11] . The establishment of transformation relationship makes effective use of ant colony algorithm for iterative optimization of test cases.",
            "cite_spans": [
                {
                    "start": 280,
                    "end": 284,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Kamna et al. evaluated the performances of genetic algorithm (GA), Bee Colony optimization (BCO), ACO and modified ACO (m-ACO) for test case prioritization in terms of Average Percentage of Faults Detected (APFD) and Percentage of Test Cases"
        },
        {
            "text": "In this paper, generating the test cases from the state table is achieved by the modified ACO algorithm. The algorithm is for the effective traversing through the different states. Also the feasible test cases are generated so as to cover all transitions at least once. The procedure is given, 1. Initialize parameters.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Kamna et al. evaluated the performances of genetic algorithm (GA), Bee Colony optimization (BCO), ACO and modified ACO (m-ACO) for test case prioritization in terms of Average Percentage of Faults Detected (APFD) and Percentage of Test Cases"
        },
        {
            "text": "Initialize heuristic value of each transition in the state graph \u0220 =2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Set heuristic value (\u00ef)."
        },
        {
            "text": "Initialize pheromone value for each transition in the state graph (\u01ae=1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Set pheromone intensity (\u01ae)."
        },
        {
            "text": "Initialize V s = 0 (the condition in which ant not visited any state).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Set visited status (V s )."
        },
        {
            "text": "Initialize P = 0. 1.5 Initialize \u03b1 =1, \u03b2 =1, the parameters which controls the desirability and visibility. 1.6 Set count = maximum number of possible transitions. The probability has values between 0 and 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Set probability (P)."
        },
        {
            "text": "3. Move to the next node.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Set probability (P)."
        },
        {
            "text": "3.1 Select the destination node. Ant will follow the rules. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Set probability (P)."
        },
        {
            "text": "We have discussed how the test cases are minimized while maximizing coverage of testing. If there are 'n' states in a state graph, then there will be a maximum of 'n*n' test cases both feasible and infeasible generated thereby increasing the testing time overhead. For the automated generation of test cases, we used an open source testing tool multidimensional modified condition/decision coverage which supports state graph based testing and generates test cases by traversing through the state transition graph [12] . The test cases given in Table 2 , twenty four test cases both valid and invalid, which cause or do not cause change in transition from one state to another during the execution of a task has to be minimized.",
            "cite_spans": [
                {
                    "start": 514,
                    "end": 518,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [
                {
                    "start": 545,
                    "end": 552,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Results and Discussion"
        },
        {
            "text": "Wang's algorithm [13] was used for the effective reduction of test cases. After completely extracting all the transitions, the next step is to generate the test cases from TC1 to TC24.",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 21,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Steps for Minimizing Test Cases"
        },
        {
            "text": "The last step is to reduce the set of generated test cases by calculating the node coverage for each test case and determining which test cases are covered by other test cases. i.e. from NC(TC1) to NC(TC24). The test cases are valid if the node coverage is empty. All other test cases are invalid and can be ignored.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Steps for Minimizing Test Cases"
        },
        {
            "text": "Hence the six valid test cases which causes state transitions in the execution of a task in an operating system are Test Suite, TS = {TC1, TC8, TC15, TC16, TC18, TC23} as  shown in Table 4 . This reduction in test suite helps saving of time in resource constrained software projects. The ACIACO algorithm effectively covered the criteria such as reduced test suite size, improved fault detection capability, reduced time, cost and highest coverage criteria. A comparison of the three kinds of coverage -statement coverage, branch coverage and modified condition/decision coverage shows that the modified ACIACO algorithm obtained better values as shown in Table 5 . It is evident that the ACO optimization algorithm will effectively improve the quality of the test cases generated. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 92,
                    "end": 188,
                    "text": "an operating system are Test Suite, TS = {TC1, TC8, TC15, TC16, TC18, TC23} as  shown in Table 4",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 656,
                    "end": 663,
                    "text": "Table 5",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Steps for Minimizing Test Cases"
        },
        {
            "text": "We have proposed a modified ACO based approach for the automated and effective generation of valid test cases for the state transition based software testing. An FSM model is prepared. From the model, a state graph followed a state table and a test case table was generated. Also a test suite reduction algorithm is implemented thereby the optimization is achieved. ACO is a promising methodology for test case generation, selection and prioritization problem. ACO algorithm fully satisfies software coverage without having any redundancy. The power of nature inspired models in software engineering area is emerging because of its optimization outcome. The swarm based optimization is evolving in many of the software optimization fields. It is highly recommended, agent and swarm fused optimization algorithms can be used to generate efficient automated test environments.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 226,
                    "end": 263,
                    "text": "state table and a test case table was",
                    "ref_id": null
                }
            ],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Literature review on test case generation approach",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Setiani",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ICSIM 2019 Proceedings of the Second International Conference on Software Engineering and Information Management",
            "volume": "",
            "issn": "",
            "pages": "91--95",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Automated software test data generation: direction of research",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Tahbildar",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Kalita",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Int. J. Comput. Sci. Eng. IJCSES",
            "volume": "2",
            "issn": "",
            "pages": "99--120",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Generation and optimization of test cases for object oriented software using state chart diagram",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "R"
                    ],
                    "last": "Swain",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "CS & IT -CSCP",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Evaluation of test cases using ACO with a new heuristic function: a proposed approach",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Singh",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Int. J. Adv. Res. Comput. Sci. Softw. Eng. IJARCSSE",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Structured testing using ant colony optimization",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        ";"
                    ],
                    "last": "Srivastava",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Iitm",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "India",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proceedings of the First International Conference on Intelligent Interactive Technologies and Multimedia",
            "volume": "",
            "issn": "",
            "pages": "203--207",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A Comparative evaluation of 'm-ACO' technique for test suite prioritization",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kamna",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Indian J. Sci. Technol",
            "volume": "9",
            "issn": "30",
            "pages": "1--10",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "An ant colony optimization approach to test sequence generation for state based software testing",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "P"
                    ],
                    "last": "Lam",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proceedings of the fifth international conference on quality software",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "A survey on test case selection using optimization techniques in software testing",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Thakur",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Varma",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Int. J. Innov. Sci. Eng. Technol. IJISET",
            "volume": "2",
            "issn": "",
            "pages": "593--596",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Smell detection agent based optimization algorithm",
            "authors": [
                {
                    "first": "Vinod",
                    "middle": [],
                    "last": "Chandra",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "S"
                    ],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "J. Insti. Eng",
            "volume": "97",
            "issn": "3",
            "pages": "431--436",
            "other_ids": {
                "DOI": [
                    "10.1007/s40031-014-0182-0"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Baby: automatic test sequence generation for state transition testing via ACO",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Srivastava",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Improved Ant algorithm for software testing cases generation",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Shunkun",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "The Sci. World J",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Generation of test case using automation in software systems -a review",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Maheshwari",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Prasanna",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Indian J. Sci. Technol",
            "volume": "8",
            "issn": "35",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Generating test cases from UML activity diagram based on graybox method",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Linzhang",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Proceedings of the 11th Asia-Pacific Software Engineering Conference",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "State graph.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "the paths or visited status of the paths V s [i] = 1. 2.2 Evaluate feasible path F (P), if any from the first node to the next node in the state graph. Else go to step 6. 2.3 Evaluate probability of the path.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "there is self-transition from (i \u2192 i), select it. 3.1.2 Else select the transition not visited. (V s =0). 3.1.3 Else if two or more transition having the same visited status V s [j] = V s [k], then random selection of the node. 4. Update values of Pheromone and heuristic. 4.1 Update pheromone intensity, \u01ae ij = (\u01ae ij ) \u03b1 * (\u00ef ij ) \u2212\u03b2 4.2 Update heuristic, \u0220 ij = 2 * (\u00ef ij ). 4.3 Update count, Decrement count by one each step. 5. Go to step 2. 6. Stop.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Calculate node coverage (NC) for each test case. Let NC (tc) = t 1 , t 2 \u2026 t n , where t 1 , t 2 , \u2026. t n are transitions. 2. If a number of set tc = 0, then tc is included in the effective set of test cases. 3. Final set of test cases is generated. In our case study, the algorithm is implemented as N = {N0, N1, N2, N3, N4} representing the nodes. ID = {ID1, ID2, \u2026. ID6} representing input data. OD = {OD1, OD2, \u2026. OD6} representing output data. T = {T1, T2, \u2026. T6} representing transitions. Ti is a transition from source node to the destination node. Ti = {Np, Nq}, where Np is the source node and Nq is the destination node. The next step is to extract each transition, T1 = {N0, N1} to T6 = {N2, N4}.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "The transition events are Admitted T1, Dispatch T2, Interrupt T3, I/O Wait T4, I/O Completion T5 and Exit T6. From the state graph, a state table is prepared. Table 1 contains cells of valid and invalid inputs. From the state table, test cases are derived. The test cases generated are stored in a tabular form known as test case table and it contains six columns. The test case table (Table 2) shows that 24 test cases are generated consisting of both valid and invalid test cases. We have to differentiate the valid and invalid test cases. Higher number of invalid test cases shows weak coverage. The solution can be obtained by reducing the test cases by prioritizing the test cases by following the rules. a. Develop test cases consisting of valid test cases that cause a change of state. b. Create test cases such that all test paths are executed at least once and the paths should be feasible.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Test case table",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Comparison of GA, BCO, ACO and m-ACO for APFD and PTR.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Cells containing valid test cases.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "The coverage of different ant numbers on ACIACO ACIACO Statement coverage Branch coverage Modified condition/Decision Coverage",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}