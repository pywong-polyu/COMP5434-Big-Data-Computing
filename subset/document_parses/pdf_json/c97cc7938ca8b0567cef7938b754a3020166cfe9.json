{
    "paper_id": "c97cc7938ca8b0567cef7938b754a3020166cfe9",
    "metadata": {
        "title": "Classification of Linear Codes by Extending Their Residuals",
        "authors": [
            {
                "first": "Stefka",
                "middle": [],
                "last": "Bouyuklieva",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Methodius University of Veliko Tarnovo",
                    "location": {
                        "settlement": "Veliko Tarnovo",
                        "country": "Bulgaria"
                    }
                },
                "email": "stefka@ts.uni-vt.bg"
            },
            {
                "first": "(",
                "middle": [
                    "B"
                ],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Iliya",
                "middle": [],
                "last": "Bouyukliev",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Bulgarian Academy of Sciences",
                    "location": {
                        "postBox": "P.O. Box 323",
                        "settlement": "Veliko Tarnovo",
                        "country": "Bulgaria"
                    }
                },
                "email": "iliyab@math.bas.bg"
            }
        ]
    },
    "abstract": [
        {
            "text": "An approach for classification of linear codes with given parameters starting from their proper residual codes or subcodes is presented. The base of the algorithm is the concept of canonical augmentation which is important for parallel implementations. The algorithms are implemented in the programs LengthExtension and DimExtension of the package QextNewEdition. As an application, the nonexistence of binary [41, 14, 14] codes is proved.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The paper is a contribution to the problem of classifying linear codes with given parameters over finite fields with q elements. Many authors have considered this problem before [2, 3, 5, 10] , and it is known to be very hard. The structure of the codes for classification is very important in the generation process. We discuss an algorithm that solves the following problem: Find all inequivalent codes with given parameters if the set of all residual codes with respect to a codeword with a given weight is given. The extension of the generator matrix of a given residual code can be done row by row or column by column. We consider in more details the problem how to generate only inequivalent codes and obtain all of needed codes. To do this, we use the concept of canonical augmentation [10, 12] . This concept is very important for parallel implementations. We also mention the dual problem namely the classification of linear codes by extending their proper subcodes.",
            "cite_spans": [
                {
                    "start": 178,
                    "end": 181,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 182,
                    "end": 184,
                    "text": "3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 185,
                    "end": 187,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 188,
                    "end": 191,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 793,
                    "end": 797,
                    "text": "[10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 798,
                    "end": 801,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The algorithms presented in this paper are implemented in the programs LengthExtension and DimExtension of the package QextNewEdition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Restrictions on the dual distance, minimum distance, etc. can be applied. The program will be available on the webpage http://www.moi.math.bas.bg/moiuser/ \u223c data/Software/QextNewEdition",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Let q be a prime power and F q the finite field with q elements, F * q = F q \\ {0}. A linear code of length n, dimension k, and minimum distance d over F q is called an [n, k, d] q code. Two linear codes of the same length and dimension are equivalent if one can be obtained from the other by a sequence of the following transformations: (1) a permutation of the coordinate positions of all codewords;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "(2) a multiplication of a coordinate of all codewords with a nonzero element from F q ; (3) a field automorphism. A sequence of the transformations given above that maps a code C to itself is called an automorphism of C. The set of all automorphisms of C forms a group, called the automophism group of the code and denoted by Aut(C). The action of Aut(C) on the code partitions the set of its codewords into orbits.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The defined equivalence relation in the set of all linear [n, k, d] q codes partitions this set into equivalence classes. We choose a canonical representative of each equivalence class. If C is a linear [n, k, d] q code, we call the canonical representative of its equivalence class the canonical form of C and denote it by \u03c1(C). If two codes C 1 and C 2 are equivalent they have the same canonical form, or \u03c1(C 1 ) = \u03c1(C 2 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Let C be an [n, k, d] q code and let c be a codeword of weight w. Then the residual code of C with respect to c, denoted Res(C; c), is the code of length n \u2212 w punctured on the set of coordinates on which c is nonzero. If only the weight w of c is of importance, we will denote it by Res(C; w). The next result gives a lower bound for the minimum distance of residual codes. Theorem 1. [8] Let C be an [n, k, d] code over F q and let c be a codeword of weight w < qd/(q \u2212 1).",
            "cite_spans": [
                {
                    "start": 386,
                    "end": 389,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We need also the following theorem Theorem 2. Let C be an [n, k, d] code over F q and x, y \u2208 C be codewords of the same weight w < qd/(q\u22121) such that y = \u03c6(x) for an automorphism \u03c6 \u2208 Aut(C). Then the residual codes Res(C; x) and Res(C; y) are equivalent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Without loss of generality we can take x = (00 \u00b7 \u00b7 \u00b7 0 11 \u00b7 \u00b7 \u00b7 1 w ). Then the sup-",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Hence the restriction of \u03c6 on the first n \u2212 w coordinates maps Res(C; x) to Res(C; y).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "To see the connection to the dual code, we use a theorem that gives the relation between a punctured of a code C and a shortened of its dual code C \u22a5 . A code C can be punctured on a coordinate set T of size t. We denote the resulting code by C T . Consider the set C(T ) of codewords whose i-th coordinate is 0 if i \u2208 T . C(T ) is a subcode of C. Shortening C(T ) on T gives a code of length n \u2212 t called shortened code of C on T and denoted by C T . If we take T to be the support of the codeword c \u2208 C of weight w, then C T is the residual code of Res(C; c) with respect to c. Theorem 3 ([9, Theorem 1.5.7]). Let C be an [n, k, d] code and T be a set of t coordinates. Then:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "As a corollary we obtain",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Since Res(C; c) \u22a5 is a shortened code of C \u22a5 , its minimum distance is at least d \u22a5 . Therefore we consider all [n \u2212 w, k \u2212 1, d \u2265 d \u2212 w + w/q ] q codes with dual distance \u2265 d \u22a5 as residual codes and then extend them to the linear [n, k, d] q codes with dual distance \u2265 d \u22a5 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We developed a second algorithm which extends all possible [n\u2212w, k\u2212w+1, \u2265 d] shortened codes to the [n, k, d] codes provided that their dual codes contain codewords of weight w, w < qd \u22a5 /(q \u2212 1). The theoretical base of this algorithm is the following corollary.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "(see Theorem 3 and Corollary 1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We are looking for all inequivalent linear codes with length n, dimension k, minimum distance d and dual distance at least d \u22a5 \u2265 2. We propose two algorithms depending on the input codes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Construction"
        },
        {
            "text": "The input in the first algorithm is a set of all inequivalent linear [n\u2212w, k\u22121, \u2265 d ] q codes with dual distance \u2265 d \u22a5 where d > d \u2212 w + w/q . These codes are all possible residual codes of [n, k, d] q linear codes with dual distance at least d \u22a5 with respect to a codeword of weight w.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Construction"
        },
        {
            "text": "Without loss of generality, we can consider the generator matrices in the form 00 \u00b7 \u00b7 \u00b7 0 11 \u00b7 \u00b7 \u00b7 1 G res G 1",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Construction"
        },
        {
            "text": "where G res is a (k\u22121)\u00d7(n\u2212w) matrix that generates the residual code Res(C; x), x = (00 \u00b7 \u00b7 \u00b7 0, 11 \u00b7 \u00b7 \u00b7 1) \u2208 C, wt(x) = w. We construct the matrix G 1 row by row in the same way as it is in the program qext l of the package Q-Extension [3] . The main question is which of the constructed in this way codes to take in our set of representatives of the equivalence classes. To do this, we use canonical augmentation [10, 12] . The presentation that follows differs from the original McKay's paper [12] but the idea is the same. First, we find the canonical form and the automorphism group of the constructed [n, k, d] code C. The orbits are ordered in the way described in [1] and this ordering depends on the canonical form \u03c1(C) and the automorphism group Aut(C). Then we check if the vector x is in the first orbit in the set of all codewords of weight w in C. If not, we reject it (it can be obtained by another residual code), if yes we say that this code passes the parent test. Finally, we check for equivalence the codes obtained from the same residual code that have passed the parent test. A pseudocode is presented in Algorithm 1.",
            "cite_spans": [
                {
                    "start": 238,
                    "end": 241,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 416,
                    "end": 420,
                    "text": "[10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 421,
                    "end": 424,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 497,
                    "end": 501,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 673,
                    "end": 676,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "The Construction"
        },
        {
            "text": "Proof. We have to prove that (1) any [n, k, d] q code with the needed dual distance is equivalent to a code in the set M , and (2) the codes in M are not equivalent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4. The set M , obtained by Algorithm 1, consists of all inequivalent [n, k, d] q codes with dual distance \u2265 d \u22a5 that have codewords of weight w."
        },
        {
            "text": "(1) Let C be an [n, k, d] q code with dual distance \u2265 d \u22a5 . The set of all codewords of weight w is partitioned into orbits under the action of Aut(C). These orbits are ordered depending on the canonical form \u03c1(C) (see [1] for details). Take a codeword x in the first orbit and the residual code Res(C; x). There is a code B \u223c = Res(C; x) in the set R. If \u03c6 maps Res (C; x) into B, we can extend the map \u03c6 to \u03c6 : C \u2192 C , C = \u03c6(C). If x = \u03c6(x), then B = Res(C , x ) and the code C passes the parent test (the codeword x \u2208 C belongs to the first orbit in the partition of the set of all codewords of weight w in C since \u03c1(C) = \u03c1(C )). Hence there is a code that is equivalent to C, has a residual code in the set R and passes the parent test. (2) If C 1 \u223c = C 2 are two codes with the needed parameters, x i \u2208 C i , i = 1, 2 are vectors of weight w, and both codes pass the parent test, then their residuals Res(C 1 , x 1 ) and Res(C 2 , x 2 ) are also equivalent (see Theorem 2).",
            "cite_spans": [
                {
                    "start": 219,
                    "end": 222,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 367,
                    "end": 373,
                    "text": "(C; x)",
                    "ref_id": null
                }
            ],
            "section": "Theorem 4. The set M , obtained by Algorithm 1, consists of all inequivalent [n, k, d] q codes with dual distance \u2265 d \u22a5 that have codewords of weight w."
        },
        {
            "text": "We use the presented algorithms implemented in the programs LengthExtension and DimExtension to obtain a systematic classification of linear codes with specific properties and parameters over fields with 2, 3 and 4 elements.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Examples"
        },
        {
            "text": "Besides specifying the parameters such as length (n), dimension (k) and minimum distance (d), many other constraints can be considered. We give two examples, both over the filed F 2 , but the first one uses the program LengthExtension and the second one DimExtension. All calculations have been done on 2 \u00d7 Intel Xeon E5-2620 V4, 32 thread computer. and weight enumerator W (y) = 1 + 99y 20 + 90y 22 + 15y 24 + 45y 28 + 6y 30 . Its automorphism group is isomorphic to (C 15 : C 4 )\u00d7S 3 , where C 15 : C 4 is the semidirect product of the cyclic groups of orders 15 and 4, and S 3 is the symmetric group (calculated by GAP Computer Algebra System [6] ). The group acts transitively on the coordinates and has order 360. The code is not self-orthogonal.",
            "cite_spans": [
                {
                    "start": 646,
                    "end": 649,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Examples"
        },
        {
            "text": "The following proposition allows one to reduce the number of cases that need to be considered for an exhaustive search for a certain class of codes. Proposition 1. If binary linear [n, k, 2d] codes exist then at least one of these codes is even.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Examples"
        },
        {
            "text": "Proof. Let C be a binary linear [n, k, 2d] code. Suppose that C contains codewords of odd weight. If C * is the punctured code of C on the right-most coordinate then C * is an [n \u2212 1, k, d * ] code where d * = 2d \u2212 1 or 2d. Then we extend C * with one coordinate by adding an overall parity check. The [7] indicates that the existence of [40, 13, 14] binary codes is also unknown. If a code with these parameters exists, its dual distance can be 5 or 6. If C is a [40, 13, 14] binary even code with dual distance 5, it contains an even [35, 9, 14] shortened code with dual distance \u2265 3. By the program DimExtension, we obtain that these codes cannot be extended to [40, 13, 14] binary codes. This means that if a [40, 13, 14] binary even code exists, its dual distance is 6. Then this code contains a shortened code with parameters [34, 8, 14] and dual distance \u2265 3. There are 10 607 917 inequivalent [34, 8, 14] codes with needed dual distance. We were not able to extend all these codes for a reasonable time and therefore we have no result for the codes with parameters [40, 13, 14] .",
            "cite_spans": [
                {
                    "start": 298,
                    "end": 301,
                    "text": "The",
                    "ref_id": null
                },
                {
                    "start": 302,
                    "end": 305,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 536,
                    "end": 540,
                    "text": "[35,",
                    "ref_id": null
                },
                {
                    "start": 541,
                    "end": 543,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 544,
                    "end": 547,
                    "text": "14]",
                    "ref_id": null
                },
                {
                    "start": 665,
                    "end": 669,
                    "text": "[40,",
                    "ref_id": null
                },
                {
                    "start": 670,
                    "end": 673,
                    "text": "13,",
                    "ref_id": null
                },
                {
                    "start": 674,
                    "end": 677,
                    "text": "14]",
                    "ref_id": null
                },
                {
                    "start": 837,
                    "end": 839,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 840,
                    "end": 843,
                    "text": "14]",
                    "ref_id": null
                },
                {
                    "start": 901,
                    "end": 905,
                    "text": "[34,",
                    "ref_id": null
                },
                {
                    "start": 906,
                    "end": 908,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 909,
                    "end": 912,
                    "text": "14]",
                    "ref_id": null
                },
                {
                    "start": 1073,
                    "end": 1077,
                    "text": "[40,",
                    "ref_id": null
                },
                {
                    "start": 1078,
                    "end": 1081,
                    "text": "13,",
                    "ref_id": null
                },
                {
                    "start": 1082,
                    "end": 1085,
                    "text": "14]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Examples"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "About the code equivalence",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Bouyukliev",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Shaska",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Huffman",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Joyner",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Advances in Coding Theory and Cryptology",
            "volume": "",
            "issn": "",
            "pages": "126--151",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Computer classification of linear codes",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Bouyukliev",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bouyuklieva",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kurz",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:2002.07826"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Some new results for optimal ternary linear codes",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Bouyukliev",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Simonis",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "IEEE Trans. Inf. Theory",
            "volume": "48",
            "issn": "4",
            "pages": "981--985",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Classification of the extremal formally self-dual even codes of length 30",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bouyuklieva",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Bouyukliev",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Adv. Math. Commun",
            "volume": "4",
            "issn": "3",
            "pages": "433--439",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Classification and nonexistence results for linear codes with prescribed minimum distances",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Feulner",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Des. Codes Cryptogr",
            "volume": "70",
            "issn": "",
            "pages": "127--138",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "GAP -Groups, Algorithms, and Programming",
            "authors": [
                {
                    "first": "Gap",
                    "middle": [],
                    "last": "The",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Group",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Bounds on the minimum distance of linear codes and quantum codes",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Grassl",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Optimal ternary linear codes",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Hill",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Newton",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Des. Codes Crypt",
            "volume": "2",
            "issn": "",
            "pages": "137--157",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Fundamentals of Error-Correcting Codes",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "C"
                    ],
                    "last": "Huffman",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Pless",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Classification Algorithms for Codes and Designs",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Kaski",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "R"
                    ],
                    "last": "\u00d6sterg\u00e5rd",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Isomorph-free exhaustive generation",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Mckay",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Algorithms",
            "volume": "26",
            "issn": "",
            "pages": "306--324",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "TABREF1": {
            "text": "resulting code C * is even and its parameters are [n, k, 2d]. Proposition 2. Binary linear [41, 14, 14] codes do not exist. Proof. According to Proposition 1, it is enough to prove the nonexistence of even codes with these parameters. Feulner proved in [5] that binary [35, 10, 13] code does not exist. We prove that binary [36, 11, 13] and [37, 12, 13] codes do not exist. The nonexistence of codes with these parameters proves that binary linear [36, 10, 14], [37, 11, 14] and [38, 12, 14] codes do not exist. This gives us that no linear [41 \u2212 i, 15 \u2212 i, 14] 2 codes exist for 1 \u2264 i \u2264 5. According to Corollary 3, the dual distance of a binary [41, 14, 14] must be at least 6. Since no [41, 27, \u2265 7] 2 codes exist [7], d \u22a5 = 6. Therefore we are looking for binary even [41, 14, 14] codes with dual distance 6 and we try to construct them by extending all possible even [35, 9, 14] 2 codes with dual distance \u2265 3. The program Generation shows that there are exactly 209 inequivalent even [35, 9, 14] 2 codes with needed dual distance. Then we try to extend them using the program DimExtension. The result is 'RES 0, Elapsed time: 432m' which means that these codes cannot be extended to [41, 14, 14] codes and this result is obtained in 432 min. Remark 1. The table of optimal codes",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We are greatly indebted to the unknown referees for their useful suggestions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgements."
        },
        {
            "text": "The second algorithm extends all [n\u2212w, k\u2212w+1, \u2265 d] codes to the [n, k, \u2265 d] codes with dual distance d \u22a5 whose dual codes contain codewords of weight w. The generator matrices of the considered codes have the form \u239b w) matrices, respectively. We fill out the matrix A row by row in a similar way as it is done in [4] . The dual code C \u22a5 has a generation matrix 11 \u00b7 \u00b7 \u00b7 1 00 \u00b7 \u00b7 \u00b7 0 G 1 G 2 where G 2 generates the residual code of C \u22a5 with respect to the codewords (11 \u00b7 \u00b7 \u00b7 100 \u00b7 \u00b7 \u00b7 0) of weight w and it is the dual code of C 0 . To take only inequivalent codes, we apply Algorithm 1 to the dual codes.",
            "cite_spans": [
                {
                    "start": 313,
                    "end": 316,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [
                {
                    "start": 216,
                    "end": 218,
                    "text": "w)",
                    "ref_id": null
                }
            ],
            "section": "annex"
        }
    ]
}