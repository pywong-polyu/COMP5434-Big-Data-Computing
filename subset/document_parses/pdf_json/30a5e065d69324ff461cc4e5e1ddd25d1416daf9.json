{
    "paper_id": "30a5e065d69324ff461cc4e5e1ddd25d1416daf9",
    "metadata": {
        "title": "On Computability of Data Word Functions Defined by Transducers",
        "authors": [
            {
                "first": "L\u00e9o",
                "middle": [],
                "last": "Exibard",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e9 Libre de Bruxelles",
                    "location": {
                        "settlement": "Brussels",
                        "country": "Belgium"
                    }
                },
                "email": "leo.exibard@ulb.ac.be"
            },
            {
                "first": "Emmanuel",
                "middle": [],
                "last": "Filiot",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e9 Libre de Bruxelles",
                    "location": {
                        "settlement": "Brussels",
                        "country": "Belgium"
                    }
                },
                "email": ""
            },
            {
                "first": "Pierre-Alain",
                "middle": [],
                "last": "Reynier",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS, LIS",
                    "location": {
                        "settlement": "Marseille",
                        "country": "France"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "In this paper, we investigate the problem of synthesizing computable functions of infinite words over an infinite alphabet (data \u03c9-words). The notion of computability is defined through Turing machines with infinite inputs which can produce the corresponding infinite outputs in the limit. We use non-deterministic transducers equipped with registers, an extension of register automata with outputs, to specify functions. Such transducers may not define functions but more generally relations of data \u03c9-words, and we show that it is PSpace-complete to test whether a given transducer defines a function. Then, given a function defined by some register transducer, we show that it is decidable (and again, PSpace-c) whether such function is computable. As for the known finite alphabet case, we show that computability and continuity coincide for functions defined by register transducers, and show how to decide continuity. We also define a subclass for which those problems are PTime.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Context Program synthesis aims at deriving, in an automatic way, a program that fulfils a given specification. Such setting is very appealing when for instance the specification describes, in some abstract formalism (an automaton or ideally a logic), important properties that the program must satisfy. The synthesised program is then correct-by-construction with regards to those properties. It is particularly important and desirable for the design of safety-critical systems with hard dependability constraints, which are notoriously hard to design correctly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Program synthesis is hard to realise for general-purpose programming languages but important progress has been made recently in the automatic synthesis of reactive systems. In this context, the system continuously receives input signals to which it must react by producing output signals. Such systems are not assumed to terminate and their executions are usually modelled as infinite words over the alphabets of input and output signals. A specification is thus a set of pairs (in,out), where in and out are infinite words, such that out is a legitimate output for in. Most methods for reactive system synthesis only work for synchronous systems over finite sets of input and output signals \u03a3 and \u0393 . In this synchronous setting, input and output signals alternate, and thus implementations of such a specification are defined by means of synchronous transducers, which are B\u00fcchi automata with transitions of the form (q, \u03c3, \u03b3, q ), expressing that in state q, when getting input \u03c3 \u2208 \u03a3, output \u03b3 \u2208 \u0393 is produced and the machine moves to state q . We aim at building deterministic implementations, in the sense that the output \u03b3 and state q uniquely depend on q and \u03c3. The realisability problem of specifications given as synchronous non-deterministic transducers, by implementations defined by synchronous deterministic transducers is known to be decidable [14, 20] . In this paper, we are interested in the asynchronous setting, in which transducers can produce none or several outputs at once every time some input is read, i.e., transitions are of the form (q, \u03c3, w, q ) where w \u2208 \u0393 * . However, such generalisation makes the realisability problem undecidable [2, 9] .",
            "cite_spans": [
                {
                    "start": 1358,
                    "end": 1362,
                    "text": "[14,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1363,
                    "end": 1366,
                    "text": "20]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 1664,
                    "end": 1667,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1668,
                    "end": 1670,
                    "text": "9]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In the setting we just described, the set of signals is considered to be finite. This assumption is not realistic in general, as signals may come with unbounded information (e.g. process ids) that we call here data. To address this limitation, recent works have considered the synthesis of reactive systems processing data words [17, 6, 16, 7] . Data words are infinite words over an alphabet \u03a3 \u00d7 D, where \u03a3 is a finite set and D is a possibly infinite countable set. To handle data words, just as automata have been extended to register automata, transducers have been extended to register transducers. Such transducers are equipped with a finite set of registers in which they can store data and with which they can compare data for equality or inequality. While the realisability problem of specifications given as synchronous non-deterministic register transducers (NRT syn ) by implementation defined by synchronous deterministic register transducers (DRT syn ) is undecidable, decidability is recovered for specifications defined by universal register transducers and by giving as input the number of registers the implementation must have [7, 17] .",
            "cite_spans": [
                {
                    "start": 329,
                    "end": 333,
                    "text": "[17,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 334,
                    "end": 336,
                    "text": "6,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 337,
                    "end": 340,
                    "text": "16,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 341,
                    "end": 343,
                    "text": "7]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1146,
                    "end": 1149,
                    "text": "[7,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1150,
                    "end": 1153,
                    "text": "17]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "Computable Implementations In the previously mentioned works, both for finite or infinite alphabets, implementations are considered to be deterministic transducers. Such an implementation is guaranteed to use only a constant amount of memory (assuming data have size O(1)). While it makes sense with regards to memoryefficiency, some problems turn out to be undecidable, as already mentioned: realisability of NRT syn specifications by DRT syn , or, in the finite alphabet setting, when both the specification and implementation are asynchronous. In this paper, we propose to study computable implementations, in the sense of (partial) functions f of data \u03c9-words computable by some Turing machine M that has an infinite input x \u2208 dom(f ), and produces longer and longer prefixes of the output f (x) as it reads longer and longer prefixes of the input x. Therefore, such a machine produces the output f (x) in the limit. We denote by TM the class of Turing machines computing functions in this sense. As an example, consider the function f that takes as input any data \u03c9-word u = (\u03c3 1 , d 1 )(\u03c3 2 , d 2 ) . . . and outputs (\u03c3 1 , d 1 ) \u03c9 if d 1 occurs at least twice in u, and otherwise outputs u. This function is not computable, as an hypothetic machine could not output anything as long as d 1 is not met a second time. However, the following function g is computable. It is defined only on words (\u03c3 1 , d 1 )(\u03c3 2 , d 2 ) . . . such that \u03c3 1 \u03c3 2 \u00b7 \u00b7 \u00b7 \u2208 ((a + b)c * ) \u03c9 , and transforms any (\u03c3 i , d i ) by (\u03c3 i , d 1 ) if the next symbol in {a, b} is an a, otherwise it keeps (\u03c3 i , d i ) unchanged. To compute it, a TM would need to store d 1 , and then wait until the next symbol in {a, b} is met before outputting something. Since the finite input labels are necessarily in ((a + b)c * ) \u03c9 , this machine will produce the whole output in the limit. Note that g cannot be defined by any deterministic register transducer, as it needs unbounded memory to be implemented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "However, already in the finite alphabet setting, the problem of deciding if a specification given as some non-deterministic synchronous transducer is realisable by some computable function is open. The particular case of realisability by computable functions of universal domain (the set of all \u03c9-words) is known to be decidable [12] . In the asynchronous setting, the undecidability proof of [2] can be easily adapted to show the undecidability of realisability of specifications given by non-deterministic (asynchronous) transducers by computable functions.",
            "cite_spans": [
                {
                    "start": 329,
                    "end": 333,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 393,
                    "end": 396,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "Functional Specifications As said before, a specification is in general a relation from inputs to outputs. If this relation is a function, we call it functional. Due to the negative results just mentioned about the synthesis of computable functions from non-functional specifications, we instead here focus on the case of functional specifications and address the following general question: given the specification of a function of data \u03c9-words, is this function \"implementable\", where we define \"implementable\" as \"being computable by some Turing machine\". Moreover, if it is implementable, then we want a procedure to automatically generate an algorithm that computes it. This raises another important question: how to decide whether a specification is functional ? We investigate these questions for asynchronous register transducers, here called register transducers. This asynchrony allows for much more expressive power, but is a source of technical challenge.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "Contributions In this paper, we solve the questions mentioned before for the class of (asynchronous) non-deterministic register transducers (NRT). We also give fundamental results on this class. In particular, we prove that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "1. deciding whether an NRT defines a function is PSpace-complete, 2. deciding whether two functions defined by NRT are equal on the intersection of their domains is PSpace-complete, 3. the class of functions defined by NRT is effectively closed under composition, 4. computability and continuity are equivalent notions for functions defined by NRT, where continuity is defined using the classical Cantor distance, 5. deciding whether a function given as an NRT is computable is PSpace-c, 6. those problems are in PTime for a subclass of NRT, called test-free NRT.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "Finally, we also mention that considering the class of deterministic register transducers (DRT for short) instead of computable functions as a yardstick for the notion of being \"implementable\" for a function would yield undecidability. Indeed, given a function defined by some NRT, it is in general undecidable to check whether this function is realisable by some DRT, by a simple reduction from the universality problem of non-deterministic register automata [19] .",
            "cite_spans": [
                {
                    "start": 460,
                    "end": 464,
                    "text": "[19]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Synthesis of Transducers with Registers"
        },
        {
            "text": "The notion of continuity with regards to Cantor distance is not new, and for rational functions over finite alphabets, it was already known to be decidable [21] . Its connection with computability for functions of \u03c9-words over a finite alphabet has recently been investigated in [3] for one-way and two-way transducers. Our results lift some of theirs to the setting of data words. The model of test-free NRT can be seen as a one-way non-deterministic version of a model of two-way transducers considered in [5] .",
            "cite_spans": [
                {
                    "start": 156,
                    "end": 160,
                    "text": "[21]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 279,
                    "end": 282,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 508,
                    "end": 511,
                    "text": "[5]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "For a (possibly infinite) set S, we denote by S * (resp. S \u03c9 ) the set of finite (resp. infinite) words over this alphabet, and we let S \u221e = S * \u222a S \u03c9 . For a word u = u 1 . . . u n , we denote u = n its length, and, by convention, for u \u2208 S \u03c9 , u = \u221e. The empty word is denoted \u03b5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Words and Register Transducers"
        },
        {
            "text": "In this case, we define u \u22121 v = w. For u, v \u2208 S \u221e , we say that u and v mismatch, written mismatch(u, v), when there exists a position i such that 1 \u2264 i \u2264 u ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Words and Register Transducers"
        },
        {
            "text": "Finally, for u, v \u2208 S \u221e , we denote by u \u2227 v their longest common prefix, i.e. the longest word w \u2208 S \u221e such that w u and w v.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Words and Register Transducers"
        },
        {
            "text": "Data Words In this paper, \u03a3 and \u0393 are two finite alphabets and D is a countably infinite set of data. We use letter \u03c3 (resp. \u03b3, d) to denote elements of \u03a3 (resp. \u0393 , D). We also distinguish an arbitrary data value d 0 \u2208 D. Given a set R, let \u03c4 R 0 be the constant function defined by \u03c4 R 0 (r) = d 0 for all r \u2208 R. Given a finite alphabet A, a labelled data is a pair x = (a, d) \u2208 A \u00d7 D, where a is the label and d the data. We define the projections lab(x) = a and dt(x) = d. A data word over A and D is an infinite sequence of labelled data, i.e. a word w \u2208 (A \u00d7 D) \u03c9 . We extend the projections lab and dt to data words naturally, i.e. lab(w) \u2208 A \u03c9 and dt(w) \u2208 D \u03c9 . A data word language is a subset L \u2286 (A \u00d7 D) \u03c9 . Note that here, data words are infinite, otherwise they are called finite data words.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Words and Register Transducers"
        },
        {
            "text": "Register transducers are transducers recognising data word relations. They are an extension of finite transducers to data word relations, in the same way register automata [15] are an extension of finite automata to data word languages. Here, we define them over infinite data words with a B\u00fcchi acceptance condition, and allow multiple registers to contain the same data, with a syntax close to [18] . The current data can be compared for equality with the register contents via tests, which are symbolic and defined via Boolean formulas of the following form. Given R a set of registers, a test is a formula \u03c6 satisfying the following syntax:",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 176,
                    "text": "[15]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 396,
                    "end": 400,
                    "text": "[18]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "where r \u2208 R. Given a valuation \u03c4 : R \u2192 D, a test \u03c6 and a data d, we denote by \u03c4, d |= \u03c6 the satisfiability of \u03c6 by d in valuation \u03c4 , defined as \u03c4, d |= r = if \u03c4 (r) = d and \u03c4, d |= r = if \u03c4 (r) = d. The Boolean combinators behave as usual.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "We denote by Tst R the set of (symbolic) tests over R.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "The semantics of a register transducer is given by a labelled transition system:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "* is the set of labels, and we have, for all (q, \u03c4 ), (q , \u03c4 ) \u2208 C and for all (l, w) \u2208 \u039b, that (q, \u03c4 ) -(Matching labels) \u03c3 = \u03c3 -(Compatibility) d satisfies the test \u03c6 \u2208 Tst R , i.e. \u03c4, d |= \u03c6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "-(Update) \u03c4 is the successor register configuration of \u03c4 with regards to d and asgn: \u03c4 (r) = d if r \u2208 asgn, and \u03c4 (r) = \u03c4 (r) otherwise -(Output) By writing o = (\u03b3 1 , r 1 ) . . . (\u03b3 m , r m ), we have that m = n and for all 1 \u2264 i \u2264 n, \u03b3 i = \u03b3 i and d i = \u03c4 (r i ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "Then, a run of T is an infinite sequence of configurations and transitions",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": ". . . We also define its sequence of states st(\u03c1) = q 0 q 1 . . . , and its trace tr",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "Finally, it is accepting if it is both initial and final. We",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "to express that there is a final run \u03c1 of T starting from (q 0 , \u03c4 0 ) such that in(\u03c1) = u and out(\u03c1) = v. In the whole paper, and unless stated otherwise, we always assume that the output of an accepting run is infinite (v \u2208 (\u0393 \u00d7 D) \u03c9 ), which can be ensured by a B\u00fcchi condition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "A partial run is a finite prefix of a run. The notions of input, output and states are extended by taking the corresponding prefixes. We then write (q 0 , \u03c4 0 ) u|v \u2212 \u2212 \u2192 T (q n , \u03c4 n ) to express that there is a partial run \u03c1 of T starting from configuration (q 0 , \u03c4 0 ) and ending in configuration (q n , \u03c4 n ) such that in(\u03c1) = u and out(\u03c1) = v. Finally, the relation represented by a transducer T is:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Register Transducers"
        },
        {
            "text": "As an example, consider the register transducer T rename depicted in Figure 1 . It realises the following transformation: consider a setting in which we deal with logs of communications between a set of clients. Such a log is an infinite sequence of pairs consisting of a tag, chosen in some finite alphabet \u03a3, and the identifier of the client delivering this tag, chosen in some infinite set of data values. The transformation should modify the log as follows: for a given client that needs to be modified, each of its messages should now be associated with some new identifier. The transformation has to verify that this new identifier is indeed free, i.e. never used in the log. Before treating the log, the transformation receives as input the id of the client that needs to be modified (associated with the tag del), and then a sequence of identifiers (associated with the tag ch), ending with #. The transducer is non-deterministic as it has to guess which of these identifiers it can choose to replace the one of the client. In particular, observe that it may associate multiple output words to a same input if two such free identifiers exist.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 69,
                    "end": 77,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Register Transducers"
        },
        {
            "text": "Trename. It has three registers r1, r2 and r0 and four states. \u03c3 denotes any letter in \u03a3, r1 stores the id of del and r2 the chosen id of ch, while r0 is used to output the last data value read as input. As we only assign data to single registers, we write ri for the singleton assignment set {ri}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1. A register transducer"
        },
        {
            "text": "Finite Transducers Since we reduce the decision of continuity and functionality of NRT to the one of finite transducers, let us introduce them: a finite transducer (NFT for short) is an NRT with 0 registers (i.e. R = \u2205). Thus, its transition relation can be represented as ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1. A register transducer"
        },
        {
            "text": "Let T be an NRT with k registers, and let X \u2282 f D be a finite subset of data. Then, T \u2229 (\u03a3 \u00d7 X) \u03c9 \u00d7 (\u0393 \u00d7 X) \u03c9 is recognised by an NFT of exponential size, more precisely with O(|Q| \u00d7 |X| |R| ) states.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1. A register transducer"
        },
        {
            "text": "Although automata are simpler machines than transducers, we only use them as tools in our proofs, which is why we define them from transducers, and not the other way around. A non-deterministic register automaton, denoted NRA, is a transducer without outputs: its transition relation is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "The semantics are the same, except that now we lift the condition that the output v is infinite since there is no output. For A an NRA, we denote L(A) = {u \u2208 (\u03a3 \u00d7 D) \u03c9 | there exists an accepting run \u03c1 of A over u}. Necessarily the output of an accepting run is \u03b5. In this section, we establish technical properties about NRA. Proposition 4, the so-called \"indistinguishability property\", was shown in the seminal paper by Kaminski and Francez [15, Proposition 1] . Their model differs in that they do not allow distinct registers to contain the same data, and in the corresponding test syntax, but their result easily carries to our setting. It states that if an NRA accepts a data word, then such data word can be relabelled with data from any set containing d 0 and with at least k + 1 elements. Indeed, at any point of time, the automaton can only store at most k data in its registers, so its notion of \"freshness\" is a local one, and forgotten data can thus be reused as fresh ones. Moreover, as the automaton only tests data for equality, their actual value does not matter, except for d 0 which is initially contained in the registers.",
            "cite_spans": [
                {
                    "start": 444,
                    "end": 448,
                    "text": "[15,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 449,
                    "end": 463,
                    "text": "Proposition 1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "Such \"small-witness\" property is fundamental to NRA, and will be paramount in establishing decidability of functionality (Section 3) and computability (Section 4). We use it jointly with Lemma 5, which states that the interleaving of the traces of runs of an NRT can be recognised with an NRA, and Lemma 6, which expresses that an NRA can check whether interleaved words coincide on some bounded prefix, and/or mismatch before some given position.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "The runs of a register transducer T can be flattened to their traces, so as to be recognised by an NRA. Those traces can then be interleaved, in order to be compared. The proofs of the following properties are straightforward.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "two runs of a transducer T . Then, we define their interleaving \u03c1 1 \u2297\u03c1 2 = u 1 \u00b7u 1 \u00b7v 1 \u00b7 v 1 \u00b7 u 2 \u00b7 u 2 \u00b7 v 2 \u00b7 v 2 . . . and L \u2297 (T ) = {\u03c1 1 \u2297 \u03c1 2 | \u03c1 1 and \u03c1 2 are accepting runs of T }.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "Lemma 5. If T has k registers, then L \u2297 (T ) is recognised by an NRA with 2k registers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "Then, M i j is recognisable by an NRA with 2 registers and with 1 register if i = \u221e.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Technical Properties of Register Automata"
        },
        {
            "text": "In general, since they are non-deterministic, NRT may not define functions but relations, as illustrated by Example 2. In this section, we first show that deciding whether a given NRT defines a function is PSpace-complete, in which case we call it functional. We show, as a consequence, that testing whether two functional NRT define two functions which coincide on their common domain is PSpace-complete. Finally, we show that functions defined by NRT are closed under composition. This is an appealing property in transducer theory, as it allows to define complex functions by composing simple ones.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Functionality, Equivalence and Composition of NRT"
        },
        {
            "text": "Example 7. As explained before, the transducer T rename described in Example 2 is not functional. To gain functionality, one can reinforce the specification by considering that one gets at the beginning a list of k possible identifiers, and that one has to select the first one which is free, for some fixed k. This transformation is realised by the register transducer T rename2 depicted in Figure 2 (for k = 2).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 392,
                    "end": 400,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Functionality, Equivalence and Composition of NRT"
        },
        {
            "text": ", with four registers r1, r2, r3 and r0 (the latter being used, as in Figure 1 , to output the last read data). After reading the # symbol, it guesses whether the value of register r2 appears in the suffix of the input word. If not, it goes to state 5, and replaces occurrences of r1 by r2. Otherwise, it moves to state 6, waiting for an occurrence of r2, and replaces occurrences of r1 by r3.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 70,
                    "end": 78,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Functionality, Equivalence and Composition of NRT"
        },
        {
            "text": "Let us start with the functionality problem in the data-free case. It is already known that checking whether an NFT over \u03c9-words is functional is decidable [13, 11] . By relying on the pattern logic of [10] designed for transducers of finite words, it can be shown that it is decidable in NLogSpace.",
            "cite_spans": [
                {
                    "start": 156,
                    "end": 160,
                    "text": "[13,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 161,
                    "end": 164,
                    "text": "11]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 202,
                    "end": 206,
                    "text": "[10]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Functionality, Equivalence and Composition of NRT"
        },
        {
            "text": "Deciding whether an NFT is functional is in NLogSpace.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 8."
        },
        {
            "text": "The following theorem shows that a relation between data-words defined by an NRT with k registers is a function iff its restriction to a set of data with at most 2k + 3 data is a function. As a consequence, functionality is decidable as it reduces to the functionality problem of transducers over a finite alphabet.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 8."
        },
        {
            "text": "Theorem 9. Let T be an NRT with k registers. Then, for all X \u2286 D of size |X| \u2265 2k + 3 such that d 0 \u2208 X, we have that T is functional if and only if",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 8."
        },
        {
            "text": "Proof. The left-to-right direction is trivial. Now, assume T is not functional. Let x \u2208 (\u03a3 \u00d7 D) \u03c9 be such that there exists y, z \u2208 (\u0393 \u00d7 D) \u03c9 such that y = z and (x, y), (x, z) \u2208 T . Let i = y \u2227 z . Then, consider the language L = {\u03c1 1 \u2297 \u03c1 2 | \u03c1 1 and \u03c1 2 are accepting runs of T, in(\u03c1 1 ) = in(\u03c1 2 ) and out(\u03c1 1 )\u2227out(\u03c1 2 ) \u2264 i}. Since, by Lemma 5, L \u2297 (T ) is recognised by an NRA with 2k registers and, by Lemma 6, M i \u221e is recognised by an NRA with 2 registers, we get that L = L \u2297 (T ) \u2229 M i \u221e is recognised by an NRA with 2k + 2 registers. Now, L = \u2205, since, by letting \u03c1 1 and \u03c1 2 be the runs of T both with input x and with respective outputs y and z, we have that w = \u03c1 1 \u2297 \u03c1 2 \u2208 L. Let X \u2286 D such that |X| \u2265 2k + 3 and d 0 \u2208 X. By Proposition 4, we get that L \u2229 (\u03a3 \u00d7 X) \u03c9 = \u2205. By letting w = \u03c1 1 \u2297 \u03c1 2 \u2208 L \u2229 (\u03a3 \u00d7 X) \u03c9 , and x = in(\u03c1 1 ) = in(\u03c1 2 ), y = out(\u03c1 1 ) and z = out(\u03c1 2 ), we have that (x , y ), (x , z ) \u2208 T \u2229 ((\u03a3 \u00d7 X) \u03c9 \u00d7 (\u0393 \u00d7 X) \u03c9 ) and y \u2227 z \u2264 i, so, in particular, y = z (since both are infinite words). Thus,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 8."
        },
        {
            "text": "As a consequence of Proposition 8 and Theorem 9, we obtain the following result. The lower bound is obtained by encoding non-emptiness of register automata, which is PSpace-complete [4] .",
            "cite_spans": [
                {
                    "start": 182,
                    "end": 185,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Proposition 8."
        },
        {
            "text": "Deciding whether an NRT T is functional is PSpace-complete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "Hence, the following problem on the equivalence of NRT is decidable:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "Theorem 11. The problem of deciding, given two functions f, g defined by NRT, whether for all",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "} is a function. The latter can be decided by testing whether the disjoint union of the transducers defining f and g defines a function, which is in PSpace by Corollary 10. To show the hardness, we similarly reduce the emptiness problem of NRA A over finite words, just as in the proof of Corollary 10. In particular, the functions f 1 and f 2 defined in this proof (which have the same domain) are equal iff L(A) = \u2205.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "Note that under the promise that f and g have the same domain, the latter theorem implies that it is decidable to check whether the two functions are equal. However, checking dom(f ) = dom(g) is undecidable, as the languageequivalence problem for non-deterministic register automata is undecidable, since, in particular, universality is undecidable [19] .",
            "cite_spans": [
                {
                    "start": 349,
                    "end": 353,
                    "text": "[19]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "Closure under composition is a desirable property for transducers, which holds in the data-free setting [1] . We show that it also holds for functional NRT.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 107,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "Theorem 12. Let f, g be two functions defined by NRT. Then, their composition f \u2022 g is (effectively) definable by some NRT.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "Proof (Sketch). By f \u2022 g we mean f \u2022 g : x \u2192 f (g(x) ). Assume f and g are defined by T f = (Q f , R f , q 0 , F f , \u2206 f ) and T g = (Q g , R g , p 0 , F g , \u2206 g ) respectively. Wlog we assume that the input and output finite alphabets of T f and T g are all equal to \u03a3, and that R f and R g are disjoint. We construct T such that T = f \u2022 g. The proof is similar to the data-free case where the composition is shown via a product construction which simulates both transducers in parallel, executing the second on the output of the first. Assume T g has some transition",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 41,
                    "end": 52,
                    "text": "x \u2192 f (g(x)",
                    "ref_id": null
                }
            ],
            "section": "Corollary 10."
        },
        {
            "text": "Then T has to be able to execute transitions of T f while processing o, even though o does not contain any concrete data values (it is here the main important difference with the data-free setting). However, if T knows the equality types between R f and R g , then it is able to trigger the transitions of T f . For example, assume that o = (a, r g ) and assume that the content of r g is equal to the content of r f , r f being a register of T f , then if T f has some transition of the form p , q ) where the operation r f := r g is a syntactic sugar on top of NRT that intuitively means \"put the content of r g into r f \".",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 495,
                    "end": 500,
                    "text": ", q )",
                    "ref_id": null
                }
            ],
            "section": "Corollary 10."
        },
        {
            "text": "Remark 13. The proof of Theorem 12 does not use the hypothesis that f and g are functions, and actually shows a stronger result, namely that relations defined by NRT are closed under composition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 10."
        },
        {
            "text": "We equip the set of (finite or infinite) data words with the usual distance: for u, v \u2208 (\u03a3 \u00d7 D) \u03c9 , d(u, v) = 0 if u = v and d(u, v) = 2 \u2212 u\u2227v otherwise. A sequence of (finite or infinite) data words (x n ) n\u2208N converges to some infinite data word x if for all > 0, there exists N \u2265 0 such that for all n \u2265 N , d(x n , x) \u2264 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computability and Continuity"
        },
        {
            "text": "In order to reason with computability, we assume in the sequel that the infinite set of data values D we are dealing with has an effective representation. For instance, this is the case when D = N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computability and Continuity"
        },
        {
            "text": "We now define how a Turing machine can compute a function of data words. We consider deterministic Turing machines, which three tapes: a read-only oneway input tape (containing the infinite input data word), a two-way working tape, and a write-only one-way output tape (on which it writes the infinite output data word). Consider some input data word x \u2208 (\u03a3 \u00d7 D) \u03c9 . For any integer k \u2208 N, we let M (x, k) denote the output written by M on its output tape after having read the k first cells of the input tape. Observe that as the output tape is write-only, the sequence of data words (M (x, k)) k\u22650 is non-decreasing.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computability and Continuity"
        },
        {
            "text": "x \u2208 dom(f ), the sequence (M (x, k)) k\u22650 converges to f (x).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 14 (Computability). A function f : (\u03a3 \u00d7 D) \u03c9 \u2192 (\u0393 \u00d7 D) \u03c9 is computable if there exists a deterministic multi-tape machine M such that for all"
        },
        {
            "text": "(a) for all sequences of data words (x n ) n\u2208N converging towards x, where for all i \u2208 N, x i \u2208 dom(f ), we have that (f (x n )) n\u2208N converges to f (x).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Then, f is continuous if and only if it is continuous at each x \u2208 dom(f ). Finally, a functional NRT T is continuous when T is continuous. Example 16. We give an example of a non-continuous function f . The finite input and output alphabets are unary, and are therefore ignored in the description of f . Such function associates with every sequence s = d 1 d 2 \u00b7 \u00b7 \u00b7 \u2208 D \u03c9 the word f (s) = d \u03c9 1 if d 1 occurs infinitely many times in s, otherwise f (s) = s itself. The function f is not continuous. Indeed, by taking d = d , the sequence of data words d",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Moreover, f is realisable by some NRT which non-deterministically guesses whether d 1 repeats infinitely many times or not. It needs only one register r in which to store d 1 . In the first case, it checks whether the current data d is equal the content r infinitely often, and in the second case, it checks that this test succeeds finitely many times, using B\u00fcchi conditions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "One can show that the register transducer T rename2 considered in Example 7 also realises a function which is not continuous, as the value stored in register r 2 may appear arbitrarily far in the input word. One could modify the specification to obtain a continuous function as follows. Instead of considering an infinite log, one considers now an infinite sequence of finite logs, separated by $ symbols. The register transducer T rename3 , depicted in Figure 3 , defines such a function. del, | r1, We now prove the equivalence between continuity and computability for functions defined by NRT. One direction, namely the fact that computability implies continuity, is easy, almost by definition. For the other direction, we rely on the following lemma which states that it is decidable whether a word v can be safely output, only knowing a prefix u of the input. In particular, given a function f , we letf be the function defined over all finite prefixes u of words in dom(f ) byf (u) = (f (uy) | uy \u2208 dom(f )), the longest common prefix of all outputs of continuations of u by f . Then, we have the following decidability result:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 454,
                    "end": 462,
                    "text": "Figure 3",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Lemma 17. The following problem is decidable. Given an NRT T defining a function f , two finite data words u \u2208 (\u03a3 \u00d7 D) * and v \u2208 (\u0393 \u00d7 D) * , decide whether v f (u).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Theorem 18. Let f be a function defined by some NRT T . Then f is continuous iff f is computable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Proof. \u21d0 Assuming f = T is computable by some Turing machine M , we show that f is continuous. Indeed, consider some x \u2208 dom(f ), and some i \u2265 0. As the sequence of finite words (M (x, k)) k\u2208N converges to f (x) and these words have non-decreasing lengths, there exists j \u2265 0 such that |M (x, j)| \u2265 i. Hence, for any data word y \u2208 dom(f ) such that |x \u2227 y| \u2265 j, the behaviour of M on y is the same during the first j steps, as M is deterministic, and thus |f (",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "showing that f is continuous at x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "\u21d2 Assume that f is continuous. We describe a Turing machine computing f ; the corresponding algorithm is formalised as Algorithm 1. When reading a finite prefix Now that we have shown that computability is equivalent with continuity for functions defined by NRT, we exhibit a pattern which allows to decide continuity. Such pattern generalises the one of [3] to the setting of data words, the difficulty lying in showing that our pattern can be restricted to a finite number of data.",
            "cite_spans": [
                {
                    "start": 355,
                    "end": 358,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Theorem 19. Let T be a functional NRT with k registers. Then, for all X \u2286 D such that |X| \u2265 2k + 3 and d 0 \u2208 X, T is not continuous at some x \u2208 (\u03a3 \u00d7 D) \u03c9 if and only if T is not continuous at some z \u2208 (\u03a3 \u00d7 X) \u03c9 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Proof. The right-to-left direction is trivial. Now, let T be a functional NRT with k registers which is not continuous at some",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Now, let X \u2286 D be such that |X| \u2265 2k + 3 and d 0 \u2208 X. We need to build two words u and v labelled over X which coincide on a sufficiently long prefix to allow for pumping, hence yielding a converging sequence of input data words whose images do not converge, witnessing non-continuity. To that end, we use a similar proof technique as for Theorem 9: we show that the language of interleaved runs whose inputs coincide on a sufficiently long prefix while their respective outputs mismatch before a given position is recognisable by an NRA, allowing us to use the indistinguishability property. We also ask that one run presents sufficiently many occurrences of a final state q f , so that we can ensure that there exists a pair of configurations containing q f which repeats in both runs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "On reading such u and v, the automaton behaves as a finite automaton, since the number of data is finite ([15, Proposition 1]). By analysing the respective runs, we can, using pumping arguments, bound the position on which the mismatch appears in u, then show the existence of a synchronised loop over u and v after such position, allowing us to build the sought witness for non-continuity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Relabel over X Thus, assume T is not continuous at some point x \u2208 (\u03a3 \u00d7 D) \u03c9 . Let \u03c1 be an accepting run of T over x, and let q f \u2208 inf(st(\u03c1)) \u2229 F be an accepting state repeating infinitely often in \u03c1. Then, let i \u2265 0 be such that for all j \u2265 0, there exists y \u2208 dom(f ) such that x \u2227 y \u2265 j but f (x) \u2227 f (y) \u2264 i. Now, define K = |Q| \u00d7 (2k + 3) 2k and let m = (2i + 3) \u00d7 (K + 1). Finally, pick j such that \u03c1[1:j] contains at least m occurrences of q f . Consider the language: Choose y \u2208 dom(f ) such that x \u2227 y \u2265 j but f (x) \u2227 f (y) \u2264 i. By letting \u03c1 1 (resp. \u03c1 2 ) be an accepting run of T over x (resp. y) we have \u03c1 1 \u2297 \u03c1 2 \u2208 L, so L = \u2205. By Proposition 4, Figure 4 , where we decompose u as u = u 1 . . . u m \u00b7s and v as v = u 1 . . . u m \u00b7t; their corresponding images being respectively u = u 1 . . . u m \u00b7 s and u = u 1 . . . u m t . We also let l = (i + 1)(K + 1) and l = 2(i + 1)(K + 1). Since the data of u, v and w belong to X, we know that Repeating configurations First, let us observe that in a partial run of \u03c1 1 containing more than |Q| \u00d7 |X| k occurrences of q f , there is at least one productive transition, i.e. a transition whose output is o = \u03b5. Otherwise, by the pigeonhole principle, there exists a configuration \u00b5 : R \u2192 X such that (q f , \u00b5) occurs at least twice in the partial run. Since all transitions are improductive, it would mean that, by writing w the corresponding part of input, we have (q f , \u00b5)",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 659,
                    "end": 667,
                    "text": "Figure 4",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": ". This partial run is part of \u03c1 1 , so, in particular, (q f , \u00b5) is accessible, hence by taking",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "we have that f (w 0 w \u03c9 ) = w 0 , which is a finite word, contradicting our assumption that all accepting runs produce an infinite output. This implies that, for any n \u2265 |Q| \u00d7 |X| k (in particular for n = l), u 1 . . . u n \u2265 i + 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Locate the mismatch Again, upon reading u l+1 . . . u l , there are (i + 1)(K + 1) occurrences of q f . There are two cases:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "(a) There are at least i + 1 productive transitions in \u03c1 2 . Then, we obtain that u 1 . . . u l > i, so mismatch(u 1 . . . u l , u 1 . . . u l ), since we know f (u) \u2227 f (v) \u2264 i and they are respectively prefixes of f (u) and f (v), both of length at least i+1. Afterwards, upon reading u l +1 . . . u m , there are K+1 > |Q|\u00d7|X| 2k occurrences of q f , so, by the pigeonhole principle, there is a repeating pair: there exist indices p and p such that l \u2264 p < p \u2264 m and (q f , \u00b5 p ) = (q f , \u00b5 p ), (q p , \u03c4 p ) = (q p , \u03c4 p ). Thus, let z P = u 1 . . . u p , z R = u p+1 . . . u p and z C = u p +1 . . . u m \u00b7 t (P stands for prefix, R for repeat and C for continuation; we use capital letters to avoid confusion with indices). By denoting z P = u 1 . . . u p , z R = u p+1 . . . u p , z P = u 1 . . . u p , z R = u p+1 . . . u p and z C = u p +1 . . . u m \u00b7 t the corresponding images, z = z P \u00b7 z R \u03c9 is a point of discontinuity. Indeed, define (z n ) n\u2208N as, for all n \u2208 N, z n = z P \u00b7 z n R \u00b7 z C . Then, (z n ) n\u2208N converges towards z, but, since for all n \u2208 N, f (z n ) = z P \u00b7 z L n \u00b7 z C , we have that f (z n ) \u2212 \u2212 \u2192 n\u221e f (z) = z P \u00b7 z L \u03c9 , since mismatch(z P , z P ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "(b) Otherwise, by the same reasoning as above, it means there exists a repeating pair with only improductive transitions in between: there exist indices p and p such that l \u2264 p < p \u2264 l , (q f , \u00b5 p ) = (q f , \u00b5 p ), (q p , \u03c4 p ) = (q p , \u03c4 p ),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "Then, by taking z P = u 1 . . . u p , z R = u p+1 . . . u p and z C = u p +1 . . . u m \u00b7 t, we have, by letting z P = u 1 . . . u p , z R = u p+1 . . . u p , z P = u 1 . . . u p , z R = \u03b5 and z C = u n +1 . . . u m \u00b7 t , that z = z P \u00b7 z R \u03c9 is a point of discontinuity. Indeed, define (z n ) n\u2208N as, for all n \u2208 N, z n = z P \u00b7 z n R \u00b7 z C . Then, (z n ) n\u2208N indeed converges towards z, but, since for all n \u2208 N, f (z n ) = z P \u00b7 z C , we have that f (z n ) \u2212 \u2212 \u2192 n\u221e f (z) = z P \u00b7 z R \u03c9 , since mismatch(z P , z P \u00b7 z C ) (the mismatch necessarily lies in z P , since z P \u2265 i + 1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 15 (Continuity). A function"
        },
        {
            "text": "PSpace-complete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 20. Deciding whether an NRT defines a continuous function is"
        },
        {
            "text": "Proof. Let X \u2286 D be a set of size 2k + 3 containing d 0 . By Theorem 19, T is not continuous iff it is not continuous at some z \u2208 (\u03a3 \u00d7 X) \u03c9 , iff T \u2229 (\u03a3 \u00d7 X) \u03c9 \u00d7 (\u0393 \u00d7 X) \u03c9 is not continuous. By Proposition 3, such relation is recognisable by a finite transducer T X with O(|Q| \u00d7 |X| |R| ) states, which can be built on-the-fly. By [3] , the continuity of functions defined by NFT is decidable in NLogSpace, which yields a PSpace procedure.",
            "cite_spans": [
                {
                    "start": 331,
                    "end": 334,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Corollary 20. Deciding whether an NRT defines a continuous function is"
        },
        {
            "text": "For the hardness, we reduce again from the emptiness problem of register automata, which is PSpace-complete [4] . Let A be a register automaton over some alphabet \u03a3 \u00d7 D. We construct a transducer T which defines a continuous function iff L(A) = \u2205 iff the domain of T is empty. Let f be a non-continous function realised by some NRT H (it exists by Example 16). Then, let # \u2208 \u03a3 be a fresh symbol, and define the function g as the function mapping any data word of the form w(#, d)w to w(#, d)f (w ) if w \u2208 L(A). The function g is realised by an NRT which simulates A and copies its inputs on the output to implement the identity, until it sees #. If it was in some accepting state of A before seeing #, it branches to some initial state of H and proceeds executing H. If there is some w 0 \u2208 L(A), then the subfunction g w0 mapping words of the form w 0 (#, d)w to w 0 (#, d)f (w ) is not continuous, since f is not. Hence g is not continuous. Conversely, if L(A) = \u2205, then dom(g) = \u2205, so g is continuous.",
            "cite_spans": [
                {
                    "start": 108,
                    "end": 111,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Corollary 20. Deciding whether an NRT defines a continuous function is"
        },
        {
            "text": "In [3] , non-continuity is characterised by a specific pattern (Lemma 21, Figure 1 ), i.e. the existence of some particular sequence of transitions. By applying this characterisation to the finite transducer recognising T \u2229 ((\u03a3 \u00d7 X) \u03c9 \u00d7 (\u0393 \u00d7 X) \u03c9 ), as constructed in Proposition 3, we can characterise non-continuity by a similar pattern, which will prove useful to decide (non-)continuity of test-free NRT in NLogSpace (cf Section 5):",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 6,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 74,
                    "end": 82,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Corollary 20. Deciding whether an NRT defines a continuous function is"
        },
        {
            "text": "Corollary 21 ( [3] ). Let T be an NRT with k registers. Then, for all X \u2286 D such that |X| \u2265 2k + 3 and d 0 \u2208 X, T is not continuous at some x \u2208 (\u03a3 \u00d7 D) \u03c9 if and only if it has the pattern of Figure 5 . , where q f is accepting, as well as finite input data words u, v, finite output data words u , v , u , v , and an infinite input data word w admitting an accepting run from configuration (q, \u03c4 ) producing output w , such that mismatch(u , u ) \u2228 (v = \u03b5 \u2227 mismatch(u , u w )).",
            "cite_spans": [
                {
                    "start": 15,
                    "end": 18,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 191,
                    "end": 199,
                    "text": "Figure 5",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Corollary 20. Deciding whether an NRT defines a continuous function is"
        },
        {
            "text": "In [7] , we introduced a restriction which allows to recover decidability of the bounded synthesis problem for specifications expressed as non-deterministic register automata. Applied to transducers, such restriction also yields polynomial complexities when considering the functionality and computability problems. An NRT T is test-free when its transition function does not depend on the tests conducted over the input data. Formally, we say that T is test-free if for all",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 6,
                    "text": "[7]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Thus, we can omit the tests altogether and its transition relation can be represented as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Example 22. Consider the function f : (\u03a3 \u00d7 D) \u03c9 \u2192 (\u0393 \u00d7 D) \u03c9 associating, to x = (\u03c3 1 , d 1 )(\u03c3 2 , d 2 ) . . . , the value (\u03c3 1 , d 1 )(\u03c3 2 , d 1 )(\u03c3 3 , d 1 ) . . . if there are infinitely many a in x, and (\u03c3 1 , d 2 )(\u03c3 2 , d 2 )(\u03c3 3 , d 2 ) . . . otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "f can be implemented using a test-free NRT with one register: it initially guesses whether there are infinitely many a in x, if it is the case, it stores d 1 in the single register r, otherwise it waits for the next input to get d 2 and stores it in r. Then, it outputs the content of r along with each \u03c3 i . f is not continuous, as even outputting the first data requires reading an infinite prefix when d 1 = d 2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Note that when a transducer is test-free, the existence of an accepting run over a given input x only depends on its finite labels. Hence, the existence of two outputs y and z which mismatch over data can be characterised by a simple pattern (Figure 6 ), which allows to decide functionality in polynomial time:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 242,
                    "end": 251,
                    "text": "(Figure 6",
                    "ref_id": "FIGREF9"
                }
            ],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Theorem 23. Deciding whether a test-free NRT is functional is in PTime.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Proof. Let T be a test-free NRT such that T is not functional. Then, there exists x \u2208 (\u03a3 \u00d7 D) \u03c9 , y, z \u2208 (\u0393 \u00d7 D) \u03c9 such that (x, y), (x, z) \u2208 T and y = z. Then, let i be such that y[i] = z[i]. There are two cases. Either lab(y[i]) = lab(z[i]), which means that the finite transducer T obtained by ignoring the registers of T is not functional. By Proposition 8, such property can be decided in NLogSpace, so let us focus on the second case: ). Finally, for readability, we did not write that r should not be reassigned between j and l . Note that the position of i with regards to j, j , l and l does not matter; nor does the position of l w.r.t. l .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "We here give a sketch of the proof: observe that an input x admits two outputs which mismatch over data if and only if it admits two runs which respectively store x[j] and x[j ] such that x[j] = x[j ] and output them later at the same output position i; the outputs y and z are then such that dt(y[i]) = dt(z[i]). Since T is test-free, the existence of two runs over the same input x only depends on its finite labels. Then, the registers containing respectively x[j] and x[j ] should not be reassigned before being output, and should indeed output their content at the same position i (cf Figure 6) . Besides, again because of test-freeness, we can always assume that x is such that x[j] = x[j ]. Overall, such pattern can be checked by a 2-counter Parikh automaton, whose emptiness is decidable in PTime [8] (under conditions that are satisfied here). Now, let us move to the case of continuity. Here again, the fact that test-free NRT conduct no test over the input data allows to focus on the only two registers that are responsible for the mismatch, the existence of an accepting run being only determined by finite labels.",
            "cite_spans": [
                {
                    "start": 806,
                    "end": 809,
                    "text": "[8]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [
                {
                    "start": 590,
                    "end": 599,
                    "text": "Figure 6)",
                    "ref_id": "FIGREF9"
                }
            ],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Theorem 24. Deciding whether a test-free NRT defines a continuous function is in PTime.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Proof. Let T be a test-free NRT. First, it can be shown that T is continuous if and only if T has the pattern of Figure 7 , where r is coaccessible (since acceptance only depends on finite labels, T can be trimmed 3 in polynomial time). Fig. 7 . A pattern characterising non-continuity of functions defined by NRT, where we ask that there exist some states q f , q and r, where q f is accepting, as well as finite input data words u, v, z and finite output data words u , v , u , v , z such that mismatch(u , u )\u2228(v = \u03b5 \u2227 mismatch(u , u z )). Register assignments are not depicted, as there are no conditions on them. We unrolled the loops to highlight the fact that they do not necessarily loop back to the same configuration.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 113,
                    "end": 121,
                    "text": "Figure 7",
                    "ref_id": null
                },
                {
                    "start": 237,
                    "end": 243,
                    "text": "Fig. 7",
                    "ref_id": null
                }
            ],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Now, it remains to show that such simpler pattern can be checked in PTime. We treat each part of the disjunction separately: q, where q f \u2208 F and mismatch(u , u ). Then, as shown in the proof of Theorem 23, there exists a mismatch between some u and u produced by the same input u if and only if there exists two runs and two registers r and r assigned at two distinct positions, and later on output at the same position. Such pattern can similarly be checked by a 2-counter Parikh automaton; the only difference is that here, instead of checking that the two end states are coaccessible with a common \u03c9-word, we only need to check that q f \u2208 F and that there is a synchronised loop over q f and q, which are regular properties that can be checked by the Parikh automaton with only a polynomial increase. , where q f \u2208 F and mismatch(u , u z ). By examining again the proof of Theorem 23, it can be shown that to obtain a mismatch, it suffices that the input is the same for both runs only up to position max(j, j ). More precisely, there is a mismatch between u and u z if and only if there exists two registers r and r and two positions j, j \u2208 {1, . . . , u } such that j = j , r is stored at position j, r is stored at position j , r and r are respectively output at input positions l \u2208 {1, . . . , u } and l \u2208 {1, . . . , uz } and they are not reassigned in the meantime. Again, such property, along with the fact that q f \u2208 F and the existence of a synchronised loop can be checked by a 2-counter Parikh automaton of polynomial size.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        },
        {
            "text": "Overall, deciding whether a test-free NRT is continuous is in PTime.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Test-free Register Transducers"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Transductions and Context-free Languages",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Berstel",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Uniformization in Automata Theory",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Carayol",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "L\u00f6ding",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings of the 14th Congress of Logic",
            "volume": "",
            "issn": "",
            "pages": "153--178",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Deciding the computability of regular functions over infinite words",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Dave",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Filiot",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "N"
                    ],
                    "last": "Krishna",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lhote",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "LTL with the freeze quantifier and register automata",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Demri",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Lazic",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ACM Trans. Comput. Log",
            "volume": "10",
            "issn": "3",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Regular transformations of data words through origin information",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Durand-Gasselin",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Habermehl",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Foundations of Software Science and Computation Structures -19th International Conference, FOSSACS 2016, Held as Part of the European Joint Conferences on Theory and Practice of Software",
            "volume": "",
            "issn": "",
            "pages": "285--300",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-49630-5_17"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Synthesis with identifiers",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Ehlers",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "A"
                    ],
                    "last": "Seshia",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kress-Gazit",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the 15th International Conference on Verification, Model Checking, and Abstract Interpretation",
            "volume": "8318",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-54013-4_23"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Synthesis of data word transducers",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Exibard",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Filiot",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Reynier",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "30th International Conference on Concurrency Theory, CONCUR 2019",
            "volume": "24",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Path logics for querying graphs: Combining expressiveness and efficiency",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Figueira",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Libkin",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "30th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2015",
            "volume": "",
            "issn": "",
            "pages": "329--340",
            "other_ids": {
                "DOI": [
                    "10.1109/LICS.2015.39"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "On equivalence and uniformisation problems for finite transducers",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Filiot",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Jecker",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "L\u00f6ding",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Winter",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "43rd International Colloquium on Automata, Languages, and Programming, ICALP 2016",
            "volume": "125",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.ICALP.2016.125"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A pattern logic for automata with outputs",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Filiot",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Mazzocchi",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Raskin",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Developments in Language Theory -22nd International Conference",
            "volume": "",
            "issn": "",
            "pages": "304--317",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-98654-8_25"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Two decidability problems for infinite words",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Gire",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "Inf. Process. Lett",
            "volume": "22",
            "issn": "3",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/0020-0190(86)90058-X"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Degrees of lookahead in regular infinite games",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Holtmann",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kaiser",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Thomas",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Logical Methods in Computer Science",
            "volume": "8",
            "issn": "3",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Equivalence problems for mappings on infinite strings",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "C"
                    ],
                    "last": "Ii",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "K"
                    ],
                    "last": "Pachl",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Information and Control",
            "volume": "49",
            "issn": "1",
            "pages": "90444--90451",
            "other_ids": {
                "DOI": [
                    "10.1016/S0019-9958(81)90444-7"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Solving sequential conditions finite-state strategies",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "R"
                    ],
                    "last": "B\u00fcchi",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "H"
                    ],
                    "last": "Landweber",
                    "suffix": ""
                }
            ],
            "year": 1969,
            "venue": "Transactions of the American Mathematical Society",
            "volume": "138",
            "issn": "",
            "pages": "295--311",
            "other_ids": {
                "DOI": [
                    "10.2307/1994916"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Finite-memory automata",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kaminski",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Francez",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Theor. Comput. Sci",
            "volume": "134",
            "issn": "2",
            "pages": "90242--90251",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(94)90242-9"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Register-bounded synthesis",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Khalimov",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kupferman",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "30th International Conference on Concurrency Theory, CONCUR",
            "volume": "25",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Bounded synthesis of register transducers",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Khalimov",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Maderbacher",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bloem",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Automated Technology for Verification and Analysis, 16th International Symposium",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-01090-4_29"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Regular expressions for data words",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Libkin",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Tan",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Vrgoc",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "J. Comput. Syst. Sci",
            "volume": "81",
            "issn": "7",
            "pages": "1278--1297",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jcss.2015.03.005"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Finite state machines for strings over infinite alphabets",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schwentick",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Vianu",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "ACM Trans. Comput. Logic",
            "volume": "5",
            "issn": "3",
            "pages": "403--435",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "On the synthesis of a reactive module",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Pnueli",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Rosner",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "ACM Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "How to decide continuity of rational functions on infinite words",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Prieur",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Theor. Comput. Sci",
            "volume": "276",
            "issn": "1-2",
            "pages": "307--310",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(01)00307-3"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made. The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "that, by writing l = (\u03c3 , d) and w = (\u03b3 1 , d 1 ) . . . (\u03b3 n , d n ):",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "A register transducer Trename3. This transducer is non-deterministic, yet it defines a continuous function.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "x[:j] of its input x \u2208 dom(f ), it computes the set P j of all configurations (q, \u03c4 ) reached by T on x[:j]. This set is updated along taking increasing values of j. It also keeps in memory the finite output word o j that has been output so far. For any j, if dt(x[:j]) denotes the data that appear in x, the algorithm then decides, for each input (\u03c3, d) \u2208 \u03a3 \u00d7 (dt(x[:j]) \u222a {d 0 }) whether (\u03c3, d) can safely be output, i.e., whether all accepting runs on words of the form x[:j]y, for an infinite word y, outputs at least o j (\u03c3, d). The latter can be decided, given T , o j and x[:j], by Lemma 17. Note that it suffices to look at data in dt(x[:j]) \u222a {d 0 } only since, by definition of NRT, any data that is output is necessarily stored in some register, and therefore appears in x[:j] or is equal to d 0 . Let us show that Algorithm 1: Algorithm describing the machine M f computing f . Data: x \u2208 dom(f ) 1 o := ; 2 for j = 0 to \u221e do 3 for (\u03c3, d) \u2208 \u03a3 \u00d7 (dt(x[:j]) \u222a {d0}) do 4 if o.(\u03c3, d) f (x[:j]) then // such test is decidable by M f actually computes f . Let x \u2208 dom(f ). We have to show that the sequence (M f (x, j)) j converges to f (x). Let o j be the content of variable o of M f when exiting the inner loop at line 8, when the outer loop (line 2) has been executed j times (hence j input symbols have been read). Note that o j = M f (x, j).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "out(\u03c1 1 ) \u2227 out(\u03c1 2 ) \u2264 i and there are at least m occurrences of q f in \u03c1 1 [1:j] By Lemma 5, L \u2297 (T ) is recognised by an NRA with 2k registers. Additionnally, by Lemma 6, M i j is recognised by an NRA with 2 registers. Thus, L = L \u2297 (checks there are at least m occurrences of q f in \u03c1 1 [1:j] (this is easily doable from the automaton recognising L \u2297 (T ) by adding an m-bounded counter), is recognisable by an NRA with 2k + 2 registers.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "and there are at least m occurrences of q f in \u03c1 1 [1:j]. Now, we depict \u03c1 1 and \u03c1 2 in",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Runs of f over u = u1 . . . um \u00b7 s and v = u1 . . . um \u00b7 t.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "A pattern characterising non-continuity of functions definable by an NRT: we ask that there exist configurations (q f , \u00b5) and (q, \u03c4 )",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "A situation characterising the existence of a mismatch over data. Since acceptance does not depend on data, we can always choose x such that dt(x[j]) = dt(x[j ]). Here, we assume that the labels of x, y and z range over a unary alphabet; in particulary[i] = x[j] iff dt(y[i]) = dt(x[j]",
            "latex": null,
            "type": "figure"
        },
        "TABREF1": {
            "text": "To show that (o j ) j converges to f (x), it remains to show that (o j ) j is non-stabilising, i.e. o i1 \u227a o i2 \u227a . . . for some infinite subsequence i 1 < i 2 < . . . . First, note that f being continuous is equivalent to the sequence (f (x[:k])) k converging to f (x). Therefore we have that f (x) \u2227f (x[:k]) can be arbitrarily long, for sufficiently large k. Let j \u2265 0 and (\u03c3, d) = f (x)[|o j |+1]. By the latter property and the fact that o j .(\u03c3, d) f (x), necessarily, there exists some k > j such that o j .(\u03c3, d)f (x[:k]). Moreover, by definition of NRT, d is necessarily a data that appears in some prefix of x, therefore there exists k \u2265 k such that d appears in x[:k ] and o j .(\u03c3, d) that for all for all j, there exists k > j such that o j \u227a o k , which concludes the proof.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}