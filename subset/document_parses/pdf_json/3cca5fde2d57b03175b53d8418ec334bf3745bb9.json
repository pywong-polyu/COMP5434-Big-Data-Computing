{
    "paper_id": "3cca5fde2d57b03175b53d8418ec334bf3745bb9",
    "metadata": {
        "title": "Focused Proof-search in the Logic of Bunched Implications",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Gheorghiu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University College London",
                    "location": {
                        "settlement": "London",
                        "country": "United Kingdom"
                    }
                },
                "email": "alexander.gheorghiu.19@ucl.ac.uk"
            },
            {
                "first": "Sonia",
                "middle": [],
                "last": "Marin",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University College London",
                    "location": {
                        "settlement": "London",
                        "country": "United Kingdom"
                    }
                },
                "email": "s.marin@ucl.ac.uk"
            }
        ]
    },
    "abstract": [
        {
            "text": "The logic of Bunched Implications (BI) freely combines additive and multiplicative connectives, including implications; however, despite its well-studied proof theory, proof-search in BI has always been a difficult problem. The focusing principle is a restriction of the proofsearch space that can capture various goal-directed proof-search procedures. In this paper we show that focused proof-search is complete for BI by first reformulating the traditional bunched sequent calculus using the simpler data-structure of nested sequents, following with a polarised and focused variant that we show is sound and complete via a cut-elimination argument. This establishes an operational semantics for focused proofsearch in the logic of Bunched Implications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The Logic of Bunched Implications (BI) [31] is well-known for its applications in systems modelling [32] , especially a particular theory (of a variant of BI) called Separation Logic [37, 23] which has found industrial use in program verification. In this work, we study an aspect of proof search in BI, relying on its well-developed and well-studied proof theory [33] . We show that a goal-directed proof-search procedure known as focused proof-search is complete; that is, if there is a proof then there is a focused one. Focused proofs are both interesting in the abstract, giving insight into the proof theory of the logic, and have (for other logics) been a useful modelling technology in applied settings. For example, focused proof-search forms an operational semantics of the DPLL SAT-solvers [14] , logic programming [29, 1, 13, 7] , automated theorem provers [28] , and has been successful in providing a meta-theoretic framework in intuitionistic, substructural, and modal logics [27, 30, 25] .",
            "cite_spans": [
                {
                    "start": 39,
                    "end": 43,
                    "text": "[31]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 100,
                    "end": 104,
                    "text": "[32]",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 183,
                    "end": 187,
                    "text": "[37,",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 188,
                    "end": 191,
                    "text": "23]",
                    "ref_id": null
                },
                {
                    "start": 364,
                    "end": 368,
                    "text": "[33]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 801,
                    "end": 805,
                    "text": "[14]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 826,
                    "end": 830,
                    "text": "[29,",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 831,
                    "end": 833,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 834,
                    "end": 837,
                    "text": "13,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 838,
                    "end": 840,
                    "text": "7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 869,
                    "end": 873,
                    "text": "[28]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 991,
                    "end": 995,
                    "text": "[27,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 996,
                    "end": 999,
                    "text": "30,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 1000,
                    "end": 1003,
                    "text": "25]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Syntactically BI combines additive and multiplicative connectives, but unlike related logics such as Linear Logic (LL) [22] , BI takes all the connectives as primitive. Indeed, it arose from a proof-theoretic investigation on the relationship between conjunction and implication. As a result, sequents in BI have a more complicated structure: each implication comes with an associated contextformer. Therefore, in BI contexts are not lists, nor multisets, but instead are bunches: binary trees whose leaves are formulas and internal nodes contextformers. Additive composition (\u0393 ; \u2206) admits the structural rules of weakening and contraction, whereas multiplicative composition (\u0393, \u2206) denies them. The principal technical challenges when studying proof-search in BI arise from the interaction between the additive and multiplicative fragments. We overcome these challenges by restricting the application of structural rules in the sequent calculus LBI as well as working with a representation of bunches as nested multisets.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 123,
                    "text": "[22]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Throughout we use the term sequent calculus in a strict sense; that is, meaning a label-free internal sequent calculus, formed in the case of BI by a context (a bunch) and a consequent (a formula). The term proof-search is consistently understood to be read as backward reduction within such a system. Although there is an extensive body of research on systems and procedures for semanticsbased calculi in BI [19, 20, 16, 17, 18] , there has been comparatively little formal study on proof-search in the strict sense. One exception is the completeness result for (unit-simple) uniform proofs [2] which is partially subsumed by the results herein.",
            "cite_spans": [
                {
                    "start": 409,
                    "end": 413,
                    "text": "[19,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 414,
                    "end": 417,
                    "text": "20,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 418,
                    "end": 421,
                    "text": "16,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 422,
                    "end": 425,
                    "text": "17,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 426,
                    "end": 429,
                    "text": "18]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 592,
                    "end": 595,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The focusing principle was introduced for Linear Logic [1] and is characterised by alternating focused and unfocused phases of goal-directed proof-search. The unfocused phase comprises rules which are safe to apply (i.e. rules where provability is invariant); conversely, the focused phase contains the reduction of a formula and its sub-formulas where potentially invalid sequents may arise, and backtracking may be required. During focused proof-search the unfocused phases are performed eagerly, followed by controlled goal-directed focused phases, until safe reductions are available again. We say that the focusing principle holds when every provable sequent has a focused proof. This alternation can be enforced by a mechanism based on a partition of the set of formulas into two classes, positive and negative, which correspond to safe behaviour on the left and right respectively; that is, for negative formulas provability is invariant with respect to the application of a right rule, and for positive formulas, of a left rule, but in the other cases the application may result in invalid sequents.",
            "cite_spans": [
                {
                    "start": 55,
                    "end": 58,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The original proof of the focusing principle in Linear Logic was via long and tedious permutations of rules [1] . In this paper, we use for BI a different methodology, originally presented in [24] , which has since been implemented in a variety of logics [25, 5, 6] and proof systems [13] . The method is as follows: given a sequent calculus, first one polarises the syntax according to the positive/negative behaviours; second, one gives a focused variation of the sequent calculus where the control flow of proof-search is managed by polarisation; third, one shows that this system admits cut (the only non-analytic rule); and, finally, one shows that in the presence of cut the original sequent calculus may be simulated in the focused one. When the polarised system is complete, the focusing principle holds.",
            "cite_spans": [
                {
                    "start": 108,
                    "end": 111,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 192,
                    "end": 196,
                    "text": "[24]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 255,
                    "end": 259,
                    "text": "[25,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 260,
                    "end": 262,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 263,
                    "end": 265,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 284,
                    "end": 288,
                    "text": "[13]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In LBI certain rules (the structural rules) have no natural placement in either the focused or the unfocused phases of proof-search. Thus, a design choice must be made: to eliminate/constrain these rules, or to permit them without restriction. The first gives a stricter control proof-search regime, but the latter typically achieves a more well-behaved proof theoretic meta-theory. In this paper, we choose the former as our motivation is to study computational behaviour of proof-search in BI, the latter being recovered by familiar admissibility results. The only case where confinement is not possible is the exchange rule. In standard sequent calculi the exchange rule is made implicit by working with a more convenient data-structure such as multisets as opposed to lists; however, the specific structure of bunches in BI means that a more complex alternative is required. The solution presented is to use nested multisets of two types (additive and multiplicative) corresponding to the two different context-formers/conjunctions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In Section 2 we present the logic of Bunched Implications; in particular, Section 2.1 and Section 2.2 contain the background on BI (the syntax and sequent calculus respectfully); meanwhile, Section 2.3 gives representation of bunches as nested multisets. Section 3 contains the focused system: first, in Section 3.1 we introduce the polarised syntax; second, in Section 3.2 we introduce the focused sequents calculus and some metatheory, most importantly the cut-admissibility result; finally, in Section 3.3 we give the completeness theorem, from which the validity of the focusing principle follows as a corollary. We conclude in Section 4 with some further discussion and future directions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "2 Re-presentations of BI",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The logic BI has a well-studied metatheory admitting familiar categorical, algebraic, and truth-functional semantics which have the expected dualities [34, 17, 33, 11, 32] . In practice, it is the free combination (or, more precisely, the fibration [15, 33] ) of intuitionistic logic (IL) and the multiplicative fragment of intuitionistic linear logic (MILL), which imposes the presence of two distinct context-formers in its sequent presentation. That is to say, the two conjunctions \u2227 and * are represented at the meta-level by context-formers ; and , in place of the usual commas for IL and MILL respectively. Definition 1 (Formula). Let P be a denumerable set of propositional letters. The formulas of BI, denoted by small Greek letters (\u03d5, \u03c8, \u03c7, . . .), are defined by the following grammar, where A \u2208 P,",
            "cite_spans": [
                {
                    "start": 151,
                    "end": 155,
                    "text": "[34,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 156,
                    "end": 159,
                    "text": "17,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 160,
                    "end": 163,
                    "text": "33,",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 164,
                    "end": 167,
                    "text": "11,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 168,
                    "end": 171,
                    "text": "32]",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 249,
                    "end": 253,
                    "text": "[15,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 254,
                    "end": 257,
                    "text": "33]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "Traditional Syntax"
        },
        {
            "text": "If \u2022 \u2208 {\u2227, \u2228, \u2192, } then it is an additive connective and if \u2022 \u2208 { * , \u2212 * , * } then it is a multiplicative connective. The set of all formulas is denoted F.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Traditional Syntax"
        },
        {
            "text": "A bunch is constructed from the following grammar, where \u03d5 \u2208 F, \u2206 :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2 (Bunch)."
        },
        {
            "text": "The symbols \u2205 + and \u2205 \u00d7 are the additive and multiplicative units respectively, and the symbols ; and , are the additive and multiplicative context-formers respectively. A bunch is basic if it is a formula, \u2205 + , or \u2205 \u00d7 and complex otherwise. The set of all bunches is denoted B, the set of complex bunches with additive root context-former by B + , and the set of complex bunches with multiplicative root context-former by B \u00d7 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2 (Bunch)."
        },
        {
            "text": "For two bunches \u2206, \u2206 \u2208 B if \u2206 is a sub-tree of \u2206, it is called a sub-bunch. We may use the standard notation \u2206(\u2206 ) (despite its slight inpracticality) to denote that \u2206 is a sub-bunch of \u2206, in which case \u2206(\u2206 ) is the result of replacing the occurrence of \u2206 by \u2206 . If \u03b4 is a sub-bunch of \u2206, then the context-former \u2022 is said to be its principal context-former in \u2206(\u2206 \u2022 \u03b4) (and \u2206(\u03b4 \u2022 \u2206 )).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2 (Bunch)."
        },
        {
            "text": "Example 3. Let \u03d5, \u03c8 and \u03c7 be formulas, and let \u2206 = (\u03d5, (\u03c7; \u2205 + )); (\u03c8; (\u03c8; \u2205 \u00d7 )). The bunch may be written for example as \u2206(\u03d5, (\u03c7; \u2205 + )) which means that we can have \u2206(\u03d5; \u03d5) = (\u03d5; \u03d5); (\u03c8; (\u03c8; \u2205 \u00d7 )).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2 (Bunch)."
        },
        {
            "text": "A bunched sequent is a pair of a bunch \u2206, called the context, and a formula \u03d5, denoted \u2206 \u21d2 \u03d5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "Bunches are intended to be considered up-to coherent equivalence (\u2261). It is the least relation satisfying:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "-Commutative monoid equations for ; with unit \u2205 + , -Commutative monoid equations for , with unit \u2205 \u00d7 ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "It will be useful to have a measure on sub-bunches which can identify their distance from the root node.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "Definition 5 (Rank). If \u2206 is a sub-bunch of \u2206, then \u03c1(\u2206 ) is the number of alternations of additive and multiplicative context-formers between the principal context-former of \u2206 , and the root context-former of \u2206.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "Let \u2206 be a complex bunch, we use \u2206 \u2208 \u2206 to denote that \u2206 is a (proper) top-most sub-bunch; that is, \u2206 is a sub-bunch satisfying \u2206 = \u2206 but \u03c1(\u2206 ) = 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "Example 6. Let \u2206 be as in Example 3, then \u03c1(\u2205 + ) = 2 whereas \u03c1(\u2205 \u00d7 ) = 0; hence, \u03c8, \u2205 \u00d7 and (\u03d5, (\u03c7, \u2205 \u00d7 )) \u2208 \u2206. Consider the parse-tree of \u2206:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "Reading upward from \u2205 + one encounters first ; which changes into , and then back to ; so the rank is 2; whereas counting up from \u2205 \u00d7 one only encounters ; so the rank is 0. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Bunched Sequent)."
        },
        {
            "text": "The proof theory of BI is well-developed including familiar Hilbert, natural deduction, sequent calculi, tableaux systems, and display calculi [33, 17, 3] . In the foregoing we restrict attention to the sequent calculus as it more amenable to studying proof-search as computation, having local correctness while enjoying the completeness of analytic proofs.",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 147,
                    "text": "[33,",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 148,
                    "end": 151,
                    "text": "17,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 152,
                    "end": 154,
                    "text": "3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Sequent Calculus"
        },
        {
            "text": "Definition 7 (System LBI). The bunched sequent calculus LBI is composed of the rules in Figure 1 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 88,
                    "end": 96,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Sequent Calculus"
        },
        {
            "text": "The classification of \u2227 as additive may seem dubious upon reading the \u2227 R rule, but the designation arises from the use of the structural rules; that is, the \u2227 R and \u2192 R rules may be replaced by additive variants without loss of generality. The presentation in Figure 1 is as in [33] and simply highlights the nature of the additive and multiplicative context-formers. Nonetheless, the choice of rule does affect proof-search behaviours, and the consequences are discussed in more detailed in Section 3.1.",
            "cite_spans": [
                {
                    "start": 279,
                    "end": 283,
                    "text": "[33]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [
                {
                    "start": 261,
                    "end": 269,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Sequent Calculus"
        },
        {
            "text": "If \u03d5 has a LBI-proof, then it has a cut-free LBIproof, i.e., a proof with no occurence of the cut rule.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "Throughout, unless specified otherwise, we take proof to mean cut-free proof. Moreover, if L is a sequent calculus we use L \u2206 \u21d2 \u03d5 to denote that there is an L-proof of \u2206 \u21d2 \u03d5. Further, if R is a rule, then we may denote L + R to denote the sequent calculus combining the rules of L with R.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "The following result, that a generalised version of the axiom is derivable in LBI, will allow for such sequents to be used in proof-construction later on. Lemma 9. For any formula \u03d5, LBI \u03d5 \u21d2 \u03d5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "Proof. Follows from induction on size of \u03d5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "The remainder of this section is the meta-theory required to control the structural rules, which pose the main issue to the study of proof-search in BI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "Lemma 10. The following rules are derivable in LBI, and replacing W with them does not affect the completeness of the system.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "We can construct in LBI derivations with the same premisses and conclusion as these rules by use of the structural rules. Let LBI be LBI without W but with these new rules (retaining also * R , \u2212 * L , * R , R , and Ax), then W is admissible in LBI using standard permutation argument.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "One may regard the above modification to LBI as forming a new calculus, but since all the new rules are derivable it is really a restriction of the calculus, in the sense that all proofs in the new system have equivalent proofs in LBI differing only by explicitly including instances of weakening.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8 (Cut-elimination)."
        },
        {
            "text": "Originally, sequents in the calculi for classical and intuitionistic logics (LK and LJ, respectively) were introduced as lists, and a formal exchange rule was required to permute elements when needed for a logical rule to be applied [21] . However, in practice, the exchange rule is often suppressed, and contexts are simply presented as multisets of formulas. This reduces the number of steps/choices being made during proof-search without increasing the complexity of the underlying data structure. Bunches have considerably more structure than lists, but a quotient with respect to coherent equivalence can be made resulting in two-sorted nested multisets; this was first suggested in [12] , though never formally realised.",
            "cite_spans": [
                {
                    "start": 233,
                    "end": 237,
                    "text": "[21]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 688,
                    "end": 692,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Definition 11 (Two-sorted Nest). Nests (\u0393 ) are formulas or multisets, ascribed either additive (\u03a3), or multiplicative (\u03a0) kind, containing nests of the opposite kind:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "The constructors are multiset constructors which may be empty in which case the nests are denoted \u2205 + and \u2205 \u00d7 respectively. No multiset is a singleton; and the set of all nests is denoted B/\u2261.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Given nests \u039b and \u0393 , we write \u039b \u2208 \u0393 to denote either that \u039b = \u0393 , if \u0393 is a formula, or that \u039b is an element of the multiset \u0393 otherwise. Furthermore, we write \u039b \u2286 \u0393 to denote \u2200\u03b3 \u2208 B/\u2261 if \u03b3 \u2208 \u039b then \u03b3 \u2208 \u0393 . We will depart from the standard, yet impractical subbunch notation, and adopt a context notation for nests instead. We write \u0393 {\u00b7} + (resp. \u0393 {\u00b7} \u00d7 ) for a nest with a hole within one of its additive (resp. multiplicative) multisets.The notation \u0393 {\u039b} + (resp. \u0393 {\u039b} \u00d7 ), denotes that \u039b is a sub-nest of \u0393 of additive (resp. multiplicative) kind; we may use \u0393 {\u039b} when the kind is not specified. In either case \u0393 {\u039b } denotes the substitution of \u039b for \u039b . A promotion in the syntax tree may be required after a substitution either to handle a singleton or an improper alternation of constructor types.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Example 12. The following inclusions are valid,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Note the absence of the {\u00b7} + constructor after substitution, this is due to a promotion in the syntax tree to avoid having two nested additive constructors. Similarly, since \u2205 \u00d7 denotes the empty multiset of multiplicative kind, substituting \u03c7 with it gives {\u03d5, \u03c8 , \u03c8 , \u2205 \u00d7 } + ; that is, first the improper {\u03d5, \u2205 \u00d7 } \u00d7 becomes {\u03d5} \u00d7 ; then, the resulting singleton {\u03d5} \u00d7 is promoted to \u03d5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Typically we will only be interested in fragments of sub-nests so we have the following abuse of notation, where \u2022 \u2208 {+, \u00d7}:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "The notion of rank has a natural analogue in this setting.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Definition 13 (Depth, Rank). Let \u2022 \u2208 {+ , \u00d7} be a nest, we define the depth on B as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "The equivalence of the two presentations, bunches and nests, follows from a moral (in the sense that bunches are intended to be considered modulo congruence) inverse between a nestifying function \u03b7 and a bunching function \u03b2. The transformation \u03b2 is simply going from a tree with arbitrary branching to a binary one, and \u03b7 is the reverse.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Definition 14 (Canonical Translation). The canonical translation \u03b7 : B \u2192 B/\u2261 is defined recursively as follows,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "The canonical translation \u03b2 : B/\u2261 \u2192 B is defined recursively as follows,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Applying \u03b7 to the bunch in Example 3 gives the nest in Example 12:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "The translations are inverses up-to congruence; that is,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Proof. The first two statements follow by induction on the depth (either for bunches or nests), where one must take care to consider the case of a context consisting entirely of units. The third statement employs the first in the forward direction, and proceeds by induction on depth in the reverse direction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Definition 17 (System \u03b7LBI). The nested sequent calculus \u03b7LBI is composed of the rules in Figure 2 , where the metavariables denote possibly empty nests.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 90,
                    "end": 98,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Nested Calculus"
        },
        {
            "text": "Observe the use of metavariable \u0393 instead of \u03a0 (resp. \u03a3) as sub-contexts in Figure 2 . This allows classes of inferences such as",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 76,
                    "end": 84,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Nested Calculus"
        },
        {
            "text": "to be captured by a single figure. In practice it implements the abuse of notation given above:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "This system is a new and very convenient presentation of LBI, not per se a development of the proof theory for the logic.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Lemma 18 (Soundness and Completeness of \u03b7LBI). Systems LBI and \u03b7LBI are equivalent:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "Proof. Each claim follows by induction on the context, appealing to Lemma 16 to organise the data structure for the induction hypothesis, without loss of generality.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "The following is a proof in \u03b7LBI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "We expect no obvious difficulty in studying focused proof-search with bunches instead of nested multisets; the design choice is simply to reduce the complexity of the argument by pushing all uses of exchange (E) to Lemma 18, rather than tackle it at the same time as focusing itself. In particular, working without the nested system would mean working with a weaker notion of focusing since the exchange rule must then be permissible during both focused and unfocused phases of reduction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Calculus"
        },
        {
            "text": "At no point in this section will we refer to bunches, thus the variable \u2206, so far reserved for elements of B, is re-appropriated as an alternative to \u0393 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Focused System"
        },
        {
            "text": "Polarity in the focusing principle is determined by the invariance of provability under application of a rule, that is, by the proof rules themselves. One way the distinction between positive and negative connectives is apparent is when their rule behave either synchronously or asynchronously. For example, the * R and \u2212 * L highlight the synchronous behaviour of the multiplicative connectives since the structure of the context affects the applicability of the rule. Displaying such a synchronous behaviour on the left makes \u2212 * a negative connective, while having it on the right makes * a positive connective. Another way to characterise the polarity of a connective is the study of the inveribility properties of the corresponding rules. For example, consider the inverses of the \u2228 L rule,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "They are derivable in LBI with cut (below -the left branch being closed using Lemma 9) and therefore admissible in LBI without cut (by Lemma 8) .",
            "cite_spans": [
                {
                    "start": 135,
                    "end": 143,
                    "text": "Lemma 8)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "This means that provability is invariant in general upon application of \u2228 L since it can always be reverted if needed, as follows",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "Note however that dual connectives do not necessarily have dual behaviours in terms of provability invariance, on the left and on the right. For example, consider all the possible rules for \u2227, of which some qualify as positive and others as positive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "All of these rules are sound, and replacing the conjunction rules in LBI with any pair of a left and right rule will result in a sound and complete system. Indeed, the rules are inter-derivable when the structural rules are present, but otherwise they can be paired to form two sets of rules which have essentially different proof-search behaviours. That is, the rules in the top-row make \u2227 negative while the bottom row make \u2227 positive. Each conjunction also comes with an associated unit, that is, \u2212 for negative conjunctio and + for positive conjunction. We choose to add all of them to our system in order to have access to those different proof search behaviours at will.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "Finally, the polarity of the propositional letters can be assigned arbitrarily as long as only once for each. Definition 20 (Polarised Syntax). Let P + P \u2212 be a partition of P, and let A + \u2208 P + and A \u2212 \u2208 P \u2212 , then the polarised formulas are defined by the following grammar, P, Q ::= L | P \u2228 Q | P * Q | P \u2227 + Q | + | * | \u22a5 L ::",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "The set of positive formulas P is denoted F + ; the set of negative formulas N is denoted F \u2212 ; and the set of all polarised formulas is denoted F \u00b1 . The subclassifications L and R are left-neutral and right-neutral formulas respectfully.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "The shift operators have no logical meaning; they simply mediate the exchange of polarity, and thus the shifting into a new phase of proof-search. Consequently, to reduces cases in subsequent proofs, we will consider formulas of the form \u2191\u2193N and \u2193\u2191P , but not \u2193\u2191\u2193N , \u2193\u2191\u2193\u2191P , etc.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "Definition 21 (Depolarisation). Let \u2022 \u2208 {\u2228 , * , \u2192 , \u2212 * }, and let A + \u2208 P + and A \u2212 \u2208 P \u2212 , then the depolarisation function \u00b7 : F \u00b1 \u2192 F is defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "Since proof-search is controlled by polarity, the construction of sequents in the focused system must be handled carefully to avoid ambiguity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Polarisation"
        },
        {
            "text": "Positive and neutral nests, denoted by \u0393 and \u2212 \u2192 \u0393 resp., are defined according to the following grammars",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 22 (Polarised Sequents)."
        },
        {
            "text": "A pair of a polarised nest and a polarised formula is a polarised sequent if it falls into one of the following cases",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 22 (Polarised Sequents)."
        },
        {
            "text": "The decoration \u03d5 indicates that the formula is in focus; that is, it is a positive formula on the right, or a negative formula on the left. Of the three possible cases for well-formed polarised sequents, the first may be called unfocused, with the particular case of being neutral when of the form \u2212 \u2192 \u0393 \u21d2 R; and the latter two may be called focused.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 22 (Polarised Sequents)."
        },
        {
            "text": "Definition 23 (Depolarised Nest). The depolarisation map extends to polarised nests \u00b7 : B/\u2261 \u00b1 \u2192 B/\u2261 as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 22 (Polarised Sequents)."
        },
        {
            "text": "We may now give the focused system. That is, the operational semantics for focused proof-search in LBI. All the rules, with the exception of P and N, are polarised versions of the rules from \u03b7LBI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Definition 24 (System fBI). The focused system fBI is composed of the rules on Figure 3 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 79,
                    "end": 87,
                    "text": "Figure 3",
                    "ref_id": null
                }
            ],
            "section": "Focused Calculus"
        },
        {
            "text": "Note the absence of a cut-rule, this is because the above system is intended to encapsulate precisely focused proof-search. Below we show that a cut-rule is indeed admissible, but proofs in fBI + cut are not necessarily focused themselves. Here the distinction between the methodologies for establishing the focusing principle becomes present since one may show completeness without leaving fBI by a permutation argument instead of a cut-elimination one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "The P and N rules will allow us to move a formula from one side to another during the proof of the completeness of fBI + cut (Lemma 34).The depolarised version are not directly present in LBI, but are derivable in LBI (Lemma 9). However, the way they are focused renders them not provable in fBI because it forces one to begin with a potentially bad choice; for example, A \u2228 B \u21d2 A \u2228 B has no proof beginning with \u2228 R . In practice, they are a feature rather than a bug since they allow one to terminate proof-search early, without unnecessary further expansion of the axiom. In related works, such as [6, 5] , the analogous rules are eliminated by initially working with a weaker notion of focused proofsearch, and it is reasonable to suppose that the same may be true for BI. We leave this to future investigation.",
            "cite_spans": [
                {
                    "start": 601,
                    "end": 604,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 605,
                    "end": 607,
                    "text": "5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Note also that, although it is perhaps proof-theoretically displeasing to incorporate weakening into the operational rules as in \u2212 * L and * R , it has good computational behaviour during focused proof-search since the reduction of \u03d5 \u2212 * \u03c8 can only arise out of an explicit choice made earlier in the computation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Soundness follows immediately from the depolarisation map; that is, the interpretation of polarised sequents as nested sequents, and hence proofs in fBI actually are focused proofs in \u03b7LBI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Theorem 25 (Soundness of fBI). Let \u0393 be a polarised nest and N a negative formula. If fBI \u0393 \u21d2 N then \u03b7LBI \u0393 \u21d2 N Proof. Every rule in fBI except the shift rules, as well as the P and N axioms, become a rule in \u03b7BI when the antecedent(s) and consequent are depolarised. Instance of the shift rule can be ignored since the depolarised versions of the consequent and antecedents are the same. Finally, the depolarised versions of P and N follow from Lemma 9 with the use of some weakening.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Example 26. Consider the following proof in fBI, we suppose here that propositional letters A and C are negative, but B is positive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "It is a focused version of the proof given in Example 19. Observe that the only non-deterministic choices are which formula to focus on, such as in steps (1) and (2) , where different choices have been made for the sake of demonstration. The point of focusing is that only at such points do choices that affect termination occur. The assignment of polarity to the propositional letters is what forced the shape of the proof; for example, if B had been negative the above would not have been well-formed. This phenomenon is standarly observed in focused systems (e.g. [7] ).",
            "cite_spans": [
                {
                    "start": 162,
                    "end": 165,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 567,
                    "end": 570,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "We now introduce the tool which will allow us to show that if there is a proof of a sequent (a priori unstructured), then there is necessarily a focused one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Definition 27. All instances of the following rule where the sequents are wellformed are instances of cut, where \u2212 \u2192 \u03d5 denotes that \u03d5 is possibly prenexed with",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Admissibility follows from the usual argument, but within the focused system; that is, through the upward permutation of cuts until they are eliminated in the axioms or are reduced in some other measure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Focused Calculus"
        },
        {
            "text": "Let D be a fBI + cut proof, a cut is a quadruple L, R, C, \u03d5 where L and R are the premises to a cut rule, concluding C in D, and \u03d5 is the cut-formula. They are classified as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "Good -If \u03d5 is principal in both L and R.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "Bad -If \u03d5 is not principal in one of L and R. Type 1: If \u03d5 is not principal in L. Type 2: If \u03d5 is not principal in R.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "Definition 29 (Cut Ordering). The cut-rank of a cut L, R, C, \u03d5 in a proof is the triple cut-complexity, cut-duplicity, cut-level , where the cut-complexity is the size of \u03d5, the cut-duplicity is the number of contraction instances above the cut, the cut-level is the sum of the heights of the sub-proofs concluding L and R. Let D and D be two fBI + cut proofs, let \u03c3 and \u03c3 denote their multiset of cuts respectively. Proofs are ordered by D \u227a D \u21d0\u21d2 \u03c3 < \u03c3 , where < is the multiset ordering derived from the lexicographic ordering on cut-rank.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "It follows from a result in [10] that the ordering on proofs is a well-order, since the ordering on cuts is a well-order.",
            "cite_spans": [
                {
                    "start": 28,
                    "end": 32,
                    "text": "[10]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "Lemma 30 (Good Cuts Elimination). Let D be a fBI + cut proof of S; there is a fBI + cut proof D of S containing no good cuts such that D D.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "Proof. Let D be as in hypothesis, if it contains no good cuts then D = D gives the desired proof. Otherwise, there is at least one good cut L, R, C, \u03d5 . Let \u2202 be the sub-proof in D concluding C, then there is a transformation \u2202 \u2192 \u2202 where \u2202 is a fBI + cut proof of S with \u2202 \u227a \u2202 such that the multiset of good cuts in \u2202 is smaller (with respect to \u227a) than the multiset of good cuts in \u2202. Since \u227a is a well-order indefinitely replacing \u2202 with \u2202 in D for various cuts yields the desired D .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "The key step is that a cut of a certain cut-complexity is replaced by cuts of lower cut-complexity, possibly increasing the cut-duplicity or cut-level of other cuts in the proof, but not modifying their complexity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "We denote by a double-line the fact that we do not actually use a weakening, but only the fact that it is admissible in fBI by construction (Lemma 10).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 28 (Good and Bad Cuts)."
        },
        {
            "text": "Let D be a fBI + cut proof of S that contains only one cut which is bad, then there is a fBI + cut proof D of S such that D \u227a D.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "Proof. Without loss of generality suppose the cut is the last inference in the proof, then it may be replaced by other cuts whose cut-level or cut-duplicity is smaller, but with same cut-complexity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "First we consider bad cuts when L and R are both axioms. There are no Type 1 bad cuts on axioms as the formula is always principal, meanwhile the Type 2 bad cuts can trivially be permuted upwards or ignored; for example,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "Here again we are using an appropriate version of Lemma 10. For the remaining cases the cuts are commutative in the sense that they may be permuted upward thereby reducing the cut-level. An example is given below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "The exceptional case is the interaction with contraction where the cut is replaced by cuts of possibly equal cut-level, but cut-duplicity decreases.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "Theorem 32 (Cut-elimination in fBI). Let \u0393 be a positive nest and N a negative formula. Then, fBI \u0393 \u21d2 N if and only if fBI+cut \u0393 \u21d2 N .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "Proof. (\u21d2) Trivial as any fBI-proof is a fBI + cut-proof. (\u21d0) Let D be a fBI + cut-proof of \u0393 \u21d2 N , if it has no cuts then it is a fBI-proof so we are done. Otherwise, there is at least one cut, and we proceed by well-founded induction on the ordering of proofs and sub-proofs of D with respect to \u227a. Base Case. Assume D is minimal with respect to \u227a with at least one cut; without loss of generality, by Lemma 30, assume the cut is bad. It follows from Lemma 31 that there is a proof strictly smaller in \u227a-ordering, but this proof must be cut-free as D is minimal.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "Inductive",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "Step. Let D be as in the hypothesis, then by Lemma 30 there is a proof \u2202 of \u0393 \u21d2 N containing no good cuts such that D D. Either D is cut-free and we are done, or it contains bad cuts. Consider the topmost cut, and denote the sub-proof by \u2202, it follows from Lemma 31 that there is a proof \u2202 of the same sequent such that \u2202 \u227a \u2202. Hence, by inductive hypothesis, there is a cut-free proof the sequent and replacing \u2202 by this proof in D gives a proof of \u0393 \u21d2 \u03d5 strictly smaller in \u227a-ordering, thus by inductive hypothesis there is a cut-free proof as required.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 31 (Bad Cuts Elimination)."
        },
        {
            "text": "The completeness theorem of the focused system, the operational semantics, is with respect to an interpretation (i.e. a polarisation). Indeed, any polarisation may be considered; for example, both (\u2193A \u2212 * B + )\u2227 + \u2193A \u2212 and \u2193(A + * \u2193B \u2212 )\u2227 + A + are correct polarised versions of the formulas (A * B) \u2227 A. Taking arbitrary \u03d5 the process is as follows: first, fix a polarised syntax (i.e. a partition of the propositional letters into positive and negative sets), then assign a polarity to \u03d5 with the following steps:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "-If \u03d5 is a propositional atom, it must be polarised by default; -If \u03d5 = , then choose polarisation + or \u2212 ; -If \u03d5 = \u03c8 1 \u2227 \u03c8 2 , first polarise \u03c8 1 and \u03c8 2 , then choose an additive conjunction and combine accordingly, using shifts to ensure the formula is well-formed;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "-If \u03d5 = \u03c8 1 \u2022 \u03c8 2 where \u2022 \u2208 { * , \u2212 * , \u2192, \u2228}, then polarise \u03c8 1 and \u03c8 2 and combine with \u2022 accordingly, using shifts where necessary.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Example 33. Suppose A is negative and B is positive, then (A * B) \u2227 A may be polarised by choosing the additive conjunction to be positive resulting in (\u2193A * B) \u2227 + \u2193A (when \u2193(A * \u2193B) \u2227 + A) would not be well-formed). Choosing to shift one can ascribe a negative polarisation \u2191((\u2193A * B) \u2227 + \u2193A).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "The above generates the set of all such polarised formulas when all possible choices are explored. The free assignment of polarity to formulas means several distinct focusing procedures are captured by the completeness theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Lemma 34 (Completeness of fBI + cut). For any unfocused sequent \u0393 \u21d2 N , if \u03b7LBI \u0393 \u21d2 N then fBI+cut \u0393 \u21d2 N .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Proof. We show that every rule in \u03b7LBI is derivable in fBI + cut, consequently every proof in \u03b7LBI may be simulated; hence, every provable sequent has a focused proof. For unfocused rules \u2192 R , \u2212 * R , \u2227 \u2212 R , \u2227 + L , \u2228 L , * L , \u22a5 L , \u2212 R , + L , * L , this is immediate; as well as for Ax and C. Below we give an example on how to simulate a focused rule.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Where it does not matter (e.g. in the case of inactive nests), we do not distinguish the polarised and unpolarised versions; each of the simulations can be closed thanks to the presence of the P and N rules in fBI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Theorem 35 (Completeness of fBI). For any unfocused \u0393 \u21d2 N , if \u03b7LBI \u0393 \u21d2 N then fBI \u0393 \u21d2 N .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Proof. It follows from Lemma 34 that there is a proof of \u0393 \u21d2 N in fBI + cut, and then it follows from Lemma 32 that there is a proof of \u0393 \u21d2 N in fBI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "Given an arbitrary sequent the above theorem guarantees the existence of a focused proof, thus the focusing principle holds for \u03b7LBI and therefore for LBI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness of fBI"
        },
        {
            "text": "By proving the completeness of a focused sequent calculus for the logic of Bunched Implications, we have demonstrated that it satisfies the focusing principle; that is, any polarisation of a BI-provable sequent can be proved following a focused search procedure. This required a careful analysis of how to restrict the usage of structural rules. In particular, we had to fully develop the congruenceinvariant representation of bunches as nested multisets (originally proposed in [12] ) to treat the exchange rule within bunched structures.",
            "cite_spans": [
                {
                    "start": 479,
                    "end": 483,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Proof-theoretically the completeness of the focused systems suggests a syntactic orderliness of LBI, though the P and N rules leave something to be desired. Computationally, these axioms are unproblematic as during search it makes sense to terminate a branch as soon as possible; however, unless they may be eliminated it means that the focusing principle holds in BI only up to a point. In related works (c.f. [6] ) the analogous problem is overcome by first considering a weak focused system; that is, one where the structural rules are not controlled and unfocused rules may be performed inside focused phases if desired. Completeness of (strong) focusing is achieved by appealing to a synthetic system. It seems reasonable to suppose the same can be done for BI, resulting in a more proof-theoretically satisfactory focused calculus, exploring this possibility is a natural extension of the work on fBI.",
            "cite_spans": [
                {
                    "start": 411,
                    "end": 414,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "The methodology employed for proving the focusing principle can be interpreted as soundness and completeness of an operational semantics for goaldirected search. The robustness of this technique is demonstrated by its efficacy in modal [6, 5] and substructural logics [26] , including now bunched ones. Although BI may be the most employed bunched logic, there are a number of others, such as the family of relevant logics [36] , and the family of bunched logics [11] , for which the focusing principle should be studied. However, without the presence of a cut-free sequent calculus goal-directed search becomes unclear, and currently such calculi do not exist for the two main variants of BI: Boolean BI [33] and Classical BI [4] . On the other hand, large families of bunched and substructural logics have been given hypersequent calculi [8, 9] . Effective proof-search procedures have been established for the hypersequent calculi in the substructural case [35] , but not the bunched one, and focused proof-search for neither. There is a technical challenge in focusing these systems as one must not only decide which formula to reduce, but also which sequent.",
            "cite_spans": [
                {
                    "start": 236,
                    "end": 239,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 240,
                    "end": 242,
                    "text": "5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 268,
                    "end": 272,
                    "text": "[26]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 423,
                    "end": 427,
                    "text": "[36]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 463,
                    "end": 467,
                    "text": "[11]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 705,
                    "end": 709,
                    "text": "[33]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 727,
                    "end": 730,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 840,
                    "end": 843,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 844,
                    "end": 846,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 960,
                    "end": 964,
                    "text": "[35]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "In the future it will be especially interesting to see how focused search, when combined with the expressiveness of BI, increases its modelling capabilities. Indeed, the dynamics of proof-search can be used to represent models of computation within (propositional) logics; for example, the undecidability of Linear Logic involves simulating two-counter machines [26] . One particularly interesting direction is to see how focused proof-search in BI may prove valuable within the context of Separation Logic. Focused systems in particular have been used to emulate proofs for other logics [27] ; and to give structural operational semantics for systems used in industry, such as algorithms for solving constraint satisfaction problems [14] . A more immediate possibility though is the formulation of a theorem prover; we leave providing specific implementation or benchmarks to future research.",
            "cite_spans": [
                {
                    "start": 362,
                    "end": 366,
                    "text": "[26]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 588,
                    "end": 592,
                    "text": "[27]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 734,
                    "end": 738,
                    "text": "[14]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Logic programming with focusing proofs in linear logic",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Andreoli",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Journal of Logic and Computation",
            "volume": "2",
            "issn": "",
            "pages": "297--347",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Bunched Logic Programming",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Armelin",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A unified display proof theory for bunched logic",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brotherston",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "proceedings of the 26th Conference on the Mathematical Foundations of Programming Semantics",
            "volume": "265",
            "issn": "",
            "pages": "197--211",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Classical BI: Its semantics and proof theory",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brotherston",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Calcagno",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Logical Methods in Computer Science",
            "volume": "6",
            "issn": "3",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.2168/LMCS-6"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Focused and synthetic nested sequents",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Chaudhuri",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Marin",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Stra\u00dfburger",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Foundations of Software Science and Computation",
            "volume": "",
            "issn": "",
            "pages": "390--407",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Modular focused proof systems for intuitionistic modal logics",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Chaudhuri",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Marin",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Stra\u00dfburger",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "FSCD 2016 -1st International Conference on Formal Structures for Computation and Deduction",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "A logical characterization of forward and backward chaining in the inverse method",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Chaudhuri",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Pfenning",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Price",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "97--111",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Algebraic proof theory for substructural logics: Cut-elimination and completions",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ciabattoni",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Galatos",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Terui",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Annals of Pure and Applied Logic",
            "volume": "163",
            "issn": "3",
            "pages": "266--290",
            "other_ids": {
                "DOI": [
                    "10.1016/j.apal.2011.09.003"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Bunched hypersequent calculi for distributive substructural logics",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ciabattoni",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Ramanayake",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "LPAR-21. 21st International Conference on Logic for Programming",
            "volume": "46",
            "issn": "",
            "pages": "417--434",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Proving termination with multiset orderings",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Dershowitz",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Manna",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Automata, Languages and Programming",
            "volume": "",
            "issn": "",
            "pages": "188--202",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Bunched Logics: A Uniform Approach",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Docherty",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "The inverse method for the logic of bunched implications",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Donnelly",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Gibson",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Krishnaswami",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Magill",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Logic for Programming, Artificial Intelligence, and Reasoning",
            "volume": "",
            "issn": "",
            "pages": "466--480",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "LJQ: A strongly focused calculus for intuitionistic logic",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Dyckhoff",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lengrand",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "173--185",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "A bisimulation between DPLL(T) and a proof-search strategy for the focused sequent calculus",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Farooque",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Graham-Lengrand",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Mahboubi",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the Eighth ACM SIGPLAN international workshop on Logical frameworks & meta-languages: theory & practice. p. 3-14. LFMTP '13",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Oxford Logic Guides",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gabbay",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Semantic labelled tableaux for propositional BI",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Galmiche",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00e9ry",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "J. Log. Comput",
            "volume": "13",
            "issn": "",
            "pages": "707--753",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "The semantics of BI and resource tableaux",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Galmiche",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00e9ry",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Pym",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Mathematical Structures in Computer Science",
            "volume": "15",
            "issn": "6",
            "pages": "1033--1088",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Relating labelled and label-free bunched calculi in BI logic",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Galmiche",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Marti",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00e9ry",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "International Conference on Automated Reasoning with Analytic Tableaux and Related Methods",
            "volume": "",
            "issn": "",
            "pages": "130--146",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Proof-search and countermodel generation in propositional BI Logic -extended abstract",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Galmiche",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00e9ry",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "4th International Symposium on Theoretical Aspects of Computer Software -TACS",
            "volume": "2215",
            "issn": "",
            "pages": "263--282",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Connection-based proof search in propositional BI logic",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Galmiche",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00e9ry",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "18th International Conference on Automated Deduction -CADE-18",
            "volume": "2392",
            "issn": "",
            "pages": "111--128",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "The Collected Papers of Gerhard Gentzen",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Gentzen",
                    "suffix": ""
                }
            ],
            "year": 1969,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "BI as an assertion language for mutable data structures",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "Y"
                    ],
                    "last": "Girard",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ishtiaq",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "W"
                    ],
                    "last": "O&apos;hearn",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "Theoretical Computer Science",
            "volume": "50",
            "issn": "1",
            "pages": "84--96",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "A proof of the focalization property of linear logic",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Laurent",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Focusing and polarization in linear, intuitionistic, and classical logics",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Liang",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Journal of Theoretical Computer Science",
            "volume": "410",
            "issn": "46",
            "pages": "4747--4768",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Decision problems for propositional linear logic",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Lincoln",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mitchell",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Scedrov",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Shankar",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Annals of Pure and Applied Logic",
            "volume": "56",
            "issn": "1",
            "pages": "239--311",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "A focused framework for emulating modal proof systems",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Marin",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Volpe",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "11th conference on\" Advances in Modal Logic",
            "volume": "",
            "issn": "",
            "pages": "469--488",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Imogen: Focusing the polarized focused inverse method for intuitionistic propositional logic",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mclaughlin",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Pfenning",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "15th International Conference on Logic, Programming, Artificial Intelligence and Reasoning (LPAR)",
            "volume": "5330",
            "issn": "",
            "pages": "174--181",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Uniform proofs as a foundation for logic programming",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Nadathur",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Pfenning",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Scedrov",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Annals of Pure and Applied Logic",
            "volume": "51",
            "issn": "1",
            "pages": "125--157",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "A formal framework for specifying sequent calculus proof systems",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Pimentel",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theoretical Compututer Science",
            "volume": "474",
            "issn": "",
            "pages": "98--116",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "The logic of bunched implications",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "O&apos;hearn",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Pym",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "The Bulletin of Symbolic Logic",
            "volume": "5",
            "issn": "2",
            "pages": "215--244",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Resource semantics: Logic as a modelling technology",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Pym",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM SIGLOG News",
            "volume": "6",
            "issn": "2",
            "pages": "5--41",
            "other_ids": {
                "DOI": [
                    "10.1145/3326938.3326940"
                ]
            }
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "The Semantics and Proof Theory of the Logic of Bunched Implications",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "J"
                    ],
                    "last": "Pym",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Applied Logic Series",
            "volume": "26",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Possible Worlds and Resources: the Semantics of BI",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "J"
                    ],
                    "last": "Pym",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "W"
                    ],
                    "last": "O&apos;hearn",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Theoretical Computer Science",
            "volume": "315",
            "issn": "1",
            "pages": "257--305",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Extended Kripke lemma and decidability for hypersequent substructural logics",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Ramanayake",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science. p. 795-806. LICS '20, Association for Computing Machinery",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3373718.3394802"
                ]
            }
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Relevant Logic: A Philosophical Examination of Inference",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Read",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Separation logic: a logic for shared mutable data structures",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Reynolds",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Proceedings 17th Annual IEEE Symposium on Logic in Computer Science",
            "volume": "",
            "issn": "",
            "pages": "55--74",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made. The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Sequent Calculus LBI",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}