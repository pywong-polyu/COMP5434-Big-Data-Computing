{
    "paper_id": "cc3464ecfd737210183e85565442156abd8692ec",
    "metadata": {
        "title": "Proof Blocks: Autogradable Scaffolding Activities for Learning to Write Proofs",
        "authors": [
            {
                "first": "Seth",
                "middle": [],
                "last": "Poulsen",
                "suffix": "",
                "affiliation": {},
                "email": "sethp3@illinois.edu"
            },
            {
                "first": "Mahesh",
                "middle": [],
                "last": "Viswanathan",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Geoffrey",
                "middle": [
                    "L"
                ],
                "last": "Herman",
                "suffix": "",
                "affiliation": {},
                "email": "glherman@illinois.edu"
            },
            {
                "first": "Matthew",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "In this software tool paper we present Proof Blocks, a tool which enables students to construct mathematical proofs by dragging and dropping prewritten proof lines into the correct order. We present both implementation details of the tool, as well as a rich reflection on our experiences using the tool in courses with hundreds of students. Proof Blocks problems can be graded completely automatically, enabling students to receive rapid feedback. When writing a problem, the instructor specifies the dependency graph of the lines of the proof, so that any correct arrangement of the lines can receive full credit. This innovation can improve assessment tools by increasing the types of questions we can ask students about proofs, and potentially give greater access to proof knowledge by increasing the amount that students can learn on their own with the help of a computer.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Constructing mathematical proofs is one of the critical, yet difficult skills that students must learn as a part of the discrete mathematics curriculum. A panel of 21 experts using a Delphi process Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. agreed that 6 of the 11 most difficult topics in a typical discrete mathematics course are related to proofs and logic [10] . Proofs and proof techniques are included by the ACM curricular guidelines as a core knowledge area that should be understood by any student obtaining a degree in computer engineering, computer science, or software engineering [11, 21, 28] .",
            "cite_spans": [
                {
                    "start": 903,
                    "end": 907,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1136,
                    "end": 1140,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1141,
                    "end": 1144,
                    "text": "21,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1145,
                    "end": 1148,
                    "text": "28]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "One problem discrete math instructors face is being able to provide students with rapid feedback on their proof writing skills, since proofs must be graded by hand by instructors or teaching assistants. With the exception of students who are able to sit down with instructors during office hours to receive immediate feedback, most students receive significantly delayed feedback on the correctness of the proofs which they have constructed while completing their homework or exams.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "What if students were able to receive in-flow automated feedback on their proofs, just as they are able to with code they write? Providing students a way to write proofs in such a way that a computer can give automated feedback can be a huge advantage. For many students, this will simply be a convenience factor, but for others, gaining automated feedback can be a huge step in increasing equity and access in discrete mathematics education. For example, consider students who are unable to make it to office hours to receive help due to family commitments, or whose university courses are understaffed. For these and other populations, automated feedback has the potential to make a huge difference by giving them access to feedback they wouldn't have otherwise received.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Another difficulty for instructors is scaffolding students as they try to make the jump from seeing their instructor write a proof to writing proofs themselves. To combat this same issue in code writing, researchers have created new types of learning environments and problems including Parson's Problems [22] and block programming languages like Scratch [18] and Blockly [9] . The scaffolding provided by both Parson's Problems and block programming languages have been shown to help students learn more quickly at the beginning of the learning process [8, 30] . Transitioning from seeing others write proofs to writing them on their own requires students to use multiple skills, including writing logical statements and analyzing sequences of logical statements to make sure that each statement is supported by previous ones. Due to the complexity of the task, we believe that students should be given scaffolding for learning to write mathematical proofs, as with writing code, and they will receive similar benefits. Figure 1 : Example of the Proof Blocks user interface used by students. Individual lines of the proof start out shuffled in the starting zone, and students attempt to drag and drop them into the correct order in the target zone. The instructor wrote the problem with 1, 2, 3, 4, 5, 6, 7 as the intended solution, but the Proof Blocks autograder will also accept any other correct solution as determined by the dependency graph shown in (b) For example, both 4, 5, 6, 1, 2, 3, 7 and 1, 4, 2, 3, 5, 6, 7 would also be accepted as correct solutions.",
            "cite_spans": [
                {
                    "start": 305,
                    "end": 309,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 355,
                    "end": 359,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 372,
                    "end": 375,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 554,
                    "end": 557,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 558,
                    "end": 561,
                    "text": "30]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [
                {
                    "start": 1021,
                    "end": 1029,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we present Proof Blocks, a novel user interface for students to construct mathematical proofs by dragging and dropping prewritten statements into the correct order (see Figure 1 ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 184,
                    "end": 192,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "Proof Blocks allows students to receive instant feedback on the proofs they have constructed to accelerate the learning process. It also provides the necessary scaffolding to help students bridge the gap between seeing others write proofs and writing proofs themselves-reminding students to use good practices such as defining variables before using them and being explicit about the proof techniques being employed. Proof Blocks also provide an opportunity for better student assessment, by providing questions which are, on average, more difficult than multiple choice questions given to students in a typical discrete mathematics course, but easier than free response proof writing questions [24] .",
            "cite_spans": [
                {
                    "start": 695,
                    "end": 699,
                    "text": "[24]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The rest of the paper is organized as follows: we will first discuss related work, then proceed by explaining the user interface of Proof Blocks from both the student and instructor perspective. We will also discuss our experience using Proof Blocks in a discrete mathematics course with over 400 students, and then explain the architecture of the autograder and implications for future work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The specific contributions of this work are:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "\u2022 A novel grading algorithm for drag-and-drop problems based on a directed acyclic graph \u2022 Application of this algorithm to grading mathematical proofs \u2022 Insights from experiences using this tool with hundreds of students",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Work in intelligent tutors for mathematical proofs goes back to work by John Anderson and his colleagues on The Geometry Tutor [1, 2, 12] . More recently, researchers have created tutors for propositional logic, most notably Deep Thought [19, 20] and Lo-gEx [14] [15] [16] [17] . A number of other tools have been created to help students learn to construct mathematical proofs with the aid of a computer. Polymorphic Blocks [13] is a novel user interface which presents propositions as colorful blocks with uniquely shaped connectors. The Incredible Proof Machine [5] guides students through constructing proofs as graphs. Jape [4] is a \"Proof calculator, \" which guides students through the process of constructing formal proofs in mathematical notation with the help of the computer, but requires the instructor to implement the logics in a custom language. MathsTiles [3] is a block-based programming interface for constructing proofs for the Isabelle/HOL proof assistant. Having an open-ended environment where students could construct arbitrarily complex proofs seems like an advantage, but user studies showed that students were only successful if they were provided a small instructor-procured subset of blocks.",
            "cite_spans": [
                {
                    "start": 127,
                    "end": 130,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 131,
                    "end": 133,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 134,
                    "end": 137,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 238,
                    "end": 242,
                    "text": "[19,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 243,
                    "end": 246,
                    "text": "20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 258,
                    "end": 262,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 263,
                    "end": 267,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 268,
                    "end": 272,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 273,
                    "end": 277,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 425,
                    "end": 429,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 565,
                    "end": 568,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 629,
                    "end": 632,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 872,
                    "end": 875,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "In reviewing the design of existing tools for computerized proofs it is clear that there is a tension between two desirable properties: ease of use for beginners, and ability to handle complex proofs. The tools which have an elegant, easy to understand interface (Polymorphic Blocks, The Incredible Proof Machine) only cover formal (and in some cases, simple) logics, limiting their usability for discrete mathematics courses where students write informal proofs on a variety of topics from graph theory to number theory. The tools which can handle an arbitrary complexity of proofs are very complex and thus difficult and time consuming for students and instructors to use, especially at the same time as trying to learn to write proofs. Proof Blocks solves this problem by allowing informally written proofs to be automatically graded, making the tool both easy to use, and able to cover topics of all level of complexity, including but not limited to number theory, properties of functions, cardinality, graph theory, Big-O, and combinatorics.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Anecdotally, we have heard of instructors using scrambled proofs to assess student knowledge both in Euclidean geometry and in higher-level mathematics. In theory, instructors may have offered such questions on paper even before the advent of computers, though we can find no explicit record of this. Ensley and Winston offer some scrambled proofs in a JavaScript applet as supplementary material to their discrete mathematics textbook [6] . Such questions could also be written using generic drag-and-drop task widgets that are present in many learning management systems. However, the ability use directed acyclic-graph based grading and to demarcate subproofs are features unique to Proof Blocks that we have not seen in any other system, and enable assessing proofs which are more complex and use a greater variety of writing styles.",
            "cite_spans": [
                {
                    "start": 436,
                    "end": 439,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Proof Blocks was originally designed for and pilot tested in the discrete mathematics course in the computer science department at the University of Illinois at Urbana-Champaign during the Fall 2020 semester. across multiple sections. Most students are freshmen, and take the course as part of their computer science major, computer science minor, or computer engineering major. The course is designed to prepare students for the theory track in the department and usually covers logic, proofs, functions, cardinality, graphs and trees, induction, recursion, number theory, probability, basic algorithm analysis, and sometimes additional topics as time permits. In Fall 2020, the course was held completely online due to the COVID-19 pandemic. The course was split into 3 sections, each with a different instructor, for a total of over 400 students. The first author of this paper was one of the teaching assistants for the course, and the second author was one of the instructors. For more details of the course, and for the results of the statistical analyses we performed on data collected from the course, see [24] .",
            "cite_spans": [
                {
                    "start": 1114,
                    "end": 1118,
                    "text": "[24]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Development Context"
        },
        {
            "text": "After the semester, we made some small changes based on feedback that we recieved, and then the features of Proof Blocks were integrated into the core PrairieLearn codebase so that they would be open source and could be used more broadly. PrairieLearn is in use regularly at about 10 universities, with more universities pilot testing. Proof Blocks is being used by courses in three different departments at the University of Illinois, as well as at the University of British Columbia and the University of Chicago, and we expect these numbers to continue to grow.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Development Context"
        },
        {
            "text": "Proof Blocks is built in to PrairieLearn. Both the student and teacher user interfaces for creating and using Proof Blocks problems are user friendly, and can be used with almost no training. In an anonymous survey given to our students, 46 out of 51 students responded positively to the statement \"The proof blocks user interface was easy to use,\" with the remaining 5 responding neutrally. Additionally, over two thirds of respondents agreed with the statements \"Proof Blocks accurately represent my understanding of how to write proofs,\" and \"Proof Blocks would be a good tool for practicing writing proofs.\" For more detailed survey results, see [24] . Figure 1 shows an example of the Proof Blocks user interface seen by students as they work through Proof Blocks problems. Individual lines of the proof start out shuffled in the starting zone, and students attempt to drag and drop them into the correct order in the target zone. Students were able to successfully complete proofs using Proof Blocks after completing a lecture, worksheet, and homework about proofs, with no training specifically in how to use the interface. Figure 2 shows an example of feedback given to students working on Proof Blocks problems. This is the feedback that a student would receive if they were to select \"Save & Grade\" after having put their Proof Blocks into the state shown in Figure 1 . To avoid giving students so much information that we are not actually testing their knowledge, they are only told at which line their proof fails and some possible reasons why, not the exact reason why or what the solution is. One area of future research is to iterate on what kind of feedback is best for students to receive when using Proof Blocks as a tool for learning to write proofs. Figure 2 : Example of feedback given to students working on Proof Blocks problems. To avoid giving students so much information that we are not actually testing their knowledge, they are only told at which line their proof fails, not the reason why or what the solution is. One area of future research is to investigate what kind of feedback is best for students to recieve when using Proof Blocks as a tool for learning to write proofs.",
            "cite_spans": [
                {
                    "start": 650,
                    "end": 654,
                    "text": "[24]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [
                {
                    "start": 657,
                    "end": 665,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 1131,
                    "end": 1139,
                    "text": "Figure 2",
                    "ref_id": null
                },
                {
                    "start": 1369,
                    "end": 1377,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 1770,
                    "end": 1778,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "User Interface"
        },
        {
            "text": "In PrairieLearn, each question written by the instructor will include (1) an HTML file defining what the students will see, and (2) a JSON file containing metadata such as the question topic, type, grading options, and author. The HTML file may use custom HTML elements defined by PrairieLearn for writing homework and exam questions. The HTML is then processed on the backend into HTML, CSS, and JavaScript before being delivered to the student's browser. Figure 3 shows the instructor-written HTML code that generates the Proof Blocks exercise shown in Figure 1 . The HTML elements that are prefixed with \"pl\" have special meaning to PrairieLearn, which processes them on the backend before sending the HTML to the client. The pl-question-panel element notifies PrairieLearn of the beginning of a new question. The pl-order-blocks signals to PrairieLearn to create the actual Proof Blocks user interface, and each pl-answer element inside of it defines a draggable line of proof.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 457,
                    "end": 465,
                    "text": "Figure 3",
                    "ref_id": null
                },
                {
                    "start": 555,
                    "end": 563,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Instructor Interface"
        },
        {
            "text": "Critically, the instructor writing the problem must specify which lines of the proof must precede each other line. Though seemingly a small detail, it is what makes Proof Blocks such a powerful tool, since it allows instructors to write proofs with arbitrary English language statements. This overcomes the proof complexity constraints of earlier student computer proof systems, and makes it so that students can construct proofs that a computer can grade at any level of complexity. The proof dependencies are declared using the \"depends\" attribute. For example, the proof graph for the problem shown in Figure 3 is given in Figure 1b .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 605,
                    "end": 613,
                    "text": "Figure 3",
                    "ref_id": null
                },
                {
                    "start": 626,
                    "end": 635,
                    "text": "Figure 1b",
                    "ref_id": null
                }
            ],
            "section": "Instructor Interface"
        },
        {
            "text": "The instructors of the course were able to create new Proof Blocks questions without any special training by simply looking at those already created by the authors, only asking a few questions for clarification about the configuration options, which could now be answered by looking at the documentation. An instructor can choose for all of the given lines to be required, or can add in distractor lines which are not part of the proof. In our discrete mathematics course, we used test questions both with and without distractor lines. Whether or not having distractor lines in the problem leads to better assessment or learning outcomes is an open question which we leave for future work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Instructor Interface"
        },
        {
            "text": "Our experience using Proof Blocks with hundreds of students led us to a few best practices in having Proof Blocks problems work well for students.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "The principal cause for an erroneous Proof Blocks question is because the instructor failed to recognize a possible rearrangement of the proof lines that is logically consistent. This results in a correct student response being incorrectly marked as faulty by the autograder. Unfortunately, it is easy to make such mistakes when designing a Proof Blocks question. These can be avoided if the instructor is aware of the main reasons this arises, which we outline below. In addition, we recommend that the instructor ask another member of the course staff who did not design the question, to solve the problem in different ways without looking at the source code. In our experience, these steps help catch all such mistakes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "One example of this is when the instructor identifies more dependencies between the proof lines than actually exist. For example an instructor may code up a problem in a manner which specifies to the autograder that each line in the proof depends on the line before it. Such strong dependencies are rarely demanded in any proof. While this is a simple scenario where additional dependencies have been identified, other cases are more subtle. They often arise because experienced mathematicians follow stylistic norms in addition to logical dependencies when structuring their proofs. These are so ingrained in a practicing mathematician, that stylistic norms inadvertently seep in as logical dependencies when coding up a problem. For example, one often structures proof with subgoals, with the proof of a new subgoal begun only after the proof of the previous subgoal has been finished. A classical example in a discrete mathematics class is where students are asked to prove a statement using induction where the proof of the induction step follows a complete proof of the base case. However, often there is no logical dependence between the statements in the subproof of each case. From a logical perspective, the proof statements for <pl-question-panel> <p>Recall that the interval $(0,1) = \\{r \\in \\mathbb{R}\\: |\\: 0 \\lt r \\lt 1\\}$ and $[0,1] = \\{r \\in \\mathbb{R}\\: |\\: 0 \\leq r \\leq 1\\}$. Drag and drop a subset of the blocks below to create a proof of the following statement. <strong style=\"color:blue;\">Note, not all blocks are needed in the proof.</strong></p> <p style=\"color:red;text-align:center;\">$|(0,1)| = |[0,1]|$</p> <p>We will prove this result by showing $|(0,1)| \\leq |[0,1]|$ and $|[0,1]| \\leq |(0,1)|$ and using the Cantor-Schroeder-Bernstein theorem.</p> </pl-question-panel> <pl-order-blocks feedback=\"first-wrong\" answers-name=\"csb-v1\" grading-method=\"dag\"> <pl-answer correct=\"true\" tag=\"1\" depends=\"\">Consider the function $id: (0,1) \\to [0,1]$ where for any $r \\in (0,1)$, $id(r) = r$.</pl-answer> <pl-answer correct=\"true\" tag=\"2\" depends=\"1\">$id$ is injective because if $id(r) = r = s = id(s)$ then $r=s$.</pl-answer> <pl-answer correct=\"true\" tag=\"3\" depends=\"2\">Since $id$ is injective, $|(0,1)| \\leq |[0,1]|$.</pl-answer> <pl-answer correct=\"true\" tag=\"4\" depends=\"\" >Consider the function $f: [0,1] \\to (0,1)$ where for any $r \\in [0,1]$, $f(r) = \\frac{r+1}{4}$.</pl-answer> <pl-answer correct=\"true\" tag=\"5\" depends=\"4\">$f$ is injective because if $f(r) = \\frac{r+1}{4} = \\frac{s+1}{4} = f(s)$ then $r=s$.</pl-answer> <pl-answer correct=\"true\" tag=\"6\" depends=\"5\">Since $f$ is injective, $|[0,1]| \\leq |(0,1)|$.</pl-answer> <pl-answer correct=\"true\" tag=\"7\" depends=\"3,6\">Result follows from the Cantor-Schroeder-Bernstein theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "(End of Proof)</pl-answer> <!--Distractors --> <pl-answer correct=\"false\" tag=\"\" depends=\"\">Consider the function $f: [0,1] \\to (0,1)$ where for any $r \\in [0,1]$, $f(r) = r$.</pl-answer> <pl-answer correct=\"false\" tag=\"\" depends=\"\">$f$ is injective because if $f(r) = r = s = f(s)$ then $r=s$.</pl-answer> <pl-answer correct=\"false\" tag=\"\" depends=\"\">$f$ is surjective because for any $r \\in (0,1)$, $f(r) = r$.</pl-answer> </pl-order-blocks> Figure 3 : The instructor-written HTML code that generates the Proof Blocks exercise shown in 1. The HTML elements that are prefixed with \"pl\" have special meaning to PrairieLearn, which processes them on the backend before sending the HTML to the client. The \"depends\" property on each \"pl-answer\" element is used to declare the dependency between statements in the proof structure.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 444,
                    "end": 452,
                    "text": "Figure 3",
                    "ref_id": null
                }
            ],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "each case can be interleaved in any manner. Of course, emphasizing stylistic norms is just as important a learning objective, but in that case instructors should be encouraged to spell this goal out in the problem statement. To avoid such mistakes, after coding a Proof Blocks question, we encourage instructors to examine the dependencies of each line in the coded problem in isolation, without the large proof context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "Another common cause for errors arises in proofs that contain many algebraic manipulation steps. In informal proof writing, it is often acceptable to skip intermediate steps of algebraic manipulation. Coding a question in a manner that demands all the steps leads to student complaints about the autograder. There are two ways to address this problem. One is to write multiple algebraic simplification steps in a single proof statement in the problem. The second, and probably the best, is to avoid having any distractors in the problem, and notify the student that all blocks should be used to construct a correct proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "The last cause for an error could be distractors. When designing a question, it is useful to remember that none of the distractors should be part of any correct proof. A common mistake is to have distractors that are superfluous to the correct proof; this is a problem because we can write logically correct proofs that have additional statements that do not contribute to the end goal. Thus, it is important to ensure that adding any distractor would result in a logically inconsistent argument. One simple way to ensure this is to have each distractor (on its own) be a logically inconsistent statement. Even though this might seem like an easy distractor for a student to avoid, in practice we have found that students are nonetheless confounded by such distractors. In the future, we hope to extend the Proof Blocks grader so that it can also handle having lines which can optionally be part of a correct proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best Practices For Question Writing"
        },
        {
            "text": "The autograder is currently built in to PrairieLearn, but the core algorithm is about 100 lines of Python code that could be made to work with an alternative frontend, or reimplemented in any other language.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Autograder"
        },
        {
            "text": "While creating the tool, we recognized that it would be a poor student experience if the student was expected to place the lines of the proof in the exact order which the instructor first wrote them, because in many mathematical proofs, certain lines can be permuted without affecting the correctness of the proof. It would also be a poor user experience for the instructor if they had to explicitly declare every possible correct answer to each question. This led us to our current grading scheme, which is based on the dependency graph of the lines in the proof, which is a directed acyclic graph (DAG). The instructor simply declares the dependency graph of statements in the proof, and then the grader will accept any correct permutation of the lines.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Autograder"
        },
        {
            "text": "In the basic case, where a proof has no subproofs like the example in Figure 1 , checking if a proof is correct is equivalent to checking if the student ordering of the lines is a topological sort of the DAG. A more rigorous treatment of the grading algorithm, and the details of our edit-distance based partial credit algorithm can be seen in [23] .",
            "cite_spans": [
                {
                    "start": 344,
                    "end": 348,
                    "text": "[23]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [
                {
                    "start": 70,
                    "end": 78,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Autograder"
        },
        {
            "text": "Even in an introductory discrete mathematics course, an instructor may want to use proofs that have cases. For example, using cases to prove an \"or\" statement, or proof by induction. Here each subproof is a connected subgraph of the entire proof graph. In such cases, checking for topological sorting of the proof DAG is insufficient, because this would allow for intermixing of statements from separate subproofs in a nonsensical fashion. A correct proof is a topological sort of the lines of the proof with the added condition that the lines of each subproof must be listed contiguously. Therefore, there is an extra check which ensures that once a given subproof is started, it is finished before any lines from outside the subproof appear.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subproofs"
        },
        {
            "text": "To write a question with a subproof, the instructor wraps each subproof in a pl-block-group element. The pl-block-group element may then be given its own tag, so that lines that logically depend on the entire subproof can refer to them in their depends attribute. For more details and examples of problems with subproofs, see the Proof Blocks documentation [26] . As noted in Section 5, it is important to note that subproofs declared only for stylistic, and not logical, reasons can be misleading for student unless they are explicitly notified of the style which they are to follow.",
            "cite_spans": [
                {
                    "start": 357,
                    "end": 361,
                    "text": "[26]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Subproofs"
        },
        {
            "text": "Using data from hundreds of student exams from the discrete math course in Fall 2020, we have shown that Proof Blocks problems provide about as much information about student knowledge as written proof problems do. We have also shown that as test questions, Proof Blocks problems are in fact easier than written proofs, which are often very difficult. An anonymous survey given to these students showed that students felt that Proof Blocks problems accurately represented their ability to write proofs, and that the user interface was easy to use. Full details of this evaluation can be seen in [24] . Ongoing evaluation work seeks to explore the possibility that Proof Blocks can help students learn more efficiently than writing proofs from scratch, just as Parson's Problems can help students learn more efficiently than writing code from scratch [8] .",
            "cite_spans": [
                {
                    "start": 595,
                    "end": 599,
                    "text": "[24]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 850,
                    "end": 853,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Evaluation"
        },
        {
            "text": "To use Proof Blocks with your students, start by following the onboarding instructions for PrairieLearn [27] . Once familiar with the basic workings of PrairieLearn, follow the documentation for writing Proof Blocks questions [26] . More example problems can be found in the documentation and example courses. PrairieLearn is in the process of integrating with Learning Tools Interoperability [25] to enable easier sharing of student data across learning platforms. Feel free to reach out to the authors with any questions, or about the possibility of adding Proof Blocks support on other platforms.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 108,
                    "text": "[27]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 226,
                    "end": 230,
                    "text": "[26]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 393,
                    "end": 397,
                    "text": "[25]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "Adopting Proof Blocks"
        },
        {
            "text": "The key limitation of Proof Blocks is that it restricts what students can do, only allowing them to place prewritten lines into their proof rather than allowing them to write whatever they want. As with Parson's Problems and block based programming languages, we expect that there is a certain skill level at which Proof Blocks will become a hindrance rather than a help to students, but this is of course expected for all forms of education scaffolding. Similarly, we believe that Proof Blocks will can be a huge help for students who are just getting started in learning to write proofs. Another limitation is that proofs will be graded correctly only as long as the instructor correctly codes the question-but this is really no worse than most other types of exam questions given to students. Finally, Proof Blocks is currently only usable within the PrairieLearn. Ongoing efforts to improve interoperability between PrairieLearn and other learning platforms will help ease adoption.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Limitations"
        },
        {
            "text": "The versatility of the Proof Blocks platform makes it ideally suited for many future avenues of research. Next, we would like to enable automatic generation of Proof Blocks problems so that students can have essentially unlimited practice. We will also want to research a way to predict the difficulty of a given generated problem, so students can be guided through questions of varying difficulty as the learn, and for fairness on assessments. Beyond discrete mathematics, there are great possibilities in using Proof Blocks problems for other courses involving proofs such as algorithms courses, or even high school geometry.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Future Work and implications"
        },
        {
            "text": "As noted, Proof Blocks are a good way to bridge the gap between students learning to read and write proofs. To give further support to students as they learn to write proofs, we can try variations on Proof Blocks. For example, we could have students drag and drop lines of a proof which are mostly prewritten, but have some blanks for the students to fill in, much as Weinman et al. have done with their \"Faded Parson's Problems\" [29] Proof Blocks can increase access to proof knowledge by helping students gain more rapid feedback on the proofs they write. Additionaly, it can improve assessment tools by increasing the types and difficulty levels of questions we can ask students about proofs, and save many hours of instructor grading time which can be reallocated to office hours or other effective means of helping students [24] . There has been some evidence that mathematics is acting as a gatekeeper to learning programming, and that it doesn't actually predict performance in software developers [7] . Furthermore, many people going into software development study curricula that involve less math than a standard computer science curricula. Proof Blocks can also provide a solution in this case: rather than teaching less mathematics, Proof Blocks provides a middle ground. Students can be introduced to logical thinking and proof writing in a gentler way, potentially reducing the gatekeeping of mathematics while helping students learn the content.",
            "cite_spans": [
                {
                    "start": 430,
                    "end": 434,
                    "text": "[29]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 829,
                    "end": 833,
                    "text": "[24]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 1005,
                    "end": 1008,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Future Work and implications"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "The Geometry Tutor, proc. of 9th Internation Joint Conference on Artificial Intelligence",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Jr Anderson",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Boyle",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Yost",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Cognitive tutors: Lessons learned. The journal of the learning sciences",
            "authors": [
                {
                    "first": "Albert",
                    "middle": [
                        "T"
                    ],
                    "last": "John R Anderson",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Corbett",
                    "suffix": ""
                },
                {
                    "first": "Ray",
                    "middle": [],
                    "last": "Kenneth R Koedinger",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Pelletier",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "",
            "volume": "4",
            "issn": "",
            "pages": "167--207",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Student proof exercises using Math-sTiles and Isabelle/HOL in an intelligent book",
            "authors": [
                {
                    "first": "William",
                    "middle": [],
                    "last": "Billingsley",
                    "suffix": ""
                },
                {
                    "first": "Peter",
                    "middle": [],
                    "last": "Robinson",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Journal of Automated Reasoning",
            "volume": "39",
            "issn": "",
            "pages": "181--218",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Jape: A calculator for animating proofon-paper",
            "authors": [
                {
                    "first": "Richard",
                    "middle": [],
                    "last": "Bornat",
                    "suffix": ""
                },
                {
                    "first": "Bernard",
                    "middle": [],
                    "last": "Sufrin",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "International Conference on Automated Deduction",
            "volume": "",
            "issn": "",
            "pages": "412--415",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Visual theorem proving with the Incredible Proof Machine",
            "authors": [
                {
                    "first": "Joachim",
                    "middle": [],
                    "last": "Breitner",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "International Conference on Interactive Theorem Proving",
            "volume": "",
            "issn": "",
            "pages": "123--139",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Discrete mathematics: mathematical reasoning and proof with puzzles, patterns, and games",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Douglas",
                    "suffix": ""
                },
                {
                    "first": "J Winston",
                    "middle": [],
                    "last": "Ensley",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Crawley",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "The computer boys take over: Computers, programmers, and the politics of technical expertise",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nathan",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Ensmenger",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Solving parsons problems versus fixing and writing code",
            "authors": [
                {
                    "first": "Lauren",
                    "middle": [
                        "E"
                    ],
                    "last": "Barbara J Ericson",
                    "suffix": ""
                },
                {
                    "first": "Jochen",
                    "middle": [],
                    "last": "Margulieux",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Rick",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 17th Koli Calling International Conference on Computing Education Research",
            "volume": "",
            "issn": "",
            "pages": "20--29",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Ten things we've learned from Blockly",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Fraser",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "2015 IEEE Blocks and Beyond Workshop (Blocks and Beyond",
            "volume": "",
            "issn": "",
            "pages": "49--50",
            "other_ids": {
                "DOI": [
                    "10.1109/BLOCKS.2015.7369000"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Identifying important and difficult concepts in introductory computing courses using a delphi process",
            "authors": [
                {
                    "first": "Ken",
                    "middle": [],
                    "last": "Goldman",
                    "suffix": ""
                },
                {
                    "first": "Paul",
                    "middle": [],
                    "last": "Gross",
                    "suffix": ""
                },
                {
                    "first": "Cinda",
                    "middle": [],
                    "last": "Heeren",
                    "suffix": ""
                },
                {
                    "first": "Geoffrey",
                    "middle": [],
                    "last": "Herman",
                    "suffix": ""
                },
                {
                    "first": "Lisa",
                    "middle": [],
                    "last": "Kaczmarczyk",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Michael",
                    "suffix": ""
                },
                {
                    "first": "Craig",
                    "middle": [],
                    "last": "Loui",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Zilles",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Proceedings of the 39th SIGCSE technical symposium on Computer science education",
            "volume": "",
            "issn": "",
            "pages": "256--260",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Computer Science Curricula 2013: Curriculum Guidelines for Undergraduate Degree Programs in Computer Science",
            "authors": [],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Abstract planning and perceptual chunks: Elements of expertise in geometry",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kenneth",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Koedinger",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "John R Anderson",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Cognitive Science",
            "volume": "14",
            "issn": "",
            "pages": "511--550",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Polymorphic blocks: Formalism-inspired UI for structured connectors",
            "authors": [
                {
                    "first": "Sorin",
                    "middle": [],
                    "last": "Lerner",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Stephen",
                    "suffix": ""
                },
                {
                    "first": "William G",
                    "middle": [],
                    "last": "Foster",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Griswold",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 33rd",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Annual ACM Conference on Human Factors in Computing Systems",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "3063--3072",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Proving the equivalence of two logical formulae with LogEx",
            "authors": [
                {
                    "first": "Josje",
                    "middle": [],
                    "last": "Lodder",
                    "suffix": ""
                },
                {
                    "first": "Bastiaan",
                    "middle": [],
                    "last": "Heeren",
                    "suffix": ""
                },
                {
                    "first": "Johan",
                    "middle": [],
                    "last": "Jeuring",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "A pilot study of the use of LogEx, lessons learned",
            "authors": [
                {
                    "first": "Josje",
                    "middle": [],
                    "last": "Lodder",
                    "suffix": ""
                },
                {
                    "first": "Bastiaan",
                    "middle": [],
                    "last": "Heeren",
                    "suffix": ""
                },
                {
                    "first": "Johan",
                    "middle": [],
                    "last": "Jeuring",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1507.03671"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A comparison of elaborated and restricted feedback in LogEx, a tool for teaching rewriting logical formulae",
            "authors": [
                {
                    "first": "Josje",
                    "middle": [],
                    "last": "Lodder",
                    "suffix": ""
                },
                {
                    "first": "Bastiaan",
                    "middle": [],
                    "last": "Heeren",
                    "suffix": ""
                },
                {
                    "first": "Johan",
                    "middle": [],
                    "last": "Jeuring",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Journal of Computer Assisted Learning",
            "volume": "35",
            "issn": "",
            "pages": "620--632",
            "other_ids": {
                "DOI": [
                    "10.1111/jcal.12365"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Providing Hints, Next Steps and Feedback in a Tutoring System for Structural Induction",
            "authors": [
                {
                    "first": "Josje",
                    "middle": [],
                    "last": "Lodder",
                    "suffix": ""
                },
                {
                    "first": "Bastiaan",
                    "middle": [],
                    "last": "Heeren",
                    "suffix": ""
                },
                {
                    "first": "Johan",
                    "middle": [],
                    "last": "Jeuring",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Electronic Proceedings in Theoretical Computer Science",
            "volume": "313",
            "issn": "",
            "pages": "17--34",
            "other_ids": {
                "DOI": [
                    "10.4204/EPTCS.313.2"
                ],
                "arXiv": [
                    "arXiv:2002.12552"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "The scratch programming language and environment",
            "authors": [
                {
                    "first": "John",
                    "middle": [],
                    "last": "Maloney",
                    "suffix": ""
                },
                {
                    "first": "Mitchel",
                    "middle": [],
                    "last": "Resnick",
                    "suffix": ""
                },
                {
                    "first": "Natalie",
                    "middle": [],
                    "last": "Rusk",
                    "suffix": ""
                },
                {
                    "first": "Brian",
                    "middle": [],
                    "last": "Silverman",
                    "suffix": ""
                },
                {
                    "first": "Evelyn",
                    "middle": [
                        "Eastmond"
                    ],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ACM Transactions on Computing Education (TOCE)",
            "volume": "10",
            "issn": "",
            "pages": "1--15",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Evolution of an Intelligent Deductive Logic Tutor Using Data-Driven Elements",
            "authors": [
                {
                    "first": "Behrooz",
                    "middle": [],
                    "last": "Mostafavi",
                    "suffix": ""
                },
                {
                    "first": "Tiffany",
                    "middle": [],
                    "last": "Barnes",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "International Journal of Artificial Intelligence in Education",
            "volume": "27",
            "issn": "1",
            "pages": "5--36",
            "other_ids": {
                "DOI": [
                    "10.1007/s40593-016-0112-1"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Data-Driven Worked Examples Improve Retention and Completion in a Logic Tutor",
            "authors": [
                {
                    "first": "Behrooz",
                    "middle": [],
                    "last": "Mostafavi",
                    "suffix": ""
                },
                {
                    "first": "Guojing",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "Collin",
                    "middle": [],
                    "last": "Lynch",
                    "suffix": ""
                },
                {
                    "first": "Min",
                    "middle": [],
                    "last": "Chi",
                    "suffix": ""
                },
                {
                    "first": "Tiffany",
                    "middle": [],
                    "last": "Barnes",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "9_102 Series Title: Lecture Notes in Computer Science",
            "volume": "9112",
            "issn": "",
            "pages": "726--729",
            "other_ids": {
                "DOI": [
                    "http:/link.springer.com/10.1007/978-3-319-19773-9_102"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering",
            "authors": [],
            "year": 2014,
            "venue": "The Joint Task Force on Computing Curricula",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Parson's Programming Puzzles: A Fun and Effective Learning Tool for First Programming Courses",
            "authors": [
                {
                    "first": "Dale",
                    "middle": [],
                    "last": "Parsons",
                    "suffix": ""
                },
                {
                    "first": "Patricia",
                    "middle": [],
                    "last": "Haden",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the 8th Australasian Conference on",
            "volume": "52",
            "issn": "",
            "pages": "157--163",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Efficient Partial Credit Grading of Proof Blocks Problems",
            "authors": [
                {
                    "first": "Seth",
                    "middle": [],
                    "last": "Poulsen",
                    "suffix": ""
                },
                {
                    "first": "Shubhang",
                    "middle": [],
                    "last": "Kulkarni",
                    "suffix": ""
                },
                {
                    "first": "Geoffrey",
                    "middle": [],
                    "last": "Herman",
                    "suffix": ""
                },
                {
                    "first": "Matthew",
                    "middle": [],
                    "last": "West",
                    "suffix": ""
                }
            ],
            "year": 2022,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.48550/ARXIV.2204.04196"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Evaluating Proof Blocks Problems as Exam Questions",
            "authors": [
                {
                    "first": "Seth",
                    "middle": [],
                    "last": "Poulsen",
                    "suffix": ""
                },
                {
                    "first": "Mahesh",
                    "middle": [],
                    "last": "Viswanathan",
                    "suffix": ""
                },
                {
                    "first": "Geoffrey",
                    "middle": [
                        "L"
                    ],
                    "last": "Herman",
                    "suffix": ""
                },
                {
                    "first": "Matthew",
                    "middle": [],
                    "last": "West",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Proceedings of the 2021 ACM Conference on International Computing Education Research",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Ims learning tools interoperability: Enabling a mash-up approach to teaching and learning tools",
            "authors": [
                {
                    "first": "Charles",
                    "middle": [],
                    "last": "Severance",
                    "suffix": ""
                },
                {
                    "first": "Ted",
                    "middle": [],
                    "last": "Hanss",
                    "suffix": ""
                },
                {
                    "first": "Josepth",
                    "middle": [],
                    "last": "Hardin",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Technology, Instruction, Cognition and Learning",
            "volume": "7",
            "issn": "",
            "pages": "245--262",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "PrairieLearn Team. 2021. pl-order-blocks Documentation",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "PrairieLearn Team. 2021. PrairieLearn Documentation",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Curriculum Guidelines for Undergraduate Degree Programs in Computer Engineering",
            "authors": [],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Exploring challenging variations of parsons problems",
            "authors": [
                {
                    "first": "Nathaniel",
                    "middle": [],
                    "last": "Weinman",
                    "suffix": ""
                },
                {
                    "first": "Armando",
                    "middle": [],
                    "last": "Fox",
                    "suffix": ""
                },
                {
                    "first": "Marti",
                    "middle": [],
                    "last": "Hearst",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 51st ACM Technical Symposium on Computer Science Education",
            "volume": "",
            "issn": "",
            "pages": "1349--1349",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "To block or not to block, that is the question: students' perceptions of blocks-based programming",
            "authors": [
                {
                    "first": "David",
                    "middle": [],
                    "last": "Weintrop",
                    "suffix": ""
                },
                {
                    "first": "Uri",
                    "middle": [],
                    "last": "Wilensky",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 14th international conference on interaction design and children",
            "volume": "",
            "issn": "",
            "pages": "199--208",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "July 8-13, 2022, Dublin, Ireland \u00a9 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM. ACM ISBN 978-1-4503-9201-3/22/07. . . $15.00 https://doi.org/10.1145/3502718.3524774",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "We would like to thank Benjamin Cosman, Patrick Lin, and Yael Gertner for being willing to test early versions of Proof Blocks with their students, and the Computers & Education research group at the University of Illinois for feedback on earlier versions of this paper. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgments"
        }
    ]
}