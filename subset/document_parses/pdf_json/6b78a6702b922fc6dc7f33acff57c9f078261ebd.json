{
    "paper_id": "6b78a6702b922fc6dc7f33acff57c9f078261ebd",
    "metadata": {
        "title": "Counting and Computing Join-Endomorphisms in Lattices",
        "authors": [
            {
                "first": "Santiago",
                "middle": [],
                "last": "Quintero",
                "suffix": "",
                "affiliation": {
                    "laboratory": "LIX",
                    "institution": "\u00c9cole Polytechnique de Paris",
                    "location": {
                        "settlement": "Palaiseau",
                        "country": "France"
                    }
                },
                "email": "squinter@lix.polytechnique.fr"
            },
            {
                "first": "Sergio",
                "middle": [],
                "last": "Ramirez",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Pontificia Universidad Javeriana Cali",
                    "location": {
                        "settlement": "Cali",
                        "country": "Colombia"
                    }
                },
                "email": ""
            },
            {
                "first": "Camilo",
                "middle": [],
                "last": "Rueda",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Pontificia Universidad Javeriana Cali",
                    "location": {
                        "settlement": "Cali",
                        "country": "Colombia"
                    }
                },
                "email": ""
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Valencia",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Pontificia Universidad Javeriana Cali",
                    "location": {
                        "settlement": "Cali",
                        "country": "Colombia"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Structures involving a lattice and join-endomorphisms on it are ubiquitous in computer science. We study the cardinality of the set E(L) of all joinendomorphisms of a given finite lattice L. In particular, we show that when L is Mn, the discrete order of n elements extended with top and bottom, |E(L)| = n!Ln(\u22121) + (n + 1) 2 where Ln(x) is the Laguerre polynomial of degree n. We also study the following problem: Given a lattice L of size n and a set S \u2286 E(L) of size m, find the greatest lower bound E(L) S. The join-endomorphism E(L) S has meaningful interpretations in epistemic logic, distributed systems, and Aumann structures. We show that this problem can be solved with worst-case time complexity in O(n + m log n) for powerset lattices, O(mn 2 ) for lattices of sets, and O(mn + n 3 ) for arbitrary lattices. The complexity is expressed in terms of the basic binary lattice operations performed by the algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "There is a long established tradition of using lattices to model structural entities in many fields of mathematics and computer science. For example, lattices are used in concurrency theory to represent the hierarchical organization of the information resulting from agent's interactions [12] . Mathematical morphology (MM), a well-established theory for the analysis and processing of geometrical structures, is founded upon lattice theory [2, 14] . Lattices are also used as algebraic structures for modal and epistemic logics as well as Aumann structures (e.g., modal algebras and constraint systems [7] ).",
            "cite_spans": [
                {
                    "start": 288,
                    "end": 292,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 441,
                    "end": 444,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 445,
                    "end": 448,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 603,
                    "end": 606,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In all these and many other applications, lattice join-endomorphisms appear as fundamental. A join-endomorphism is a function from a lattice to itself that preserves finite joins. In MM, join-endomorphisms correspond to one of its fundamental operations; dilations. In modal algebra, they correspond via duality to the box modal operator. In epistemic settings, they represent belief or knowledge of agents. In fact, our own interest in lattice theory derives from using join-endomorphisms to model the perception that agents may have of a statement in a lattice of partial information [7] .",
            "cite_spans": [
                {
                    "start": 586,
                    "end": 589,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "For finite lattices, devising suitable algorithms to compute lattice maps with some given properties would thus be of great utility. We are interested in constructing algorithms for computing lattice morphisms. This requires, first, a careful study of the space of such maps to have a clear idea of how particular lattice structures impact on the size of the space. We are, moreover, particularly interested in computing the maximum join-endomorphism below a given collection of join-morphisms. This turns out to be important, among others, in spatial computation (and in epistemic logic) to model the distributed information (resp. distributed knowledge) available to a set of agents as conforming a group [8] . It could also be regarded as the maximum perception consistent with (or derivable from) a collection of perceptions of a group of agents.",
            "cite_spans": [
                {
                    "start": 707,
                    "end": 710,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Problem. Consider the set E(L) of all join-endomorphisms of a finite lattice L. The set E(L) can be made into a lattice by ordering join-endomorphisms point-wise wrt the order of L. We investigate the following maximization problem: Given a lattice L of size n and a set S \u2286 E(L) of size m, find in E(L) the greatest lower bound of S, i.e., E(L) S. Simply taking \u03c3 : L \u2192 L with \u03c3(e) def = L {f (e) | f \u2208 S} does not solve the problem as \u03c3 may not be a join-endomorphism. Furthermore, since E(L) can be seen as the search space, we also consider the problem of determining its cardinality. Our main results are the following. This Paper. We present characterizations of the exact cardinality of E(L) for some fundamental lattices. Our contribution is to establish the cardinality of E(L) for the stereotypical non-distributive lattice L = M n . We show that |E(M n )| equals r n 0 + . . . + r n n + r n+1 1 = n!L n (\u22121) + (n + 1) 2 where r m k is the number of ways to place k non-attacking rooks on an m \u00d7 m board and L n (x) is the Laguerre polynomial of degree n. We also present cardinality results for powerset and linear lattices that are part of the lattice theory folklore: The number of join-endomorphisms is n log 2 n for powerset lattices of size n and 2n n for linear lattices of size n + 1. Furthermore, we provide algorithms that, given a lattice L of size n and a set S \u2286 E(L) of size m, compute E(L) S. Our contribution is to show that E(L) S can be computed with worstcase time complexity in O(n + mlog n) for powerset lattices, O(mn 2 ) for lattices of sets, and O(nm + n 3 ) for arbitrary lattices.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Due to space restrictions we only include the main proofs. The missing proofs can be found in the technical report of this paper [13] .",
            "cite_spans": [
                {
                    "start": 129,
                    "end": 133,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We presuppose basic knowledge of order theory [3] and use the following notions. Let (L, ) be a partially ordered set (poset), and let S \u2286 L. We use L S to denote the least upper bound (or supremum or join) of S in L, if it exists. Dually, L S is the greatest lower bound (glb) (infimum or meet) of S in L, if it exists. We shall often omit the index L from L and L when no confusion arises. As usual, if S = {c, d}, c d and c d represent S and S, respectively. If L has a greatest element (top) , and a least element (bottom) \u22a5, we have \u2205 = \u22a5 and \u2205 = . The poset L is distributive iff for every a, b, c \u2208 L, a (b c) = (a b) (a c).",
            "cite_spans": [
                {
                    "start": 46,
                    "end": 49,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Background: Join-Endomorphisms and Their Space"
        },
        {
            "text": "The poset L is a lattice iff each finite nonempty subset of L has a supremum and infimum in L, and it is a complete lattice iff each subset of L has a supremum and infimum in L. A self-map on L is a function f :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background: Join-Endomorphisms and Their Space"
        },
        {
            "text": "We shall use the following posets and notation. Given n, we use n to denote the poset {1, . . . , n} with the linear order x y iff x \u2264 y. The posetn is the set {1, . . . , n} with the discrete order x y iff x = y. Given a poset L, we use L \u22a5 for the poset that results from adding a bottom element to L. The poset L is similarly defined. The lattice 2 n is the n-fold Cartesian product of 2 ordered coordinate-wise. We define M n as the lattice (n \u22a5 ) . A lattice of sets is a set of sets ordered by inclusion and closed under finite unions and intersections. A powerset lattice is a lattice of sets that includes all the subsets of its top element.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background: Join-Endomorphisms and Their Space"
        },
        {
            "text": "We shall investigate the set of all join-endomorphisms of a given lattice ordered point-wise. Notice that every finite lattice is a complete lattice.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background: Join-Endomorphisms and Their Space"
        },
        {
            "text": "Let L be a complete lattice. We say that a self-map is a (lattice) join-endomorphism iff it preserves the join of every finite subset of L. Define E(L) as the set of all join-endomorphisms of L. Furthermore,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Join-endomorphisms and their space)."
        },
        {
            "text": "The following are immediate consequences of the above definition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Join-endomorphisms and their space)."
        },
        {
            "text": "Given a set S \u2286 E(L), where L is a finite lattice, we are interested in finding the greatest join-endomorphism in E(L) below the elements of S, i.e., E(L) S. Since every finite lattice is also a complete lattice, the existence of E(L) S is guaranteed by the following proposition. In the following sections we study the cardinality of E(L) for some fundamental lattices and provide efficient algorithms to compute E(L) S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Join-endomorphisms and their space)."
        },
        {
            "text": "The main result of this section is Theorem 1. It states the size of E(M n ). Propositions 3 and 4 state, respectively, the size of E(L) for the cases when L is a powerset lattice and when L is a total order. These propositions follow from simple observations and they are part of the lattice theory folklore [1, 10, 16] . We include our original proofs of these propositions in the technical report of this paper [13] .",
            "cite_spans": [
                {
                    "start": 308,
                    "end": 311,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 312,
                    "end": 315,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 316,
                    "end": 319,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 413,
                    "end": 417,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "The Size of the Function Space"
        },
        {
            "text": "We begin with lattices isomorphic to 2 n . They include finite boolean algebras and powerset lattices [3] . The size of these lattices are easy to infer from the observation that the join-preserving functions on them are determined by their action on the lattices' atoms. Thus powerset lattices and boolean algebras have a super-polynomial, sub-exponential number of join-endomorphisms. Nevertheless, linear order lattices allow for an exponential number of join-endomorphisms given by the central binomial coefficient.",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 105,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Distributive Lattices"
        },
        {
            "text": "The following proposition is also easy to prove from the observation that the joinendomorphisms over a linear order are also monotonic functions. In fact, this result appears in [1] and it is well-known among the RAMICS community [10, 16] . It is easy to prove that 4 n 2 \u221a n \u2264 2n n \u2264 4 n for n \u2265 1. Together with Proposition 4, this gives us explicit exponential lower and upper bounds for |E(L)| when L is a linear lattice.",
            "cite_spans": [
                {
                    "start": 178,
                    "end": 181,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 230,
                    "end": 234,
                    "text": "[10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 235,
                    "end": 238,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Distributive Lattices"
        },
        {
            "text": "The number of join-endomorphisms for some non-distributive lattices of a given size can be much bigger than that for those distributive lattices of the same size in the previous section. We will characterize this number for an archetypal non-distributive lattice in terms of Laguerre (and rook) polynomials.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "Laguerre polynomials are solutions to Laguerre's second-order linear differential equation xy +(1\u2212x)y +ny = 0 where y and y are the first and second derivatives of an unknown function y of the variable x, and n is a non-negative integer. The Laguerre polynomial of degree n in x, L n (x) is given by the summation n k=0 n k",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "The lattice M n is non-distributive for any n \u2265 3. The size of E(M n ) can be succinctly expressed as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "In combinatorics rook polynomials are generating functions of the number of ways to place non-attacking rooks on a board. A rook polynomial (for square boards) R n (x) has the form n k=0 x k r(k, n) where the (rook) coefficient r(k, n) represents the number of ways to place k non-attacking rooks on an n \u00d7 n chessboard. For instance, r(0, n) = 1, r(1, n) = n 2 and r(n, n) = n!. In general r(k, n) = n k 2 k!.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "Rook polynomials are related to Laguerre polynomials by the equation R n (x) = n!x n L n (\u2212x \u22121 ). Therefore, as a direct consequence of the above theorem, we can also characterize |E(M n )| in combinatorial terms as the following sum of rook coefficients.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "We conclude this section with another pleasant correspondence between the endomorphisms in E(M n ) and R n (x). Let f : L \u2192 L be a function over a lattice (L, ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "We say that f is non-reducing in L iff it does not map any value to a smaller one; i.e., there is no e \u2208 L such that f (e) e. The number of join-endomorphisms that are non-reducing in M n is exactly the value of the rook polynomial R n (x) for x = 1. Table 1 illustrates the join-endomorphisms over the lattice M n as a union 4 i=1 F i . Corollary 2 follows from the observation that the set of non-reducing functions in M n is equal to F 4 whose size is R n (1) as shown in the following proof of Theorem 1.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 251,
                    "end": 258,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Non-distributive Case"
        },
        {
            "text": "Proof of Theorem 1. We show that |E(M n )| can be expressed in terms of Laguerre polynomials: Table 1 , and",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 94,
                    "end": 101,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Non-distributive Case"
        },
        {
            "text": "Suppose f (\u22a5) = \u22a5. Let J, K, H be disjoint possibly empty sets such that I = J \u222a K \u222a H and let j = |J|, k = |K| and h = |H|. The sets J, K, H represent the elements of I mapped by f to , to elements of I, and to \u22a5, respectively. More precisely,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "We show that f \u2208 E(M n ) for case (3), proofs of cases (1) and (2) are included in [13] .",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "Suppose k = 0. Notice that f \u2208 F 3 and f \u2208 F 4 hence h = 1 and h = 0. Thus h > 1 implies that there are at least two e 1 , e 2 ",
            "cite_spans": [
                {
                    "start": 125,
                    "end": 126,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "Suppose k > 0. Assume h = 0. Notice that K = I \\ J and Img(f K ) \u2286 I. Since f is a \u22a5 and preserving function and it satisfies conditions (a) and (c) of",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "Assume h > 0. There must be e 1 , e 2 , e 3 \u2208 I such that f (e 1 ) = \u22a5 and f (e 2 ) = e 3 .",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 89,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "It is easy to prove that |F 1 | = 1, |F 2 | = n 2 + n and |F 3 | = n. The reader is referred to [13] for details. Here we prove that |F 4 | = n!L n (\u22121).",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 100,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "Let f \u2208 F 4 and let J \u2286 I be a possibly empty set such that Img(f J ) = { } and Img(f I\\J ) \u2286 I, where f I\\J is an injective function. We shall call j = |J|. For each of the n j possibilities for J, the elements of I \\ J are to be mapped to I by the injective function f I\\J . The number of functions f I\\J is n! j! . Therefore,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-distributive Case"
        },
        {
            "text": "We shall provide efficient algorithms for the maximization problem mentioned in the introduction: Given a finite lattice L and S \u2286 E(L) find E(L) S, i.e., the greatest joinendomorphism in the lattice E(L) below all the elements of S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms"
        },
        {
            "text": "Finding E(L) S may not be immediate. E.g., see E(L) S in Fig. 1a for a small lattice of four elements and two join-endomorphisms. As already mentioned, a naive approach is to compute E(L) S by taking \u03c3 S (c)",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 57,
                    "end": 64,
                    "text": "Fig. 1a",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Algorithms"
        },
        {
            "text": "This does not work since \u03c3 S is not necessarily a join-endomorphism as shown in Fig. 1b. A brute force solution to compute E(L) S can be obtained by generating the set S = {g | g \u2208 E(L) and g f for all f \u2208 S} and taking its join. This approach works since S = E(L) S but as shown in Sect. 3, the size of E(L) can be super-polynomial for distributive lattices and exponential in general.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 80,
                    "end": 88,
                    "text": "Fig. 1b.",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Algorithms"
        },
        {
            "text": "Nevertheless, one can use lattice properties to compute E(L) S efficiently. For distributive lattices, we use the inherent compositional nature of E(L) S. For arbitrary lattices, we present an algorithm that uses the function \u03c3 S in the naive approach to compute E(L) S by approximating it from above.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms"
        },
        {
            "text": "We will give the time complexities in terms of the number of basic binary lattice operations (i.e., meets, joins and subtractions) performed during execution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms"
        },
        {
            "text": "Here we shall illustrate some pleasant compositionality properties of the infima of joinendomorphisms that can be used for computing the join-endomorphism E(L) S in a finite distributive lattice L. In what follows we assume n = |L| and m = |S|.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Meet of Join-Endomorphisms in Distributive Lattices"
        },
        {
            "text": "We use X J to denote the set of tuples (x j ) j\u2208J of elements x j \u2208 X for each j \u2208 J.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Meet of Join-Endomorphisms in Distributive Lattices"
        },
        {
            "text": "The above lemma basically says that E(L) S (c) is the greatest element in L below all possible applications of the functions in S to elements whose join is greater or equal to c. The proof that \u03b4 S E E(L) S uses the fact that join-endomorphisms preserve joins. The proof that \u03b4 S E E(L) S proceeds by showing that \u03b4 S is a lower bound in E(L) of S. Distributivity of the lattice L is crucial for this direction. In fact without it E(L) S = \u03b4 S does not necessarily hold as shown by the following counter-example. Example 1. Consider the non-distributive lattice M 3 and S = {f 1 , f 2 } defined as in Fig. 1c . We obtain \u03b4 S (1 2) = \u03b4 S ( ) = \u22a5 and \u03b4 S (1) \u03b4 S (2) = 1 \u22a5 = 1. Then, \u03b4 S (1 2) = \u03b4 S (1) \u03b4 S (2), i.e., \u03b4 S is not a join-endomorphism.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 601,
                    "end": 608,
                    "text": "Fig. 1c",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Meet of Join-Endomorphisms in Distributive Lattices"
        },
        {
            "text": "Naive Algorithm A 1 . One could use Lemma 1 directly in the obvious way to provide an algorithm for E(L) S by computing \u03b4 S : i.e., computing the meet of elements of the form i\u2208I f i (a i ) for every tuple (a i ) i\u2208I such that i\u2208I a i c. Nevertheless, we can use Lemma 1 to provide a recursive characterization of E(L) S that can be used in a divide-and-conquer algorithm with lower time complexity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Meet of Join-Endomorphisms in Distributive Lattices"
        },
        {
            "text": "The above proposition bears witness to the compositional nature of E(L) S. It can be proven by replacing E(L) S 1 (a) and E(L) S 2 (b) by \u03b4 S1 (a) and \u03b4 S2 (b) using Lemma 1 (see [13] ).",
            "cite_spans": [
                {
                    "start": 179,
                    "end": 183,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Proposition 5. Let L be a finite distributive lattice and"
        },
        {
            "text": "Naive Algorithm A 2 . We can use Proposition 5 to compute E(L) S with the following recursive procedure: Take any partition {S 1 , S 2 } of S such that the absolute value of The time complexity of the naive algorithm A 2 is better than that of A 1 . However, by using a simple memoization technique to avoid repeating recursive calls and the following observations one can compute E(L) S in a much lower time complexity order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 5. Let L be a finite distributive lattice and"
        },
        {
            "text": "In what follows we show that E(L) S can be computed in O(mn 2 ) for distributive lattices and, in particular, in O(n + mlog n) for powerset lattices. To achieve this we use the subtraction operator from co-Heyting algebras and the notion of down set 1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using Subtraction and Downsets to Characterize E(L ) S"
        },
        {
            "text": "Subtraction Operator. Notice that in Proposition 5 we are considering all pairs a, b \u2208 L such that a b c. However, because of the monotonicity of join-endomorphisms, it suffices to take, for each a \u2208 L, just the least b such that a b c. In finite distributive lattices, and more generally in co-Heyting algebras [5] , the subtraction operator c\\a gives us exactly such a least element. The subtraction operator is uniquely determined by the property (Galois connection) b c\\a iff a b c for all a, b, c \u2208 L. Down-Sets. Besides using just c\\a instead of all b's such that a b c, we can use a further simplification: Rather than including every a \u2208 L, we only need to consider every a in the down-set of c. Recall that the down-set of c is defined as \u2193 c = {e \u2208 L |e c}. This additional simplification is justified using properties of distributive lattices to show that for any a \u2208 L, such that a c, there exists a c such that",
            "cite_spans": [
                {
                    "start": 312,
                    "end": 315,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [
                {
                    "start": 450,
                    "end": 506,
                    "text": "(Galois connection) b c\\a iff a b c for all a, b, c \u2208 L.",
                    "ref_id": null
                }
            ],
            "section": "Using Subtraction and Downsets to Characterize E(L ) S"
        },
        {
            "text": ". The above observations lead us to the following theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using Subtraction and Downsets to Characterize E(L ) S"
        },
        {
            "text": "The above result can be used to derive a simple recursive algorithm that, given a finite distributive lattice L and S \u2286 E(L), computes E(L) S in worst-case time complexity O(mn 2 ) where m = |S| and n = |L|. We show this algorithm next.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2. Let L be a finite distributive lattice and S"
        },
        {
            "text": "We first describe the algorithm DMEETAPP that computes the value E(L) S (c). We then describe the algorithm DMEET that computes the function E(L) S by calling DMEETAPP in a particular order to avoid repeating computations. We use the following definition to specify the calling order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Distributive Lattices"
        },
        {
            "text": "Let \u0394 be a bpt of S. We use \u0394(S ) for the subtree of \u0394 rooted at S \u2286 S, if it exists. We use S, \u0394 1 , \u0394 2 for the bpt of S with \u0394 1 and \u0394 2 as its left and right subtrees.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A binary partition tree (bpt) of a finite set S = \u2205 is a binary tree such that (a) its root is S, (b) if |S| = 1 then its root is a leaf, and (c) if |S| > 1 it has a left and a right subtree, themselves bpts of S 1 and S 2 resp., for a partition {S 1 , S 2 } of S."
        },
        {
            "text": "The following proposition is an immediate consequence of the previous definition. Since e \u2208 P there must be a, b satisfying the above condition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A binary partition tree (bpt) of a finite set S = \u2205 is a binary tree such that (a) its root is S, (b) if |S| = 1 then its root is a leaf, and (c) if |S| > 1 it has a left and a right subtree, themselves bpts of S 1 and S 2 resp., for a partition {S 1 , S 2 } of S."
        },
        {
            "text": "The previous algorithm may fail to produce the E(L) S for non-distributive finite lattices. Nonetheless, for any arbitrary finite lattice L, E(L) S can be computed by successive approximations, starting with some self-map known to be smaller than each f \u2208 S and greater than E(L) S. Assume a self-map \u03c3 : ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "Let \u03c3 be the function resulting after the update. Then, (1) \u03c3 \u03c3 and (2) \u03c3",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "The procedure (see Algorithm 3) loops through pairs u, v \u2208 L while there is some pair satisfying cases (1) or (2) above for the current \u03c3. When there is, it updates \u03c3 as mentioned in Theorem 4. At the end of the loop all pairs u, v \u2208 L satisfy the join preservation property. By the invariant mentioned in the theorem, this means \u03c3 = E(L) S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "for all u \u2208 L 2: Initialize Sup w , Conw, Failw, for all w 3: while w \u2208 L such that (u, v) \u2208 Conw do some conflict set not empty 4:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "Failw \u2190 Failw \u222a Sup w all pairs previously in Sup w are now failures 7:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "for u \u2208 L, verify property Sup w u 9:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "while z \u2208 L such that (x, y) \u2208 Failz do some failures set not empty 10:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "Failx \u2190 Failx \u222a Sup x all pairs in Sup x are now failures 14:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "Sup x \u2190 \u2205 15:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "for u \u2208 L, verify property Sup x u 16: if \u03c3(y) = \u03c3(y) \u03c3(z) then 17:",
            "cite_spans": [
                {
                    "start": 35,
                    "end": 38,
                    "text": "16:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "\u03c3(y) \u2190 \u03c3(y) \u03c3(z) \u03c3(y) decreases 18:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "Faily \u2190 Faily \u222a Sup y all pairs in Sup y are now failures 19:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "Sup y \u2190 \u2205 20: CHECKSUPPORTS(y) for u \u2208 L, verify property Sup y u",
            "cite_spans": [
                {
                    "start": 14,
                    "end": 30,
                    "text": "CHECKSUPPORTS(y)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Arbitrary Lattices"
        },
        {
            "text": "if \u03c3(x) \u03c3(y) = \u03c3(z) then 22:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "As for the previous algorithms in this paper the worst-time time complexity will be expressed in terms of the binary lattice operations performed during execution. Assume a fixed set S of size m. The complexity of the initialization (Line 1) of GMEET is O(nm) with n = |L |. The value of \u03c3 for a given w \u2208 L can be updated (decreased) at most n times. Thus, there are at most n 2 updates of \u03c3 for all values of L. Finding a w = u v where \u03c3(w) needs an update because \u03c3(u) \u03c3(v) = \u03c3(u v) (test of the loop, Line 2) takes O(n 2 ). Hence, the worst time complexity of the loop is in O(n 4 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "The program GMEET+ in Algorithm 4 uses appropriate data structures to reduce significantly the time complexity of the algorithm. Essentially, different sets are used to keep track of properties of (u, v) lattice pairs with respect to the current \u03c3. We have a support (correct) pairs set",
            "cite_spans": [],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "We also have a conflicts set",
            "cite_spans": [],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "Algorithm 4 updates \u03c3 as mentioned in Theorem 4 and so maintains the invariant \u03c3 E(L) S. An additional invariant is that, for all w, sets Sup w , Con w , Fail w are pairwise disjoint. When the outer loop finishes sets Con w and Fail w are empty (for all w) and thus every (u, v) belongs to Sup u v , i.e. the resulting \u03c3 = E(L) S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "Auxiliary procedure CHECKSUPPORTS(u) identifies all pairs of the form (u, x) \u2208 Sup u x that may no longer satisfy the join-endomorphism property \u03c3(u) \u03c3(x) = ",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 36,
                    "text": "CHECKSUPPORTS(u)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "Here we present some experimental results showing the execution time of the proposed algorithms. We also discuss a small example with join-endomorphisms representing dilation operators from Mathematical Morphology [2] . We use the algorithms presented above to compute the greatest dilation below a given set of dilations and illustrate its result for a simple image.",
            "cite_spans": [
                {
                    "start": 214,
                    "end": 217,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "Consider Fig. 2 . In plots Fig. 2A -C, the horizontal axis is the size of the lattice. In plots Fig. 2D -F, the horizontal axis is the size of S. Curves in images Fig. 2A -C plot, for each algorithm, the average execution time of 100 runs (10 for Fig. 2A) with Fig. 2D -F, show the mean execution time of each algorithm for 100 runs (10 for Fig. 2D ) varying the number of join-endomorphisms (|S| = 4i, 1 \u2264 i \u2264 8). The lattice size is fixed: |L| = 10 for Fig. 2E and F, and |L| = 2 5 for Fig. 2D . In all cases the lattices were randomly generated, and the parameters selected to showcase the difference between each algorithm with a sensible overall execution time. For a given lattice L and S \u2286 E(L), the brute-force algorithm explores the whole space E(L) to find all the join-endomorphism below each element of S and then computes the greatest of them. In particular, the measured spike in plot Fig. 2C corresponds to the random lattice of seven elements with the size of E(L) being bigger than in the other experiments in the same figure. In our experiments we observed that for a fixed S, as the size of the lattice increases, DMEET outperforms GMEET+. This is noticeable in lattices 2 n (see Fig. 2A) . Similarly, for a fixed lattice, as the size of S increases GMEET+ outperforms DMEET. GMEET+ performance can actually improve with a higher number of join-endomorphisms (see Fig. 2D ) since the initial \u03c3 is usually smaller in this case.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 9,
                    "end": 15,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 27,
                    "end": 34,
                    "text": "Fig. 2A",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 96,
                    "end": 103,
                    "text": "Fig. 2D",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 163,
                    "end": 170,
                    "text": "Fig. 2A",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 247,
                    "end": 255,
                    "text": "Fig. 2A)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 261,
                    "end": 268,
                    "text": "Fig. 2D",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 341,
                    "end": 348,
                    "text": "Fig. 2D",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 455,
                    "end": 462,
                    "text": "Fig. 2E",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 488,
                    "end": 495,
                    "text": "Fig. 2D",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 899,
                    "end": 906,
                    "text": "Fig. 2C",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1199,
                    "end": 1207,
                    "text": "Fig. 2A)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1383,
                    "end": 1390,
                    "text": "Fig. 2D",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "To illustrate some performance gains, Table 2 shows the mean execution time of the algorithms discussed in this paper. We include A 1 and A 2 , the algorithms outlined just after Lemma 1 and Proposition 5.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 38,
                    "end": 45,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "An MM Example. Mathematical morphology (MM) is a theory, based on topological, lattice-theoretical and geometric concepts, for the analysis of geometric structures. Its algebraic framework comprises [2, 14, 17] , among others, complete lattices together with certain kinds of morphisms, such as dilations, defined as join-endomorphisms [14] .",
            "cite_spans": [
                {
                    "start": 199,
                    "end": 202,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 203,
                    "end": 206,
                    "text": "14,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 207,
                    "end": 210,
                    "text": "17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 336,
                    "end": 340,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "Our results give bounds about the number of all dilations over certain specific finite lattices and also efficient algorithms to compute their infima.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "A typical application of MM is image processing. Consider the space G = Z 2 . A dilation [2] by s i \u2286 P(G) is a function \u03b4 si : P(G) \u2192 P(G) such that \u03b4 si (X) = {x + e | x \u2208 X and e \u2208 s i }. The dilation \u03b4 si (X) describes the interaction of an image X with the structuring element s i . Intuitively, the dilation of X by s i is the result of superimpose s i on every activated pixel of X, with the center of s i aligned with the corresponding pixel of X. Then, each pixel of every superimposed s i is included in \u03b4 si (X).",
            "cite_spans": [
                {
                    "start": 89,
                    "end": 92,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "Let L be the powerset lattice for some finite set D \u2286 G. It turns out that the dilation E(L) S corresponds to the intersection of the structuring elements of the corresponding dilations in S. Figure 3 illustrates E(L) S for the two given dilations \u03b4 s1 (I) and \u03b4 s2 (I) with structuring elements s 1 and s 2 over the given image I. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 192,
                    "end": 200,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Experimental Results and Small Example"
        },
        {
            "text": "We have shown that given a lattice L of size n and a set S \u2286 E(L) of size m, E(L) S can be computed in the worst-case in O(n + mlog n) binary lattice operations for powerset lattices, O(mn 2 ) for lattices of sets, and O(nm + n 3 ) for arbitrary lattices. We illustrated the experimental performance of our algorithms and a small example from mathematical morphology.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions and Related Work"
        },
        {
            "text": "In [9] a bit-vector representation of a lattice is discussed. This work gives algorithms of logarithmic (in the size of the lattice) complexity for join and meet operations. These results count bit-vector operations. From [1] we know that E(L) is isomorphic to the downset of (P \u00d7 P op ), where P is the set of join-prime elements of L, and that this, in turn, is isomorphic to the set of order-preserving functions from (P \u00d7 P op ) to 2. Therefore, for the problem of computing E(L) S, we get bounds O(m log 2 (2 (n 2 ) ) = O(mn 2 ) for set lattices and O(m(log 2 n) 2 ) for powerset lattices where n = |L| and m = |S|. This, however, assumes a bit-vector representation of a lattice isomorphic to E(L). Computing this representation takes time and space proportional to the size of E(L) [9] which could be exponential as stated in the present paper. Notice that in our algorithms the input lattice is L instead of E(L).",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 6,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 222,
                    "end": 225,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 789,
                    "end": 792,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Related Work"
        },
        {
            "text": "We have stated the cardinality of the set of join-endomorphisms E(L) for significant families of lattices. To the best of our knowledge we are the first to establish the cardinality (n + 1) 2 + n!L n (\u22121) for the lattice M n . The cardinalities n log 2 n for power sets (boolean algebras) and 2n n for linear orders can also be found in the lattice literature [1, 10, 16] . Our original proofs for these statements can be found in the technical report of this paper [13] .",
            "cite_spans": [
                {
                    "start": 360,
                    "end": 363,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 364,
                    "end": 367,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 368,
                    "end": 371,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 466,
                    "end": 470,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Related Work"
        },
        {
            "text": "The lattice E(L) have been studied in [6] . The authors showed that a finite lattice L is distributive iff E(L) is distributive. A lower bound of 2 2n/3 for the number of monotonic self-maps of any finite poset L is given in [4] . Nevertheless to the best of our knowledge, no other authors have studied the problem of determining the size E(L) nor algorithms for computing E(L) S. We believe that these problems are important, as argued in the Introduction; algebraic structures consisting of a lattice and joinendomorphisms are very common in mathematics and computer science. In fact, our interest in this subject arose in the algebraic setting of spatial and epistemic constraint systems [8] where continuous join-endomorphisms, called space functions, represent knowledge and the infima of endomorphisms correspond to distributed knowledge. We showed in [8] that distributed knowledge can be computed in O(mn 1+log 2 (m) ) for distributive lattices and O(n 4 ) in general. In this paper we have provided much lower complexity orders for computing infima of join-endomorphisms. Furthermore [8] does not provide the exact cardinality of the set of space functions of a given lattice.",
            "cite_spans": [
                {
                    "start": 38,
                    "end": 41,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 225,
                    "end": 228,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 692,
                    "end": 695,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 859,
                    "end": 862,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1094,
                    "end": 1097,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Related Work"
        },
        {
            "text": "As future work we plan to explore in detail the applications of our work in mathematical morphology and computer music [15] . Furthermore, in the same spirit of [11] we have developed algorithms to generate distributive and arbitrary lattices. In our experiments, we observed that for every lattice L of size n we generated, n log 2 n \u2264 |E(L)| \u2264 (n + 1) 2 + n!L n (\u22121) and if the generated lattice was distributive, n log 2 n \u2264 |E(L)| \u2264 2n n . We plan to establish if these inequalities hold for every finite lattice.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 123,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 161,
                    "end": 165,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Related Work"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Lattice Theory",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Birkhoff",
                    "suffix": ""
                }
            ],
            "year": 1967,
            "venue": "",
            "volume": "25",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Mathematical morphology",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Bloch",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Heijmans",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ronse",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Handbook of Spatial Logics",
            "volume": "",
            "issn": "",
            "pages": "857--944",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-4020-5587-4_14"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Introduction to Lattices and Order",
            "authors": [
                {
                    "first": "B",
                    "middle": [
                        "A"
                    ],
                    "last": "Davey",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "A"
                    ],
                    "last": "Priestley",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Enumeration of order preserving maps",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Duffus",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Rodl",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Sands",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Woodrow",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Order",
            "volume": "9",
            "issn": "1",
            "pages": "15--29",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Continuous Lattices and Domains",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Gierz",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "H"
                    ],
                    "last": "Hofmann",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Keimel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "D"
                    ],
                    "last": "Lawson",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mislove",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "S"
                    ],
                    "last": "Scott",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "On the lattice of all join-endomorphisms of a lattice",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Gr\u00e4tzer",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Schmidt",
                    "suffix": ""
                }
            ],
            "year": 1958,
            "venue": "Proc. Am. Math. Soc",
            "volume": "9",
            "issn": "",
            "pages": "722--722",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Belief, knowledge, lies and other utterances in an algebra for space and extrusion",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Guzm\u00e1n",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Haar",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Perchy",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rueda",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "D"
                    ],
                    "last": "Valencia",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "J. Log. Algebr. Meth. Program",
            "volume": "86",
            "issn": "1",
            "pages": "107--133",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Reasoning about distributed knowledge of groups with infinitely many agents",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Guzm\u00e1n",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Knight",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Quintero",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ram\u00edrez",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rueda",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "D"
                    ],
                    "last": "Valencia",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "30th International Conference on Concurrency Theory, CONCUR 2019",
            "volume": "29",
            "issn": "",
            "pages": "1--29",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Tree structure for distributive lattices and its applications",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Habib",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nourine",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Theor. Comput. Sci",
            "volume": "165",
            "issn": "2",
            "pages": "391--405",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Relation algebras, idempotent semirings and generalized bunched implication algebras",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Jipsen",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "RAMICS 2017",
            "volume": "10226",
            "issn": "",
            "pages": "144--158",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-57418-9_9"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Generating all finite modular lattices of a given size",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Jipsen",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lawless",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Algebra universalis",
            "volume": "74",
            "issn": "3",
            "pages": "253--264",
            "other_ids": {
                "DOI": [
                    "10.1007/s00012-015-0348-x"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Spatial and epistemic modalities in constraint-based process calculi",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Knight",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Palamidessi",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Panangaden",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "D"
                    ],
                    "last": "Valencia",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "CONCUR 2012",
            "volume": "7454",
            "issn": "",
            "pages": "317--332",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-32940-1_23"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Counting and computing joinendomorphisms in lattices",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Quintero",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ram\u00edrez",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rueda",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "D"
                    ],
                    "last": "Valencia",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Why mathematical morphology needs complete lattices",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ronse",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Sig. Process",
            "volume": "21",
            "issn": "2",
            "pages": "129--154",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "On validity in modelization of musical problems by",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rueda",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Valencia",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "CCP. Soft. Comput",
            "volume": "8",
            "issn": "9",
            "pages": "641--648",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "On discrete idempotent paths",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Santocanale",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "WORDS 2019",
            "volume": "11682",
            "issn": "",
            "pages": "312--325",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-28796-2_25"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Why mathematical morphology needs quantales",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Stell",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "International Symposium on Mathematical Morphology, ISMM09",
            "volume": "",
            "issn": "",
            "pages": "13--16",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "[6]). If (L, ) is a complete lattice, (E(L), E ) is a complete lattice.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Suppose that m \u2265 0. Let L be any lattice isomorphic to the product lattice 2 m . Then |E(L)| = n log 2 n where n = 2 m is the size of L.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Suppose that n \u2265 0. Let L be any lattice isomorphic to the linear order lattice n \u22a5 . Then |E(L)| = 2n n .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "For each c \u2208 L, \u03b4 S (c) checks n m tuples (a i ) i\u2208I , each one with a cost in O(m). Thus A 1 can compute E(L) S by performing O(n \u00d7 n m \u00d7 m) = O(mn m+1 ) binary lattice operations.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "|S 1 | \u2212 |S 2 | is at most 1. Then compute the meet of all E(L) S 1 (a) E(L) S 2 (b) for every a, b such that a b c. Then given c \u2208 L, the time complexity of a naive implementation of the above procedure can be obtained as the solution of the equation T (m) = n 2 (1 + 2T (m/2)) and T (1) = 1 which is in O(mn 2 log 2 m ). Therefore, E(L) S can be computed in O(mn 1+2 log 2 m ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "The size (number of nodes) of any bpt of S is 2m \u2212 1 where m = |S|.DMEETAPP(\u0394, c). Let \u0394 = S, \u0394 1 , \u0394 2 be a bpt of S \u2286 E(L) where L is a distributive lattice. The recursive program DMEETAPP(\u0394, c) defined in Algorithm 1 computes E(L) S (c).It uses a global lookup table T for storing the results of calls to DMEE-TAPP. Initially each entry of T stores a null value not included in L. Since S is the union of the roots of \u0394 1 and \u0394 2 , the correctness of DMEETAPP(\u0394, c) follows from Theorem 2. Termination follows from the fact that L is finite and the bpts \u0394 1 and \u0394 2 in the recursive calls are strictly smaller than \u0394.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "DMEETAPP(\u0394, c) returns E(L) S (c) where \u0394 is a bpt of S \u2286 E(L)and L is a finite distributive lattice. The global variable T is used as a lookup table.1: procedure DMEETAPP(\u0394, c) \u0394 = S, \u03941, \u03942 2: if IsNull (T [S, c]) then 3: if S = {f } then 4: T [S, c] \u2190 f (c) 5: else 6: T [S, c] \u2190 L {DMEETAPP(\u03941, a) DMEETAPP(\u03942, c\\a) | a \u2208\u2193 c}. Computing E(L) S for Distributive Lattices. Let us consider an execution of DMEE-TAPP(\u0394, c). From the definition of subtraction it follows that c\\a \u2208\u2193 c. Then for each recursive call DMEETAPP(\u0394 , a ) performed by an execution of DMEETAPP(\u0394, c) we have a \u2208\u2193 c. This and the fact that T is initialized with a null value not in L lead us the following simple observation. Observation 3. Let \u0394 = S, \u0394 1 , \u0394 2 with \u0394 1 and \u0394 2 rooted at S 1 and S 2 . Assume that T [S 1 , a ], T [S 2 , a ] \u2208 L for every a \u2208\u2193 c. Then the number of binary lattice operations (meets, joins, substractions) performed by DMEETAPP(\u0394, c) is in O(| \u2193 c|).Algorithm 2. DMEET(L, S, P ). Given a finite distributive lattice L, P \u2286 L and S \u2286 E(L), the algorithm computes T [S, c] = E(L) S(c) for each c \u2208 P . \u0394 is a bpt of S and T is a global lookup table. 1: T [S , a] \u2190 null for each a \u2208 P and each node S of \u0394 2: for each S in a post-order traversal sequence of \u0394 do visit each S of \u0394 in post-order 3: for each c \u2208 P in increasing order do visit each c \u2208 P in increasing order w.r.t L 4: DMEETAPP(\u0394(S ), c) DMEET(L, S, P ). The values of E(L) S (c) for each c \u2208 P \u2286 L are computed by the program in Algorithm 2 as follows. To satisfy the assumption in Observation 3, it visits each node S of \u0394 in post-order (i.e., before visiting a node it first visits its children). For each subtree \u0394(S ) of \u0394, it calls DMEETAPP(\u0394(S ), c) for every c \u2208 P in increasing order with respect to the order of L: I.e., before calling DMEE-TAPP(\u0394(S ), c) it calls first DMEETAPP(\u0394(S ), c ) for each c \u2208 (P \u2229 \u2193 c) \\ {c}. The correctness of the call DMEET(L, S, P ) follows from that of DMEETAPP(\u0394, c). Complexity for Distributive Lattices. Assume that L is a distributive lattice of size n and that S is a subset of E(L) of size m. The above-mentioned traversals of \u0394 and P ensure that the assumption in Observation 3 is satisfied by each call of the form DMEE-TAPP(\u0394(S ), c) performed during the execution of DMEET(L, S, L). From Proposition 6 we know that the number of iterations of the outer for is 2m \u2212 1. Clearly | \u2193 c| and |P | are both in O(n). Thus, given S we conclude from Observation 3 that the total number of operations from all calls of the form DMEETAPP(\u0394(S ), c), executed in the inner for, is in O(n 2 ). The worst-case time complexity of DMEET(L, S, L) is then in O(mn 2 ). Complexity for Powerset Lattices. Assume that L is a powerset lattice. We can compute E(L) S in O(n + mlog n) as follows. First call DMEET(L, S, P ) where P = J(L) \u222a {\u22a5} and J(L) is the set of join-irreducible elements (i.e., the singleton sets in this case) of L. Since |J(L)| = log 2 n and | \u2193 c| = 2 for every c \u2208 J(L), DMEET(L, S, P ) can be performed in O(m log n). This produces T [S, c] = E(L) S (c) for each c \u2208 P . To compute T [S, e] = E(L) S (e) for each e \u2208 L \\ P in a total time of O(n), visit each such an e in increasing order and set T [S, e] = T [S, a] T [S, b] for some a, b \u2208\u2193 e\\{e} such that e = a b.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "for all u \u2208 L. By definition of , \u03c3 is the biggest function under all functions in S, hence \u03c3 E E(L) S. The program GMEET in Algorithm 3 computes decreasing upper bounds of E(L) S by correcting \u03c3 values not conforming to the following join-endomorphism property: \u03c3(u) \u03c3(v) = \u03c3(u v). The correction decreases \u03c3 and maintains the invariant \u03c3 E E(L) S, as stated in Theorem 4.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Let L be a finite lattice, u, v \u2208 L, \u03c3 : L \u2192 L and S \u2286 E(L). Assume \u03c3 E E(L) S holds, and consider the following updates:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Average performance time of GMEET+, DMEET and BRUTE-FORCE. Plots A and D use 2 n lattices, B and E distributive lattices, and C and F arbitrary (possibly non-distributive) lattices. Plots A-C have a fixed number of join-endomorphisms and plots D-F have a fixed lattice size. \u03c3(u x) because of an update to \u03c3(u). When this happens, it adds (u, x) to the appropriate Con, or Fail set. The time complexity of the algorithm depends on the set operations computed for each w \u2208 L chosen, either in the conflicts Con w set or in the failuresFail w set. When a w is selected (for some (u, v) such that u v = w) the following holds: (1) at least one of \u03c3(w), \u03c3(u), \u03c3(v) is decreased,(2)some fix k number of elements are removed from or added to a set, (3) a union of two disjoint sets is computed, and (4) new support sets of w, u or v are calculated. With an appropriate implementation, operations (1)-(2) take O(1), and also operation (3), since sets are disjoint. Operation (4) clearly takes O(n). In each loop of the (outer or inner) cycles of the algorithm, at least one \u03c3 reduction is computed. Furthermore, for each reduction of \u03c3, O(n) operations are performed. The maximum possible number of \u03c3(w) reductions, for a given w, is equal to the length d of the longest strictly decreasing chain in the lattice. The total number of possible \u03c3 reductions is thus equal to nd. The total number of operations of the algorithm is then O(n 2 d). In general, d could be (at most) equal to n, therefore, after initialization, worst case complexity is O(n 3 ). The initialization (Lines 1-2) takes O(nm) + O(n 2 ), where m = |S|. Worst time complexity is thus O(mn + n 3 ). For powerset lattices, d = log 2 n, thus worst time complexity in this case is O(mn + n 2 log 2 n).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Binary image I (on the left). Dilations \u03b4s 1 , \u03b4s 2 for structuring elements s1, s2. On the right E(L) {\u03b4s 1 , \u03b4s 2 } (I). New elements of the image after each operation in grey and black.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Families F1, . . . , F4 of join-endomorphisms of Mn. I = {1, . . . , n}. f A is the restriction of f to a subset A of its domain. Img(f ) is the image of f . A function from each Fi for M5 is depicted with blue arrows.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Average time in seconds over powerset lattices with |S| = 4",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We are indebted to the anonymous referees and editors of RAMICS 2020 for helping us to improve one of the complexity bounds, some proofs, and the overall quality of the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgments."
        }
    ]
}