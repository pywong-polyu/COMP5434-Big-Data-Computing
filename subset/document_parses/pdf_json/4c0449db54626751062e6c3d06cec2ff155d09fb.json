{"paper_id": "4c0449db54626751062e6c3d06cec2ff155d09fb", "metadata": {"title": "Cherry-Picking from Spaghetti: Multi-range Filtering of Event Logs", "authors": [{"first": "Maxim", "middle": [], "last": "Vidgof", "suffix": "", "affiliation": {"laboratory": "", "institution": "Vienna University of Economics and Business (WU)", "location": {"settlement": "Vienna", "country": "Austria"}}, "email": "maxim.vidgof@wu.ac.at"}, {"first": "Djordje", "middle": [], "last": "Djurica", "suffix": "", "affiliation": {"laboratory": "", "institution": "Vienna University of Economics and Business (WU)", "location": {"settlement": "Vienna", "country": "Austria"}}, "email": ""}, {"first": "Saimir", "middle": [], "last": "Bala", "suffix": "", "affiliation": {"laboratory": "", "institution": "Vienna University of Economics and Business (WU)", "location": {"settlement": "Vienna", "country": "Austria"}}, "email": ""}, {"first": "Jan", "middle": [], "last": "Mendling", "suffix": "", "affiliation": {"laboratory": "", "institution": "Vienna University of Economics and Business (WU)", "location": {"settlement": "Vienna", "country": "Austria"}}, "email": ""}]}, "abstract": [{"text": "Mining real-life event logs results into process models which provide little value to the process analyst without support for handling complexity. Filtering techniques are specifically helpful to tackle this problem. These techniques have been focusing on leaving out infrequent aspects of the process which are considered outliers. However, it is exactly in these outliers where it is possible to gather important insights on the process. This paper addresses this problem by defining multi-range filtering. Our technique not only allows to combine both frequent and nonfrequent aspects of the process but it supports any user-defined intervals of frequency of activities and variants. We evaluate our approach through a prototype based on the PM4Py library and show the benefits in comparison to existing filtering techniques.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "The goal of process mining is extracting actionable process knowledge using event logs of IT systems that are available in the organizations [1] . Process discovery is one of the areas of interest of process mining that is concerned with the extracting the process models from logs. With the development of process mining, a number of automated process discovery algorithms that address this problem has appeared.", "cite_spans": [{"start": 141, "end": 144, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Introduction"}, {"text": "The problem with automated process discovery of process models from event logs is that despite the variety of different algorithms, automated process discovery methods all suffer from joint deficiencies when used for real-life event logs [1] : they produce large spaghetti-like models and they produce models with either low level of fitness to the event log, or have low precision or generalization. Managing to correct these shortcomings proved to be a difficult task. Research by Augusto et al. [2] states that for complex event logs it is highly recommended to use filtering of the logs before automated process discovery techniques and that without this type of filtering precision of the resulting models is close to zero. The authors also highlight a research gap that is necessary to be closed suggesting the need to develop a filter which will can be tuned at will to deal with complex logs.", "cite_spans": [{"start": 238, "end": 241, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 498, "end": 501, "text": "[2]", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Introduction"}, {"text": "Therefore, the purpose of our study was to rectify this research gap by implementing a new filter, able to capture both most frequent behavior and the rare one. We created a prototype based on the PM4Py, process mining toolkit for Python [3] . Our prototype is fully customizable in which the user define an arbitrary number of ranges for both activities and variants of the process that user wants to analyze. In this research, we demonstrate how our technique helps to unveil new insights into the process using an illustrative example from the real-world event log.", "cite_spans": [{"start": 238, "end": 241, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Introduction"}, {"text": "This paper is structured as follows. Section 2 describes the problem setting and discusses common process mining techniques that rely on filtering of the logs in order to simplify models. Further, we present different types of filters and compare them. Finally, we derive requirements for new filter type. Section 3 presents a conceptual description of our filter with the formal definitions, while Sect. 4 presents an example that emphasizes the benefits of this technique. Section 5 shows the benefits of our technique against existing process mining tools. Section 6 concludes the paper and discusses future work.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "This section describes the problem and provides an overview on related literature before deriving three requirements for a filtering technique.", "cite_spans": [], "ref_spans": [], "section": "Theoretical Background"}, {"text": "Data analysis plays a fundamental part in Business Process Management (BPM) and allows to improve processes based on facts. Process mining is the main technique to analyze processes using data which stem from event logs. These event logs keep track of the history of the various runs of the business process execute over time. Real world event logs typically contain a high number of cases, which may or may not differ from one another in the way they were handled. Mining such event logs usually results in models which contain an overwhelming amount of behavior (i.e., process variants). These models are also referred to as Spaghetti models as they make it hard to identify specific paths in their chaotic layout.", "cite_spans": [], "ref_spans": [], "section": "Motivation and Problem Description"}, {"text": "Spaghetti models provide little value as they are hard to understand. Literature has defined several techniques to overcome this problem, such as reducing complexity on a log level [11] and reducing complexity on a model level [6] . A main technique for reducing complexity offered by many of the process mining techniques is filtering. Usually process mining techniques show their results in visual interfaces which offer sliders to set up custom parameters for filtering. By moving these sliders the user are able to focus on specific aspects of the process.", "cite_spans": [{"start": 181, "end": 185, "text": "[11]", "ref_id": "BIBREF10"}, {"start": 227, "end": 230, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Motivation and Problem Description"}, {"text": "What makes spaghetti models so complex is the fact that they show all possible behaviour, including paths that were seldom taken in the process. Therefore, the focus of existing techniques from both academia and practice has been on filtering out this infrequent behaviour. We argue that in some cases, it is the infrequent behaviour that gives us better important insights on problems in the process, thus helping improvement. Indeed, existing tools such as ProM 1 , Disco 2 and Celonis 3 are able to filter for specific behaviour. However, there is no way to set these filters in such a way that multiple variants or activities are shown together. This way of filtering leaves out important information, which might be seen for instance by a combination of the most and the least frequent cases.", "cite_spans": [], "ref_spans": [], "section": "Motivation and Problem Description"}, {"text": "Let us illustrate the problem through a running example. Figure 1 shows a simple complaint handling process adapted from [5] . The process works as follows. After a client files a complaint, (s)he immediately receives an automated confirmation message. Next, an employee brings the application to a meeting with colleagues in order to discuss a solution. The same employee is in charge of contacting back the customer with an apology and proposes a solution. The solution may be accepted or rejected by the client. In case of acceptance, the solution is executed right away. In case of rejection, the employee contacts the client to investigate on alternatives. As long as a reasonable alternative is found, the employee has a new meeting with colleagues to discuss the solution and proceed as usual. If no alternative solutions can be found, the complaint is brought to court and the process fails. There are several ways in which instances of the process may traverse the depicted process model. The sunny case scenario, is the one in which an agreement with the client is found right away. In a good process this case should occur frequently. On the opposite, the rainy case scenario consists of the cases which result in no agreement and the company is brought to court. In this case, the costs sustained from the company may be much higher than settling for a solution. An intermediate scenario is the one in which a customer does not accept the first proposed solution, but some iterations are done.", "cite_spans": [{"start": 121, "end": 124, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [{"start": 57, "end": 65, "text": "Figure 1", "ref_id": null}], "section": "Motivation and Problem Description"}, {"text": "In order to improve the process, the company is interested to compare the sunny case scenario in order to understand which were the decisions and the proposed solutions that lead to the respective outcomes. Table 1a lists the activities involved in the process as well as their short labels for better readability.", "cite_spans": [], "ref_spans": [{"start": 207, "end": 215, "text": "Table 1a", "ref_id": "TABREF1"}], "section": "Motivation and Problem Description"}, {"text": "Typical process mining techniques retrieve variants as shows in Table 1b (i.e., sorted by frequency). Each variant represents one path in the output process model. In order to simplify the model, filtering must be used. However, if we filter out the least frequent behavior, we lose the information on the rainy case, which is the one that bears higher costs for the company. Some process mining tools like Celonis, would allow to select exactly the variant corresponding to the rainy case scenario. Unfortunately, this would leave out the sunny case scenario, which is also of interest of the company as this is the scenario in which the best decisions were taken. The same consideration also holds for events and activities. Indeed, the company might be interested in activities or events which occur within a specific range of frequencies. For instance, the top 10 most frequent and the top 10 most infrequent activities can play a role into guiding process redesign. In other words, frequency of traces and activities do not necessarily reflect importance. There may be extremely infrequent variants or activities which have a very high impact on the process (e.g., Black Swans [10] ). Hence, it is crucial that filtering does not compromise this information.", "cite_spans": [{"start": 1182, "end": 1186, "text": "[10]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Motivation and Problem Description"}, {"text": "According to Dumas et al. [5] , process mining tools use two approaches to simplify event logs: abstraction and event log filtering. Abstraction is used to remove the subset of the nodes from the process map, producing a smaller dependency graph of the given event log. This way of simplifying process models is often beneficial because it enables model viewers to aggregate paths or activities of a given Spaghetti model and provides them with a better understanding about how the process functions on a macro level. However, while abstraction can visualize large event logs, it lacks the efficiency of coping with the full complexity of real-life event logs [6] .", "cite_spans": [{"start": 26, "end": 29, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 660, "end": 663, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Filtering Techniques"}, {"text": "Consequently, process mining offers another type of event log simplification called event log filtering. Filtering an event log can be achieved with the use of three types of filters that remove a subset of the traces, events, or event pairs intending to produce a simpler log. Event filters allow users to remove or to keep all the events that satisfy a predefined condition set by the user. They allow users to focus only on a particular activity. Event pair filter, allow users to remove or keep all the pairs of events that fulfill a specific condition. This type of event log filtering is used to show a relation between two events and gather more insight into, for instance, situations where event A is followed by event B. Finally, using trace filters enables users to remove or retain all the traces from the log that fit the defined criteria. This filter can be used to, for example, show all the traces that occur with a defined level of frequency, or all traces that have a specific duration of cycle time [6] .", "cite_spans": [{"start": 1017, "end": 1020, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Filtering Techniques"}, {"text": "In their paper on filtering out infrequent behaviour from event logs, Conforti et al. [4] mention more types of event filters mainly used in process mining tool ProM. First such filter is Filter Log by Attribute which removes all the events where the value of the attribute is not equal to the value defined by the user. It can also remove all the events that do not contain a certain selected attribute. Next, Filter on Timeframe serves to filter out all the events which fall into the desired timeframe. Some filters serve to filter out infrequent behaviour. One such instance is a Filter Log using Simple Heuristics which can remove all the traces that do not start and/or end with a particular event. It also can remove all the events related to the specific process task by calculating frequencies of event occurrence. Another example of the infrequent behaviour filter is Filter Log using Prefix-Close Language. This filter eliminates all the traces that are not a prefix of another prefix in the log by using a frequency threshold defined by the user.", "cite_spans": [{"start": 86, "end": 89, "text": "[4]", "ref_id": "BIBREF3"}], "ref_spans": [], "section": "Filtering Techniques"}, {"text": "While both abstraction and event log filtering techniques work well with structured processes but have problems visualizing and discovering less structured ones, recently, new techniques have been emerging that try to bridge this gap [9, 12] . Trace clustering is a technique where the event log is divided into homogeneous subsets which are then used to create separate process models. This approach is able to cope with real flexible environments and improve process mining results. However, trace clustering is shown to suffer from a significant difference between clustering and the evaluation biases. The technique that tackles this problem, and manages to bridge this difference is Active Trace Clustering [12] inspired by principles of active learning. This approach borrows elements from machine learning and utilizes selective sampling strategy which enables an active learner to decide which instances to select based on their informativeness. Most frequently used informativeness measure is the frequency of the trace.", "cite_spans": [{"start": 234, "end": 237, "text": "[9,", "ref_id": "BIBREF8"}, {"start": 238, "end": 241, "text": "12]", "ref_id": "BIBREF12"}, {"start": 712, "end": 716, "text": "[12]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Filtering Techniques"}, {"text": "Several process discovery algorithms deal with noise in the logs are developed. The most well-known ones are Heuristics Miner [13] , Inductive Miner [7] , and Fuzzy Miner [6] . Heuristics miner deals with noise by introducing frequencybased metrics, while Inductive Miner uses two types of filters that accomplish this. The first filter applies a similar approach to Heuristics Miner and removes all the edges from the directly-follows graphs. In contrast, the second filter removes edges that the first filter did not remove by using eventually-follows graphs. However, process models mined using Inductive miner are often oversimplified. A different approach to the previous two is Fuzzy Miner. This algorithm filters noise directly on the discovered model using the desired level of significance and correlation thresholds defined by users.", "cite_spans": [{"start": 126, "end": 130, "text": "[13]", "ref_id": "BIBREF13"}, {"start": 149, "end": 152, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 171, "end": 174, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Filtering Techniques"}, {"text": "As we can see, there are numerous techniques and algorithms which can be used to simplify event logs and models to help users understand the core process better. However, all of them are achieving this by filtering out infrequent behaviour, considering it to be the noise in the event logs [1] . We argue that this is a substantial limitation that needs to be addressed since infrequent behaviour can carry important information which is lost by filtering it out of the log. For example, having an insight into rare cases can help companies detect errors in the process or even detect fraud. Furthermore, none of the presented techniques considers that users might want to observe a process model that comprises both the most frequent and infrequent traces of the process.", "cite_spans": [{"start": 290, "end": 293, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Filtering Techniques"}, {"text": "Against this background, we derive the following requirements for a filtering technique.", "cite_spans": [], "ref_spans": [], "section": "Requirements for a Filtering Technique"}, {"text": "A filtering technique must allow the user to slice the log. That is, it must offer a way of selecting process variants relevant to the user. RQ2. (Select activities). A filtering technique must be able to dice the log. That is, it must offer a way of selecting the most relevant activities for the user. RQ3. (Multi-range filtering) . A filtering technique must be able to slice and dice on multiple ranges. That is, it must offer a way of selecting relevant information form several frequency intervals.", "cite_spans": [], "ref_spans": [{"start": 309, "end": 332, "text": "(Multi-range filtering)", "ref_id": null}], "section": "RQ1. (Select variants)."}, {"text": "In this section we describe our filtering technique that allows to learn process models without ruling out infrequent behaviour. We show an overview of the technique, provide the necessary definitions and then describe the technique in detail.", "cite_spans": [], "ref_spans": [], "section": "Technique for Multi-range Filtering"}, {"text": "Our technique is summarized in Fig. 2 . It takes as input an event log and two user defined multi-ranges. A multi-range is a set of intervals of frequencies. As we use frequencies, interval boundaries are from 0 to 1, where [0,0] means that we get the least frequent variant or activity, and [0,1] means that that we consider all possible behavior. The aforementioned multi-ranges are used respectively by two filter types: i) variants filter; and ii) activities filter. These two filters can be used independently or consecutively. In the latter case, their application must follow the order: variants filter first. The output of each filter is a simplified event log, complying with filtering criteria. This event log can be used by any process mining technique to generate a process model which allows the user to analyze the data. ", "cite_spans": [], "ref_spans": [{"start": 31, "end": 37, "text": "Fig. 2", "ref_id": "FIGREF1"}], "section": "Overview of the Technique"}, {"text": "For example, given L = [ a, b, c, d, e, f, g, h 20 , a, b, c, d, e, i, j, k, l 5 ], then  vf ( a, b, c, d, e, f, g, h ) = 20 and af (a) = 25.", "cite_spans": [], "ref_spans": [{"start": 13, "end": 119, "text": "given L = [ a, b, c, d, e, f, g, h 20 , a, b, c, d, e, i, j, k, l 5 ], then  vf ( a, b, c, d, e, f, g, h )", "ref_id": "FIGREF1"}], "section": "Definition 3 (Variant frequency, Activity frequency). Variant frequency vf (V ) is defined as the frequency occurrence of its constituting traces t \u2208 V . Activity frequency af (a) is defined as the sum of the number of times activity a in the event log L."}, {"text": "A filtering technique is a function f : L \u2192 L which transforms an event log L into a simpler event log L . Next, we use the given definitions to describe the algorithms used by our technique.", "cite_spans": [], "ref_spans": [], "section": "Definition 3 (Variant frequency, Activity frequency). Variant frequency vf (V ) is defined as the frequency occurrence of its constituting traces t \u2208 V . Activity frequency af (a) is defined as the sum of the number of times activity a in the event log L."}, {"text": "Our implementation provides two filters: the variants filter and the activities filter. These two filters are composable but their application is not commutative, i.e. it has to be performed in strictly defined order. Namely, first the variants filter is applied and then the activities filter is applied on the results of the variants filter. In case the former one filtered out some variants, only the activities present in the remaining variants can be used in the latter one.", "cite_spans": [], "ref_spans": [], "section": "Implementation"}, {"text": "We are interested in filtering at multiple ranges in the event log. These Ranges can be applied to both filtering on the variants level -referred to as R vand filtering on the activities level -R a . Since the range boundaries are specified as frequency percentages, the minimum value of min i is 0, and the maximum value of max i is 1. We also establish that [min, max] means that the boundaries of the interval are included and (min, max) means the boundaries are excluded. With this definition we can express the non-overlaps condition on the ranges specified by the user as \u2200i, j \u2208 [0...n] \u21d2 [min i , max i ] \u2229 [min j , max j ] = \u2205. This is a precondition for applying both the activity and the variants filters. In other words, ranges may share boundaries but they must not overlap.", "cite_spans": [], "ref_spans": [], "section": "Implementation"}, {"text": "Our implementation consists of three main blocks. First, the ranges specified by the user for each of the applied filters are checked for overlaps. If the ranges are incorrect, an error is produced and the filtering is not applied.", "cite_spans": [], "ref_spans": [], "section": "Implementation"}, {"text": "Second, if the ranges are correct, the variants filter can be applied. The variants are filtered according to Algorithm 1.", "cite_spans": [], "ref_spans": [], "section": "Implementation"}, {"text": "Third, we can apply Algorithm 2 on the resulting log. First, it builds a list of activities sorted by their frequency, analogous to Algorithm 1. Then, a range filter is applied in the same manner. Finally, we iterate over all traces in the input log and rebuild them in such a way that only filtered activities remain in the trace. The new trace is appended to the output log only in case it is not empty, i.e. it contains at least one of the activities that should remain. ", "cite_spans": [], "ref_spans": [], "section": "Implementation"}, {"text": "Next, we built a prototype to evaluate our technique. This section presents the results. First, we describe the experimental setup. Then we demonstrate that our technique addresses all the requirements by applying our technique to the running example we provided in Sect. 2.1. Last, we show the usefulness of our technique in a real-life log.", "cite_spans": [], "ref_spans": [], "section": "Results"}, {"text": "We implemented our technique as a prototype. We built our prototype using the PM4Py [3] library. It is a library for process mining implemented in the Python programming language. We used Jupyter notebook for our implementation. We tested on a laptop with Intel\u00aeCore \u2122 i7-8565U CPU @ 4.60 GHz x 4 machine with 16 GB of DDR4 RAM and Linux kernel 4.15.0-88-generic 64-bit version.", "cite_spans": [{"start": 84, "end": 87, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Experimental Setup"}, {"text": "By default, our tool takes an event log in XES format as input but it can be also configured to accept event log in CSV format. The output is a filtered log, again, in XES or CSV format. The output of our tool can be used with any other process process mining tool. Apart from mining the resulting log in PM4Py, the user can export it and work on it with other tools like ProM, Disco, Celonis, etc. We used PM4Py and ProM in our evaluation. Our prototype is publicly available as open source software on GitHub 4 .", "cite_spans": [], "ref_spans": [], "section": "Experimental Setup"}, {"text": "We generated a log of our example process in Fig. 1 using BIMP 5 . The log contains 1000 cases and was built with the following rules: i) positive response is received with 80% probability; ii) negative response is received with 20% probability; iii) alternative solution exists with 80% probability; iv) no alternative solutions exist with 20% probability.", "cite_spans": [], "ref_spans": [{"start": 45, "end": 51, "text": "Fig. 1", "ref_id": null}], "section": "Results on Artificial Log"}, {"text": "In order to evaluate our technique, let us apply our prototype on this artificial log. As already mentioned, the two filters can be used both separately and combined. First, we can use the variants filter to keep process behaviour that is of interest to us. Let us say, we are interested in the most frequent and the least frequent variants. To do that, we apply Algorithm 1 and specify two ranges for the filter: R v = {[0, 0.15], [0.9, 1]}. It means we want to keep the 15% least frequent paths as well as 10% most frequent ones. It is very important to interpret these ranges correctly: by saying we take 15% most infrequent paths we do not mean taking 15% of the cases. Instead, we mean here paths that are between the 0th and the 15th percentile in a list of all variants in the input log sorted by their frequency.", "cite_spans": [], "ref_spans": [], "section": "Results on Artificial Log"}, {"text": "We do not want to filter out any activities at this point, thus we specify one range R a = [0, 1] for the activities filter, meaning we want to keep 100% of activities. This gives us a filtered log L that we can use further either in PM4Py or in any other tool. Figure 3 shows a Petri net resulting from applying Heuristics miner in ProM on the filtered log and adapted for better readability.", "cite_spans": [], "ref_spans": [{"start": 262, "end": 270, "text": "Figure 3", "ref_id": "FIGREF4"}], "section": "Results on Artificial Log"}, {"text": "However, we may also want to filter activities at this point. Note that as we already applied the first filter on our log, only the activities present in the selected variants will be available for us to pick from. Let us say, we want to see the least frequent activities as well as the ones of medium frequency but not the most frequent ones. In order to do that, we can set multiple ranges for You can also see that the range boundaries are allowed to be the same but an overlap between ranges is not allowed. Figure 4 shows the resulting model, again, adapted to improve readability. As we can see, it only includes the activities that are in the specified range: 40% least frequent activities and some activities with medium frequency. However, the new model does not contain the most frequent activities as they are outside of the specified range. This allows the user to concentrate on the less frequent and presumably more interesting activities. In conclusion, the proposed technique fulfills the requirements for an information-preserving filtering technique. More specifically, the requirements identified in Sect. 2.3 are addressed as follows.", "cite_spans": [], "ref_spans": [{"start": 512, "end": 520, "text": "Figure 4", "ref_id": "FIGREF5"}], "section": "Results on Artificial Log"}, {"text": "is addressed as the resulting model only shows the least frequent behaviour and the most frequent one.", "cite_spans": [], "ref_spans": [], "section": "RQ1. (Select variants)"}, {"text": "is addressed by the activities filter. Here the less frequent activities such as Evaluate acceptable alternative (J), Go to court (K) as well as the ones with medium frequency like Complaint received are present whereas the most frequent ones like Discuss solution (C) and Send apology (D) are filtered out.", "cite_spans": [], "ref_spans": [], "section": "RQ2. (Select activities)"}, {"text": "RQ3. (Multi-range filtering) is addressed by our novel range specification approach. Instead of only selecting one threshold or manually picking some variants, the user can now specify multiple non-overlapping frequency ranges, and the union of sets of entities (variants or activities, depending on the filter) is written to the filtered log. The models above not only contain the least frequent traces like \u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,I,J,K,L\u232a but also the most frequent one such as \u2329A,B,C,D,E,F,G,H\u232a. However, the traces with medium frequency are not included in the filtered log L .", "cite_spans": [], "ref_spans": [], "section": "RQ2. (Select activities)"}, {"text": "Next, we applied our technique on a real-life event log of sepsis cases [8] . This is a publicly available log containing more than 1000 traces and 15000 events, each trace corresponding to a pathway through the hospital.", "cite_spans": [{"start": 72, "end": 75, "text": "[8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Results on Real-Life Logs"}, {"text": "By exploring the log, we can find out that there are 846 different variants, the most frequent of which includes only 35 cases that corresponds to slightly more than 3% of all traces in the log. There are also 784 variants having only a single conforming trace in the log. This means that the term frequent variant is not applicable to this log. Thus, it makes little sense to apply the variants filter on the log so we can set the range of the first filter to [0, 1] .", "cite_spans": [{"start": 461, "end": 464, "text": "[0,", "ref_id": null}, {"start": 465, "end": 467, "text": "1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Results on Real-Life Logs"}, {"text": "What is really of interest to us is the activities filter. While the filters of the traditional process mining tools only allow to keep the most frequent activities, which we will discuss in more detail in Sect. 5, our filter gives us more opportunities. Fir instance, we can decide to take a deeper look only into the least frequent activities. For this, we would set the activities filter to a range of [0, 0.25]. But we can also add additional ranges to these filter. Let us say, apart from the least frequent activities we are also interested in the one activity lying at the 65th percentile of frequency. This is also possible, for this we just set the second range to [0.65,0.65]. Now, if we apply the Heuristics miner on the filtered log and convert it to a Petri net, we will get a model in Fig. 5 . Again, here we only see the activities that are in the specified range of frequency, and this picture cannot be achieved by any other process mining tool.", "cite_spans": [], "ref_spans": [{"start": 799, "end": 805, "text": "Fig. 5", "ref_id": "FIGREF6"}], "section": "Results on Real-Life Logs"}, {"text": "Process mining allows the users to turn event logs into process models. However, real-life behaviour captured in these event logs of the process may be complex and exhibit notable variability. This leads to so-called spaghetti models (Fig. 6a) that are difficult to comprehend. Filtering reduces the complexity of such models by limiting the number of traces used to produce the model or the number of activities shown in the resulting model.", "cite_spans": [], "ref_spans": [{"start": 234, "end": 243, "text": "(Fig. 6a)", "ref_id": "FIGREF7"}], "section": "Discussion"}, {"text": "However, the users have little options to decide what information stays in the model and what can be left out for the moment, since existing process mining tools treat frequency as an ultimate measure of importance of a variant or an activity. Due to this, they only offer the user to keep the most frequent activities or paths. We claim, however, that a process can contain activities that are still very important despite infrequency but the tools provide virtually no possibility to include them and reduce complexity at the same time. Some of the tools provide the option to focus on any single path -also possibly an infrequent one -but then the big picture is lost and the process analyst has to manually incorporate this path in the model in case it is important. Moreover, no tool offers an option to focus on infrequent activities.", "cite_spans": [], "ref_spans": [], "section": "Discussion"}, {"text": "Our novel technique increases the utility of filtering event logs for the process analysts by allowing to set multiple ranges of frequency both for filtering variants and activities. Let us provide an illustrative example. Figure 6b shows a model produced by PM4Py heuristics miner from the real-life log about sepsis cases that we used in the previous section. Here, we used single-range filtering with R v = [0.65, 1] for the variants filter and R a = [0.6, 1] for the activities filter. Figure 6c is generated from a log where multi-range filtering was applied. In fact, only a slight modification was done to the activities filter: R a = {[0.3, 0.3], [0.6, 1]}. This modification leads to the new activity Return ER -the patient returning to the hospital -appearing in the model. This activity, judging from the name, may be extremely important for the domain expert, although it does not happen frequently.", "cite_spans": [], "ref_spans": [{"start": 223, "end": 232, "text": "Figure 6b", "ref_id": "FIGREF7"}, {"start": 490, "end": 499, "text": "Figure 6c", "ref_id": "FIGREF7"}], "section": "Discussion"}, {"text": "As this example shows, our filtering technique fills the gap that other techniques cannot fill. It does so by allowing the user to set multiple frequency ranges for both variants and activities, which in turn makes it possible to focus on previously disregarded behaviour and gain insights about the process behaviour that no other tool can provide. This can be beneficial in scenarios like monitoring of safety-critical processes, or controlling for possible fraudulent behaviour in companies. In such cases, it is of utmost importance that a filtering technique does not leave out information about potentially harmful cases. ", "cite_spans": [], "ref_spans": [], "section": "Discussion"}, {"text": "In this paper we provide a novel filtering technique which sacrifices infrequent occurrence neither of process variants nor of process activities. We leveraged the PM4Py libraries to build a prototype which can work with multiple event logs formats. As well, the result of our technique can be input to several process mining algorithms. We tested our technique both on a synthetic log generated from a well known process model as well as with real-world event logs. Our evaluation shows that we can obtain new insights which were either too hard to implement or not offered by existing process mining tools. Our work has limitations. At current stage, intervals are defined as lists of tuples in Jupyter notebooks. This does not target end users with limited programming skills. In future work, we plan to implement a user-friendly interface. Furthermore, we plan to apply our technique in real-world scenarios, such as auditing, in which multi-range filtering may unveil possible pattern of fraud or non-compliance. Finally, we plan to extend state of the art techniques by enriching them with multi-range capabilities.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Process Mining -Data Science in Action", "authors": [{"first": "W", "middle": ["M P"], "last": "Van Der Aalst", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1007/978-3-662-49851-4"]}}, "BIBREF1": {"ref_id": "b1", "title": "Automated discovery of process models from event logs: review and benchmark", "authors": [{"first": "A", "middle": [], "last": "Augusto", "suffix": ""}], "year": 2019, "venue": "IEEE Trans. Knowl. Data Eng", "volume": "31", "issn": "4", "pages": "686--705", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Process mining for python (PM4PY): bridging the gap between process -and data science", "authors": [{"first": "A", "middle": [], "last": "Berti", "suffix": ""}, {"first": "S", "middle": ["J"], "last": "Van Zelst", "suffix": ""}, {"first": "W", "middle": ["M P"], "last": "Van Der Aalst", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Filtering out infrequent behavior from business process event logs", "authors": [{"first": "R", "middle": [], "last": "Conforti", "suffix": ""}, {"first": "M", "middle": [], "last": "La Rosa", "suffix": ""}, {"first": "A", "middle": ["H M"], "last": "Ter Hofstede", "suffix": ""}], "year": 2017, "venue": "IEEE Trans. Knowl. Data Eng", "volume": "29", "issn": "2", "pages": "300--314", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Fundamentals of Business Process Management", "authors": [{"first": "M", "middle": [], "last": "Dumas", "suffix": ""}, {"first": "M", "middle": [], "last": "La Rosa", "suffix": ""}, {"first": "J", "middle": [], "last": "Mendling", "suffix": ""}, {"first": "H", "middle": ["A"], "last": "Reijers", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1007/978-3-642-33143-5"]}}, "BIBREF5": {"ref_id": "b5", "title": "Fuzzy mining -adaptive process simplification based on multi-perspective metrics", "authors": [{"first": "C", "middle": ["W"], "last": "G\u00fcnther", "suffix": ""}, {"first": "W", "middle": ["M P"], "last": "Van Der Aalst", "suffix": ""}], "year": 2007, "venue": "BPM 2007", "volume": "4714", "issn": "", "pages": "328--343", "other_ids": {"DOI": ["10.1007/978-3-540-75183-0_24"]}}, "BIBREF6": {"ref_id": "b6", "title": "Discovering block-structured process models from event logs -a constructive approach", "authors": [{"first": "S", "middle": ["J J"], "last": "Leemans", "suffix": ""}, {"first": "D", "middle": [], "last": "Fahland", "suffix": ""}, {"first": "W", "middle": ["M P"], "last": "Van Der Aalst", "suffix": ""}], "year": 2013, "venue": "PETRI NETS 2013", "volume": "7927", "issn": "", "pages": "311--329", "other_ids": {"DOI": ["10.1007/978-3-642-38697-8_17"]}}, "BIBREF7": {"ref_id": "b7", "title": "Eindhoven University of Technology. Dataset. Sepsis Cases -Event Log", "authors": [{"first": "F", "middle": [], "last": "Mannhardt", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.4121/uuid:915d2bfb-7e84-49ad-a286-dc35f063a460"]}}, "BIBREF8": {"ref_id": "b8", "title": "Trace clustering in process mining", "authors": [{"first": "M", "middle": [], "last": "Song", "suffix": ""}, {"first": "C", "middle": ["W"], "last": "G\u00fcnther", "suffix": ""}, {"first": "W", "middle": ["M P"], "last": "Van Der Aalst", "suffix": ""}], "year": 2009, "venue": "BPM 2008. LNBIP", "volume": "17", "issn": "", "pages": "109--120", "other_ids": {"DOI": ["10.1007/978-3-642-00328-8_11"]}}, "BIBREF9": {"ref_id": "b9", "title": "Random house", "authors": [{"first": "N", "middle": ["N"], "last": "Taleb", "suffix": ""}], "year": 2007, "venue": "The Black Swan: The Impact of the Highly Improbable", "volume": "2", "issn": "", "pages": "", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Understanding spaghetti models with sequence clustering for ProM", "authors": [{"first": "G", "middle": ["M"], "last": "Veiga", "suffix": ""}, {"first": "D", "middle": ["R"], "last": "Ferreira", "suffix": ""}], "year": 2009, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Active trace clustering for improved process discovery", "authors": [{"first": "J", "middle": ["D"], "last": "Weerdt", "suffix": ""}, {"first": "S", "middle": ["K L M"], "last": "Vanden Broucke", "suffix": ""}, {"first": "J", "middle": [], "last": "Vanthienen", "suffix": ""}, {"first": "B", "middle": [], "last": "Baesens", "suffix": ""}], "year": 2013, "venue": "IEEE Trans. Knowl. Data Eng", "volume": "25", "issn": "12", "pages": "2708--2720", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Flexible Heuristics Miner (FHM). In: CIDM", "authors": [{"first": "A", "middle": ["J M M"], "last": "Weijters", "suffix": ""}, {"first": "J", "middle": ["T S"], "last": "Ribeiro", "suffix": ""}], "year": 2011, "venue": "", "volume": "", "issn": "", "pages": "310--317", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "\u2329A,B,C,D,E,I,J,C,D,E,F,G,H \u232a 132 \u2329A,B,C,D,E,I,J,K,L \u232a 30 \u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,F,G,H \u232a 21 \u2329A,B,C,D,E,I,J,C,D,E,I,K,L \u232a 6 \u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,I,J,C,D,E,F,G,H \u232a 2 \u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,I,J,K,L \u232a 2 (b) Process variants ordered by trace frequency", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Overview of the approach3.2 PreliminariesDefinition 1 (Event, activity). Let A be the universe of events. Each event has attributes. Let AN be the set of attribute names. For any event e \u2208 A and name n \u2208 AN , # n (e) is the value of the attribute n for event e. An activity is a specific attribute of an event, i.e., # activity (e) is the activity associated to the event.For example, # activity (e) = 'Discuss solution'.Definition 2 (Trace, variant, event log). A trace t = e 1 , . . . , e n is a finite sequence of events. An event log L \u2286 {t} * is a multi-set of traces, i.e. A process variant is a subset of traces V \u2286 L. Variants group together traces which have similarities to one another and differences to traces in other variants. An example of trace is t = a, b, c, d, e, f, g, h . An example of log is L = [ a, b, c, d, e, f, g, h 20 , a, b, c, d, e, i, j, k, l 5 ]. In this event log, the first trace occurs 20 times whereas the second one occurs 5 times.", "latex": null, "type": "figure"}, "FIGREF2": {"text": "ranges represent frequencies expressed by the user in the form of sets of intervals. That is, R = {[min 0 , max 0 ], [min 1 , max 1 ], . . . [min n , max n ]} with min i <= max i , i = 1, . . . , n signifies that the user want to retain from the log an amount of information that falls into either of the intervals [min 0 , max 0 ], . . . , [min n , max n ].", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Input: Event log L. Ranges V = {(min0, max0) . . . (minm, maxm)}, m \u2208 N0 Result: A new event log L \u2286 L 1 variants \u2190 \u2200 variants \u2208 L; 2 variants \u2190 sort variants by vfL(variant); 3 nr variants \u2190 |variants|; 4 indices \u2190 m i=0 {n \u2208 N0|n \u2208 [round(mini \u00d7 nr variants), round(maxi \u00d7 nr variants)]}; 5 f iltered variants \u2190 i\u2208indices variantsi; 6 L \u2190 \u2200trace \u2208 L \u2229 f iltered variants; Algorithm 2. Filter activities Input: Event log L . Ranges A = {(min 0 , max 0 ), . . . , (min p , max p )}, p \u2208 N 0 Result: A new event log L \u2286 L 1 activities \u2190 dict(key = activity, value = af L (activity)); 2 forall variant \u2208 L do 3 forall activity \u2208 variant do 4 if activity / \u2208 activities then 5 activities = activities \u222a {activity}; 6 af L (activity) \u2190 vf L (variant); 7 else 8 af L (activity) \u2190 af L (activity) + vf L (variant) 9 end 10 end 11 end 12 activities \u2190 sort activities by af L (activity); 13 nr activities \u2190 |activities|; 14 indices \u2190 p i=0 {n \u2208 N 0 |n \u2208 [round(min i \u00d7 nr activities), round(max i \u00d7 nr activities)]}; 15 f iltered activities \u2190 i\u2208indices activities i ; 16 L \u2190 []; 17 forall trace \u2208 L do 18 new trace \u2190 []; 19 forall activity \u2208 trace do 20 if activity \u2208 f iltered activities then 21 new trace = new trace \u222a {activity}; 22 end 23 end 24 if new trace = \u2205 then 25 L \u2190 L \u222a {new trace}; 26 end 27 end", "latex": null, "type": "figure"}, "FIGREF4": {"text": "Model from the artificial log inTable 1with variants ranges Rv = {[0, 0.15], [0.9, 1]} produced by heuristics miner and transformed into a Petri net. the activities filter: R a = {[0, 0.1], [0.1, 0.3], [0.4, 0.6]}.", "latex": null, "type": "figure"}, "FIGREF5": {"text": "Model from the artificial log inTable 1with variants ranges Rv = {[0, 0.15], [0.9, 1]} and activities ranges Ra = {[0, 0.1], [0.1, 0.3], [0.4, 0.6]} produced by heuristics miner and transformed into a Petri net.", "latex": null, "type": "figure"}, "FIGREF6": {"text": "Model from the real-life log with activities ranges [0,0.25] and [0.65,0.65] produced by heuristics miner and transformed into a Petri net", "latex": null, "type": "figure"}, "FIGREF7": {"text": "Impact of filtering on the resulting process models", "latex": null, "type": "figure"}, "TABREF1": {"text": "Process activities and variants", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Variant </td><td>Count\n</td></tr><tr><td>\u2329A,B,C,D,E,F,G,H \u232a </td><td>807\n</td></tr><tr><td>\u2329A,B,C,D,E,I,J,C,D,E,F,G,H </td><td>\u232a 132\n</td></tr><tr><td>\u2329A,B,C,D,E,I,J,K,L </td><td>\u232a 30\n</td></tr><tr><td>\u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,F,G,H </td><td>\u232a 21\n</td></tr><tr><td>\u2329A,B,C,D,E,I,J,C,D,E,I,K,L </td><td>\u232a 6\n</td></tr><tr><td>\u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,I,J,C,D,E,F,G,H </td><td>\u232a 2\n</td></tr><tr><td>\u2329A,B,C,D,E,I,J,C,D,E,I,J,C,D,E,I,J,K,L </td><td>\u232a 2\n</td></tr></table></body></html>"}}, "back_matter": []}