{
    "paper_id": "89cbbdd144c15fc3fc52f7a873f5ad103a6af290",
    "metadata": {
        "title": "GPU-Based Criticality Analysis Applied to Power System State Estimation",
        "authors": [
            {
                "first": "Ayres",
                "middle": [],
                "last": "Nishio Da",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universidade Federal Fluminense",
                    "location": {
                        "settlement": "Niteroi",
                        "region": "RJ",
                        "country": "Brazil"
                    }
                },
                "email": "ayresnishio@gmail.com"
            },
            {
                "first": "Silva",
                "middle": [],
                "last": "Junior",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universidade Federal Fluminense",
                    "location": {
                        "settlement": "Niteroi",
                        "region": "RJ",
                        "country": "Brazil"
                    }
                },
                "email": ""
            },
            {
                "first": "Esteban",
                "middle": [
                    "W G"
                ],
                "last": "Clua",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universidade Federal Fluminense",
                    "location": {
                        "settlement": "Niteroi",
                        "region": "RJ",
                        "country": "Brazil"
                    }
                },
                "email": ""
            },
            {
                "first": "Milton",
                "middle": [
                    "B"
                ],
                "last": "Do",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universidade Federal Fluminense",
                    "location": {
                        "settlement": "Niteroi",
                        "region": "RJ",
                        "country": "Brazil"
                    }
                },
                "email": ""
            },
            {
                "first": "Coutto",
                "middle": [],
                "last": "Filho",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universidade Federal Fluminense",
                    "location": {
                        "settlement": "Niteroi",
                        "region": "RJ",
                        "country": "Brazil"
                    }
                },
                "email": ""
            },
            {
                "first": "Julio",
                "middle": [
                    "C"
                ],
                "last": "Stacchini De Souza",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universidade Federal Fluminense",
                    "location": {
                        "settlement": "Niteroi",
                        "region": "RJ",
                        "country": "Brazil"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "State Estimation (SE) is one of the main tools in the operation of power systems. Its primary role is to filter statistically small errors and to eliminate spurious measurements. SE requires an adequate number of measurements, varied, and strategically distributed in the power grid. Criticality analysis consists of identifying which combinations of measurements, forming tuples of different cardinalities, are essential for observing the power network as a whole. If a tuple of measurements becomes unavailable and, consequently, unobservable, the tuple is considered critical. The observability condition is verified by the factorization of the residual covariance matrix, which usually is a time-consuming computation task. Also, the search for criticalities is costly, being a combinatorial based problem. This paper proposes a parallel approach of the criticality analysis in the SE realm, through multi-threads execution on CPU and GPU environments. To date, no publication reporting the use of GPU for computing critical elements of the SE process is found in the specialized literature. Numerical results from simulations performed on the IEEE 14-and 30-bus test systems showed speed-ups close to 25\u00d7, when compared with parallel CPU architectures.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The Energy Management System (EMS) found in control centers encompasses computational tools to monitor, control, and optimize the operation of power networks. Among these tools, the State Estimation (SE) is responsible for processing a set of measurements to obtain the system operating state [1, 12] . The SE process depends on the number, type, and distribution of measurements throughout the grid. The observability/criticality analysis reveals the vulnerability of the measuring system to feed SE adequately. This analysis aims to discover the strengths and weaknesses of measurement plans, allowing preventive actions against possible cyber-attacks, and offering different choices of measurement reinforcements. However, due to its combinatorial characteristics, criticality analysis is computationally very expensive.",
            "cite_spans": [
                {
                    "start": 293,
                    "end": 296,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 297,
                    "end": 300,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The word critical is used in the paper to denote extremely important or essential elements of the measuring system devoted to SE. In this sense, the following definitions are stated:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "-Critical Measurement (C meas ): when not available, it makes the complete system unobservable. -Critical k-Tuple (C k ): the set of k measurements that, when simultaneously unavailable, leads the system to an unobservable state;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Besides the remarked unobservability cases, the presence of C ks compromises the SE credibility as a function capable of providing a dataset free of gross errors [3] . When there are one or more C meas in the available measurement set, it is impossible to detect any error in the value of these measurements coming from the SE residual analysis. On the other hand, if (k \u2212 2) measurements with gross errors belong to a C k , they can be detected/identified, but if (k \u2212 1) or (k) spurious measurements are present in this C k , they can only be detected. The criticality analysis becomes computationally costly, particularly when the cardinality of critical tuples k increases, as the consequence of the factorial number of possible combinations to analyze. This paper presents a parallel programming approach to speed up the process of searching for criticalities (of single measurements or when they are considered forming groups), in which diverse combinations of measurements are simultaneously analyzed. Based on the best knowledge existing so far, there is no publication concerning the use of GPU for identifying critical elements of the SE process is found in the specialized literature. The results (obtained in a multi-core GPU environment) of simulations performed on the IEEE 14-and 30-bus test systems validate the proposed approach. This paper is organized as follows: Sect. 2 presents some previous works related to criticality analysis. Section 3 presents the residual covariance matrix and its respective application to solve the problem. Section 4 presents our proposed algorithm and it's adaptations to parallel computing. Section 5 shows the results of the implementations in CPU and GPU environments. Finally, Sect. 6 concludes this work.",
            "cite_spans": [
                {
                    "start": 162,
                    "end": 165,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "One of the first studies on criticality analysis and its relation with the detection/ identification of gross measurement errors can be found in [6] . As the identification of all C ks present in a measurement system is a difficult optimization problem [14] , most of the published works were limited to study small cardinalities (k \u2264 3). This paper adopts the method based on the residual covariance matrix to identify C ks [3] .",
            "cite_spans": [
                {
                    "start": 145,
                    "end": 148,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 253,
                    "end": 257,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 425,
                    "end": 428,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Related Works"
        },
        {
            "text": "Criticality analysis is a useful tool to evaluate the robustness of measurement schemes [5, 7] , as well as to prevent possible cyber-attacks of false data injections, as described in [10, 15] . In this type of attack, a malicious attacker intentionally adds gross errors to the available measurements. Based on previous knowledge of the measurement criticalities, it is possible to take preventive actions (e.g., to reinforce the metering plan), so that the effect of an attack can be mitigated.",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 91,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 92,
                    "end": 94,
                    "text": "7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 184,
                    "end": 188,
                    "text": "[10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 189,
                    "end": 192,
                    "text": "15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Related Works"
        },
        {
            "text": "Few studies have been conducted to address the general problem of searching for C ks . Reference [2] tackles this hard combinatorial problem via the Branchand-Bound (B&B) approach. B&B is a tree-based exploratory tool for finding implicitly exact solutions.",
            "cite_spans": [
                {
                    "start": 97,
                    "end": 100,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Related Works"
        },
        {
            "text": "Parallel programming has been used to speed up the estimation filtering process [9, 10] . B&B algorithms in GPUs [4] have also been implemented. The GPU approach to deal with criticality analysis in SE using the residual covariance matrix method can be considered the main contribution of the present paper.",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 83,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 84,
                    "end": 87,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 113,
                    "end": 116,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Related Works"
        },
        {
            "text": "The entries of the residual covariance matrix (\u03a9) represent the degree of interaction between measurements, which can be explored in the criticality analysis [3] . Also, using the definition of a C k previously introduced, the following properties are useful [6]:",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 161,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "The Residual Covariance Matrix Method"
        },
        {
            "text": "1. The columns of matrix \u03a9 associated with the measurements that form a C k are linearly dependent. 2. A C k does not contain a C j , for \u2200k > j.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Residual Covariance Matrix Method"
        },
        {
            "text": "Null elements in \u03a9 indicate the presence of entirely uncorrelated measurements. Therefore, null rows/columns in \u03a9 are associated with C meas . Now, consider\u03a9 denoting a submatrix of \u03a9, composed of the columns/rows associated with a group of k measurements. If\u03a9 has linearly dependent columns/rows, then the measurements associated with those form a C k . Gauss elimination can be used to factorize\u03a9 to check whether there are linearly dependent rows/columns in the matrix.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Residual Covariance Matrix Method"
        },
        {
            "text": "To gain insight into criticalities, for instance, consider the six-bus system represented in Fig. 1 , measured by five power flows and four power injections, for which all C ks present in the set of measurements will be identified. Symmetric matrix \u03a9, obtained with the decoupled model for the adopted test system and usually adopted in the classical observability analysis [1] is presented in Table 1 . Table 1 . Covariance matrix \u03a9, obtained from six bus system depicted in Fig. 1 Meas. # 1 2 3 As one can observe, there is no null columns/rows in \u03a9; thus, the set of measurements is free from C meas . Now, concerning, for instance, the tuples of cardinality two, a C 2 is identified, involving the measurements #4 and #9, i.e., branch 4 \u2212 6 power flow (P 4,6 ) and the power injection at bus 6 (P 6 ). The submatrix\u03a9 4,9 is built with the entries related to the respective rows/columns:",
            "cite_spans": [
                {
                    "start": 374,
                    "end": 377,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 93,
                    "end": 99,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 394,
                    "end": 401,
                    "text": "Table 1",
                    "ref_id": null
                },
                {
                    "start": 404,
                    "end": 411,
                    "text": "Table 1",
                    "ref_id": null
                },
                {
                    "start": 476,
                    "end": 482,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "The Residual Covariance Matrix Method"
        },
        {
            "text": "(\u03a9 4,9 ) = 0.50 0.50 0.00 0.00 (2) For tuples of cardinality 3, for instance, rows #2, #7, and #8 are associated with measurements (P 2\u22123 , P 3 , P 5 ) that form a C 3 . Submatrices \u03a9 2,7,8 in (3) and its equivalent triangular form in (4), support this conclusion. ",
            "cite_spans": [
                {
                    "start": 31,
                    "end": 34,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "The Residual Covariance Matrix Method"
        },
        {
            "text": "Together with (P 2\u22123 , P 3 , P 5 ) nine more C 3 are identified. They are: (P 1\u22122 , P 2\u22123 , Table 2 summarizes the results achieved for all C ks . There is an upper limit (k lim ) for the cardinality of C ks , which is dependent of the difference between m (number of available measurements) and n (number of state variables), given by: k lim = m \u2212 n + 1. Thus, for the system under analysis, k lim = 9 \u2212 6 + 1 = 4. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 92,
                    "end": 99,
                    "text": "Table 2",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "The Residual Covariance Matrix Method"
        },
        {
            "text": "The proposed algorithm receives as input \u03a9, m, and k max and returns as output the solution set (solSet) containing all criticalities C ks in the measurement set. The solution set contains binary vectors, in which the elements that correspond measurements removed from the set are represented by 1. Figure 2 depicts the C ks that were found in the illustrative example of Sect. 4 stored in the solSet.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 299,
                    "end": 307,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Proposed Algorithm"
        },
        {
            "text": "As the number of C k is previously unknown, solSet was implemented as a stack. The main algorithm adaptation to parallel programming considers the possibility to evaluate all possible k combinations of m measurements simultaneously.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Algorithm"
        },
        {
            "text": "Algorithm 1 shows that each cardinality is analyzed separately within a loop until the adopted k max is reached. Furthermore, each loop consists of four steps, as shown in Algorithm 1. The following subsections detail each one of these steps. The first step creates a combination matrix (combM at) (( k m ) \u00d7 m) to store all possible combinations of m measurements taken from k at a time. Steps 2 and 3 are the main focus of the present work, in which CPU and GPU parallel computing are adopted.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Algorithm"
        },
        {
            "text": "Step 2 identifies combinations of measurements whose removal compromises the system observability. The third step checks whether or not the solution of the second step is indeed a C k . Finally, step 4 updates the solution set (solSet).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Algorithm"
        },
        {
            "text": "input : \u03a9, m, kmax output: ConjSol for k \u2190 1 to kmax do",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: Parallel Critcality Analysis"
        },
        {
            "text": "Step 1: Build Combinaton Matrix",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: Parallel Critcality Analysis"
        },
        {
            "text": "Step 2: Find out Possible C k s",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: Parallel Critcality Analysis"
        },
        {
            "text": "Step 3: Confirm C k s",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: Parallel Critcality Analysis"
        },
        {
            "text": "Step 4: Update Solution Set end",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: Parallel Critcality Analysis"
        },
        {
            "text": "The construction of combM at is an adaptation of the algorithm presented in [13] . The original algorithm allocates the measurement combinations in a stack so that they can be further successively accessed. However, to allow a parallel implementation, the combinations are represented by rows in a matrix data structure, enabling concurrent access to them.",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 80,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Step 1 : Combination Matrix"
        },
        {
            "text": "At this step, the algorithm builds a submatrix\u03a9 for each row in combM at. Then, the invertibility of each\u03a9 is tested by using Gauss Elimination, identifying possible C ks .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Step 2 : Searching for C ks"
        },
        {
            "text": "As can be seen in Algorithm 2, there is an auxiliary binary array isCrit in which each element corresponds to a row in combM at. If the algorithm finds a possible C k , it assigns 1 to its corresponding element in isCrit; otherwise, it assigns 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Step 2 : Searching for C ks"
        },
        {
            "text": "The multi-thread computing runs each loop in Algorithm 2 simultaneously. The array isCrit enables threads to record which row of combM at is a possible C k concurrently. Distinctly, in GPU implementation, this step requires \u03a9 and combM at to be transferred to GPU global memory. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Step 2 : Searching for C ks"
        },
        {
            "text": "Considering C j (j < k) a criticality solution previously stored in solSet, the algorithm compares all C j with all rows in combM at. If a row has its corresponding isCrit = 1 and contains any C j , then the measurement combination found in step 2 is not a C k . Consequently, the algorithm updates its related value in isCrit to 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Step 3 : Confirmation"
        },
        {
            "text": "The algorithm uses an element-wise subtraction to verify if an array is a subset of another. For instance, considering C 2 = {1001} as a critical set previouslystored in solSet and C 3 = {1011} as possible criticality found in step two. Subtracting each element of those arrays, (C 3 \u2212 C 2 ) = {0010}, then, since there was no element equal to \u22121 in such operation, one can conclude that C 2 \u2282 C 3 . So C 3 is not considered critical, and its related element in isCrit is set to 0. The multi-thread approach executes the inner loop in Algorithm 3 simultaneously. Also, for this implementation on GPU, solSet must be initially transferred to the GPU global memory.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Step 3 : Confirmation"
        },
        {
            "text": "In this last step, all the rows of combM at with the corresponding isCrit = 1 are added to solSet, as shown in Algorithm 4. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Step 4 : Solution Set"
        },
        {
            "text": "for i =0 : ( k m ) do if isCrit[i]==1",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 4: Solution Set"
        },
        {
            "text": "This section presents the comparative results between the sequential steps two and three and its parallel implementations in multi-core CPU and GPU environments. For GPU computing, such comparison also considered the data management between host and device.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "Simulations carried out on a computer with 8 GB RAM, Intel Core i5-9300H processor, and NVIDIA GeForce GTX 1650 graphics card. The original singlethreaded algorithm was implemented in C++. Furthermore, the CPU multithreading was performed by OpenMP, using 8 threads and GPU computing in NVIDIA CUDA, using 512 threads in each kernel call.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "From the performed simulations it could be noted that the use of parallelism did not prove to be advantageous in systems with a few measurements and for small values of k, which resulted in almost any combinations to be analyzed. Therefore, results for k > 6 using the IEEE 14-bus and IEEE 30-bus test systems will be presented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "Also, some values of k resulted in a large number of combinations that could not be stored at once in the combination matrix. Then, the k-value analysis (with more than 2 20 combinations) was partitioned.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "The IEEE 14-bus test case adopts the measuring system presented in [3] , in which there are 33 measurements available. Table 3 shows the search space covered by the proposed algorithm and the number of C ks found and confirmed up to k = 10.",
            "cite_spans": [
                {
                    "start": 67,
                    "end": 70,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 119,
                    "end": 126,
                    "text": "Table 3",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "IEEE 14-Bus System"
        },
        {
            "text": "As can be seen in Figs. 3 and 4 , for both steps, better performance has been achieved with the GPU implementation, reaching in Step 2 an average speed-up of 13x when compared to the original serial implementation, as it can be seen in Table 4 . Besides, as it is shown in Table 5 , in Step 3 we achieved speed-ups of 25x.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 18,
                    "end": 31,
                    "text": "Figs. 3 and 4",
                    "ref_id": null
                },
                {
                    "start": 236,
                    "end": 243,
                    "text": "Table 4",
                    "ref_id": "TABREF5"
                },
                {
                    "start": 273,
                    "end": 280,
                    "text": "Table 5",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "IEEE 14-Bus System"
        },
        {
            "text": "Tests were also performed with the IEEE 30-bus system with a low redundant measurement set, adapted from [2] . Table 6 confirms that the lack of redundant measurements results in more C ks of lower cardinalities. Therefore, Step 3 becomes more expensive, as those C ks are added early to the solution set and are always compared to every possible C k found in Step 2. Figures 5 and 6 show that GPU implementation again presented the best performance. As it is shown in Table 7 and 8, the speedups observed in Steps 2 and 3 were 13x and 18x, respectively. The decrease of the speedup in Step 3, concerning the one obtained with the IEEE 14-bus system, occurs because of a larger solSet is transferred to GPU global memory in each loop. The analysis for k = 9 became too expensive for the single thread CPU implementation. In GPU it took around 23 min to perform Step 3.",
            "cite_spans": [
                {
                    "start": 105,
                    "end": 108,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [
                {
                    "start": 111,
                    "end": 118,
                    "text": "Table 6",
                    "ref_id": null
                },
                {
                    "start": 368,
                    "end": 383,
                    "text": "Figures 5 and 6",
                    "ref_id": null
                },
                {
                    "start": 469,
                    "end": 476,
                    "text": "Table 7",
                    "ref_id": null
                }
            ],
            "section": "IEEE 30-Bus System"
        },
        {
            "text": "As mentioned in the introduction section, the specialized literature is sparse in studies related to the problem of searching for critical elements is state estimation. In [2] , one can find results of a B&B algorithm implemented in a CPU environment to identify C ks of cardinalities up to five in the IEEE 30-bus system. However, no information on the estimated computing time to perform this task is provided, which could enable comparative studies on the subject. At this point, it is opportune to comment that the results obtained in the paper point to a successful novel application of GPUs to perform the criticality analysis task in power system state estimation studies. As such, the proposed use of GPUs can be seen as a reference implementation, to demonstrate (proof of concept) that it is a feasible option when compared with its CPU counterparts, acting as a starting point for more elaborated (optimized) implementations. Thus, the results obtained here serve as benchmarks for future correlated research works.",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 175,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "IEEE 30-Bus System"
        },
        {
            "text": "In this work we developed a novel parallel approach for identification of measurement criticalities. Our solution may affect the quality of power system state estimation, due to its high increase of performance. The use of GPUs proved to be useful to address this difficult combinatorial problem, allowing the determination of cardinalities that would be very costly to achieve in a single-thread CPU. Different test systems and measurement redundancies were tested and the proposed implementation lead to speedups up to 28\u00d7, showing its potential for the identification of measurement criticalities, particularly those of high cardinality, whose determination is usually more challenging.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Since managing data transfer between host and device is a bottleneck for all the solutions, in future works, we intend to include steps 1 and 4 at the GPU level. However, adapt those steps to parallel implementation is not a trivial task. In step 1, it is challenging to build the combination matrix in GPU, because it is not straightforward to correlate each combination to each thread identification, according to [11] . In step 4, since we implemented the solution set in a stack, it is not possible to add elements concurrently to set. We believe that exists a better data structure that ensures performance improvements in this implementation. Important improvements in the parallel code are also possible to be made, such as the usage of GPU streams in order to assist large-scale combination arrays. We also believe that we can better explore parallel approaches to assist the Branch and Bound heuristic that were already implemented for criticality analysis solution.",
            "cite_spans": [
                {
                    "start": 416,
                    "end": 420,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Power System State Estimation: Theory and Implementation",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Abur",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "G\u00f3mez Exp\u00f3sito",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Branch-and-bound guided search for critical elements in state estimation",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "A"
                    ],
                    "last": "Augusto",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "B"
                    ],
                    "last": "Do Coutto Filho",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C S"
                    ],
                    "last": "De Souza",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "A R"
                    ],
                    "last": "Guimaraens",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Trans. Power Syst",
            "volume": "34",
            "issn": "",
            "pages": "2292--2301",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Assessing strengths and weaknesses of measurement sets for state estimation",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "A"
                    ],
                    "last": "Augusto",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "A R"
                    ],
                    "last": "Guimaraens",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "B"
                    ],
                    "last": "Do Coutto Filho",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Stacchinni De Souza",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "2017 IEEE Manchester PowerTech",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Parallel branch and bound on a CPU-GPU system",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Boukedjar",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "E"
                    ],
                    "last": "Lalami",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "El-Baz",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "2012 20th Euromicro International Conference on Parallel, Distributed and Network-based Processing",
            "volume": "",
            "issn": "",
            "pages": "392--398",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "m \u2212 k Robust observability in state estimation",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Castillo",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Conejo",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "E"
                    ],
                    "last": "Pruneda",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Solares",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "M"
                    ],
                    "last": "Menendez",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "IEEE Trans. Power Syst",
            "volume": "23",
            "issn": "",
            "pages": "296--305",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Multiple bad data detectability and identifiability: a geometric approach",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Clements",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "W"
                    ],
                    "last": "Davis",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "IEEE Trans. Power Deliv",
            "volume": "1",
            "issn": "",
            "pages": "355--360",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Power network observability: the assessment of the measurement system strength",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "D"
                    ],
                    "last": "Crainic",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "P"
                    ],
                    "last": "Horisberger",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [
                        "D"
                    ],
                    "last": "Do",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Mukhedkar",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "IEEE Trans. Power Syst",
            "volume": "5",
            "issn": "",
            "pages": "1267--1285",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "The usage of parallel calculations in state estimation algorithms",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ilya",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Pavel",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Olga",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Andrey",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "2017 9th International Conference on Information Technology and Electrical Engineering (ICITEE)",
            "volume": "",
            "issn": "",
            "pages": "1--5",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Accelerated parallel WLS state estimation for largescale power systems on GPU",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Karimipour",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Dinavahi",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "2013 North American Power Symposium (NAPS)",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "On false data injection attack against dynamic state estimation on smart power grids",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Karimipour",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Dinavahi",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "2017 IEEE International Conference on Smart Energy Grid Engineering (SEGE)",
            "volume": "",
            "issn": "",
            "pages": "388--393",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Large neighborhood local search optimization on graphics processing units",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "V"
                    ],
                    "last": "Luong",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Melab",
                    "suffix": ""
                },
                {
                    "first": "E.-G",
                    "middle": [],
                    "last": "Talbi",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "2010 IEEE International Symposium on Parallel a& Distributed Processing. Workshops and PhD Forum (IPDPSW)",
            "volume": "",
            "issn": "",
            "pages": "1--8",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Power System State Estimation: A Generalized Approach",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Monticelli",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "The coolest way to generate combinations",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ruskey",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Williams",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Discrete Math",
            "volume": "309",
            "issn": "",
            "pages": "5305--5320",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Computing critical k-tuples in power networks",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "C"
                    ],
                    "last": "Sou",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Sandberg",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "H"
                    ],
                    "last": "Johansson",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "IEEE Trans. Power Syst",
            "volume": "27",
            "issn": "",
            "pages": "1511--1520",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "False data injection attacks in electricity markets",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Xie",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Mo",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Sinopoli",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "2010 First IEEE International Conference on Smart Grid Communications",
            "volume": "",
            "issn": "",
            "pages": "226--231",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Six bus system, with its Measurement set",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Examples of output representation for criticalities P4\u22126; P6} and {P2\u22123; P3; P5",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Performance Performance for Step 3, 14-bus case",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Number of visited combinations of measurements and C ks identified in the 6-bus system depicted inFig. 1Cardinality k No. of visited combinations of measurements No. of C ks identified",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Step 2: Searching for C ks",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Confirmation",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "IEEE 14-bus system visited combinations and C ks confirmed",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "Speed-ups achieved for Step 2 in the IEEE 14-bus system",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "Speed-ups achieved for Step 3 in the IEEE 14-bus system",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Time [sec]",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "Speed-ups achieved for Step 2 in IEEE 30-bus system CPU Single-Thread \u00d7 CPU Multi-Thread 3.41 3.75 3.31 3.51 CPU Single-Thread \u00d7 GPU 11.60 12.92 13.11 12.55 Speed-ups achieved for Step 3 in IEEE 30-bus system",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}