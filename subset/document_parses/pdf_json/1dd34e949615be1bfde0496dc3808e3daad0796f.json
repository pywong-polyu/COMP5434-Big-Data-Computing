{
    "paper_id": "1dd34e949615be1bfde0496dc3808e3daad0796f",
    "metadata": {
        "title": "Malware Detection Framework Using PCA Based ANN",
        "authors": [
            {
                "first": "Khyati",
                "middle": [],
                "last": "Rami",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Mewar University",
                    "location": {
                        "settlement": "Gangarar",
                        "region": "Rajasthan",
                        "country": "India"
                    }
                },
                "email": "khyati.rami@gmail.com"
            },
            {
                "first": "(",
                "middle": [
                    "B"
                ],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Vinod",
                "middle": [],
                "last": "Desai",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Different kinds of computer threats exist to damage the computer system, and Malicious programs is one of them. Internet can be the main source to spread some threats. Experts continuously detect those which can slow down the system, or totally damage it. Malware creators have always been a step ahead. To detect malware threat, there are two basic approaches, based on signature and heuristic. For accurate and efficient result of malware detection there are detection techniques based on heuristic method. Polymorphic malwares are growing day by day and heuristic method is combined with machine learning to get more precise and effective detection. Malware detection system using data mining and machine learning methods have been proposed by many researchers to detect known and unknown malware. In this paper we present the ideas behind our malware detection framework by PCA based ANN to detect known and unknown malware. To design the proposed framework we have used MATLAB GUI.ANN is used to detect the presence of malware in CSDMC2019 API dataset. The computational time for ANN classifier is less than 0.2 s compared to NB classifier which has a computational time of 0.82 s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Computer threats is created to corrupt confidential information and malicious ways to irritate users, well malware is one of these threats. Malware is increasing at alarming rate to ruin the system. Due to that security incidents is to be grown [1, 2] . Propagation ability of malware is like chain reaction which is dangerous due to none centralized control therefore it is not easy to detect. Malwares are crucial threat to computer security according to studies [3] . Malware intelligent are trying to create program which cannot be traced easily, and time to time they are changing their techniques so malware can be transformed into the malicious code without detection. These simple ideas start first with encryption which go further with oligiomorphic, polymorphic and metamorphic viruses. As per studies existing techniques are found limited therefore combination of the Artificial Intelligence, Machine Learning and Data mining methods are increased efficiency of detection of malware [4] . Signature based detection methods are efficient to detect known malwares but not enough to detect unknown malware and polymorphic malware due to its signature changes nature. Heuristic based detection methods can trace known and unknown malwares but result can be found high rate of false positive and negative therefor it requires to develop detections methods with accuracy. The heuristic based detection techniques are combined with machine learning method to get accurate and efficient result of malware detection, due to alarming increasing rate of polymorphic malwares. So current condition requires for everyone to find better solution. The paper is organized as follows: Sect. 1 describes the introduction, Sect. 2 describe the literature review, Sect. 3 describe the proposed malware detection system and Sect. 4 describes the results. In this research work ANN is used to detect the presence of malware in CSDMC2019 API dataset. We have tested the proposed malware detection system while connecting it to a mobile OS and transferring a file from mobile OS to desktop OS. We use MALTAB GUI to design the proposed malware detection system, whereas in Sect. 5 we give the conclusion.",
            "cite_spans": [
                {
                    "start": 245,
                    "end": 248,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 249,
                    "end": 251,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 465,
                    "end": 468,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 994,
                    "end": 997,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Mariantonietta La Polla [5] surveys the different threats, vulnerabilities and security solutions for more than decade specifically in the period 2004-2014, by focusing on high-level attacks, which are on user applications. We can group existing approaches keeping in mind to protect mobile devices against different classes of attacks into different categories, based upon the detection principles, architectures, collected data and OS, main focus is on IDS-based models and tools. With this categorization, we aim to provide clear and concise view of the underlying model accepted by each approach. Sujithra M. [6] focused on various threats and vulnerabilities that affect the mobile devices and discussed how biometrics could be a solution to the mobile devices ensuring security. These systems are proved highly confidential portable mobile based security systems which is very much required. Comparing various biometric features such as fingerprint, face, gait, iris, signature and voice. Iris is proved the most effective biometric feature due to its reliability and accuracy. We have also reviewed some research papers based on Malware detection for known and unknown malware. In the following table describe the comparison of studied papers (Table 1) . ",
            "cite_spans": [
                {
                    "start": 24,
                    "end": 27,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 613,
                    "end": 616,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 1250,
                    "end": 1259,
                    "text": "(Table 1)",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Literature Review"
        },
        {
            "text": "In the above sections, we have presented a brief review about the malware detection and prevention techniques introduced in the past decades. Day by day the malware writers are improving and evolving camouflage techniques from simple encrypted virus to extreme complex and difficult to detect polymorphic and metamorphic viruses. Based on the literature review we have designed malware detection Model for known and unknown malware.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Summary"
        },
        {
            "text": "A smart host-based system was developed to detect malware on mobile devices and was evaluated. The framework is designed to be light on the system such that it consumes minimum CPU, memory and battery. It continuously samples various features on the device and collects data which is then analyzed using machine learning and temporal reasoning method and the state of the device. The features of the framework are divided into two categories namely Application Framework and Linux Kernel respectively. Features such as Messaging, Phone calls and Applications belong to the former whereas Keyboard, Touch Screen, Scheduling and Memory belong to the latter. The above Framework helps in the detection of malware and in finding the weak points in the Mobile OS. KBTA (Knowledge Based Temporal Abstraction) is normally used for showing the malware behavior in the Mobile OS. The behavior pattern is classified using a Classifier. The data passing through the System is scanned by an Anomaly Detector for incoming anomalies. There are certain preset parameters which are used to dividing the inputs and they are known as Rule Based processes. The above mentioned four processes are used to overcome the malware intrusion.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Malware Detection Framework by PCA Based ANN"
        },
        {
            "text": "We now exhibit the work process of our proposed ANN-based malware location framework as appeared in Fig. 1 . The entities in Fig. 1 are explained below.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 100,
                    "end": 106,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 125,
                    "end": 131,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Proposed Malware Detection Framework by PCA Based ANN"
        },
        {
            "text": "Graphical User Interface (GUI) allows the users to interact with electronic devices with the help of graphical icons and visual pointers such as secondary notation instead of Command Line Interfaces (CLI) which required the user to type commands or use text navigation. CLIs were not very user friendly due to the extensive typing of commands to perform simple operations. Hence GUIs were introduced. The GUI used in this Framework was designed using MATLAB.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graphical User Interface"
        },
        {
            "text": "A processor is a logic chip that reacts to and processes the basic instructions that are initiated by the computer. The four basic functions of a processor are fetching, decoding, executing and writing back.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Processor"
        },
        {
            "text": "This unit is used to extract the useful and required information from the layers. It also contains the necessary hardware and software units in it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Extractors"
        },
        {
            "text": "The Alert manager handles alerts sent by client applications. It takes care of duplicating, grouping, and routing them to the correct receiver integration such as email, Pager Duty, or OpsGenie. It also takes care of silencing and inhibition of alerts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Alert Manager"
        },
        {
            "text": "It is used to determine the results from all active processors and applies an ensemble algorithm to derive a final decision of device's infection level.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Threat Weighting Unit"
        },
        {
            "text": "This interface allows you to edit feature lists, which you can assign to packages that you apply to cPanel accounts. Feature lists provide or prevent access to specific cPanel features.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Manager"
        },
        {
            "text": "SQL is used to perform operations on the records stored in the database such as updating records, deleting records, creating and modifying tables, views, etc. We might want to stress that the work process is common and can be utilized for authorization based recognition and framework call-based discovery. In disconnected preparing stage, we initially gather true kindhearted and noxious applications. Then, the gathered applications are executed and the information sources are discarded. Utilizing the mapped information as info, we at that point prepared the neural system. In the online identification stage, we dumped the information sources from new applications and the prepared neural system would be utilized to decide if the new application is malware or kind. As authorizations and framework calls contain diverse highlights and have distinctive configurations, we initially present consent based discovery and after that framework call based identification in the accompanying subsections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SQL"
        },
        {
            "text": "Step 1: Collecting Information sources and arranging them.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "The primary step in the standalone preparing stage is gathering information from the running applications. With the help of credible applications and malware tests, the applications of a similar class should give comparable data such that the data can be used in the irregularity profile. Using these profiles we can classify applications as friendly or malicious.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 2: Discarding Data Source Permissions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "With the help of a kind application and corresponding malware tests, the consents asked for by every applications are scrapped. All the consents in an Android Framework are integrated in the AndroidManifest.xml document. For gathering the apk documents a device called Android Asset Packaging Tool (aapt) is used. It helps in recreating the source code and in obtaining the AndroidManifest.xml consents for all applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 3: Feature extraction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "A set of files consisting of consents requested by an application are collected. For the training part the data is processed as well as mapped to the prerequisite format given by the ANN. To convert the original consent into system readable input a mapping algorithm was designed. In this algorithm an integer is assigned to each feature and the value assigned defines whether it was called for by the application. An application can request only once for a consent. If a consent is requested, its assigned value is 1, else it is 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "As the ANN acknowledges integers as information, we allocate the consent names to a whole number for preparing the list of authorizations. Outputs such as \"01, 02,03,06,09, 15, and 20\" are produced by mapping. For example BLUETOOTH is mapped to 12, READ CALL LOG is mapped to 14, and READ CONTACTS is mapped to 8. We can map out this plan to use 2-gram to recognize inclusion by applying two continuous consents in place of one. For instance, we join two consecutive whole numbers and the mapping results are \"0102, 0203, 0304, and 0405\" where \"0102\" speaks to the authorizations ACCESS NETWORK STATE and GET ACCOUNTS respectively. After the number grouping, the following stage is to obtain the purpose of each component. It is to be noted that the presence of consent is treated as component esteem. For each element that comes up, its esteem is termed as 1. For those which don't show up, their qualities are termed as 0. After the last two for circles, we get the component vector pointing to the contribution of the ANN as takes after: 1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,1,0",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 4: Classifier learning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "The learning module is used in this step and it is used to build up the neural system for analyzing the application conduct from preparing information. The element vectors are input to the Matlab Neural Network Toolbox which is in Matlab R2016a (8.1.0.604) to execute consent based recognition. The quantity of hubs in a shrouded layer is set to 10 and after that 20. The online identification step is similar to that portrayed in the disconnected preparing stage. Ideally, to group an application, the initial step is to dump the consents and guide the authorization list to the organization required by the ANN. The prepared ANN is used to decide if an application is malware or friendly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "The prepared ANN and test information are used as benchmarks for fresh applications. The preparation document has a vaguely different composition from the test file, which houses the component vector related with all applications. The recognition process yields an outcome file which has the order result. The outcome is +1 or \u22121 in this framework. When there is a positive outcome the application is characterized as friendly, whereas in a negative outcome the application is characterized as malicious.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Pseudocode for permission based Detection:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 1: Begin",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 2: Gather the information from executing application Step 3: Dump the permission asked for by every application",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 4: Utilize Android Asset Packaging (aapt) to recreate the source code and acquire the AndroidMainFest.xml request for every application",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 5: Feature Extraction Collect set of files with permission",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 6: Processing and mapping the data to the prerequisite format of the ANN.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 7: Assigning an integer to every feature",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 8: If permission is requested then feature value=1 else 0",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 9: Input vector send to Matlab NN Toolbox to execute the permission based recognition",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "Step 10: If output is +1 then no malware Else if output is -1 then malware",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Permission-Based Detection"
        },
        {
            "text": "The detection system based on system calls has a comparable procedure to the detection system based on permissions. The biggest difference is that it uses a varied data source. In these next few steps, there is a brief introduction to the working of system call-based detection.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "Step 1: Data set collection and classification.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "The primary step is to gather the data set. The data set has real time friendly applications and malware samples and we segregate them into different groups.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "Step 2: System calls recording.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "A recognized tool trace is employed to record the system calls requested by the friendly applications as well as the malware samples. Nexus Root Toolkit v1.6.2 is used to avail root permission on Android devices so as to install the trace. Then the trace is run and the system calls made by both the friendly and malware applications are recorded. An Android Debug Bridge (ADB) is used to install the malware on an Android device from a remote computer.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "Step 3: Feature extraction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "Each executed application generates a file which contains the system calls and all such files are recorded in a set. The data has to be mapped and processed to prerequisite format provided by the ANN. Each system call is mapped to an integer. As an example, get current process ID -getpid is mapped to 1, readfile is mapped to 3, and readconsole is mapped to 6. We can use 2-gram protocol by using two consecutive system calls as a detection feature instead if one. In order to map the 2-gram, all pairs of continuous integers are combined and generate an outcome similar to \"0101 0103 0306 0601 0116 1616 1616 1616 1608\" where \"0103\" denotes system calls getpid and readfile being executed in order. The proportion of density of the system calls is calculated by finding the ratio of the number of each system calls to the total number of system calls generated. Hence we can denote a feature and its value.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "Step 4: Classifier learning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "The step 4 of system call based detection is similar to the step 4 of permission-based detection. After this step, the training process of the ANN is complete and is ready to be used for online malware detection. The procedure of the online detection phase is same as the offline training phase. Now, we execute the application, discard the system calls and map the sequence of system calls to the prerequisite format of the ANN to classify the application. Using the ANN trained by the offline training phase, we can identify if a new application is malicious or friendly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "System Call-Based Detection"
        },
        {
            "text": "Step 1: Begin",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 2: collect the dataset Step 3: record the system calls and obtain root permission",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 4: Running trace and capturing the system calls used by the friendly as well as malicious applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 5: to install malware utilize Android Debug Bridge (ADB)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 6: Feature Extraction record a set of files",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 7: Processing and mapping the data to the prerequisite format of the ANN.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 8: Assigning an integer to every feature",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 9: If permission is requested then feature value=1 else 0",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 9: Input vector send to Matlab NN Toolbox to execute the permission based recognition",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Step 10: if output is +1 then no malware Else if output is -1 then malware",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pseudocode for call based Detection"
        },
        {
            "text": "Simulated results area is included in the experimental results and performance evaluation of malware detection. The assessment requires two experiments in which one utilizes the public dataset MalGenome and other one is based on a private dataset. MalGenome experiment used k-fold cross validation, otherwise known as the tenfold method. Kfold cross validation utilizes the holdout scheme and runs in a loop, K-fold times. Two segments of dataset are, as the testing set is K subsets and as the training set is K-1 subsets. In the end, the median of all K trials are calculated for getting the result of evaluation. During the newest malware experiment used for both test set. To discover the potential for a forecast relationship, the training set is used as a set of data. Whereas the other test set contributes a principal role in examining how efficient the classifier is. It is worthless by not using the test dataset in the training dataset. Finally, the ideal classifier was determined as the experimental results of both situations. Our data set consists of 1449 apps in total. We collected 1008 top free apps across different category from Google Play to create a benign set. Our malware set consists of 441 apps taken from Android malware Genome Project. We used ApkTotal to make sure that our benign set is free from any malware.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simulated Results"
        },
        {
            "text": "In this research work ANN is used to detect the presence of malware in CSDMC2019 API dataset. This dataset is composed of a selection of windows API/System call trace files, intended for testing on classifiers treating with sequences.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results of ANN"
        },
        {
            "text": "We use MALTAB GUI to design the proposed malware detection system which is shown in Fig. 2 . The GUI design is flexible and can be comfortable for all the three stages of the proposed system such as malware creation, detection and prevention. Also, we have tested the proposed malware detection system while connecting it to a mobile OS and transferring a file from mobile OS to desktop OS. Once the mobile device is connected it request for the access and the access will be granted if the verification process is successfully completed. The features from the OS will be extracted and using PCA the dimensionality of the extracted features is reduced. The reduced features will be compared with the malware features based upon the training data stored in ANN. If any similarities found between the features the system detects the presence of malware which is created while transferring the data. Figure 3 shows the structure ANN while training for malware detection after loading the downloaded database and after the completion of feature extraction process and feature reduction by PCA. The OS customization initially scans the data in the desktop for malwares. Once the process of desktop OS customization completes the process of file transfer from mobile device will be initiated. As of an initial step a request window will appear to connect the mobile device. Then, the mobile device gets access to the data from the mobile device, it will be correlated and the proposed system loads and scans the data for further processing (Figs. 4 and 5) . The mobile OS get customized the user id will get verified to initiate the process of file transfer from the mobile device to the desktop system. Then, the verification process completed successfully then the process starts with accessing the files from the mobile device. Once the files are accessed the files from the appropriate device get tracked and transferred via API. Figure 6 shows the screenshot captured while selecting the files which is to be transferred and processed. Again the verification process takes place to improve the system security. Figure 7 shows the screenshot captured after when the file transfer process get completed and accessed completely. After the completion of file transfer the process of malware detection get initiated again. It checks the presence of malwares occurred during the process of file transfer (Fig. 8) . With the presence of malware detected, mail intimation will be directed to the authenticated mail id using MATLAB. The mail also contains the label of the detected malware with the intimation of corrupted file (Figs. 9 and 10) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 84,
                    "end": 90,
                    "text": "Fig. 2",
                    "ref_id": null
                },
                {
                    "start": 897,
                    "end": 905,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1534,
                    "end": 1549,
                    "text": "(Figs. 4 and 5)",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 1928,
                    "end": 1936,
                    "text": "Figure 6",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 2110,
                    "end": 2118,
                    "text": "Figure 7",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 2397,
                    "end": 2405,
                    "text": "(Fig. 8)",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 2618,
                    "end": 2634,
                    "text": "(Figs. 9 and 10)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Fig. 2. Structure of Neural Network"
        },
        {
            "text": "Trivial hash based deadlock algorithm prevents the overall system and files from the harmful malwares which may create during file transfer (Fig. 11 ). The process from user verification to OS customization will repeat to prevent the entry of malwares in any system. To prevent Malwares using trivial hash deadlock the malware detection process will be initiated and once if detected any suspicious activity the internal and external operations of the system get blocked and no one can access any files from the system. Now an intimation to reboot the system along with malware intimation will be sent to the users' mail and can operate the system only after rebooting the system. Figure 12 shows the intimation of operations blocked when a malware enters into the system. Then the system is intimated to reboot after detection of malware to prevent further harm to the system. Once the above process gets succeeded the system OS get customized along with the mobile OS and also a successful file transfer was performed and the rebooted system will completely free from malwares and also protected from future malwares.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 140,
                    "end": 148,
                    "text": "(Fig. 11",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 681,
                    "end": 690,
                    "text": "Figure 12",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Fig. 2. Structure of Neural Network"
        },
        {
            "text": "The principal aim of this presentation was to show the efficiency of updating antivirus tools with new unfamiliar malwares. We can detect new malware by using an updated classifier which can be used for sustaining an anti-virus tool. Labeled files must be modernized for both the anti-virus and its detection model called as classifier. The labeling can be done physically by experts, consequently the aim of the classification is focused effort on labeling files which are likely to be malware or new information added files about benign files.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "In this research, evaluation of various machine learning classifiers are to increase the detection of malware outcome for a strong and large collection of file samples and acquire the optimum classifier which can detect mobile malware. The classifiers were Artificial Neural Network (ANN), Bayes network, decision tree (DT) (J48), K-nearest neighbor (KNN) and support vector machine (SVM). Our experiment comprised 49 separate families containing 1,260 Android malware samples included by the MalGenome project samples whereas only 1000 were utilized. There are three phases in the machine learning process: (1) data collection, which captures network traffic; (2) feature selection and extraction; and (3) the machine learning classifier.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Malicious code detection for open firmware",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Adelstein",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Matthew",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Dexter",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "18th Annual Proceedings of the Computer Security Applications Conference",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Static detection of malicious code in executable programs",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bergeron",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Int. J. Req. Eng",
            "volume": "79",
            "issn": "",
            "pages": "184--189",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Computer Security: Principles And Practice",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "William",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Machine Learning Methods for Malware Detection and Classification",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Chumachenko",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A survey on security for mobile devices",
            "authors": [
                {
                    "first": "La",
                    "middle": [],
                    "last": "Polla",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Martinelli",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Sgandurra",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IEEE Commun. Surv. Tutorials",
            "volume": "15",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Mobile device security: a survey on mobile device threats, vulnerabilities and their defensive mechanism",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sujithra",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Int. J. Comput. Appl",
            "volume": "56",
            "issn": "14",
            "pages": "975--8887",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Detecting unknown malicious code by applying classification techniques on OpCode patterns",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shabtai",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Moskovitch",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Feher",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Dolev",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Elovici",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Secur. Inform",
            "volume": "1",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Detecting scareware by mining variable length instruction sequences",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "K"
                    ],
                    "last": "Shahzad",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lavesson",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings of the 10th Annual Information Security South Africa Conference (ISSA11)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Accurate adware detection using opcode sequence extraction",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "S"
                    ],
                    "last": "Raja",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Niklas",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Henric",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings of the 6th International Conference on Availability, Reliability and Security (ARES11)",
            "volume": "",
            "issn": "",
            "pages": "189--195",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Detection of spyware by mining executable files",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "K"
                    ],
                    "last": "Shahzad",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "I"
                    ],
                    "last": "Haider",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lavesson",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proceedings of the 5th International Conference on Availability, Reliability, and Security",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Survey on security for mobile device: threats and vulnerability",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Rami",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Desai",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Int. J. Adv. Res. Comput. Sci. Softw. Eng",
            "volume": "5",
            "issn": "12",
            "pages": "446--471",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Identification of common molecular subsequences",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "F"
                    ],
                    "last": "Smith",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "S"
                    ],
                    "last": "Waterman",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "J. Mol. Biol",
            "volume": "147",
            "issn": "",
            "pages": "195--197",
            "other_ids": {
                "DOI": [
                    "10.1016/0022-2836(81)90087-5"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Malware and malware detection techniques: a survey",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Landage",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Int. J. Eng. Res. Technol. (IJERT)",
            "volume": "2",
            "issn": "12",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Droidchameleon: evaluating android anti-malware against transformation attacks",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Vaibhav",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the 8th ACM SIGSAC Symposium on Information, Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "329--334",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Detecting mobile malware threats to homeland security through static analysis",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Seung-Hyun",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gupta",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "M"
                    ],
                    "last": "Sallam",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Bertino",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Yim",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Jtheirnal of Network and Computer Applications",
            "volume": "38",
            "issn": "",
            "pages": "43--53",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Rage against the virtual machine: hindering dynamic analysis of android malware",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Petsas",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Giannis",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Elias",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Michalis",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sotiris",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the Seventh European Workshop on System Security",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Crowdroid: behavior-based malware detection system for android",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Burguera",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Urko",
                    "suffix": ""
                },
                {
                    "first": "N.-T",
                    "middle": [],
                    "last": "Simin",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings of the 1st ACM workshop on Security and Privacy in Smartphones and Mobile Devices",
            "volume": "",
            "issn": "",
            "pages": "15--26",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Andromaly\": a behavioral malware detection system for android devices",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shabtai",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Kanonov",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Elovici",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Glezer",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Theyiss",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Jtheirnal Intell. Inf. Syst",
            "volume": "38",
            "issn": "1",
            "pages": "161--190",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Static analysis of executables for collaborative malware detection on android",
            "authors": [
                {
                    "first": "A-D",
                    "middle": [],
                    "last": "Schmidt",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "IEEE International Conference on Communications",
            "volume": "",
            "issn": "",
            "pages": "1--5",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Malware Detection Framework",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Screenshot of GUI design window for training ANN",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Screenshot of command window",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Screenshot of GUI design window after mobile device access",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Loading files to transfer",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "File transfer completed",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Intimation of Malware detected via mail",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Corrupted fileFig. 10. User Verification for malware prevention",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "User verification succeed",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Operation blocked while malware is received",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Comparison of studied papers[13]",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}