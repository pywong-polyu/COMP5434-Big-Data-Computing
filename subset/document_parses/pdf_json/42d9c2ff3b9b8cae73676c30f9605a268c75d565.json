{
    "paper_id": "42d9c2ff3b9b8cae73676c30f9605a268c75d565",
    "metadata": {
        "title": "Formal Semantics and Verification of Network-Based Biocomputation Circuits",
        "authors": [
            {
                "first": "Michelle",
                "middle": [],
                "last": "Aluf-Medina",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Bar-Ilan University",
                    "location": {
                        "settlement": "Ramat Gan",
                        "country": "Israel"
                    }
                },
                "email": ""
            },
            {
                "first": "Till",
                "middle": [],
                "last": "Korten",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Avraham",
                "middle": [],
                "last": "Raviv",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Bar-Ilan University",
                    "location": {
                        "settlement": "Ramat Gan",
                        "country": "Israel"
                    }
                },
                "email": ""
            },
            {
                "first": "Dan",
                "middle": [
                    "V"
                ],
                "last": "Nicolau",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Hillel",
                "middle": [],
                "last": "Kugler",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Bar-Ilan University",
                    "location": {
                        "settlement": "Ramat Gan",
                        "country": "Israel"
                    }
                },
                "email": "hillelk@biu.ac.il"
            }
        ]
    },
    "abstract": [
        {
            "text": "Network-Based Biocomputation Circuits (NBCs) offer a new paradigm for solving complex computational problems by utilizing biological agents that operate in parallel to explore manufactured planar devices. The approach can also have future applications in diagnostics and medicine by combining NBCs computational power with the ability to interface with biological material. To realize this potential, devices should be designed in a way that ensures their correctness and robust operation. For this purpose, formal methods and tools can offer significant advantages by allowing investigation of design limitations and detection of errors before manufacturing and experimentation. Here we define a computational model for NBCs by providing formal semantics to NBC circuits. We present a formal verification-based approach and prototype tool that can assist in the design of NBCs by enabling verification of a given design's correctness. Our tool allows verification of the correctness of NBC designs for several NP-Complete problems, including the Subset Sum, Exact Cover and Satisfiability problems and can be extended to other NBC implementations. Our approach is based on defining transition systems for NBCs and using temporal logic for specifying and proving properties of the design using model checking. Our formal model can also serve as a starting point for computational complexity studies of the power and limitations of NBC systems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Engineering biological devices to perform computation is of major interest due to the potential of utilizing inherent parallelism in biological components to This project has received funding from the European Union's Horizon 2020 research and Innovation programme under grant agreement number 732482 (Bio4Comp) and by the ISRAEL SCIENCE FOUNDATION (Grant No. 190/19) . speed up computation, construct low energy consuming devices and interface with biological material, opening up potential diagnostic and medical applications. Network-Based Biocomputation Circuits (NBCs) [4, 20] offer a new paradigm for solving complex computational problems by utilizing biological agents that operate in parallel to explore manufactured planar devices. Devices should be designed to ensure correctness and robust operation, for which formal reasoning tools can offer significant advantages by assisting in identification of limitations and errors in the design before device manufacturing. Here we define a computational model for NBCs [20] by providing formal semantics, and present a formal verification-based approach and tool that can prove correctness of the design. The tool can be used to verify that a given design contains no logical errors, and allows evaluation of different designs prior to manufacturing. Similar verification tools are now commonplace in the hardware industry, where early identification of design flaws can lead to significant savings in cost (money, development time and reputation).",
            "cite_spans": [
                {
                    "start": 349,
                    "end": 367,
                    "text": "(Grant No. 190/19)",
                    "ref_id": null
                },
                {
                    "start": 574,
                    "end": 577,
                    "text": "[4,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 578,
                    "end": 581,
                    "text": "20]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1025,
                    "end": 1029,
                    "text": "[20]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "NBC is an alternative parallel-computation method that was proposed in [20] and solves a given combinatorial problem by encoding it into a graphical, molecular network that is embedded in a nanofabricated planar device. The approach can be applied for solving NP-Complete problems [14] and other types of combinatorial problems. In addition, since biological agents are utilized in NBC, the technology can be used in the future to carry cells through the devices and perform complex computational processing with medical and diagnostic applications. In the NBC approach a device runs biological agents through the network in order to explore it in parallel and thus solve a given combinatorial problem. The combinatorial problem considered in [20] is the Subset Sum Problem (SSP), which is a known NP-complete problem. The SSP problem is given a target goal k, and asks if it can be reached as a sum of some combination of elements in a given set S = s 1 s 2 . . . s N .",
            "cite_spans": [
                {
                    "start": 71,
                    "end": 75,
                    "text": "[20]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 281,
                    "end": 285,
                    "text": "[14]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 743,
                    "end": 747,
                    "text": "[20]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "An example NBC circuit for the SSP of S = 2 5 9 is shown in Fig. 1a . Molecular agents (actin filaments or microtubules, which are propelled by molecular motors) enter from the top-left corner of the network. At split junctions, the agents have an approximately equal chance of moving down or moving diagonally, while agents continue in the current direction of movement at pass junctions, as seen in Fig. 1b . When a computational agent takes the diagonal path at a split junction, the element for that junction is \"added\". Agents exiting the network in the bottom row thus have an x coordinate (denoted exit# in Fig. 1a ) that represents a possible subset sum, and by utilizing many agents to explore the network in parallel all the possible subset sums can be determined.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 60,
                    "end": 67,
                    "text": "Fig. 1a",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 401,
                    "end": 408,
                    "text": "Fig. 1b",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 614,
                    "end": 621,
                    "text": "Fig. 1a",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "More recently, the NBC approach has been extended to encode and solve additional NP-Complete problems [16, 32] and work has been done towards improving the scalability of the approach and the design process of the circuits. New encodings include the Exact Cover (ExCov) and the Satisfiability (SAT) problems. An additional feature that could extend the capabilities of NBC is tagging-the ability to mark a protein or filament with a distinguishing attribute. Fluorescence tagging, for example, is common in biological research and is used to track biomolecules and cells. As an additional component of computation, tagging can be used to track the paths used by computational agents [20, 27] . Once the agents reach the end of the network, their tags could be examined and then used to validate the path taken and determine the output result.",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 106,
                    "text": "[16,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 107,
                    "end": 110,
                    "text": "32]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 683,
                    "end": 687,
                    "text": "[20,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 688,
                    "end": 691,
                    "text": "27]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Here we provide formal semantics to NBC by defining transition relations that capture the dynamics of an agent in the network. This forms the basis of a translation into the SMV format supported by the NuSMV [9] and nuXMV [7] model checkers and its application to verify design correctness or identify logical errors. We also extend the NBC semantics to a real time stochastic model by mapping NBCs to chemical reaction networks (CRNs) opening up possibilities to utilize stochastic simulation and probabilistic model checking. Finally our formal model can serve as a starting point for computational complexity studies of the power and limitations of NBC systems.",
            "cite_spans": [
                {
                    "start": 208,
                    "end": 211,
                    "text": "[9]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 222,
                    "end": 225,
                    "text": "[7]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Engineering biological devices to perform specified computation has the potential of utilizing the inherent parallelism in biological components to speed computation, construct low energy consuming devices and interface with biological material. Seminal work by Adelman [3] has demonstrated a method to use DNA for solving the Hamiltonian path problem, which is known to be NP-Complete. The instance of the Hamiltonian path considered in [3] is a small graph (7 nodes and 14 edges), thus a major challenge since then in the field is overcoming physical and experimental constraints towards scaling up the computation to tackle large systems.",
            "cite_spans": [
                {
                    "start": 270,
                    "end": 273,
                    "text": "[3]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 438,
                    "end": 441,
                    "text": "[3]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "There have been several different paradigms suggested to realize the vision proposed in [3] , including DNA Strand Displacement Systems (DSD) [23, 25] that utilize the complementarity of DNA base sequences to bind together and perform designed reactions, and DNA self assembly applying a reprogrammable set of DNA tiles, capable of implementing a wide variety of self assembly algorithms [24, 28] . DNA walkers are molecular machines that can move along tracks [26, 30] and can be used for performing computation or moving cargo for nanotechnology applications. Computational methods and tools have proven to be useful in improving and validating the designs of engineered biological systems [5, 15, 22] and have served as motivating applications for defining semantics and computational methods for NBC. Formal verification methods assuming discrete semantics have been used to verify the correctness of DNA Strand Displacement Systems and DNA walkers [17, 31] , and probabilistic model checking has also been applied to these systems [6, 11, 17] . More broadly, viewing biological systems as reactive systems leads naturally to specifying their behavior using temporal logic and applying model checking (see e.g. [8, 13] and references within).",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 91,
                    "text": "[3]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 142,
                    "end": 146,
                    "text": "[23,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 147,
                    "end": 150,
                    "text": "25]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 388,
                    "end": 392,
                    "text": "[24,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 393,
                    "end": 396,
                    "text": "28]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 461,
                    "end": 465,
                    "text": "[26,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 466,
                    "end": 469,
                    "text": "30]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 692,
                    "end": 695,
                    "text": "[5,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 696,
                    "end": 699,
                    "text": "15,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 700,
                    "end": 703,
                    "text": "22]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 953,
                    "end": 957,
                    "text": "[17,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 958,
                    "end": 961,
                    "text": "31]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 1036,
                    "end": 1039,
                    "text": "[6,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1040,
                    "end": 1043,
                    "text": "11,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1044,
                    "end": 1047,
                    "text": "17]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1215,
                    "end": 1218,
                    "text": "[8,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1219,
                    "end": 1222,
                    "text": "13]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Network-Based Biocomputation (NBC) [20] uses biological agents that operate in parallel to explore manufactured planar devices. To enable the exploration of the solution space effectively, NBC encodes the operations of solving NP-complete problems into graphs, which are then used as templates for the design and fabrication of networks, for instance microfluidic networks. To process the computation in a massively parallel fashion, NBC uses a large number of motile agents to explore the many possible paths towards actual solutions. The actual circuits we have verified here are physically manufactured to be populated with actin filaments or microtubules [4] , although similar devices have been experimentally implemented for bacteria [27] . In [29] , the SSP problem has been solved by the NBC approach using a laser photonic system rather than molecular motors as in [20] . Our computational methods and tools are applicable to all the variety of experimental implementation strategies currently developed for NBC and can also be extended to support future NBC technology.",
            "cite_spans": [
                {
                    "start": 35,
                    "end": 39,
                    "text": "[20]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 659,
                    "end": 662,
                    "text": "[4]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 740,
                    "end": 744,
                    "text": "[27]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 750,
                    "end": 754,
                    "text": "[29]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 874,
                    "end": 878,
                    "text": "[20]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "We first describe our general approach for providing semantics to NBC circuits, the definitions are then used and refined to encode specific designs to solve the subset sum (SSP), exact cover (ExCov) and satisfiability (SAT) problems. A network is composed of a set of junctions that are positioned on a 2-dimensional plane, allowing agents to move along the network to nearby junctions according to the type of junction visited. The encoding assumes a single agent traversing the network, and can naturally be used to construct a system consisting of several agents traversing the network in parallel. We define a discrete state semantics that includes nondeterministic choice, and then suggest a translation to chemical reaction networks (CRNs) [10] that provides a stochastic continuous time semantics.",
            "cite_spans": [
                {
                    "start": 747,
                    "end": 751,
                    "text": "[10]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Formal Semantics"
        },
        {
            "text": "Our transition system is defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "Where V are the system variables, \u03b8 is the initial condition, \u03c1 is the transition relation and C is a set of compassion requirements. The variables encode the position of the agent in the network and its direction of movement:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "The variables x and y encode the position of the agent in the network, where x \u2208 {0 \u00b7 \u00b7 \u00b7 max} and y \u2208 {0 \u00b7 \u00b7 \u00b7 max} and max is the sum of all elements in the set in the case of the subset sum problem, determining the size of the device in the general case. The variable dir is a Boolean variable encoding the direction of movement of the agent. In most circuits we assume the initial condition \u03b8 is x = 0 \u2227 y = 0 capturing an agent entering the circuit from the upper left corner, see Fig. 1a . We assume here the initial position is a split junction and do not constrain the value of the dir variable, thus it can be chosen nondeterministically to be either 0 or 1. The variable dir maintains the current movement direction of the filament, where dir = 0 means travelling down while dir = 1 means travelling diagonally.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 486,
                    "end": 493,
                    "text": "Fig. 1a",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "The transition relation specifies how the variables get updated depending on the current state:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "Agents move from the top row to the bottom row, thus the y variable always gets incremented by 1 specifying this movement. The movement can either be directly down, in which case x is not changed, this happens when the variable dir is 0, or diagonally, in which case x is incremented by 1, when the variable dir is 1. In addition we update the transition relation such that after reaching the bottom row the agent returns back to the top left corner of the network, to the state x = 0 \u2227 y = 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "The variable dir determines the direction of movement as explained above. It remains unchanged if the agent is in a pass junction, or makes a nondeterministic choice between 0 (down) or 1 (diagonal) if the agent is in a split junction:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "We define the compassion requirement:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "A compassion requirement is composed of a set of pairs, each pair is of the form p, q and requires that if p appears infinitely often then q appears infinitely often. In this case for every split junction if it is visited infinitely often it will take the direction down infinitely often and the direction diagonal infinitely often. This ensures that for every split junction both directions, down and diagonal will eventually be explored. Formally, if the state x = m \u2227 y = n that is a split junction is visited infinitely often, then both of the states x = m \u2227 y = n + 1 and x = m + 1 \u2227 y = n + 1 will be visited infinitely often.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discrete Nondeterministic Semantics"
        },
        {
            "text": "Following from the semantics described above we propose a stochastic semantics extension by providing a mapping to chemical reaction networks (CRNs). CRNs consist of a set of species C and a set of reactions R that allow the species to interact. We introduce species for each of the locations in the network, with a separate species for down or diagonal movement if the position is a pass junction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "For split and pass junctions the species are, respectively:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "The species will count how many agents are positioned at each location described by state x = i\u2227y = j, allowing to represent multiple agents simultaneously exploring the network. The reactions will correspond to an agent moving to the next location. For each split junction, assuming the next junction is a pass junction, we will define the following two reactions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "If an agent is in a split junction at position (i, j) there are two reactions as shown above that can be taken, the first will move the agent to position (i, j + 1) representing a down movement, whereas the second will move the agent to position (i + 1, j + 1) representing a diagonal movement. If the first equation is fired then the number of copies of species x i y j will be decremented by 1 and the number of copies of species x i y j+1 d 0 will be incremented by 1, whereas if the second equation is fired, the number of copies of species x i y j will be decremented by 1, and the number of copies of species x i+1 y j+1 d 1 will be incremented by 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "For pass junctions, assuming the next junction is also a pass junction, we define the following reactions, in which according to the first reaction the movement is down and according to the second reaction the movement is diagonally:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "If the next position is a split junction we define the following reactions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "The CRN defined above can also have a rate associated with each reaction which is a number that determines the probability of firing the reaction effecting how fast these reactions will fire. These definitions provide a stochastic continuous time semantics for NBCs using the underlying CRN model [10] . An example of a stochastic simulation using these semantics for the SSP network from Fig. 1a is shown in Fig. 2 . Time is shown in the X axis while the number of individual agents of each species is shown in the Y axis. Each color plot represents a different species at a specific network position. This simulation starts with 1000 individuals at position (x, y) = (0, 0) (plot not shown) that traverse the network assuming no interaction between the agents. The graph is a result of running a CRN model using Gillespie stochastic simulation implemented in the DSD tool [18] . The plots that rise beyond the background values at around 10 time units are the number of agents at each of the 8 possible subset sum exits.",
            "cite_spans": [
                {
                    "start": 297,
                    "end": 301,
                    "text": "[10]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 874,
                    "end": 878,
                    "text": "[18]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [
                {
                    "start": 389,
                    "end": 396,
                    "text": "Fig. 1a",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 409,
                    "end": 415,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Stochastic Semantics"
        },
        {
            "text": "We next explain our encodings of the SSP, ExCov and SAT problems and the temporal logic properties used to specify the correctness of the circuits. Our motivation here is to capture the networks used in the experimental work with the actual biological agents and not to find efficient ways to solve these NP-Complete problems on standard computers. The verification approach can then be generalized and utilized to NBC applications in which the main aim is to interact with living cells for diagnostic and medical applications rather than solve combinatorial problems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Stochastic Semantics"
        },
        {
            "text": "The Subset Sum Problem (SSP) is an established NP-Complete problem that returns true if a subset exists in a given set S, that sums to some given value k, and returns false otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "The SSP network is constructed using variables for rows, columns, junction types, movement direction of computational agents, and a flag. The flag is used to indicate that the computational agent has reached the network output (the last row).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "An additional tag variable was added to the network description in order to track at which split junctions the computational agents took a diagonal path, thus \"adding\" the element for that row. The tag is built by indexing split junctions starting from the top left corner of the network (index 0) and then running through each row and assigning indices to the junctions sequentially. This indexing includes junctions that are considered unreachable in a properly functioning network. Networks using tagging are able to identify the exact path taken to reach a given sum. This allows further investigation into the number of different paths to a given output. In experimentally manufactured NBC devices these tags may also allow for identification of agents that followed erroneous paths.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "Agent positioning in the network is indicated by row and column variables that run from zero to the maximum sum of elements in the given set. Only half of these (row, column) points are used due to the network's triangular structure. In order to define the transition relations for the general SSP problem, S = s 1 s 2 . . . s N , we first define the maximum sum of set S (Eq. 1), array of split junction rows (Eq. 2) and, if tagging is used, an array of tags (Eq. 3).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "The row increases with each transition until reaching the end of the network. This captures the assumption that agents cannot move backwards in the network. Junction type, which depends on the row, is decided according to a sequential sum of elements in the set. The direction of movement is either nondeterministic (when \"choosing\" at a split junction) or keeps the last selection (when at a pass junction). The full transition relation, without the additional tag variable, can be seen in Eq. 4. The tag's transitions are separately defined in Eq. 5. Two specification types were used to verify network correctness. The first type (Table 1) uses both Linear Temporal Logic (LTL) and Computational Tree Logic (CTL) to check the validity of a specific sum k by comparing it with the column value at the output. The LTL formula checks the lack of a run where column = k, while the CTL formula checks for the existence of at least one run where column = k. For the SSP, the value k can range anywhere from zero to the maximum sum value of set S. We use both CTL and LTL although the outcomes of NBC verification will be equivalent, for evaluating and optimizing the performance of model-checking, as discussed in Sect. 7.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 633,
                    "end": 642,
                    "text": "(Table 1)",
                    "ref_id": null
                }
            ],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "The second type of specification (Table 2 ) uses CTL to check that all valid sums are reachable and all invalid sums are unreachable. When used on networks containing identifiable errors (errors that can be detected by measuring agents at the exit of the network in the bottom row), a counter-example is provided indicating an unreachable valid sum and/or a reachable invalid sum. This specification does not need to get a target sum k but rather checks correctness for any target sum. Table 2 . Network specifications for overall output in CTL. csum checks that the network can exit on all valid sums. nsum checks that the network cannot exit on any invalid sum.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 33,
                    "end": 41,
                    "text": "(Table 2",
                    "ref_id": null
                },
                {
                    "start": 486,
                    "end": 493,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "CTLSPEC NAME csum :=!(EX(AG((flag = F ALSE)|(!(column = sum))))); CTLSPEC NAME nsum :=!(EF ((flag = T RUE)&(column = xsum))); column is the current sum (column in the network), sum is one of the set of valid outputs, xsum is one of the set of invalid outputs and flag is the output row indicator",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subset Sum Problem (SSP)"
        },
        {
            "text": "The Exact Cover problem (ExCov) is another important problem, which is known to be NP-Complete. This problem returns true if there exists an exact cover (a union of disjoint sets) of the defined universe U when given a collection of sets SS that contain elements from the universe, and returns false otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Exact Cover (ExCov)"
        },
        {
            "text": "We use a reduction to SSP to construct NBCs that solve the ExCov problem [16] . In the reduction, the ExCov is encoded into binary format. This encoding is then used to create the elements of an SSP network. The elements of the universe are treated as an array, where each position can be either 0 or 1, and where each element is given a specific index in the array. The sets to be examined are then each assigned an array of the same length as the universe, where only elements contained in the set are assigned a \"one\" value. All other elements are assigned a \"zero\" value. These arrays are then treated as binary numbers and are converted to their respective decimal values, as shown in Table 3 .",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 77,
                    "text": "[16]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 690,
                    "end": 697,
                    "text": "Table 3",
                    "ref_id": null
                }
            ],
            "section": "Exact Cover (ExCov)"
        },
        {
            "text": "As the ExCov does not allow the union of non-disjoint sets (the exact cover cannot contain sets that share an element), a \"force-down\" junction is included in the network to replace such split junctions. This prevents the agents from taking a diagonal path where an element in the current set is already contained in a previously included set on the path. This construction can be seen in Fig. 3 , which depicts the network for the sets given in Table 3 . There exist multiple exact covers for this set of subsets, so there are multiple paths in this network that lead to output 15, the binary encoding of the universe. The pink path exhibits the function of the force-down Table 3 . Conversion from set to decimal using binary representation. junctions, where the computational agent is forced into the downward direction instead of having the chance to move diagonally, as in a split junction. In this case, this is due to set S 4 sharing elements with sets S 1 and S 2 , which have already been included. In terms of the decision problem encoded in the network, the existence of one path leading to the required output implies that the result should be computed as true. This network is, in essence, an implementation of the SSP network with the addition of a new junction type. Thus, the state of the model is defined by the same combination of variables as that of the SSP. The junction type now depends on both row and column values as the previously defined split junction rows may now contain force-down junctions. The tag variable was added here as well, to track the path taken by the biocomputation agents. The maximum sum of the network, split junction rows, and tags are defined as they were in SSP, where the set elements are now the decimal values of the subsets' binary representation. The transition relation, without the additional tag variable, can be seen in Eq. 6, while the tag's transitions are defined in the same manner as the tags for the SSP (Eq. 5). ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 389,
                    "end": 395,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 446,
                    "end": 453,
                    "text": "Table 3",
                    "ref_id": null
                },
                {
                    "start": 674,
                    "end": 681,
                    "text": "Table 3",
                    "ref_id": null
                }
            ],
            "section": "Exact Cover (ExCov)"
        },
        {
            "text": "Both LTL and CTL specifications were used to verify the output of interest k, similar to the specifications in Table 1 . The difference here is that k is assigned the decimal value of the binary representation of the universe.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 111,
                    "end": 118,
                    "text": "Table 1",
                    "ref_id": null
                }
            ],
            "section": "Exact Cover (ExCov)"
        },
        {
            "text": "The Boolean Satisfiability problem (SAT) is considered the classic NP-complete problem. SAT is the problem of determining if there exists an assignment of true and false values to the variables of a Boolean formula, such that the formula evaluates to true. The formula is considered satisfiable if any such assignment exists, and is considered unsatisfiable when no such assignment exists (the formula always evaluates to false). One standard format for SAT problems is Conjunctive Normal Form (CNF), where the Boolean formula \u03d5, consists of a conjunction of a set of clauses C i n i=1 , and each clause consists of a disjunction of a set of literals x j m j=1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Satisfiability (SAT)"
        },
        {
            "text": "The initial model designed for SAT used a similar structure to that of the SSP network, as seen in Fig. 4a . Each row represents a literal x j , and each junction is a split junction. As computational agents progress through this network, they are tagged after each split junction for the clauses their truth assignment satisfies. The two example paths demonstrate cases where all tags are marked (the Boolean formula was satisfied), as well as where there was a tag missing (the Boolean formula was not satisfied). As there exists an output where all tags are marked, the problem is satisfiable. The next network model used, seen in Fig. 4b , is structured with individual junctions for literals and clauses, rather than having multiple junctions for each literal as in Fig. 4a . Each literal junction has paths both to the left (true) and right (false), reflecting their relevant truth assignment. These paths connect to a sequence of clause junctions. Computational agents are tagged at clause junctions with an identifier for the relevant clause satisfied by the truth assignment of the path.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 99,
                    "end": 106,
                    "text": "Fig. 4a",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 634,
                    "end": 641,
                    "text": "Fig. 4b",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 771,
                    "end": 778,
                    "text": "Fig. 4a",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Satisfiability (SAT)"
        },
        {
            "text": "Unlike the SSP and ExCov networks where the output location indicates the result, in the SAT network, the use of tagging is critical as it indicates the clauses satisfied. The final computation result depends on the total collection of tags on the computational agents at output. The problem is considered satisfiable if there exists an agent that collected tags for each clause as measured at output. Using the clause model, two network descriptions were constructed. One network description has separate variables for clause junctions and tags, while the other unifies them into a single tag variable that merges their behavior in order to minimize the number of variables and possible states created by the NuSMV model checker. The tag variables for these networks are treated as counters that indicate the number of times each clause has been satisfied. As all problems investigated are of the 3-SAT format, the tag for each clause can only be an integer from zero to three, where zero indicates the clause was never satisfied.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Satisfiability (SAT)"
        },
        {
            "text": "The state of the model is defined by a combination of variables for junction type, direction of movement, current literal and it's assigned value, exit flag, and a tag array for the clauses satisfied. The junction type is now divided into clause and literal junctions. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Satisfiability (SAT)"
        },
        {
            "text": "We developed a prototype tool [1,2] that automates both the generation of the SMV encodings for each problem (SSP, ExCov and SAT), and the verification of these encodings using the NuSMV model checker [9] . The user selects which problem they would like to solve and then the tool runs as described in the following sections. For the SSP and ExCov problems our tool also automates the translation to chemical reaction networks allowing to run a Gillespie stochastic simulation using the GEC and DSD tools [18, 21] . We systematically evaluate the verification capabilities of our tool, by proving correctness of the designs and by identifying errors in designs that were explicitly modified to represent faulty junctions or errors in the NBC encoding. Overall the verification results demonstrate that the approach can handle large NBC circuits and is applicable to the real-world systems currently designed in [4, 20, 27] .",
            "cite_spans": [
                {
                    "start": 201,
                    "end": 204,
                    "text": "[9]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 505,
                    "end": 509,
                    "text": "[18,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 510,
                    "end": 513,
                    "text": "21]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 911,
                    "end": 914,
                    "text": "[4,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 915,
                    "end": 918,
                    "text": "20,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 919,
                    "end": 922,
                    "text": "27]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "Using input sets from the user, the tool builds SMV network descriptions both with and without tags. Once the models have been generated, the tool runs NuSMV on each of the defined specifications. Verifications are first run on the specifications defined in Table 1 using two methods. The first runs all outputs in bulk, and the second runs output by output. This is done for both LTL and CTL specifications separately. Then, verifications are run on the specifications defined in Table 2 for both valid and invalid sums. Each specification's verification result and runtime is parsed and saved for further analysis. While the difference between LTL and CTL verification runtimes in small networks is negligible, the difference in large networks is considerable. As seen in Table 5 , LTL runtimes grow at a much faster rate than those of CTL. There is also a drastic increase in runtime when verifying networks utilizing tagging, as additional variables are necessary to define tags for all split junctions. For the first specification type, it is not usually necessary to look at all outputs or both logics. Thus, runtime can be decreased by examining specific outputs of interest using a single specification instead. The increase in verification runtime as a result of larger network size is not as drastic for running individual outputs (Table 6 ) due to the compounded nature of the runtime when running in bulk.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 258,
                    "end": 265,
                    "text": "Table 1",
                    "ref_id": null
                },
                {
                    "start": 481,
                    "end": 488,
                    "text": "Table 2",
                    "ref_id": null
                },
                {
                    "start": 774,
                    "end": 781,
                    "text": "Table 5",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 1341,
                    "end": 1349,
                    "text": "(Table 6",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "SSP"
        },
        {
            "text": "Verification runtime for the second specification type grows at about the same rate as that of the bulk run on the first specification's CTL format (Table 7 and  Table 8 ). The two are comparable as they both check validity of all network outputs. By using these different specification types, we are able to efficiently verify NBC designs for increasingly large networks.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 148,
                    "end": 169,
                    "text": "(Table 7 and  Table 8",
                    "ref_id": "TABREF5"
                }
            ],
            "section": "SSP"
        },
        {
            "text": "The second specification type can further be used to identify unreachable valid sums and reachable invalid sums in networks with observable errors. We model here errors that my occur as part of the manufacturing of the NBC devices, and consider a scenario where a certain junction appears to contain an error and we want to check its effect on the correctness of the overall circuit. There are three general types of errors that may be found in SSP networks:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SSP"
        },
        {
            "text": "1. Pass junction behaves as a split junction 2. Pass junction forces one direction (a) when both paths are valid (block one valid path) (b) when one path is valid, and the invalid path is forced 3. Split junction forces one direction Examples of these errors are shown in Fig. 5 . These errors are not always identifiable by observing the possible exits from the network, as affected junctions may not be reachable, forced paths may converge with valid paths, or blocked paths may not be the only path leading to the affected output. In order to simulate manufacturing errors that would cause unexpected outputs, deliberate errors were added to the network descriptions. A comparison between the expected verification result of the network and that of the network with added errors is shown in Table 9 . The correctness of NBC network design can be checked by examining these errors and their verification results. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 272,
                    "end": 278,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 794,
                    "end": 801,
                    "text": "Table 9",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "SSP"
        },
        {
            "text": "Using an input file containing a collection of universes and sets of subsets, the tool encodes the given problems into binary format. Then, tagged and not tagged networks are generated using specifications for the output of interest as defined in Table 1 . In this case, the output of interest (decimal value of universe's binary encoding) is assigned to variable k. Then, NuSMV is run on both specifications (LTL and CTL) to check for the existence of an exact cover. The tool then parses and saves verification results and runtimes for further analysis. Verification runtimes show similar behavior to those seen with SSP networks. The same difference in growth in runtime of LTL and CTL, as well as the same drastic difference in runtime of tagged as compared to not tagged networks is observed (Table 10) . As the ExCov NBC design is based off of that of the SSP, the types of errors observed in the SSP may occur here as well. As the translation is more complex due to the addition of \"force-down\" junctions, it is critical to make sure these junctions are added at all relevant locations. By not including these junctions in the network description properly, incorrect results may be observed when verifying the existence of an exact cover. As the network grows larger, it becomes more difficult to identify such errors. In order to capture such mistakes in network translation, an additional variable was used to switch junction behavior to that of split junctions, in essence switching the network with the SSP equivalent. This type of error does not affect networks where an exact cover exists as the original path to the universe output is not blocked. A comparison of network behavior in both cases is seen in Table 11 . This illustrates the utility of the verification method to verify new NBC designs that are complex or include various network optimizations, and may have subtle design errors. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 247,
                    "end": 254,
                    "text": "Table 1",
                    "ref_id": null
                },
                {
                    "start": 797,
                    "end": 807,
                    "text": "(Table 10)",
                    "ref_id": "TABREF8"
                },
                {
                    "start": 1720,
                    "end": 1728,
                    "text": "Table 11",
                    "ref_id": "TABREF9"
                }
            ],
            "section": "ExCov"
        },
        {
            "text": "Our tool generates 3-CNF SAT problems of random sizes in DIMACS format using CNFGen [19] . These are then run through the MiniSat SAT Solver to get their satisfiability results [12] for later comparison with NuSMV verification results. The tool then generates two network descriptions for each problem, one with separate clause and tag variables (Clause) and one with merged clause and tag variables (No-Clause). NuSMV is then run on each network description, once with and once without variable re-ordering (VRO). The re-ordering organizes the tag variables by first appearance of the relevant clause in the network. For example, all clauses containing the first literal come before clauses containing the second literal. Verification results and runtimes, for each of the specifications defined in Table 4 , are parsed and saved for further analysis. NBC verification results were compared with the MiniSat results, which directly check satisfiability or unsatisfiability of the formula, and were all consistent. Runtimes are examined using three comparisons; LTL vs. CTL, No VRO vs. VRO and No-Clause vs. Clause (Table 12 ). The same differences in verification runtime of LTL as compared with CTL specifications seen in SSP and ExCov were observed. While variable re-ordering may improve verification runtime, the re-ordering used here did not generally show improvement for all networks, and no tendency towards either improvement or deterioration was observed. Overall, the No-Clause network description tends to have faster runtimes than the Clause network description, as unification of the tag and clause variable decreases the size of the network description. ",
            "cite_spans": [
                {
                    "start": 84,
                    "end": 88,
                    "text": "[19]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 177,
                    "end": 181,
                    "text": "[12]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [
                {
                    "start": 800,
                    "end": 807,
                    "text": "Table 4",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 1115,
                    "end": 1124,
                    "text": "(Table 12",
                    "ref_id": "TABREF10"
                }
            ],
            "section": "SAT"
        },
        {
            "text": "We presented a prototype verification tool that takes as input an NBC design and performs formal verification to check the logical correctness of the circuit. The tool verifies the correctness of NBC designs for SSP, ExCov and SAT. For handling SAT problems, we have also implemented tagging in the verification tool, where the agent sets all the labels it gathers while traversing the network to true, and temporal logic queries can also relate to the tagging of the filament when exiting the network. We have used our tool to analyze the efficiency of different methods of verifying encodings and to generate random examples of varying sizes and difficulties using an automatic SAT formula generator. The verification results demonstrate that the approach can handle large NBC circuits and is applicable to the real-world systems currently designed in [4, 20, 27] . Our work is currently used as an integral part of the design phases of new circuits in the Bio4Comp project. Future work includes further scaling of the methods by evaluating and optimizing additional model checking algorithms and tools. Our translation to chemical reactions can form a basis for applying probabilistic model checking, which can remove some of the restricting assumptions made here. For example, we assume that pass junctions that do not have a manufacturing fault, never allow computational agents to change direction, while it was observed [4, 20] that most but not all of the of the agents traverse through pass junctions correctly. The effects of these errors could be quantified and analyzed using simulation and probabilistic model checking of CRNs to quantitatively estimate the effects of these errors in NBCs.",
            "cite_spans": [
                {
                    "start": 854,
                    "end": 857,
                    "text": "[4,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 858,
                    "end": 861,
                    "text": "20,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 862,
                    "end": 865,
                    "text": "27]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 1427,
                    "end": 1430,
                    "text": "[4,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1431,
                    "end": 1434,
                    "text": "20]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Summary"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Molecular computation of solutions to combinatorial problems",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "M"
                    ],
                    "last": "Adleman",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Science",
            "volume": "266",
            "issn": "5187",
            "pages": "1021--1024",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Bio4Comp: Bio4Comp project website",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "The formal language and design principles of autonomous DNA walker circuits",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Boemo",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "E"
                    ],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Turberfield",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Cardelli",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "ACS Synth. Biol",
            "volume": "5",
            "issn": "8",
            "pages": "878--884",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Automated design and verification of localized DNA computation circuits",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Boemo",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Turberfield",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Cardelli",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "DNA 2015",
            "volume": "9211",
            "issn": "",
            "pages": "168--180",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-21999-8_11"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "The nuXmv symbolic model checker",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Cavada",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "CAV 2014",
            "volume": "8559",
            "issn": "",
            "pages": "334--342",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-08867-9_22"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Symbolic model checking of biochemical networks",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Chabrier",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Fages",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "CMSB 2003",
            "volume": "2602",
            "issn": "",
            "pages": "149--162",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-36481-1_13"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Nusmv: a new symbolic model checker",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Cimatti",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Clarke",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Giunchiglia",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Roveri",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Int. J. Softw. Tools Technol. Transfer",
            "volume": "2",
            "issn": "4",
            "pages": "410--425",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Programmability of chemical reaction networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Cook",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Soloveichik",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Winfree",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bruck",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Condon",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Harel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kok",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Algorithmic Bioprocesses",
            "volume": "",
            "issn": "",
            "pages": "543--584",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-88869-7_27"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "DNA walker circuits: computational potential, design, and verification",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Dannenberg",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kwiatkowska",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Thachuk",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Turberfield",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "DNA 2013",
            "volume": "8141",
            "issn": "",
            "pages": "31--45",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-01928-4_3"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "An extensible SAT-solver",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "E\u00e9n",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "S\u00f6rensson",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "SAT 2003",
            "volume": "2919",
            "issn": "",
            "pages": "502--518",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-24605-3_37"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Temporal reasoning on incomplete paths",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Fisman",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kugler",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ISoLA 2018",
            "volume": "11245",
            "issn": "",
            "pages": "28--52",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-03421-4_3"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Computers and Intractability, a Guide to the Theory of NP-Completeness",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "R"
                    ],
                    "last": "Garey",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "S"
                    ],
                    "last": "Johnson",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Ruledsd: a rule-based modelling and simulation tool for DNA strand displacement systems",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Gautam",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Long",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Orponen",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "BIOINFORMATICS",
            "volume": "",
            "issn": "",
            "pages": "158--167",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Designing network based bio-computation circuits for the exact cover problem",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Korten",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "V N"
                    ],
                    "last": "Jr",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Diez",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kugler",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Linke",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Design and analysis of DNA strand displacement devices using probabilistic model checking",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lakin",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Parker",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Cardelli",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kwiatkowska",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Roy. Soc. Interface",
            "volume": "9",
            "issn": "72",
            "pages": "1470--1485",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Modelling, simulating and verifying turing-powerful strand displacement systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "R"
                    ],
                    "last": "Lakin",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "DNA 2011",
            "volume": "6937",
            "issn": "",
            "pages": "130--144",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-23638-9_12"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "CNFgen: a generator of crafted benchmarks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lauria",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Elffers",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Nordstr\u00f6m",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vinyals",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "SAT 2017",
            "volume": "10491",
            "issn": "",
            "pages": "464--473",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-66263-3_30"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Parallel computation with molecular-motor-propelled agents in nanofabricated networks",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "V"
                    ],
                    "last": "Nicolau",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proc. Natl. Acad. Sci",
            "volume": "113",
            "issn": "10",
            "pages": "2591--2596",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Towards programming languages for genetic engineering of living cells",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pedersen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "J. Roy. Soc. Interface",
            "volume": "6",
            "issn": "4",
            "pages": "437--450",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "A programming language for composable DNA circuits",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Cardelli",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "J. Roy. Soc. Interface",
            "volume": "6",
            "issn": "4",
            "pages": "1470--1485",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Scaling up digital circuit computation with DNA strand displacement cascades",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Qian",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Winfree",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Science",
            "volume": "332",
            "issn": "6034",
            "pages": "1196--1201",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Algorithmic self-assembly of DNA Sierpinski triangles",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "W"
                    ],
                    "last": "Rothemund",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Papadakis",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Winfree",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "PLoS Biol",
            "volume": "2",
            "issn": "12",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Enzyme-free nucleic acid logic circuits",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Seelig",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Soloveichik",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Winfree",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Science",
            "volume": "314",
            "issn": "5805",
            "pages": "1585--1588",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "A synthetic DNA walker for molecular transport",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "S"
                    ],
                    "last": "Shin",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [
                        "A"
                    ],
                    "last": "Pierce",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "J. Am. Chem. Soc",
            "volume": "126",
            "issn": "35",
            "pages": "10834--10835",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Something has to give: scaling combinatorial computing by biological agents exploring physical networks encoding NP-complete problems",
            "authors": [
                {
                    "first": "F",
                    "middle": [
                        "C"
                    ],
                    "last": "Van Delft",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Interface Focus",
            "volume": "8",
            "issn": "6",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Diverse and robust molecular algorithms using reprogrammable DNA self-assembly",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Woods",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Doty",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Myhrvold",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hui",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Yin",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Winfree",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Nature",
            "volume": "567",
            "issn": "7748",
            "pages": "366--372",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "A scalable photonic computer solving the subset sum problem",
            "authors": [
                {
                    "first": "X",
                    "middle": [
                        "Y"
                    ],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Sci. Adv",
            "volume": "6",
            "issn": "5",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1126/sciadv.aay5853"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "A unidirectional DNA walker that moves autonomously along a track",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Yin",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yan",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [
                        "G"
                    ],
                    "last": "Daniell",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Turberfield",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "H"
                    ],
                    "last": "Reif",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Angew. Chem",
            "volume": "116",
            "issn": "37",
            "pages": "5014--5019",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Functional analysis of large-scale DNA strand displacement circuits",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Yordanov",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "M"
                    ],
                    "last": "Wintersteiger",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Hamadi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kugler",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "DNA 2013",
            "volume": "8141",
            "issn": "",
            "pages": "189--203",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-01928-4_14"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Solution of a 3-sat problem based on network-based biocomputation via molecular motors",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Zhu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Network design for SSP (reproduced from[20]). (a) Overall network structure of the SSP for the set S = 2 5 9 . Split junctions are denoted as filled black circles and pass junctions as unfilled circles. Agents enter from the top left point of the network. The yellow path corresponds to the sum 11 being computed utilizing 2 and 9. (b) Physical design of pass and split junctions. Pass junctions are designed to maintain the agent's direction of movement, while split junctions are designed to allow agents an approximately equal chance to maintain or change their direction of movement.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Stochastic simulation of an SSP network for S = 2 5 9 with 1000 agents.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Network specifications for individual outputs. LTL specification (ltl k) checks that the output of interest is never reachable. CTL specification (ctl k) checks if there is any path to the output of interest. LTLSPEC NAME ltl k := G!((flag = T RUE)&(column = k)); CTLSPEC NAME ctl k := EF ((flag = T RUE)&(column = k));column is the current sum, k is the output of interest and flag is the output row indicator",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "ExCov network for U = 1 2 3 4 and SS = 2 , 3 , 1 4 , 2 3 . Split and pass junctions are as defined in Fig. 1a. Force-down junctions are denoted as filled orange circles. The blue path combines sets S3 and S4, constituting an exact cover. (Color figure online)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "SAT network models for three literals and three clauses.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "LTL LTLSPEC NAME ltl sat := G!((flag = T RUE)&( i\u22650 tag[i] > 0))There is no path that satisfies all clauses CTL CTLSPEC NAME ctl sat := EF ((flag = T RUE)&( i\u22650 tag[i] > 0))There exists a path that satisfies all clausesEach tag[i] corresponds to a specific clause Both models use the same LTL and CTL specifications to check if all tags have a positive, non-zero value when reaching the output state. That is, tag[i] > 0 for every clause i when flag = T RUE. The number of tags directly corresponds with the number of clauses.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "SSP network for S = 2 3 5 with example errors and their resulting outputs. Each error type is assigned a color. Resulting reachable paths are marked with dashed lines. Blocked paths are marked with an X at the initial and end points.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "[r, c, d, j, f ]|0 \u2264 r, c \u2264 max, d \u2208 {down, diag}, j \u2208 {split, pass, f down},",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "SAT clause network LTL and CTL specifications. For satisfiable networks LTL returns false and CTL returns true. For unsatisfiable networks LTL returns true and CTL returns false.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "SSP all output verification runtimes in minutes",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "SSP output 9 and 10 verification runtimes in minutes.",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "SSP general sum verification runtimes in minutes.",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "SSP general sum verification runtimes in minutes on network with no tag variable. Sets include the first k prime numbers.",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "SSP general sum verification results for valid networks and observably invalid networks. Error is denoted as the (row, column) junction location along with the error type as in the error type definitions.",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "ExCov verification runtimes in minutes.",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "ExCov existence verification on networks with properly functioning forcedown junctions (Valid) and networks with force-down junctions that behave as split junctions (Invalid).",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "SAT verification runtimes in minutes.3-SAT # Clauses # Variables No-clause runtimesClause runtimes",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}