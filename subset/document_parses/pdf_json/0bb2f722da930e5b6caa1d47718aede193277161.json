{
    "paper_id": "0bb2f722da930e5b6caa1d47718aede193277161",
    "metadata": {
        "title": "Good-for-MDPs Automata for Probabilistic Analysis and Reinforcement Learning",
        "authors": [
            {
                "first": "Ernst",
                "middle": [
                    "Moritz"
                ],
                "last": "Hahn",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Queen's University Belfast",
                    "location": {
                        "country": "UK"
                    }
                },
                "email": ""
            },
            {
                "first": "Mateo",
                "middle": [],
                "last": "Perez",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Colorado Boulder",
                    "location": {
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Sven",
                "middle": [],
                "last": "Schewe",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Liverpool",
                    "location": {
                        "country": "UK"
                    }
                },
                "email": ""
            },
            {
                "first": "Fabio",
                "middle": [],
                "last": "Somenzi",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Colorado Boulder",
                    "location": {
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Ashutosh",
                "middle": [],
                "last": "Trivedi",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Colorado Boulder",
                    "location": {
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Dominik",
                "middle": [],
                "last": "Wojtczak",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Liverpool",
                    "location": {
                        "country": "UK"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "We characterize the class of nondeterministic \u03c9-automata that can be used for the analysis of finite Markov decision processes (MDPs). We call these automata 'good-for-MDPs' (GFM). We show that GFM automata are closed under classic simulation as well as under more powerful simulation relations that leverage properties of optimal control strategies for MDPs. This closure enables us to exploit state-space reduction techniques, such as those based on direct and delayed simulation, that guarantee simulation equivalence. We demonstrate the promise of GFM automata by defining a new class of automata with favorable properties-they are B\u00fcchi automata with low branching degree obtained through a simple construction-and show that going beyond limit-deterministic automata may significantly benefit reinforcement learning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "System specifications are often captured in the form of finite automata over infinite words (\u03c9-automata), which are then used for model checking, synthesis, and learning. Of the commonly-used types of \u03c9-automata, B\u00fcchi automata have the simplest acceptance condition, but require nondeterminism to recognize all \u03c9-regular languages. Nondeterministic machines can use unbounded look-ahead to resolve nondeterministic choices. However, important applications-like reactive synthesis or model checking and reinforcement learning (RL) for Markov Decision Process (MDPs [23] )-have a game setting, which restrict the resolution of nondeterminism to be based on the past.",
            "cite_spans": [
                {
                    "start": 565,
                    "end": 569,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Being forced to resolve nondeterminism on the fly, an automaton may end up rejecting words it should accept, so that using it can lead to incorrect results. Due to this difficulty, initial solutions to these problems have been based on deterministic automatausually with Rabin or parity acceptance conditions. For two-player games, Henzinger and Piterman proposed the notion of good-for-games (GFG) automata [15] . These are nondeterministic automata that simulate [21, 14, 9] a deterministic automaton that recognizes the same language. The existence of a simulation strategy means that nondeterministic choices can be resolved without look-ahead. This work has been supported by the National Natural Science Foundation of China (Grant Nr. 61532019), EPSRC grants EP/M027287/1 and EP/P020909/1, and a CU Boulder RIO grant.",
            "cite_spans": [
                {
                    "start": 408,
                    "end": 412,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 465,
                    "end": 469,
                    "text": "[21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 470,
                    "end": 473,
                    "text": "14,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 474,
                    "end": 476,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The situation is better in the case of probabilistic model checking, because the game for which a strategy is sought is played on an MDP against \"blind nature,\" rather than against a strategic opponent who may take advantage of the automaton's inability to resolve nondeterminism on the fly. As early as 1985, Vardi noted that probabilistic model checking can be performed with B\u00fcchi automata endowed with a limited form of nondeterminism [34] . Limit deterministic B\u00fcchi automata (LDBA) [4, 11, 29] perform no nondeterministic choice after seeing an accepting transition. Still, they recognize all \u03c9-regular languages and are, under mild restrictions [29] , suitable for probabilistic model checking. Related Work. The production of deterministic and limit deterministic automata for model checking has been intensively studied [24, 22, 1, 26, 33, 32, 27, 29, 8, 30, 20] , and several tools are available to produce different types of automata, incl. MoChiBA/Owl [29, 30, 20] , LTL3BA [1] , GOAL [33, 32] , SPOT [8] , Rabinizer [19] , and B\u00fcchifier [16] .",
            "cite_spans": [
                {
                    "start": 439,
                    "end": 443,
                    "text": "[34]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 488,
                    "end": 491,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 492,
                    "end": 495,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 496,
                    "end": 499,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 652,
                    "end": 656,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 829,
                    "end": 833,
                    "text": "[24,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 834,
                    "end": 837,
                    "text": "22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 838,
                    "end": 840,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 841,
                    "end": 844,
                    "text": "26,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 845,
                    "end": 848,
                    "text": "33,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 849,
                    "end": 852,
                    "text": "32,",
                    "ref_id": null
                },
                {
                    "start": 853,
                    "end": 856,
                    "text": "27,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 857,
                    "end": 860,
                    "text": "29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 861,
                    "end": 863,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 864,
                    "end": 867,
                    "text": "30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 868,
                    "end": 871,
                    "text": "20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 964,
                    "end": 968,
                    "text": "[29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 969,
                    "end": 972,
                    "text": "30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 973,
                    "end": 976,
                    "text": "20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 986,
                    "end": 989,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 997,
                    "end": 1001,
                    "text": "[33,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 1002,
                    "end": 1005,
                    "text": "32]",
                    "ref_id": null
                },
                {
                    "start": 1013,
                    "end": 1016,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1029,
                    "end": 1033,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1050,
                    "end": 1054,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "So far, only deterministic and a (slightly restricted [29] ) class of limit deterministic automata have been considered for probabilistic model checking [34, 4, 11, 29] . Thus, while there have been advances in the efficient production of such automata [11, 29, 30, 20] , the consideration of suitable LDBAs by Courcoubetis and Yannakakis in 1988 [3] has been the last time when a fundamental change in the automata foundation of MDP model checking has occurred. Contribution. The simple but effective observation that simulation preserves the suitability for MDPs (for both traditional simulation and the AEC simulation we introduce) extends the class of automata that can be used in the analysis of MDPs. This provides us with three advantages: The first advantage is that we can now use a wealth of simulation based statespace reduction techniques [7, 31, 10, 9] on an automaton A (e.g. an SLDBA) that we would otherwise use for MDP model checking. The second advantage is that we can use A to check if a different language equivalent automaton, such as an NBA B (e.g. an NBA from which A is derived) simulates A. For this second advantage, we can dip into the more powerful class of AEC simulation we define in Section 4 that use properties of winning strategies on finite MDPs. While this is not a complete method for identifying GFM automata, our experimental results indicate that the GFM property is quite frequent for NBAs constructed from random formulas, and can often be established efficiently, while providing a significant statespace reduction and thus offering a significant advantage for model checking.",
            "cite_spans": [
                {
                    "start": 54,
                    "end": 58,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 153,
                    "end": 157,
                    "text": "[34,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 158,
                    "end": 160,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 161,
                    "end": 164,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 165,
                    "end": 168,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 253,
                    "end": 257,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 258,
                    "end": 261,
                    "text": "29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 262,
                    "end": 265,
                    "text": "30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 266,
                    "end": 269,
                    "text": "20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 347,
                    "end": 350,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 851,
                    "end": 854,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 855,
                    "end": 858,
                    "text": "31,",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 859,
                    "end": 862,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 863,
                    "end": 865,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A third advantage is that we can use the additional flexibility to tailor automata for different applications than model checking, for which specialized automata classes have not yet been developed. We demonstrate this for model-free reinforcement learning (RL). We argue that RL benefits from three properties that are less important in model checking: The first-easy to measure-property is a small number of successors, the second and third, are cautiousness, the scope for making wrong decisions, and forgiveness, the resilience against making wrong decisions, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A small number of successors is a simple and natural goal for RL, as the lack of an explicit model means that the product space of a model and an automaton cannot be evaluated backwards. In a forward analysis, it matters that nondeterministic choices have to be modeled by enriching the decisions in the MDPs with the choices made by the automaton. For LDBAs constructed from NBAs, this means guessing a suit-able subset of the reachable states when progressing to the deterministic part of the automaton, meaning a number of choices that is exponential in the NBA. We show that we can instead use slim automata in Section 3.2 as a first example of NBAs that are good-for-MDPs, but not limit deterministic. They have the appealing property that their branching degree is at most two, while keeping the B\u00fcchi acceptance mechanism that works well with RL [12] . (Slim automata can also be used for model checking, but they don't provide similar advantages over suitable LDBAs there, because the backwards analysis used in model checking makes selecting the correct successor trivial.)",
            "cite_spans": [
                {
                    "start": 853,
                    "end": 857,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Cautiousness and forgiveness are further properties, which are-while harder to quantify-very desirable for RL: LDBAs, for example, suffer from having to make a correct choice when moving into the deterministic part of the automaton, and they have to make this correct choice from a very large set of nondeterministic transitions. While this is unproblematic for standard model checking algorithms that are based on backwards analysis, applications like RL that rely on forward analysis can be badly affected when more (wrong) choices are offered, and when wrong choices cannot be rectified. Cautiousness and forgiveness are a references to this: an automaton is more cautious if it has less scope for making wrong decisions and more forgiving if it allows for correcting previously made decisions (cf. Figure 5 for an example). Our experiments (cf. Section 5) indicate that cautiousness and forgiveness are beneficial for RL. Organization of the Paper. After the preliminaries, we introduce the \"good-for-MDP\" property (Section 3) and show that it is preserved by simulation, which enables all minimization techniques that offer the simulation property (Section 3.1). In Section 3.2 we use this observation to construct slim automata-NBAs with a branching degree of 2 that are neither limit deterministic nor good-for-games-as an example of a class of automata that becomes available for MDP model checking and RL. We then introduce a more powerful simulation relation, AEC simulation, that suffices to establish that an automaton is good-for-MDPs (Section 4). In Section 5, we evaluate the impact of the contributions of the paper on model checking and reinforcement learning algorithms.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 802,
                    "end": 810,
                    "text": "Figure 5",
                    "ref_id": null
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "A nondeterministic B\u00fcchi automaton is a tuple A = \u03a3, Q, q 0 , \u2206, \u0393 , where \u03a3 is a finite alphabet, Q is a finite set of states, q 0 \u2208 Q is the initial state, \u2206 \u2286 Q \u00d7 \u03a3 \u00d7 Q are transitions, and \u0393 \u2286 Q \u00d7 \u03a3 \u00d7 Q is the transition-based acceptance condition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A run r of A on w \u2208 \u03a3 \u03c9 is an \u03c9-word r 0 , w 0 , r 1 , w 1 , . . . in (Q\u00d7\u03a3) \u03c9 such that r 0 = q 0 and, for i > 0, it is (r i\u22121 , w i\u22121 , r i ) \u2208 \u2206. We write inf(r) for the set of transitions that appear infinitely often in the run r.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The language, L A , of A (or, recognized by A) is the subset of words in \u03a3 \u03c9 that have accepting runs in A. A language is \u03c9-regular if it is accepted by a B\u00fcchi automaton. An automaton A = \u03a3, Q, Q 0 , \u2206, \u0393 is deterministic if (q, \u03c3, q ), (q, \u03c3, q ) \u2208 \u2206 implies q = q . A is complete if, for all \u03c3 \u2208 \u03a3 and all q \u2208 Q, there is a transition (q, \u03c3, q ) \u2208 \u2206. A word in \u03a3 \u03c9 has exactly one run in a deterministic, complete automaton.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A Markov decision process (MDP) M is a tuple (S, A, T, \u03a3, L) where S is a finite set of states, A is a finite set of actions, T : S \u00d7 A \u2212 D(S), where D(S) is the set of probability distributions over S, is the probabilistic transition (partial) function, \u03a3 is an alphabet, and L : S \u00d7 A \u00d7 S \u2192 \u03a3 is the labeling function of the set of transitions. For a state s \u2208 S, A(s) denotes the set of actions available in s. For states s, s \u2208 S and a \u2208 A(s), we have that T (s, a)(s ) equals Pr (s |s, a).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A run of M is an \u03c9-word s 0 , a 1 , . . . \u2208 S \u00d7 (A \u00d7 S) \u03c9 such that Pr (s i+1 |s i , a i+1 ) > 0 for all i \u2265 0. A finite run is a finite such sequence. For a run r = s 0 , a 1 , s 1 , . . . we define the corresponding labeled run as L(r) = L(s 0 , a 1 , s 1 ), L(s 1 , a 2 , s 2 ), . . . \u2208 \u03a3 \u03c9 . We write \u2126(M) (Paths(M)) for the set of runs (finite runs) of M and \u2126 s (M) (Paths s (M)) for the set of runs (finite runs) of M starting from state s. When the MDP is clear from the context we drop the argument M.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A strategy in M is a function \u00b5 : Paths \u2192 D(A) such that supp(\u00b5(r)) \u2286 A(last(r)), where supp(d) is the support of d and last(r) is the last state of r. Let \u2126 M \u00b5 (s) denote the subset of runs \u2126 M (s) that correspond to strategy \u00b5 and initial state s. Let \u03a0 M be the set of all strategies. We say that a strategy \u00b5 is pure if \u00b5(r) is a point distribution for all runs r \u2208 Paths and we say that \u00b5 is positional if last(r) = last(r ) implies \u00b5(r) = \u00b5(r ) for all runs r, r \u2208 Paths. The behavior of an MDP M under a strategy \u00b5 with starting state s is defined on a probability space (\u2126 \u00b5 s , F \u00b5 s , Pr \u00b5 s ) over the set of infinite runs of \u00b5 from s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Given an MDP M and an automaton A = \u03a3, Q, q 0 , \u2206, \u0393 , we want to compute an optimal strategy satisfying the objective that the run of M is in the language of A. We define the semantic satisfaction probability for A and a strategy \u00b5 from state s as: Finally, \u0393 \u00d7 \u2286 (S \u00d7Q)\u00d7(A\u00d7Q)\u00d7(S \u00d7Q) is defined by ((s, q), (a, q ), (s , q )) \u2208 \u0393 \u00d7 if, and only if, (q, L(s, a, s ), q ) \u2208 \u0393 and T (s, a)(s ) > 0. A strategy \u00b5 on the MDP defines a strategy \u00b5 \u00d7 on the product, and vice versa. We define the syntactic satisfaction probabilities as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "Note that PSyn M A (s) = PSem M A (s) holds for a deterministic A. In general, PSyn M A (s) \u2264 PSem M A (s) holds, but equality is not guaranteed because the optimal resolution of nondeterministic choices may require access to future events (see Figure 1 ). For an automaton to match PSem M A (s 0 ), its nondeterminism is restricted not to rely heavily on the future; rather, it must possible to resolve the nondeterminism on-the-fly. For example, the B\u00fcchi automaton presented on the left of Figure 1 , which has to guess whether the next symbol is a or b, is not good for MDPs, because the simple Markov chain on the right of Figure 1 does not allow resolution of its nondeterminism on-the-fly.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 245,
                    "end": 253,
                    "text": "Figure 1",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 493,
                    "end": 501,
                    "text": "Figure 1",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 628,
                    "end": 636,
                    "text": "Figure 1",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "There are three families of automata that are known to be good for MDPs: (1) deterministic automata, (2) good for games automata [15, 18] , and (3) limit deterministic automata that satisfy a few side constraints [4, 11, 29] .",
            "cite_spans": [
                {
                    "start": 129,
                    "end": 133,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 134,
                    "end": 137,
                    "text": "18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 213,
                    "end": 216,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 217,
                    "end": 220,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 221,
                    "end": 224,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "A limit-deterministic B\u00fcchi automaton (LDBA) is a nondeterministic B\u00fcchi au-",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": ", (q, \u03c3, q ) \u2208 \u2206 and q, q \u2208 Q f implies q = q ; and (q, \u03c3, q ) \u2208 \u2206 and q \u2208 Q f implies q \u2208 Q f . An LDBA behaves deterministically once it has seen an accepting transition. Usual LDBA constructions [11, 29] produce GFM automata. We refer to LDBAs with this property as suitable (SLDBAs), cf. Theorem 1.",
            "cite_spans": [
                {
                    "start": 198,
                    "end": 202,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 203,
                    "end": 206,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "In the context of RL, techniques based on SLDBAs are particularly useful, because these automata use the B\u00fcchi acceptance condition, which can be translated to reachability goals. Good for games and deterministic automata require more complex acceptance conditions, like parity, that do not have a natural translation into rewards [12] .",
            "cite_spans": [
                {
                    "start": 331,
                    "end": 335,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "Using SLDBA [4, 11, 29] has the drawback that they naturally have a high branching degree in the initial part, as they naturally allow for many different transitions to the accepting part of the LDBA. This can be avoided, but to the cost of a blow-up and a more complex construction and data structure [29] . We therefore propose an automata construction that produces NBAs with a small branching degree-it never produces more than two successors. We call these automata slim. The resulting automata are not (normally) limit deterministic, but we show that they are good for MDPs.",
            "cite_spans": [
                {
                    "start": 12,
                    "end": 15,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 16,
                    "end": 19,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 20,
                    "end": 23,
                    "text": "29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 302,
                    "end": 306,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "Due to technical dependencies we start with presenting a second observation, namely that automata that simulate language equivalent GFM automata are GFM. As a side result, we observe that the same holds for good-for-games automata. The side result is not surprising, as good-for-games automata were defined through simulation of deterministic automata [15] . But, to the best of our knowledge, the observation from Corollary 1 has not been made yet for good-for-games automata.",
            "cite_spans": [
                {
                    "start": 352,
                    "end": 356,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Good-for-MDP (GFM) Automata"
        },
        {
            "text": "An automaton A simulates an automaton B if the duplicator wins the simulation game. The simulation game is played between a duplicator and a spoiler, who each control a pebble, which they move along the edges of A and B, respectively. The game is started by the spoiler, who places her pebble on an initial state of B. Next, the duplicator puts his pebble on an initial state of A. The two players then take turns, always starting with the spoiler choosing an input letter and a transition for that letter in B, followed by the duplicator choosing a transition for the same letter in A. This way, both players produce an infinite run of their respective automaton. The duplicator has two ways to win a play of the game: if the run of A he constructs is accepting, and if the run the spoiler constructs on B is rejecting. The duplicator wins this game if he has a winning strategy, i.e., a recipe to move his pebble that guarantees that he wins. Such a winning strategy is \"good-for-games,\" as it can only rely on the past. It can be used to transform winning strategies of B, so that, if they were witnessing a good for games property or were good for an MDP, then the resulting strategy for A has the same property.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simulating GFM"
        },
        {
            "text": "For \u03c9-automata A and B the following holds. (1) and (2) are well known observations. Fact (1) holds because an accepting run of B on a word \u03b1 can be translated into an accepting run of A on \u03b1 by using the winning strategy of A in the simulation game. Fact (2) follows immediately from Fact (1). Facts (3) and (4) follow by simulating the behaviour of B on each run.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1 (Simulation Properties)."
        },
        {
            "text": "This observation allows us to use a family of state-space reduction techniques, in particular those based on language preserving translations for B\u00fcchi automata based on simulation relation [7, 31, 10, 9] . This requires stronger notions of simulations, like direct and delayed simulation [9] . For the deterministic part of an LDBA, one can also use space reduction techniques for DBAs like [25] . Corollary 1. All statespace reduction techniques that turn an NBA A into an NBA B that simulates A preserve GFG and GFM: if A is GFG or GFM, then B is GFG or GFM, respectively.",
            "cite_spans": [
                {
                    "start": 190,
                    "end": 193,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 194,
                    "end": 197,
                    "text": "31,",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 198,
                    "end": 201,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 202,
                    "end": 204,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 289,
                    "end": 292,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 392,
                    "end": 396,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "If"
        },
        {
            "text": "Let us fix B\u00fcchi automaton B = \u03a3, Q, Q 0 , \u2206, \u0393 . We can write \u2206 as a function \u03b4 : Q \u00d7 \u03a3 \u2192 2 Q with\u03b4 : (q, \u03c3) \u2192 {q \u2208 Q | (q, \u03c3, q ) \u2208 \u2206}, which can be lifted to sets, using the deterministic transition function \u03b4 : 2 Q \u00d7 \u03a3 \u2192 2 Q with \u03b4 : (S, \u03c3) \u2192 q\u2208S\u03b4 (q, \u03c3). We also define an operator, ndet, that translates deterministic transition functions \u03b4 : R \u00d7 \u03a3 \u2192 R to relations, using",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "This is just an easy means to move back and forth between functions and relations, and helps one to visualize the maximal number of successors. We next define the variations of subset and breakpoint constructions that are used to define the well-known limit deterministic GFM automata-which we use in our proofs-and the slim GFM automata we construct. Let 3 Q := (S, S ) | S S \u2286 Q and 3 Q + := (S, S ) | S \u2286 S \u2286 Q . We define the subset notation for the transitions and accepting transitions as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "We define the raw breakpoint transitions \u03b4 R :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": ". In this construction, we follow the set of reachable states (first set) and the states that are reachable while passing at least one of the accepting transitions (second set). To turn this into a breakpoint automaton, we reset the second set to the empty set when it equals the first; the transitions where we reset the second set are exactly the accepting ones. The breakpoint automaton",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": ", then there are three cases:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Finally, we define transitions \u2206 SB \u2286 2 Q \u00d7 \u03a3 \u00d7 3 Q that lead from a subset to a breakpoint construction, and \u03b3 2,1 : 3 Q \u00d7 \u03a3 \u2192 3 Q that promote the second set of a breakpoint construction to the first set as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "1. \u2206 SB = S, \u03c3, (S , \u2205) | \u2205 = S \u2286 \u03b4 S (S, \u03c3) are non-accepting transitions, 2. if \u03b4 S (S , \u03c3) = \u03b3 S (S, \u03c3) = \u2205, then \u03b3 2,1 (S, S ), \u03c3 is undefined, and 3. otherwise \u03b3 2,1 : (S, S ), \u03c3 \u2192 \u03b4 S (S , \u03c3)\u222a\u03b3 S (S, \u03c3), \u2205 is an accepting transition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "We can now define standard limit deterministic good for MDP automata.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "recognizes the same language as B. It is limit deterministic and good for MDPs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "We now show how to construct a slim GFM B\u00fcchi automaton.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Theorem 2 (Slim GFM B\u00fcchi Automaton). The automaton",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "simulates A. S is slim, language equivalent to B, and good for MDPs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Proof. S is slim: its set of transitions is the union of two sets of deterministic transitions. We show that S simulates A by defining a strategy in the simulation game, which ensures that, if the spoiler produces a run S 0 . . . S j\u22121 (S j , S j )(S j+1 , S j+1 ) . . . for A, then the duplicator produces a run (T 0 , T 0 ) . . . (T j\u22121 , T j\u22121 )(T j , T j )(T j+1 , T j\u22121 ) . . . for S, such that (1) S i \u2286 T i holds for all i \u2208 \u03c9, and (2) if there are two accepting transitions (S k\u22121 , S k\u22121 ), \u03c3 k , (S k , S k ) and (S l\u22121 , S l\u22121 ), \u03c3 l , (S l , S l ) with k < l, there is an k < m \u2264 l, such that (T m\u22121 , T m\u22121 ), \u03c3 m (T m , T m ) is accepting.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "To obtain this, we describe a winning strategy for the duplicator while arguing inductively that it mainains (1). Note that (1) holds initially (T 0 = S 0 , induction basis).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Initial Phase: Every move of the spoiler-with some letter \u03c3-that uses a transition from \u03b4 S -the subset part of A-is followed by a move from \u03b4 B with the same letter \u03c3. When the duplicator follows this strategy the following holds: when, after a pair of moves, the pebble of the spoiler is on state S \u2286 Q, then the pebble of the duplicator is on some state (S, S ). In particular, (1) is preserved during this phase (induction step).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Transition Phase: The one spoiler move-with some letter \u03c3-that uses a transition from \u2206 SB -the transition to the breakpoint part of A-is followed by a move from \u03b4 B with the same letter \u03c3. When the duplicator follows this strategy, and when, after the pair of moves, the pebble of the spoiler is on state (S, \u2205), then the pebble of the duplicator is on some state (T, T ) with S \u2286 T . In particular, (1) is preserved (induction step).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Final Phase: When the spoiler moves from some state (S, S )-with some letter \u03c3that uses a transition from \u03b4 B -the breakpoint part of A-to (S,S ), and when the duplicator is in some state (T, T ), then the duplicator does the following. He calculates (T , \u2205) = \u03b3 2,1 (T, T ), \u03c3 and checks ifS \u2286T holds. IfS \u2286T holds, he plays this transition from \u03b3 2,1 (with the same letter \u03c3). Otherwise, he plays the transition from \u03b4 B (with the same letter \u03c3). In either case (1) is preserved (induction step), which closes the inductive argument for (1) .",
            "cite_spans": [
                {
                    "start": 539,
                    "end": 542,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Note that no accepting transition of A is passed in the initial or tansition phase, so the two accepting transitions from (2) must both fall into the final phase.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "To show (2), we first observe that S k = \u2205, and thus S k \u2286 T k holds. Assuming for contradition that all transitions of S for \u03c3 k+1 . . . \u03c3 l\u22121 are non-accepting, we obtainusing (1)-by a straightforward inductive argument that S i \u2286 T i for all i with k\u2264i<l. (Note that transitions in \u03b4 B are accepting when they are also be in \u03b3 B .)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Using that S l = \u03b4 S (S l\u22121 , \u03c3 l ) \u222a \u03b3 S (S l\u22121 , \u03c3 l ) \u2286 \u03b4 S (T l\u22121 , \u03c3 l ) \u222a \u03b3 S (T l\u22121 , \u03c3 l ) holds, the spoiler uses an accepting transition from \u03b3 2,1 in this step.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "Using Lemma 1, it now suffices to show that the language of S is included in the language of B. To show this, we simply argue that an accepting run \u03c1 = (Q 0 , Q 0 ), (Q 1 , Q 1 ), (Q 2 , Q 2 ), (Q 3 , Q 3 ), . . . of S on an input word \u03b1 = \u03c3 0 , \u03c3 1 , \u03c3 2 , . . . can be interpreted as a forest of finitely many finitely branching trees of overall infinite size, where all infinite branches are accepting runs of B. K\u0151nig's Lemma then proves the existence of an accepting run of B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "This forest is the usual one. The nodes are labeled by states of B, and the roots (level 0) are the initial states of B. 1 ) be the set of positions after accepting transitions in \u03c1. We define the predecessor function pred : N \u2192 I\u222a{0} with pred : i \u2192 max j \u2208 I\u222a{0} | j < i .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 121,
                    "end": 122,
                    "text": "1",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "We call a node with label q l on level l an end-point if one of the following applies: (1) q l / \u2208 Q l or (2) l \u2208 I and for all j such that pred(l) \u2264 j < l, where q j is the label of the ancestor of this node on level j, we have (q j , \u03c3 j , q j+1 ) / \u2208 \u0393 . (1) may only happen after a transition from \u03b3 2,1 has been taken, and the q l is not among the states that is traced henceforth. (2) identifies parts of the run tree that do not contain an accepting transition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "A node labeled with q l on level l that is not an endpoint has \u03b4 S (q l , \u03c3 l ) children, labeled with the different elements of \u03b4 S (q l , \u03c3 l ). It is now easy to show by induction over i that the following holds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "1. For all q \u2208 Q i , there is a node on level i labeled with q.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Constructing Slim GFM Automata"
        },
        {
            "text": "\u2208 I and q \u2208 Q i , there is a node labeled q on level i, a j with pred(i) \u2264 j < i, and ancestors on level j and j +1 labeled q j and q j+1 , such that (q j , \u03c3 j , q j+1 ) \u2208 \u0393 . (The 'ancestor' on level j + 1 might be the state itself.) For i \u2208 I and q \u2208 Q i , there is a node labeled q on level i, which is not an end point.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "For i /"
        },
        {
            "text": "Consequently, the forest is infinite, finitely branching, and finitely rooted, and thus contains an infinite path. By construction, this path is an accepting run of B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "For i /"
        },
        {
            "text": "The resulting automata are simple in structure and enable symbolic implementation (See Fig. 2 ). It cannot be expected that there are much smaller good for MDP automata, as its explicit construction is the only non-polynomial part in model checking MDPs.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 87,
                    "end": 93,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "For i /"
        },
        {
            "text": "Theorem 3. Constructing a GFM B\u00fcchi automaton G that recognizes the models of an LTL formula \u03d5 requires time doubly exponential in \u03d5, and constructing a GFM B\u00fcchi automaton G that recognizes the language of an NBA B requires time exponential in B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "For i /"
        },
        {
            "text": "Proof. As resulting automata are GFM, they can be used to model check MDPs M against this property, with cost polynomial in product of M and G. If G could be produced faster (and if they could, consequently be smaller) than claimed, it will contradict the 2-EXPTIME-and EXPTIME-hardness [4] of these model checking problems.",
            "cite_spans": [
                {
                    "start": 287,
                    "end": 290,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "For i /"
        },
        {
            "text": "An end-component [5, 2] of an MDP M is a sub-MDP M of M such that its underlying graph is strongly connected. A maximal end-component is maximal under set-inclusion. Every state of an MDP belongs to at most one maximal end-component.",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 20,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 21,
                    "end": 23,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Accepting End-Component Simulation"
        },
        {
            "text": "Once an end-component C of an MDP is entered, there is a strategy that visits every state-action combination in C infinitely often with probability 1 and stays in C forever.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "For a product MDP, an accepting end-component (AEC) is an end-component that contains some transition in \u0393 \u00d7 . There is a positional pure strategy for an AEC C that surely stays in C and almost surely visits a transition in \u0393 \u00d7 infinitely often.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "For a product MDP, there is a set of disjoint accepting end-components such that, from every state, the maximal probability to reach the union of these accepting endcomponents is the same as the maximal probability to satisfy \u0393 \u00d7 . Moreover, this probability can be realized by combining a positional pure (reachability) strategy outside of this union with the aforementioned positional pure strategies for the individual AECs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "Lemma 1 shows that the GFM property is preserved by simulation: For languageequivalent automata A and B, if A simulates B and B is GFM, then A is also GFM. However, a GFM automaton may not simulate a language-equivalent GFM automaton. (See Figure 3. ) Therefore we introduce a coarser preorder, Accepting End-Component (AEC) simulation, that exploits the finiteness of the MDP M. We rely on Theorem 4 to focus on positional pure strategies for M \u00d7 B. Under such strategies, M \u00d7 B becomes a Markov chain [2] such that almost all its runs have the following properties: With this in mind, we can intuitively ask the spoiler to pick a run through this Markov chain, and to disclose information about this run. Specifically, we can ask her to signal when she has reached an accepting LSCC 5 in the Markov chain, and to provide information about this LSCC, in particular information entailed by the full list of sequences of transitions of some fixed length described above. Runs that can be identified to either not reach an accepting LSCC, to visit transitions not in this list, or to visit only a subset of sequences from this list, form a 0 set. In the simulation game we define below, we make use of this observation to discard such runs. A simulation game can only use the syntactic material of the automata--neither the MDP nor the strategy are available. The information the spoiler may provide cannot explicitly refer to them. What the spoiler may be asked to provide is information on when she has entered an accepting LSCC, and, once she has signaled this, which sequences of length l of automata transitions of B occur in the LSCC. The sequences of automata transitions are simply the projections on the automata transitions from the sequences of transitions of length that occur in the LSCC L. We call this information a gold-brim accepting end-component claim of length , -GAEC claim for short.",
            "cite_spans": [
                {
                    "start": 503,
                    "end": 506,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [
                {
                    "start": 240,
                    "end": 249,
                    "text": "Figure 3.",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "The term \"gold-brim\" in the definition indicates that this is a powerful approach, but not one that can be implemented efficiently. We will define weaker, efficiently implementable notions of accepting end-component claims (AEC claims) later.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "The AEC simulation game is very similar to the simulation game of Section 3.1. Both players produce an infinite run of their respective automata. If the spoiler makes an AEC claim, e.g., an -GAEC claim, we say that her run complies with it if, starting with the transition when the AEC claim is made, all states, transitions, or sequences of transitions in the claim appear infinitely often, and all states, transitions, and sequences of transitions the claim excludes do not appear. For an -GAEC claim, this means that all of the sequences of transitions of length in the claim occur infinitely often, and no other sequence of length occurs henceforth.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "Thus, like a classic simulation game, an -GAEC simulation game is started by the spoiler, who places her pebble on an initial state of B. Next, the duplicator puts his pebble on an initial state of A. The two players then take turns, always starting with the spoiler choosing an input letter and an according transition from B, followed by the duplicator choosing a transition for the same letter in A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "Different from the classic simulation game, in an -GAEC simulation game, the spoiler has an additional move that she can (and, in order to win, has to) perform once in the game: In addition to choosing a letter and a transition, she can claim that she has reached an accepting end-component, and provide a complete list of sequences of automata transitions of length that can henceforth occur. This store is maintained, and never updated. It has no further effect on the rules of the game: Both players produce an infinite run of their respective automata. The duplicator has four ways to win:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "1. if the spoiler never makes an AEC claim, 2. if the run of A he constructs is accepting, 3. if the run the spoiler constructs on B does not comply with the AEC claim, and 4. if the run that the spoiler produces is not accepting.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "For -GAEC claims, (4) simply means that the set of transitions defined by the sequences does not satisfy the B\u00fcchi, parity, or Rabin acceptance condition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (End-Component Properties. Theorem 3.1 and Theorem 4.2 of [5])."
        },
        {
            "text": "A and B are language equivalent automata, B is GFM, and there exists an such that A -GAEC simulates B, then A is GFM.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "For the proof, we use an arbitrary (but fixed) MDP M, and an arbitrary (but fixed) pure optimal positional strategy \u00b5 for M \u00d7 B, resulting in the Markov chain (M \u00d7 B) \u00b5 . We assume w.l.o.g. that the accepting LSCCs in (M \u00d7 B) \u00b5 are identified, e.g., by a bit.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "Let \u03c4 be a winning strategy of the duplicator in an -GAEC simulation game. Abusing notation, we let \u03c4 \u2022 \u00b5 denote the finite-memory strategy 6 obtained from \u00b5 and \u03c4 for M \u00d7 A, where \u03c4 is acting only on the automata part of (M \u00d7 B), and where the spoiler makes the move to the end-component when she is in some LSCC B of (M \u00d7 B) \u00b5 and gives the full list of sequences of transitions of length that occur in B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "Proof. As B is good for MDPs, we only have to show that the chance of winning in (M \u00d7 A) \u03c4 \u2022\u00b5 is at least the chance of winning in (M \u00d7 B) \u00b5 . The chance of winning in (M \u00d7 B) \u00b5 is the chance of reaching an accepting LSCC in (M \u00d7 B) \u00b5 . It is also the chance of reaching an accepting LSCC L \u2208 (M \u00d7 B) \u00b5 and, after reaching L, to see exactly the sequences of transitions of length that occur in L, and to see all of them infinitely often.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "By construction, \u03c4 \u2022 \u00b5 will translate those runs into accepting runs of (M \u00d7 A) \u03c4 \u2022\u00b5 , such that the chance of an accepting run of (M \u00d7 A) \u03c4 \u2022\u00b5 is at least the chance of an accepting run of (M \u00d7 B) \u00b5 . As \u00b5 is optimal, the chance of winning in M \u00d7 A is at least the chance of winning in M \u00d7 B. As B is GFM, this is the chance of M producing a run accepted by B (and thus A) when controlled optimally, which is an upper bound on the chance of winning in M \u00d7 A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "An -GAEC simulation, especially for large , results in very large state spaces, because the spoiler has to list all sequences of transitions of B of length that will appear infinitely often. No other sequence of length may then appear in the run 7 . This can, of course, be prohibitively expensive.",
            "cite_spans": [
                {
                    "start": 246,
                    "end": 247,
                    "text": "7",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "As a compromise, one can use coarser-grained information at the cost of reducing the duplicator's ability of winning the game. E.g., the spoiler could be asked to only reveal a transition that is repeated infinitely often, plus (when using more powerful acceptance conditions than B\u00fcchi), some acceptance information, say the dominating priority in a parity game or a winning Rabin pair. This type of coarse-grained claim can be refined slightly by allowing the duplicator to change at any time the transition that is to appear infinitely often to the transition just used by the spoiler. Generally, we say that an AEC simulation game is any simulation game, where the spoiler provides a list of states, transitions, or sequences of transitions that will occur infinitely often and a list of states, transitions, or sequences of transitions that will not occur in the future when making her AEC claim, and the duplicator may be able to update this list based on his observations, there exists some -GAEC simulation game such that a winning strategy of the spoiler translates into a winning strategy of the spoiler in the AEC simulation game.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "The requirement that a winning spoiler strategy translates into a winning spoiler strategy in an -GAEC game entails that AEC simulation games can prove the GFM property.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. [ -GAEC Simulation] If"
        },
        {
            "text": "A and B are language equivalent automata, B is good for MDPs, and A AEC-simulates B, then A is good for MDPs. Of course, for every AEC simulation, one first has to prove that winning strategies for the spoiler translate. We have used two simple variations of the AEC simulation games:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "accepting transition: the spoiler may only make her AEC claim when taking an accepting transition; this transition-and no other information-is stored, and the spoiler commits to-and commits only to-seeing this transition infinitely often;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "accepting transition with update: different to the accepting transition AEC simulation game, the duplicator can-but does not have to-update the stored accepting transition whenever the spoiler passes by an accepting transition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "Theorem 6. Both, the accepted transition and the accepted transition with update AEC simulation, can be used to establish the good for MDPs property.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "To show this, we describe the strategy translations in accordance with Corollary 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "Proof. In both cases, the translation of a winning strategy of the spoiler for the 1-GAEC simulation game are straightforward: The spoiler essentially follows her winning strategy from the 1-GAEC simulation game, with the extra rule that she will make her AEC claim to the duplicator on the first accepting transition on or after her AEC claim in the 1-GAEC claim. If the duplicator is allowed to update the transition, this information is ignored by the spoiler-she plays according to her winning strategy from the 1-GAEC simulation game. Naturally, the resulting play will comply with her 1-GAEC claim, and will thus also be winning for the-weaker-AEC claim made to the duplicator.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "We use AEC simulation to identify GFM automata among the automata produced (e.g., by SPOT [8] ) at the beginning of the transformation. Figure 3 shows an example for which the duplicator wins the AEC simulation game, but loses the ordinary simulation game. Candidates for automata to simulate are, e.g., the slim GFM B\u00fcchi automata and the limit deterministic B\u00fcchi automata discussed above.",
            "cite_spans": [
                {
                    "start": 90,
                    "end": 93,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [
                {
                    "start": 136,
                    "end": 144,
                    "text": "Figure 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Corollary 2. [AEC Simulation] If"
        },
        {
            "text": "As discussed, automata that simulate slim automata or SLDBAs are good for MDPs. This fact can be used to allow B\u00fcchi automata produced from general-purpose tools such as SPOT's [8] ltl2tgba rather than using specialized automata types. Automata produced by such tools are often smaller because such general-purpose tools are highly optimized and not restricted to producing slim or limit deterministic automata. Thus, one produces an arbitrary B\u00fcchi automaton using any available method, then transforms this automaton into a slim or limit deterministic automaton, and finally checks whether the original automaton simulates the generated one.",
            "cite_spans": [
                {
                    "start": 177,
                    "end": 180,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Size of General B\u00fcchi Automata for Probabilistic Model Checking"
        },
        {
            "text": "We have evaluated this idea on random LTL formulas produced by SPOT's tool randltl. We have set the tree size, which influences the size of the formulas, to 50, and have produced 1000 formulas with 4 atomic propositions each. We left the other values to their defaults. We have then used SPOT's ltl2tgba (version 2.7) to turn these formulas into non-generalized B\u00fcchi automata using default options. Finally, for each automaton, we have used our tool to check whether the automaton simulates a limit deterministic automaton that we produce from this automaton. For comparison, we have also used Owl's [29] tool ltl2ldba (version 19.06.03) to compute limit deterministic nongeneralized Buchi automata. We have also used the option of this tool to compute B\u00fcchi automata with a nondeterministic initial part. We used 10 minute timeouts.",
            "cite_spans": [
                {
                    "start": 601,
                    "end": 605,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Size of General B\u00fcchi Automata for Probabilistic Model Checking"
        },
        {
            "text": "Of these 1000 formulas, 315 can be transformed to deterministic B\u00fcchi automata. For an additional 103 other automata generated, standard simulation sufficed to show that they are GFM. For a further 11 of them, the simplest AEC simulation (the spoiler chooses an accepting transition to occur infinitely often) sufficed, and another 1 could be classed GFM by allowing the duplicator to update the transition. 501 automata turned out to be nonsimulatable and for 69 we did not get a decision due to a timeout.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Size of General B\u00fcchi Automata for Probabilistic Model Checking"
        },
        {
            "text": "For the LTL formulas for which ltl2tgba could not produce deterministic automata, but for which simulation could be shown, the number of states in the generated automata was often lower than the number of states in the automata produced by Owl's tools. On average, the number of states per automaton was \u224815.21 for SPOT's ltl2tgba; while for Owl's ltl2ldba it was \u224846.35. The extended version of this paper [13] contains more details about the evaluation. Let us consider the ratio between the size of automata produced by ltl2tgba and the size of semi-deterministic automata produced by Owl. The average of this number for all automata that are not deterministic and that can be simulated in some way is \u2248 1.0335. This means that on average, for these automata, the semi-deterministic automata are slightly smaller. If we take a look at the first 5 deciles depicted in Fig. 4 , we see that there is a large number of formulas for which ltl2tgba and Owl produce automata of the same size. For around 24.3478% of the cases, automata by SPOT are smaller than those produced by Owl (ratio < 1).",
            "cite_spans": [
                {
                    "start": 407,
                    "end": 411,
                    "text": "[13]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 870,
                    "end": 876,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Size of General B\u00fcchi Automata for Probabilistic Model Checking"
        },
        {
            "text": "SLDBAs have been used in [12] for model-free reinforcement learning of \u03c9-regular objectives. While the B\u00fcchi acceptance condition allows for a faithful translation of the objective to a scalar reward, the agent has to learn how to control the automaton's nondeterministic choices; that is, the agent has to learn when the SLDBA should cross from the initial component to the accepting component to produce a successful run of a behavior that satisfies the given objective.",
            "cite_spans": [
                {
                    "start": 25,
                    "end": 29,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "GFM Automata and Reinforcement Learning"
        },
        {
            "text": "Any GFM automaton with a B\u00fcchi acceptance condition can be used instead of an SLDBA in the approach of [12] . While in many cases SLDBAs work well, GFM automata that are not limit-deterministic may provide a significant advantage.",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 107,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "GFM Automata and Reinforcement Learning"
        },
        {
            "text": "Early during training, the agent relies on uniform random choices to discover policies that lead to successful episodes. This includes randomly resolving the automaton nondeterminism. If random choices are unlikely to produce successful runs of the automaton in case of behaviors that should be accepted, learning is hampered because good behaviors are not rewarded. Therefore, GFM automata that are more likely to accept under random choices will result in the agent learning more quickly. We have found the following properties of GFM automata to affect the agent's learning ability. Low branching degree. A low branching degree presents the agent with fewer alternatives, reducing the expected number of trials before the agent finds a good combination of choices. Consider an MDP and an automaton that require a specific sequence of k nondeterministic choices in order for the automaton to accept. If at each choice there are b equiprobable options, the correct sequence is obtained with probability b \u2212k .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GFM Automata and Reinforcement Learning"
        },
        {
            "text": "Cautiousness. An automaton that enables fewer nondeterministic choices for the same finite input word gives the agent fewer chances to choose wrong. The slim automata construction has the interesting property of \"collecting hints of acceptance\" before a nondeterministic choice is enabled because S has to be nonempty for a \u03b3 2,1 transition to be present and that requires going through at least one accepting transition. Forgiveness. Mistakes made in resolving nondeterminism may be irrecoverable. This is often true of SLDBAs meant for model checking, in which jumps are made to select a subformula to be eventually satisfied. However, general GFM automata, thanks also to their less constrained structure, may be constructed to \"forgive mistakes\" by giving more chances of picking a successful run. Figure 5 compares a typical SLDBA to an automaton that is not limit-deterministic and is not produced by the breakpoint construction, but is proved GFM by AEC simulation. This latter automaton has a nondeterministic choice in state q 0 on letter x \u2227 \u00acy that can be made an unbounded number of times. The agent may choose q 1 repeatedly even if eventually F G x is false and G F y is true. With the SLDBA, on the other hand, there is no room for error. A Case Study. We compared the effectiveness in learning to control a cart-pole model of three automata for the property (F G x) \u2228 (G F y) \u2227 G safe. The safety component of the objective is to keep the pole balanced and the cart on the track. The left two thirds of the track alternate between x and y at each step. The right third is always labeled y, but in order to reach it, the cart has to cross a barrier, with probability 1/3 of failing.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 802,
                    "end": 810,
                    "text": "Figure 5",
                    "ref_id": null
                }
            ],
            "section": "GFM Automata and Reinforcement Learning"
        },
        {
            "text": "The three automata are an SLDBA (4 states), a slim automaton (8 states), and a handcrafted forgiving automaton (4 states) similar to the one of Fig. 5 . Training of the continuous-statespace model employed PPO [28] as implemented in OpenAI Baselines [6] . Figure 6 shows the learning curves for the three automata averaged over ten runs. They underline the importance of choosing the right automaton in RL. Training parameters, more details on the model, and additional examples can be found in the extended version of this paper [13] .",
            "cite_spans": [
                {
                    "start": 210,
                    "end": 214,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 250,
                    "end": 253,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 530,
                    "end": 534,
                    "text": "[13]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 144,
                    "end": 150,
                    "text": "Fig. 5",
                    "ref_id": null
                },
                {
                    "start": 256,
                    "end": 264,
                    "text": "Figure 6",
                    "ref_id": null
                }
            ],
            "section": "GFM Automata and Reinforcement Learning"
        },
        {
            "text": "We have defined the class of automata that are good for MDPs-nondeterministic automata that can be used for the analysis of MDPs-and shown it to be closed under different simulation relations. This has multiple favorable implications for model checking and reinforcement learning. Closure under classic simulation opens a rich toolbox of statespace reduction techniques that come in handy to push the boundary of analysis techniques, while the more powerful (and more expensive) AEC simulation has promise to identify source automata that happen to be good for MDPs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "The wider class of GFM automata also shows promise: the slim automata we have defined to tame the branching degree while retaining the desirable B\u00fcchi condition for reinforcement learning are able to compete even against optimized SLDBAs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "As outlined in Section 5.2, a low branching degree, cautiousness, and forgiveness make automata particularly well-suited for learning. From a practical point of view, much of the power of this new approach is in harnessing the power of simulation for learning, and forgiveness is closely related to simulation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "The natural follow-up research is to tap the full potential of simulation-based statespace reduction instead of the limited version that we have implemented. Besides using this to get the statespace small-useful for model checking-we will use simulation to construct forgiving automata, which is promising for reinforcement learning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Datasets generated and analyzed during the current study are available at: https://doi.org/10.6084/m9.figshare.11882739 [35, 36] ",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 124,
                    "text": "[35,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 125,
                    "end": 128,
                    "text": "36]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "LTL to B\u00fcchi automata translation: Fast and more deterministic",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Babiak",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "K\u0159et\u00ednsk\u00fd",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Reh\u00e1k",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Strejcek",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Tools and Algorithms for the Construction and Analysis of Systems",
            "volume": "",
            "issn": "",
            "pages": "95--109",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Principles of Model Checking",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Ch",
                    "suffix": ""
                },
                {
                    "first": "J.-P",
                    "middle": [],
                    "last": "Baier",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Katoen",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Verifying temporal properties of finite-state probabilistic programs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Courcoubetis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yannakakis",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "338--345",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The complexity of probabilistic verification",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Courcoubetis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yannakakis",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "J. ACM",
            "volume": "42",
            "issn": "4",
            "pages": "857--907",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Formal Verification of Probabilistic Systems",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "De Alfaro",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Openai baselines",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Dhariwal",
                    "suffix": ""
                },
                {
                    "first": "Ch",
                    "middle": [],
                    "last": "Hesse",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Klimov",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Nichol",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Plappert",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Radford",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schulman",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sidor",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zhokhov",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Checking for language inclusion using simulation relations",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "L"
                    ],
                    "last": "Dill",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Hu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wong-Toi",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Computer Aided Verification",
            "volume": "575",
            "issn": "",
            "pages": "255--265",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Spot 2.0 -A framework for LTL and \u03c9-automata manipulation",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Duret-Lutz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lewkowicz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Fauchille",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Michaud",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Renault",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Automated Technology for Verification and Analysis",
            "volume": "",
            "issn": "",
            "pages": "122--129",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Fair simulation relations, parity games, and state space reduction for B\u00fcchi automata",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Etessami",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wilke",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "A"
                    ],
                    "last": "Schuller",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "SIAM J. Comput",
            "volume": "34",
            "issn": "5",
            "pages": "1159--1175",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Fair simulation minimization",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Gurumurthy",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bloem",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Somenzi",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Computer Aided Verification (CAV'02)",
            "volume": "",
            "issn": "",
            "pages": "610--623",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Lazy probabilistic model checking without determinisation",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "M"
                    ],
                    "last": "Hahn",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Turrini",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Concurrency Theory",
            "volume": "",
            "issn": "",
            "pages": "354--367",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Omega-regular objectives in model-free reinforcement learning",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "M"
                    ],
                    "last": "Hahn",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Perez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Somenzi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Trivedi",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wojtczak",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Tools and Algorithms for the Construction and Analysis of Systems",
            "volume": "",
            "issn": "",
            "pages": "395--412",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Fair simulation",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Henzinger",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kupferman",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Rajamani",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Concurrency Theory",
            "volume": "1243",
            "issn": "",
            "pages": "273--287",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Solving games without determinization",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "A"
                    ],
                    "last": "Henzinger",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Piterman",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Computer Science Logic",
            "volume": "4207",
            "issn": "",
            "pages": "394--409",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Optimal translation of LTL to limit deterministic automata",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kini",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Viswanathan",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Tools and Algorithms for the Construction and Analysis of Systems",
            "volume": "",
            "issn": "",
            "pages": "113--129",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Are good-for-games automata good for probabilistic model checking",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00fcller",
                    "suffix": ""
                },
                {
                    "first": "Ch",
                    "middle": [],
                    "last": "Baier",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kl\u00fcppelholz",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Language and Automata Theory and Applications",
            "volume": "",
            "issn": "",
            "pages": "453--465",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Are good-for-games automata good for probabilistic model checking",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "M\u00fcller",
                    "suffix": ""
                },
                {
                    "first": "Ch",
                    "middle": [],
                    "last": "Baier",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kl\u00fcppelholz",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Language and Automata Theory and Applications",
            "volume": "",
            "issn": "",
            "pages": "453--465",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Rabinizer 4: from LTL to your favourite deterministic automaton",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "K\u0159et\u00ednsk\u00fd",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Meggendorfer",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sickert",
                    "suffix": ""
                },
                {
                    "first": "Ch",
                    "middle": [],
                    "last": "Ziegler",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Computer Aided Verification",
            "volume": "",
            "issn": "",
            "pages": "567--577",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Owl: A library for \u03c9-words, automata, and LTL",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "K\u0159et\u00ednsk\u00fd",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Meggendorfer",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sickert",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Automated Technology for Verification and Analysis",
            "volume": "",
            "issn": "",
            "pages": "543--550",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "An algebraic definition of simulation between programs",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Milner",
                    "suffix": ""
                }
            ],
            "year": 1971,
            "venue": "Int. Joint Conf. on Artificial Intelligence",
            "volume": "",
            "issn": "",
            "pages": "481--489",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "From deterministic B\u00fcchi and Streett automata to deterministic parity automata",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Piterman",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Logical Methods in Computer Science",
            "volume": "3",
            "issn": "3",
            "pages": "1--21",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Markov Decision Processes: Discrete Stochastic Dynamic Programming",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Puterman",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Complexity of Automata on Infinite Objects",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Safra",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Beyond hyper-minimisation-minimising DBAs and DPAs is NP-complete",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Foundations of Software Technology and Theoretical Computer Science, FSTTCS",
            "volume": "",
            "issn": "",
            "pages": "400--411",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Tight bounds for the determinisation and complementation of generalised B\u00fcchi automata",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Varghese",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Automated Technology for Verification and Analysis",
            "volume": "",
            "issn": "",
            "pages": "42--56",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Determinising parity automata",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Varghese",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Mathematical Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "486--498",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Proximal policy optimization algorithms",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schulman",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Wolski",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Dhariwal",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Radford",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Klimov",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Limit-deterministic B\u00fcchi automata for linear temporal logic",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sickert",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Esparza",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Jaax",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "K\u0159et\u00ednsk\u00fd",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Computer Aided Verification",
            "volume": "9780",
            "issn": "",
            "pages": "312--332",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "MoChiBA: Probabilistic LTL model checking using limitdeterministic B\u00fcchi automata",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sickert",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "K\u0159et\u00ednsk\u00fd",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Automated Technology for Verification and Analysis",
            "volume": "",
            "issn": "",
            "pages": "130--137",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Efficient B\u00fcchi automata from LTL formulae",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Somenzi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bloem",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Computer Aided Verification",
            "volume": "",
            "issn": "",
            "pages": "248--263",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "GOAL for games, omega-automata, and logics",
            "authors": [
                {
                    "first": "M.-H",
                    "middle": [],
                    "last": "Tsai",
                    "suffix": ""
                },
                {
                    "first": "Y.-K",
                    "middle": [],
                    "last": "Tsay",
                    "suffix": ""
                },
                {
                    "first": "Y.-S",
                    "middle": [],
                    "last": "Hwang",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Computer Aided Verification",
            "volume": "",
            "issn": "",
            "pages": "883--889",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Automatic verification of probabilistic concurrent finite state programs",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "Y"
                    ],
                    "last": "Vardi",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "327--338",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Good-for-MDPs Automata for Probabilistic Analysis and Reinforcement Learning Figshare",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "M"
                    ],
                    "last": "Hahn",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Perez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Somenzi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Trivedi",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wojtczak",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.6084/m9.figshare.11882739"
                ]
            }
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made. The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "PSem M A (s, \u00b5)= Pr \u00b5 s {r\u2208\u2126 \u00b5 s : L(r)\u2208L A } and PSem M A (s)= sup \u00b5\u2208\u03a0 M PSem M A (s, \u00b5) . When using automata for the analysis of MDPs, we need a syntactic variant of the acceptance condition. Given an MDP M = (S, A, T, \u03a3, L) with initial state s 0 \u2208 S and automaton A = \u03a3, Q, q 0 , \u2206, \u0393 , the product M\u00d7A=(S\u00d7Q, (s 0 , q 0 ), A\u00d7Q, T \u00d7 , \u0393 \u00d7 ) is an MDP [17] augmented with an initial state (s 0 , q 0 ) and accepting transitions \u0393 \u00d7 . The (partial) function T \u00d7 : (S \u00d7 Q) \u00d7 (A \u00d7 Q) \u2212 D(S \u00d7 Q) is defined by T \u00d7 ((s, q), (a, q ))((s , q )) = T (s, a)(s ) if (q, L(s, a, s ), q ) \u2208 \u2206 undefined otherwise.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "An NBA, which accepts all words over the alphabet {a, b}, that is not good for MDPs. The dotted transitions are accepting. For the Markov chain on the right where the probability of a and b is 1 2 , the chance that the automaton makes infinitely many correct predictions is 0 Definition 1 (GFM automata). An automaton A is good for MDPs if, for all MDPs M, PSyn M A (s 0 ) = PSem M A (s 0 ) holds, where s 0 is the initial state of M.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "An NBA for G F a (in the upper right corner) together with an SLDBA and a slim NBA constructed from it. The SLDBA and the slim NBA are shown sharing their common part. State {0, 1}, produced by the subset construction, is the initial state of the SLDBA, while state ({0, 1}, \u2205)-the initial state of the breakpoint construction-is the initial state of the slim NBA. States ({1}, \u2205) and ({0}, \u2205) are states of the breakpoint construction that only belong to the SLDBA because they are not reachable from ({0, 1}, \u2205). The transitions out of {0, 1}, except the self loop, belong to \u2206SB. The dashed-line transition from ({0, 1}, {0}) belongs to \u03b32,1",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "They will eventually reach a leaf strongly connected component (LSCC) in the Markov chain. -If they have reached a LSCC L, then, for all \u2208 N, all sequences of transitions of length in L occur infinitely often, and no other sequence of length occurs.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Automata A (left) and B (right) for \u03d5 = (G F a) \u2228 (G F b). The dotted transitions are accepting. The NBA A does not simulate the DBA B: B can play a's until A moves to either the state on the left, or the state on the right. B then wins by henceforth playing only b's or only a's. However, A is good for MDPs. It wins the AEC simulation game by waiting until an AEC is reached (by B), and then check if a or b occurs infinitely often in this AEC. Based on this knowledge, A can make its decision. This can be shown by AEC simulation if B has to provide sufficient information, such as a list of transitions-or even a list of letters-that occur infinitely often. The amount of information the spoiler has to provide determines the strength of the AEC simulation used. If, e.g., B only has to reveal one accepting transition of the end-component, then it can select an end-component where the revealed transition is (b1, c, b0), which does not provide sufficient information. Whereas, if the duplicator is allowed to update the transition, then the duplicator wins by updating the recorded transition to the next a or b transition",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Deciles ratio ltl2tgba /semi-deterministic automata",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Two GFM automata for (F G x) \u2228 (G F y). SLDBA (left), and forgiving (right) Learning curves",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}