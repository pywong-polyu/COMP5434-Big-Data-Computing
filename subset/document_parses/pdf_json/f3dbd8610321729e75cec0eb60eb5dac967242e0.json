{"paper_id": "f3dbd8610321729e75cec0eb60eb5dac967242e0", "metadata": {"title": "Boolean Monadic Recursive Schemes as a Logical Characterization of the Subsequential Functions", "authors": [{"first": "Siddharth", "middle": [], "last": "Bhaskar", "suffix": "", "affiliation": {"laboratory": "", "institution": "K\u00f8benhavns Universitet", "location": {"postCode": "2100", "settlement": "Copenhagen", "country": "Denmark"}}, "email": "sbhaskar@di.ku.dk"}, {"first": "Jane", "middle": [], "last": "Chandlee", "suffix": "", "affiliation": {"laboratory": "", "institution": "Haverford College", "location": {"settlement": "Haverford", "region": "PA", "country": "USA"}}, "email": "jchandlee@haverford.edu"}, {"first": "Adam", "middle": [], "last": "Jardine", "suffix": "", "affiliation": {"laboratory": "", "institution": "Rutgers University", "location": {"settlement": "New Brunswick", "region": "NJ", "country": "USA"}}, "email": "adam.jardine@rutgers.edu"}, {"first": "Christopher", "middle": [], "last": "Oakden", "suffix": "", "affiliation": {"laboratory": "", "institution": "Rutgers University", "location": {"settlement": "New Brunswick", "region": "NJ", "country": "USA"}}, "email": "chris.oakden@rutgers.edu"}]}, "abstract": [{"text": "This paper defines boolean monadic recursive schemes (BMRSs), a restriction on recursive programs, and shows that when interpreted as transductions on strings they describe exactly the subsequential functions. We discuss how this new result furthers the study of the connections between logic, formal languages and functions, and automata.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "A fundamental result in the connection between automata and logic is that of Elgot [7] , B\u00fcchi [1] , and Trakhtenbrot [21] , which states that sentences in monadic second-order (MSO) logic describe exactly the same class of formal languages as finite-state acceptors (FSAs); namely, the regular class of languages. Further work established many connections between restrictions on MSO, restrictions on FSAs, and sub-classes of the regular languages [14, 20] .", "cite_spans": [{"start": 83, "end": 86, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 95, "end": 98, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 118, "end": 122, "text": "[21]", "ref_id": "BIBREF21"}, {"start": 449, "end": 453, "text": "[14,", "ref_id": "BIBREF14"}, {"start": 454, "end": 457, "text": "20]", "ref_id": "BIBREF20"}], "ref_spans": [], "section": "Introduction"}, {"text": "More recently, a major result of Engelfriet and Hoogeboom shows the relationship between MSO and regular functions on strings-that is, exactly those functions described by two-way finite state transducers [9] . Essentially, string functions can be described by a MSO interpretation in which the binary successor relation and alphabet labels of the output string are defined by a series of binary and unary predicates in the MSO logic of the input strings, relativized over a copy set which allows the output string to be larger than the input string. Each element in the output string is thus a copy of an index in the input string, and the character it receives and where it is in the order is determined by which predicates are satisfied by the input string at that index. This technique has allowed a rich study of the relationship between sub-MSO logics and restrictions on finite-state transducers [10, 11] parallel to the earlier work on logic and finite-state automata and languages.", "cite_spans": [{"start": 205, "end": 208, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 903, "end": 907, "text": "[10,", "ref_id": "BIBREF9"}, {"start": 908, "end": 911, "text": "11]", "ref_id": "BIBREF10"}], "ref_spans": [], "section": "Introduction"}, {"text": "However, there remain some interesting classes for which no logical characterization has been previously established. In this paper, we investigate the subsequential functions, a strict sub-class of the rational functions, or those that are describable by one-way finite-state transducers. 1 While a weak class, there are a number of reasons why the subsequential class is a worthy object of study. From a theoretical perspective, the subsequential functions admit an abstract characterization that generalizes the Myhill-Nerode equivalence classes of regular languages [19] . This property makes the subsequential functions learnable from a sample of positive data [18] . In terms of practical applications, the subsequential functions have applications to speech and language processing [16] , and form a hypothesis for the computational upper bound of functions in certain domains of natural language phonology [12, 13] .", "cite_spans": [{"start": 290, "end": 291, "text": "1", "ref_id": "BIBREF0"}, {"start": 570, "end": 574, "text": "[19]", "ref_id": "BIBREF19"}, {"start": 666, "end": 670, "text": "[18]", "ref_id": "BIBREF18"}, {"start": 789, "end": 793, "text": "[16]", "ref_id": "BIBREF16"}, {"start": 914, "end": 918, "text": "[12,", "ref_id": "BIBREF11"}, {"start": 919, "end": 922, "text": "13]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Introduction"}, {"text": "In this paper, we define boolean monadic recursive schemes (BMRSs), a restriction on the general notion of a recursive program scheme in the sense of Moschovakis [17] . As indicated by the name, these schemes recursively define a series of unary functions that take as inputs indices from a string and return a boolean value. A system of BMRS functions can be used to express a logical transduction in the sense of Engelfriet and Hoogeboom by assigning these functions to symbols in an output alphabet. An output string then consists of the characters whose functions are true at each index in the input string. We show that string transductions defined by BMRS transductions with predecessor or successor describe exactly the left-and right-subsequential functions, respectively. This is an entirely novel result; the closest result in the literature is that of [6] , who give a fragment of least-fixed point logic that captures strict subsets of the left-and right-subsequential functions. As we discuss at the end of the paper, the current result allows for further study of the connections among subclasses of the subsequential functions and of rational functions in general.", "cite_spans": [{"start": 162, "end": 166, "text": "[17]", "ref_id": "BIBREF17"}, {"start": 863, "end": 866, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Introduction"}, {"text": "This paper is structured as follows. Sections 2 and 3 establish the notation and definitions for strings, subsequential functions, and subsequential transducers. Section 4 establishes BMRSs and BMRS transductions, and Sect. 5 shows the equivalence between BMRS transductions and subsequential functions. Sections 6 and 7 discuss the implications of this result and conclude the paper.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "An alphabet \u03a3 is a finite set of symbols; let \u03a3 * be all strings over \u03a3, including \u03bb, the empty string. We will frequently make use of special left and right string boundary symbols , \u2208 \u03a3. We denote by", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "For a string w, |w| indicates the length of w. We write w r for the reversal of w.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "A string u is a prefix of w, written u w, iff w = uv for some string v. For a set L \u2286 \u03a3 * of strings let the common prefixes be comprefs(L) = w\u2208L {u | u w}. The longest common prefix of L is the maximum element in comprefs(L): lcp(L) = w \u2208 comprefs(L) s.t. for all v \u2208 comprefs(L), |v| \u2264 |w|.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "We first define the subsequential functions based on the notion of tails [16, 19] . Let f : \u03a3 * \u2192 \u0393 * be an arbitrary function and f p (x) = lcp({f (xu) | u \u2208 \u03a3 * }). Then of course, for every u, f p (x) f (xu). Now let the tail function f x (u) be defined as v such that f p (x)v = f (xu). This function represents the tails of x. This allows us to define the subsequential functions as follows.", "cite_spans": [{"start": 73, "end": 77, "text": "[16,", "ref_id": "BIBREF16"}, {"start": 78, "end": 81, "text": "19]", "ref_id": "BIBREF19"}], "ref_spans": [], "section": "Abstract Definition"}, {"text": "is left-subsequential. Note that for any x = a n for an even n, f p (x) = (abb) n/2 , and so f x = f . For any y = a n for an odd n, then f p (y) = (abb) (n\u22121)/2 a, and so f y is the function f y (a m ) = d if m = 0; bb \u00b7 f (a m\u22121 ) otherwise. Then f is describable by these two tail functions {f x , f y }.", "cite_spans": [], "ref_spans": [], "section": "Definition 1 (Left-subsequential). A function"}, {"text": "Conversely, the function g defined as g(a n ) = ca n\u22121 if n is even; da n\u22121 if n is odd,", "cite_spans": [], "ref_spans": [], "section": "Definition 1 (Left-subsequential). A function"}, {"text": "is not left-subsequential. Note that for any x = a n , g p (x) = \u03bb. This is because {g(xu) | u \u2208 \u03a3 * } includes both ca i and da j for some i and j. Because g x (u) is defined as v such that g p (x)v = g(xu), and because g p (x) = \u03bb, g x (u) = g(xu).", "cite_spans": [], "ref_spans": [], "section": "Definition 1 (Left-subsequential). A function"}, {"text": "The consequence of this is that for any x = a n and y = a m for a distinct m = n, for any u, g x (u) = g y (u). Thus the set of tails functions for g is an infinite set", "cite_spans": [], "ref_spans": [], "section": "Definition 1 (Left-subsequential). A function"}, {"text": "The right-subsequential functions are those that are the mirror image of some left-subsequential function.", "cite_spans": [], "ref_spans": [], "section": "Definition 1 (Left-subsequential). A function"}, {"text": "A function f is right-subsequential iff there is some left-subsequential function f such that for any string in the domain of f , f (w) = (f (w r )) r .", "cite_spans": [], "ref_spans": [], "section": "Definition 2 (Right-subsequential)."}, {"text": "We leave it to the reader to show that g is right-subsequential. Thus, the subsequential functions are those functions that are either left-or rightsubsequential.", "cite_spans": [], "ref_spans": [], "section": "Definition 2 (Right-subsequential)."}, {"text": "A (left-)subsequential finite-state transducer (SFST) for an input alphabet \u03a3 and an output alphabet \u0393 is a tuple", "cite_spans": [], "ref_spans": [], "section": "Subsequential Finite-State Transducers"}, {"text": "and \u03c9 : Q f \u2192 \u0393 * is the final function. We define the reflexive, transitive closure of \u03b4 and o as \u03b4 * : Q \u00d7 \u03a3 * \u2192 Q and o * : Q \u00d7 \u03a3 * \u2192 \u0393 * in the usual way.", "cite_spans": [], "ref_spans": [], "section": "Subsequential Finite-State Transducers"}, {"text": "The semantics of a SFST is a transduction t(T ) defined as follows ", "cite_spans": [], "ref_spans": [], "section": "Subsequential Finite-State Transducers"}, {"text": "For more properties of the subsequential functions and their application to speech and language processing see [16] .", "cite_spans": [{"start": 111, "end": 115, "text": "[16]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Theorem 2 ([16]). Both the left-and right-subsequential functions are a strict subset of the rational functions."}, {"text": "We identify strings in \u03a3 with structures of the form S = D; \u03c3 1 , \u03c3 2 , ..., \u03c3 n , p, s where the domain D is the set of indices; for each character \u03c3 \u2208 \u03a3 , we also write \u03c3 i for the unary relation \u03c3 i \u2286 D selecting the indices of that character (and we assume that the least and greatest indices contain the characters and , respectively); p is the predecessor function on indices (fixing the least index); and s is the successor function on indices (fixing the greatest index). As an abbreviatory convention we use x \u2212 i for i applications of p to x, and likewise x + i for i applications of s. (E.g. x \u2212 2 is the same as p(p(x))).", "cite_spans": [], "ref_spans": [], "section": "Syntax and Semantics"}, {"text": "Boolean monadic recursive schemes are simple programs that operate over such string structures. They are a particular case of the recursive programs of Moschovakis [17] . We briefly review the syntax and semantics of such recursive programs in this particular signature, then impose (Definition 3) the pertinent syntactic restriction to obtain BMRSs.", "cite_spans": [{"start": 164, "end": 168, "text": "[17]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Syntax and Semantics"}, {"text": "We have two types of data: boolean values and string indices. We have two countably infinite set of variables: (index) variables X, which range over string indices, and recursive function names F. Each recursive function name f \u2208 F comes with an arity n \u2208 N and an output type, either \"index\" or \"boolean\". Function names f of arity n and type s range over n-ary functions from string indices to s.", "cite_spans": [], "ref_spans": [], "section": "Data and Variables."}, {"text": "Terms. Terms are given by the following grammar", "cite_spans": [], "ref_spans": [], "section": "Data and Variables."}, {"text": "Terms inherit \"boolean\" or \"index\" types inductively from their variables and function names, and term formation is subject to the usual typing rules: for", "cite_spans": [], "ref_spans": [], "section": "Data and Variables."}, {"text": ", the type of each T I must be \"index\"; for T 1 = T 2 , the types of T 1 and T 2 must be the same; for and \"if T 1 then T 2 else T 3 ,\" then the type of T 1 must be \"boolean,\" and the types of T 2 and T 3 must agree.", "cite_spans": [], "ref_spans": [], "section": "Data and Variables."}, {"text": "where T i is a term whose type agrees with the output type of f i , every variable that occurs in T i is some x ij , and every function name that occurs in T i is some f j . Syntactically, we will write", "cite_spans": [], "ref_spans": [], "section": "Data and Variables."}, {"text": "to indicate that the above properties hold.", "cite_spans": [], "ref_spans": [], "section": "Data and Variables."}, {"text": "Semantics. We impose the usual least fixed-point semantics on recursive programs. Briefly; over a given string, terms denote functionals which are monotone relative to extension relation on partial functions. We define the semantics of a program to be the first coordinatef 1 of the least fixed-point ( [17] .", "cite_spans": [{"start": 303, "end": 307, "text": "[17]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Data and Variables."}, {"text": "Boolean monadic recursive schemes compute (partial) functions from string indices to booleans, or equivalently (partial) subsets of indices. For example, the following scheme detects exactly those indices with some preceding b.", "cite_spans": [], "ref_spans": [], "section": "Definition 3. A boolean monadic recursive scheme (BMRS) is a program in which the arity of every function name in the program is one, and the output type of every function name in the program is \"boolean.\""}, {"text": "We can define a string transduction t : \u03a3 * \u2192 \u0393 * via a BMRS interpretation as follows. Fix a copy set C = {1, . . . , m} and for n = |\u0393 | consider a system T of equations with a set of recursive functions f = (\u03b3 1 1 , . . . , \u03b3 m 1 , \u03b3 1 2 , . . . , \u03b3 m n , f 1 , . . . , f k ); that is, with a function \u03b3 c for each \u03b3 \u2208 \u0393 and c \u2208 C.", "cite_spans": [], "ref_spans": [], "section": "Schemes as Definitions of String Transductions"}, {"text": "Following the definition of logical string transductions [9, 10] , the semantics of T given an input model S with a universe D as follows. For each d \u2208 D, we output a copy d c of d if and only if there is exactly one \u03b3 \u2208 \u0393 for c \u2208 C such that \u03b3 c (x) \u2208 T evaluates to when x is mapped to d. We fix the order of these output copies to be derived from C and the order on D induced by the predecessor function p: for any two copies d c and d e of a single index d, d c < d e iff c < e in the order on C, and for any copies d c i and d e j for distinct input indices", "cite_spans": [{"start": 57, "end": 60, "text": "[9,", "ref_id": "BIBREF8"}, {"start": 61, "end": 64, "text": "10]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Schemes as Definitions of String Transductions"}, {"text": "the order on the indices in S. We fix the order due to the relation between order-preserving logical transductions and one-tape finite-state transducers [10] .", "cite_spans": [{"start": 153, "end": 157, "text": "[10]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Schemes as Definitions of String Transductions"}, {"text": "This semantics of T thus defines a string transduction t = t(T ) where for a string w \u2208 \u03a3 * of length , t(w) = u 0 u 1 ...u u +1 , where each u i = \u03b3 1 ...\u03b3 r if and only if for each \u03b3 j , 1 \u2264 j \u2264 r, \u03b3 j is the unique symbol in \u0393 for j \u2208 C such that \u03b3 j j (x) evaluates to when x is assigned to i in the structure of w . An example is given in Example 2.", "cite_spans": [], "ref_spans": [], "section": "Schemes as Definitions of String Transductions"}, {"text": "To describe partial functions we can add to f a special function def(x) and specify the semantics of t to state that t(w) is defined iff def(x) evaluates to for element in w.", "cite_spans": [], "ref_spans": [], "section": "Schemes as Definitions of String Transductions"}, {"text": "The following is a BMRS definition of f from Example 1 using strings models from \u03a3 * . The copy set is C = {1, 2}.", "cite_spans": [], "ref_spans": [], "section": "Example 2."}, {"text": "The following shows how this maps aaaaa to abbabbad: We define two important variants of BMRS logic. For BMRS systems of equations over a set of recursive function symbols f, we say a system of equations T \u2208 BMRS p iff it contains no terms of the form s(T 1 ) for any term T 1 , and likewise T \u2208 BMRS s iff it contains no terms of the form p(T 1 ) for any term T 1 . We define these as they fix the 'direction' of the recursion, which will be important in connecting them to the left-and right-subsequential functions.", "cite_spans": [], "ref_spans": [], "section": "Example 2."}, {"text": "We only want to consider BMRS that compute well-defined transductions. Therefore, we require that for each string w \u2208 \u03a3 * , each index i of w, and each c \u2208 C and \u03b3 \u2208 \u0393 , every function \u03b3 c (i) converges, and furthermore for each c, there is a unique \u03b3 such that \u03b3 c (i) = .", "cite_spans": [], "ref_spans": [], "section": "Convergence and Well-Definedness"}, {"text": "This is of course a semantic property, which is not an issue as far as the following proofs of extensional equivalence are concerned. However, there is an effective way of transforming a BMRS T into a BMRS T such that T computes a well-defined transduction, and agrees with T on inputs where T is well-defined. 2 Therefore, considering partially-defined schemata do not increase the computational power in any appreciable way.", "cite_spans": [{"start": 311, "end": 312, "text": "2", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Convergence and Well-Definedness"}, {"text": "For a left-subsequential function f : \u03a3 * \u2192 \u0393 * , we can define an equivalent function in BMRS p over models of strings in \u03a3 * . We do this by giving a construction of its SFST.", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "For an SFST T = Q, q 0 , Q f , \u03b4, o, \u03c9 , where Q is the set of k states, we construct a BMRS p system of equations T over the set of recursive functions f = (\u03b3 1 1 , ..., \u03b3 m 1 , \u03b3 1 2 , ..., \u03b3 m n , q 0 , . . . , q k\u22121 ), where n = |\u0393 | and m is the maximum length of any output of o or \u03c9. The definitions in T are fixed as follows. First, we define q 0 , . . . , q k\u22121 to parallel the transition function \u03b4. For each state q \u2208 Q we define its corresponding recursive function symbol q as", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "where q 1 , ..., q is the set of states reaching q; that is, the set of states such that for each q i , \u03b4(q i , \u03c3 i ) = q. For the start state we instead set the final 'else' statement to x is the minimum element in the string; i.e. that (p(x)).", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "We then define the set of functions \u03b3 1 1 , ..., \u03b3 m 1 , \u03b3 1 2 , ..., \u03b3 m n representing the symbols in the output strings to parallel the output and final functions o and \u03c9:", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "for all states q i whose output on \u03c3 i has \u03b3 as the cth symbol. That is, for each", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "If there are no such states we set \u03b3 c (x) = \u22a5.", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "Finally, in cases when Q f Q we can, via the definition of the semantics of BMRS transductions for partial functions, we set the equation for the special function def(x) determining when the function is defined as", "cite_spans": [], "ref_spans": [], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "An example definition modeling the SFST in Fig. 1 , and an example computation for an input string aaaa is given in Table 1 . Table 1 . A BMRS transduction for the SFST in Fig. 1 (left) and an example derivation (right). The rows for a 2 (x), c 2 (x), and d 2 (x) have been omitted.", "cite_spans": [], "ref_spans": [{"start": 43, "end": 49, "text": "Fig. 1", "ref_id": "FIGREF1"}, {"start": 116, "end": 123, "text": "Table 1", "ref_id": null}, {"start": 126, "end": 133, "text": "Table 1", "ref_id": null}, {"start": 172, "end": 178, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Subsequential Functions Are BMRS-Definable"}, {"text": "Proof. It is sufficient to show that the above construction creates from any SFST T a BMRS p system of equations T whose transduction t(T ) = t(T ). Consider any string in w = \u03c3 1 ...\u03c3 n \u2208 \u03a3 * of length n; we refer to the positions in w as their indices 0, 1, ..., n + 1. From the construction q 0 (x) is always true of position 1; likewise by definition T is in state q 0 at position 1. By definition (2) for T , whenever T is in state q i , reads position i, and \u03b4(q i , \u03c3 i ) = q j , then q j (x) in T evaluates to for i+1, because 'if q i (x) then \u03c3 i (x)' is in the definition for q j (x). By induction on \u03b4 * it is thus the case that whenever T is in state q i at position i, position i satisfies q i (x) in T .", "cite_spans": [], "ref_spans": [], "section": "Lemma 1. Any left-subsequential function has some BMRS p definition."}, {"text": "Let o(q i , \u03c3 i ) = u = \u03b3 1 ...\u03b3 m for any position i in w. By (3), for each \u03b3 j there is a function \u03b3 j j (x) whose definition includes 'if q i (x) then \u03c3 i (x)'. Because i satisfies q i (x) in T , then each jth copy of i will be \u03b3 j , and so the output of i under T will also be \u03b3 1 ...\u03b3 j = u. This also holds for the output function \u03c9.", "cite_spans": [], "ref_spans": [], "section": "Lemma 1. Any left-subsequential function has some BMRS p definition."}, {"text": "Thus for any w, t(T )(w) = w implies that t(T )(w) = w , and it is not hard to show that the reverse holds.", "cite_spans": [], "ref_spans": [], "section": "Lemma 1. Any left-subsequential function has some BMRS p definition."}, {"text": "The following lemma shows that the same is true for right-subsequential functions and BMRS s , which follows by the same logic as for Lemma 1.", "cite_spans": [], "ref_spans": [], "section": "Lemma 1. Any left-subsequential function has some BMRS p definition."}, {"text": "Any right-subsequential function has some BMRS s definition.", "cite_spans": [], "ref_spans": [], "section": "Lemma 2."}, {"text": "To show the converse, we show that for any well-defined BMRS p transduction T , for f = t(T ), the sets {f x | x \u2208 \u03a3 * } are finite. For a copy set C = {1, ..., m} and for n = |\u0393 | consider a system T of equations with a set of recursive functions", "cite_spans": [], "ref_spans": [], "section": "BMRS p and BMRS s -Definable String Functions Are Subsequential"}, {"text": "let F be the set of function names appearing in f, and let be the maximum number such that x \u2212 appears as a term in T . First, define sats(w, i) = {f \u2208 T | f(i) = in w} to identify the functions in T true in w at index i. The following fact will be used throughout this proof.", "cite_spans": [], "ref_spans": [], "section": "BMRS p and BMRS s -Definable String Functions Are Subsequential"}, {"text": "For any f \u2208 F and string w \u2208 \u03a3 * , the value of f(i) can be calculated from the sets F , F \u22121 , ..., F 1 , where for each 1 \u2264 j \u2264 , F j = sats(w, i\u2212j).", "cite_spans": [], "ref_spans": [], "section": "Remark 1."}, {"text": "Proof. Let f(x) = T f be the equation for f in T . By the definition of T , is the maximum number of times the p function can be applied to a variable in any term in T . Thus, for any function g \u2208 F , T f can only contain g(x\u2212h) for at most some h \u2264 . Thus, in terms of the semantics of f(i) for some index i in w, the value of g(i \u2212 h) can be determined by whether g is in F h . The remainder of the semantics of f(i) then follows from the definition of the semantics of BMRSs.", "cite_spans": [], "ref_spans": [], "section": "Remark 1."}, {"text": "The following states that sats(w, i) holds no matter how w is extended. This follows directly from Remark 1.", "cite_spans": [], "ref_spans": [], "section": "Remark 1."}, {"text": "For any w, v \u2208 \u03a3 * , sats(w, i) = sats(wv, i).", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "Recall that among the functions in F there is a function \u03b3 c \u2208 F for each \u03b3 \u2208 \u0393 and c \u2208 C. Recall also that the semantics of BMRS transductions produces an output string u i at each input index i such that \u03b3 is the cth position in u i if and only if \u03b3 c (i) evaluates to . (The stipulation that there is only one such \u03b3 c ensures that only a single output string is produced for each index). To refer to this string we define out(w, i) = \u03b3 1 \u03b3 2 ...\u03b3 h where each \u03b3 j \u2208 sats(w, i).", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "Then let out T (w) = out(w, 1)\u00b7out(w, 2)\u00b7...\u00b7out(w, last(w)), where last(w) indicates the final index in w.", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "We can now connect these facts to the string function f = t(T ) described by T . Recall the technicality that the domain of f is \u03a3 * but T is defined over string models of the form \u03a3 * . First, the above allows us to make the following assertion about the relationship between out T and f p .", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "Proof. This follows directly from Remark 2: the output at each index at w will be constant no matter how w is extended. Thus, f p (w) at least includes out T ( w).", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "The final piece is to define when two strings w and v are equivalent with respect to T , which we then show that they are equivalent with respect to f ; that is, that f w = f v . Intuitively, w and v are equivalent if their final indices satisfy exactly the same functions in F . Formally,", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "Proof. For any sequence of indices, there are at most (2 |F | ) possible sequences of subsets of F that they satisfy.", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "The following states the key implication that equivalence with respect to T implies equivalence with respect to f .", "cite_spans": [], "ref_spans": [], "section": "Remark 2."}, {"text": "Proof. First, for any \u03c3 \u2208 \u03a3 , out( w\u03c3, last( w\u03c3)) = out( v\u03c3, last( v\u03c3)). In other words, the string output at any additional \u03c3 following w and v is the same. This follows from Remark 1 and the fact that the final indices in w and v satisfy the same sets of functions in F .", "cite_spans": [], "ref_spans": [], "section": "Lemma 3. For any two strings"}, {"text": "For any string u \u2208 \u03a3 * , then, by induction on the length of u it is clear that f (wu) = out T ( w)u and f (vu) = out T ( v)u for the same u \u2208 \u0393 * . From this and Remark 3, we know that f p (w) = out T ( w)u 1 and f p (v) = out T ( v)u 1 for the same u 1 \u2208 \u0393 * . Clearly then for any u \u2208 \u03a3 * , f (wu) = f p (w)u and f (vu) = f p (v)u and so by the definition of f w and f v , f w = f v .", "cite_spans": [], "ref_spans": [], "section": "Lemma 3. For any two strings"}, {"text": "Proof. The set {f x | x \u2208 \u03a3 * } is finite: from Remark 4, \u2261 T induces a finite partition on \u03a3 * , and by Lemma 3, for any two strings w, v in the same block in this partition, f w = f v . Thus there can only be finitely many such functions f x .", "cite_spans": [], "ref_spans": [], "section": "Lemma 4. For any BMRS p transduction T , the function f = t(T ) is a leftsubsequential function."}, {"text": "We omit the proof for the following parallel lemma for BMRS s .", "cite_spans": [], "ref_spans": [], "section": "Lemma 4. For any BMRS p transduction T , the function f = t(T ) is a leftsubsequential function."}, {"text": "For any BMRS s transduction T , the function f = t(T ) is a rightsubsequential function.", "cite_spans": [], "ref_spans": [], "section": "Lemma 5."}, {"text": "We now can give the central result of the paper. Theorem 3. BMRS p (respectively, BMRS s ) transductions are equivalent to the left-subsequential (resp., right-subsequential) functions.", "cite_spans": [], "ref_spans": [], "section": "Main Theorem"}, {"text": "Proof. From Lemmas 1, 2, 4, and 5.", "cite_spans": [], "ref_spans": [], "section": "Main Theorem"}, {"text": "The above result provides the first logical characterization of the subsequential functions. A consequence of this is we can get a better understanding of subclasses of the subsequential functions. We sketch two here.", "cite_spans": [], "ref_spans": [], "section": "Discussion"}, {"text": "First, the input strictly local (ISL) functions are a strict subset of the subsequential class for which the output string is computed by referencing a bounded window in the input string only [2, 3] . Briefly, a function is ISL iff there is some number k such that for any two strings w and v that share a k \u2212 1 suffix, f w = f v . This class has attractive learnability properties [3] and empirically is relevant to processes in natural language phonology [5] . We omit a proof, but it is almost certainly the case that a BMRS system of equations T corresponds to an ISL function iff for each function symbol f \u2208 f, the definition of f contains no recursive function calls. This is further interesting in that it suggests that any left-subsequential function f has a ISL counterpart whose input alphabet subsumes the recursive function symbols in the BMRS p definition of f . 3 This is strongly reminiscent of the old result that any regular language is the homomorphism of a strictly 2-local language [15] .", "cite_spans": [{"start": 192, "end": 195, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 196, "end": 198, "text": "3]", "ref_id": "BIBREF2"}, {"start": 382, "end": 385, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 457, "end": 460, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 1003, "end": 1007, "text": "[15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Discussion"}, {"text": "A sister class to the ISL functions is the output strictly local (OSL) functions, which are those subsequential functions which compute the output string by referencing the current input and a bounded window in the output [2, 4] . They are divided into two classes the left-and right-OSL functions depending on whether the string is read from the left or right. We conjecture that a BMRS system of equations T corresponds to an OSL function iff for each function f i \u2208 f corresponding to \u03b3 c \u2208 \u0393 , for any non recursively-defined \u03c3(t) (\u03c3 \u2208 \u03a3), then t = x. BMRS p systems of equations of this type correspond to left-OSL functions, while BMRS s systems of this type correspond to right-OSL functions.", "cite_spans": [{"start": 222, "end": 225, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 226, "end": 228, "text": "4]", "ref_id": "BIBREF3"}], "ref_spans": [], "section": "Discussion"}, {"text": "Finally, this paper has limited its discussion to BMRS transductions restricted to either p or s, so an obvious open question is to what functions are described by BMRS transductions without this restriction. As any rational function is the composition of a right-and left-subsequential function [8] , it is clear that BMRS transductions in general are strictly more expressive than either the BMRS p and BMRS s transductions. Based on this, we tentatively conjecture that the BMRS transductions in general are equivalent to the rational functions, but this claim requires more rigorous investigation than can be done here.", "cite_spans": [{"start": 296, "end": 299, "text": "[8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Discussion"}, {"text": "This paper has given the first logical characterization of the subsequential functions. As with previous work connecting logical, language-theoretic, and automata-theoretic characterizations of formal languages and functions, we are confident this will further study of the connections between subclasses of the subsequential functions, and subclasses of the rational functions in general.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Weak second-order arithmetic and finite automata", "authors": [{"first": "J", "middle": ["R"], "last": "B\u00fcchi", "suffix": ""}], "year": 1960, "venue": "Z. Math. Log. Grundl. Mathmatik", "volume": "6", "issn": "", "pages": "66--92", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "Strictly Local Phonological Processes", "authors": [{"first": "J", "middle": [], "last": "Chandlee", "suffix": ""}], "year": 2014, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Learning strictly local subsequential functions", "authors": [{"first": "J", "middle": [], "last": "Chandlee", "suffix": ""}, {"first": "R", "middle": [], "last": "Eyraud", "suffix": ""}, {"first": "J", "middle": [], "last": "Heinz", "suffix": ""}], "year": 2014, "venue": "Trans. Assoc. Comput. Linguist", "volume": "2", "issn": "", "pages": "491--503", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Output strictly local functions", "authors": [{"first": "J", "middle": [], "last": "Chandlee", "suffix": ""}, {"first": "R", "middle": [], "last": "Eyraud", "suffix": ""}, {"first": "J", "middle": [], "last": "Heinz", "suffix": ""}], "year": 2014, "venue": "Proceedings of the 14th Meeting on the Mathematics of Language", "volume": "", "issn": "", "pages": "52--63", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Strictly locality and phonological maps", "authors": [{"first": "J", "middle": [], "last": "Chandlee", "suffix": ""}, {"first": "J", "middle": [], "last": "Heinz", "suffix": ""}], "year": 2018, "venue": "Linguist. Inq", "volume": "49", "issn": "", "pages": "23--60", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Autosegmental input-strictly local functions", "authors": [{"first": "J", "middle": [], "last": "Chandlee", "suffix": ""}, {"first": "A", "middle": [], "last": "Jardine", "suffix": ""}], "year": 2019, "venue": "Trans. Assoc. Comput. Linguist", "volume": "7", "issn": "", "pages": "157--168", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Decision problems of finite automata design and related arithmetics", "authors": [{"first": "C", "middle": ["C"], "last": "Elgot", "suffix": ""}], "year": 1961, "venue": "Trans. Am. Math. Soc", "volume": "98", "issn": "1", "pages": "21--51", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "On relations defined by generalized finite automata", "authors": [{"first": "C", "middle": ["C"], "last": "Elgot", "suffix": ""}, {"first": "J", "middle": ["E"], "last": "Mezei", "suffix": ""}], "year": 1965, "venue": "IBM J. Res. Dev", "volume": "9", "issn": "", "pages": "47--68", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "MSO definable string transductions and two-way finite-state transducers", "authors": [{"first": "J", "middle": [], "last": "Engelfriet", "suffix": ""}, {"first": "H", "middle": ["J"], "last": "Hoogeboom", "suffix": ""}], "year": 2001, "venue": "ACM Trans. Comput. Log", "volume": "2", "issn": "", "pages": "216--254", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Logic-automata connections for transformations", "authors": [{"first": "E", "middle": [], "last": "Filiot", "suffix": ""}], "year": 2015, "venue": "Heidelberg", "volume": "8923", "issn": "", "pages": "30--57", "other_ids": {"DOI": ["10.1007/978-3-662-45824-2_3"]}}, "BIBREF10": {"ref_id": "b10", "title": "Transducers, logic, and algebra for functions of finite words", "authors": [{"first": "E", "middle": [], "last": "Filiot", "suffix": ""}, {"first": "P", "middle": [], "last": "Reynier", "suffix": ""}], "year": 2016, "venue": "ACM SIGLOG News", "volume": "3", "issn": "3", "pages": "4--19", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "The computational nature of phonological generalizations", "authors": [{"first": "J", "middle": [], "last": "Heinz", "suffix": ""}], "year": null, "venue": "Phonological Typology. Phonetics and Phonology", "volume": "", "issn": "", "pages": "126--195", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Vowel harmony and subsequentiality", "authors": [{"first": "J", "middle": [], "last": "Heinz", "suffix": ""}, {"first": "R", "middle": [], "last": "Lai", "suffix": ""}], "year": 2013, "venue": "Proceedings of the 13th Meeting on Mathematics of Language", "volume": "", "issn": "", "pages": "52--63", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "Counter-Free Automata", "authors": [{"first": "R", "middle": [], "last": "Mcnaughton", "suffix": ""}, {"first": "S", "middle": [], "last": "Papert", "suffix": ""}], "year": 1971, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "On the class of events representable in a finite automaton", "authors": [{"first": "Y", "middle": ["T"], "last": "Medvedev", "suffix": ""}], "year": 1964, "venue": "Sequential Machines -Selected Papers", "volume": "", "issn": "", "pages": "215--227", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Finite-state transducers in language and speech processing", "authors": [{"first": "M", "middle": [], "last": "Mohri", "suffix": ""}], "year": 1997, "venue": "Comput. Linguist", "volume": "23", "issn": "2", "pages": "269--311", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "Abstract Recursion and Intrinsic Complexity", "authors": [{"first": "Y", "middle": ["N"], "last": "Moschovakis", "suffix": ""}], "year": 2019, "venue": "Lecture Notes in Logic", "volume": "48", "issn": "", "pages": "", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Learning subsequential transducers for pattern recognition tasks", "authors": [{"first": "J", "middle": [], "last": "Oncina", "suffix": ""}, {"first": "P", "middle": [], "last": "Garc\u00eda", "suffix": ""}, {"first": "E", "middle": [], "last": "Vidal", "suffix": ""}], "year": 1993, "venue": "IEEE Trans. Pattern Anal. Mach. Intell", "volume": "15", "issn": "", "pages": "448--458", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Sur une variante des fonctions s\u00e9quentielles", "authors": [{"first": "M", "middle": ["P"], "last": "Sch\u00fctzenberger", "suffix": ""}], "year": 1977, "venue": "Theor. Comput. Sci", "volume": "4", "issn": "", "pages": "47--57", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Classifying regular events in symbolic logic", "authors": [{"first": "W", "middle": [], "last": "Thomas", "suffix": ""}], "year": 1982, "venue": "J. Comput. Syst. Sci", "volume": "25", "issn": "", "pages": "360--376", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Finite automata and logic of monadic predicates", "authors": [{"first": "B", "middle": ["A"], "last": "Trakhtenbrot", "suffix": ""}], "year": 1961, "venue": "Dokl. Akad. Nauk SSSR", "volume": "140", "issn": "", "pages": "326--329", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "Springer Nature Switzerland AG 2020 A. Leporati et al. (Eds.): LATA 2020, LNCS 12038, pp. 157-169, 2020. https://doi.org/10.1007/978-3-030-40608-0_10", "latex": null, "type": "figure"}, "FIGREF1": {"text": "A graph representation of the SFST for the function f from Example 1.", "latex": null, "type": "figure"}, "TABREF1": {"text": "Table 1.\nTable 1. A BMRS transduction for the SFST in Fig. 1 (left) and an example derivation\n(right). The rows for a 2 ( x ), c 2 ( x ), and d 2 ( x ) have been omitted.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>q0(x) </td><td>def(x) = \n= if q1(p(x)) then a(x) else  (p(x))\n</td><td>Input:  </td><td>a a a a \n0 1 2 3 4 5\n</td></tr><tr><td>q1(x) </td><td>= if q0(p(x)) then a(x) else \u22a5\n</td><td>q0(x) </td><td>\u22a5  \u22a5  \u22a5 \n</td></tr><tr><td>a1(x) </td><td>= if q0(x) then a(x) else \u22a5\n</td><td>q1(x) </td><td>\u22a5 \u22a5  \u22a5  \u22a5\n</td></tr><tr><td>a2(x) </td><td>= \u22a5\n</td><td>a1(x) </td><td>\u22a5  \u22a5  \u22a5 \u22a5\n</td></tr><tr><td>b1(x) </td><td>= if q1(x) then a(x) else \u22a5\n</td><td>b1(x) </td><td>\u22a5 \u22a5  \u22a5  \u22a5\n</td></tr><tr><td>b2(x) </td><td>= if a(x) else \u22a5\n</td><td>b2(x) </td><td>\u22a5 \u22a5  \u22a5  \u22a5\n</td></tr><tr><td>c1(x) </td><td>q1(x) then \u22a5\n</td><td>c1(x) </td><td>\u22a5 \u22a5 \u22a5 \u22a5 \u22a5 \n</td></tr><tr><td>= if q0(x) then  (x) else </td><td>d1(x) </td><td>\u22a5 \u22a5 \u22a5 \u22a5 \u22a5 \u22a5\n</td></tr><tr><td>c2(x) </td><td>= \u22a5\n</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>d1(x) </td><td>= if q1(x) then  (x) else \u22a5\n</td><td>Output:\n</td><td>\u00a0</td></tr><tr><td>d2(x) </td><td>\u22a5\n</td><td>Copy 1 : </td><td>a b a b c\n</td></tr><tr><td>= </td><td>Copy 2 : b </td><td>b\n</td></tr></table></body></html>"}}, "back_matter": []}