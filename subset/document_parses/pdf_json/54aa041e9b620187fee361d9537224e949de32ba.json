{
    "paper_id": "54aa041e9b620187fee361d9537224e949de32ba",
    "metadata": {
        "title": "Diminuendo! Tactics in Support of FaaS Migrations",
        "authors": [
            {
                "first": "Sebastian",
                "middle": [],
                "last": "Werner",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "J\u00f6rn",
                "middle": [],
                "last": "Kuhlenkamp",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Pallas",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "Niklas",
                "middle": [],
                "last": "Anders",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "Nebi",
                "middle": [],
                "last": "Mucaj",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "Olesia",
                "middle": [],
                "last": "Tsaplina",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "Christian",
                "middle": [],
                "last": "Schmidt",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            },
            {
                "first": "Kann",
                "middle": [],
                "last": "Yildirim",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Technische Universit\u00e4t Berlin",
                    "location": {
                        "settlement": "Berlin",
                        "country": "Germany"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Function-as-a-Service (FaaS) receives close attention due to highly desirable characteristics, including pay-as-you-go pricing, high elasticity, and its fully managed nature. To leverage these benefits for existing applications, developers face the challenge of migrating legacy code to a FaaS platform (FaaSification). Unfortunately, however, actionable guidance on how to do so for real-world applications does not exist. In this paper, we report on our experience from FaaSifying a dataintensive application, and evaluating different options through extensive experimentation, using approaches such as regression tests and tracing. Based on the obtained results, we present five migration tactics in support of future FaaSification.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Function-as-a-Service (FaaS) is a new cloud execution model that receives close attention due to highly desirable characteristics, including pay-as-you-go pricing, millisecond elasticity, or provider-managed operational tasks for, e.g., deployment [6] . To leverage these benefits for existing applications, developers face the challenge of migrating legacy code to a FaaS platform (FaaSification).",
            "cite_spans": [
                {
                    "start": 248,
                    "end": 251,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "While an increasing number of supported programming languages and relaxed limitations, e.g., maximum execution time, give the impression that FaaSification is a trivial task, first exploratory research [4, 7] indicates that leveraging the non-functional benefits of FaaS beyond correct execution requires a careful redesign, profiling, and configuration. Unfortunately, little information is available on how these and further subjects are (to be) addressed in the FaaSification of real-world web applications. Thus, many application developers are unaware of the different fallacies of FaaSification.",
            "cite_spans": [
                {
                    "start": 202,
                    "end": 205,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 206,
                    "end": 208,
                    "text": "7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we report on our experience from FaaSifying a data-intensive web application from a VM-based deployment. For the migration, we initially used a na\u00efve migration approach presented in [7] that expectedly resulted in failing non-functional end-to-end regression tests. We were able to significantly reduce these degradations by 1) instrumenting application code for tracing purposes, 2) identifying the root-cause for degradation in different third-party libraries and some sections of legacy code, and, finally, 3) refactoring parts of the application architecture and the usage of third-party libraries.",
            "cite_spans": [
                {
                    "start": 197,
                    "end": 200,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To let others profit from our experiences, we synthesize our insights from the migration and additional previous research into five common migration tactics in support of future FaaSification: Precompute, Reuse, Strip, Be Lazy, and Replace.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We selected the open participatory data platform OpenSense.network [2] as a use-case to evaluate the effects of legacy code during the migration to FaaS environments. OpenSense.network offers a horizontally scalable, Flask-based API to let users contribute and access sensor data of globally distributed environmental sensors in a uniform, web-friendly way. To provide geospatial capabilities and high-volume sensor data in a performant and scalable manner, it employs a hybrid storage model, comprising a PostGIS database for static metadata and a Cassandra cluster holding timeseries of actual measurements (see Fig. 1 ). Both the API and databases of OpenSense.network are deployed on the TU Berlin data center premises. For the migration, we were particularly interested in moving the Flask API to a FaaS platform to free up computation resources when the API is not in use while at the same time being able to handle spiking loads in case of, for instance, occasional bulk inserts or data access surges. Further, we were interested in reducing operational overhead, e.g., the management of the Flask API virtual machines. We selected Apache OpenWhisk 1 as the target platform and deployed it in the same network as the current OpenSense.network deployment to allow connections to the same databases as the original APIs and, thus, to avoid the need for data migration.",
            "cite_spans": [
                {
                    "start": 67,
                    "end": 70,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [
                {
                    "start": 614,
                    "end": 620,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Application and Migration Goal"
        },
        {
            "text": "To compare the behavior and responses of the migrated API to those of the original one, we additionally created and continuously extended a rich set of end-to-end regression tests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sensor Metadata"
        },
        {
            "text": "In this section, we outline our approach in migrating OpenSense.network. We start by describing our initial na\u00efve approach, followed by the steps taken to identify root-causes of performance degradations and the subsequent refactoring.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FaaS Migration Approach"
        },
        {
            "text": "In the first step of the migration, we followed a na\u00efve reuse approach similar to Llyod et al. [7] . Accordingly, we implemented a custom runtime container, based on the OpenWhisk Python runtime 2 with the necessary Python dependencies for OpenSense.network already built-in. These custom runtimes can reduce coldstart problems as less code needs to be downloaded and compiled initially.",
            "cite_spans": [
                {
                    "start": 95,
                    "end": 98,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Na\u00efve Migration"
        },
        {
            "text": "Furthermore, we used a modified version of the flask-openwhisk 3 wrapper to map OpenWhisk requests to Flask, resulting in a FaaS version of the preexisting Flask API with almost zero modification. 4 In line with our expectations and previous findings [7] , this na\u00efve FaaSification approach was successful on a functional level but exhibited significant performance degradation compared to the original deployment. For instance, a request for a single sensor value for the migrated API took between 2 and 20 s for cold and warm functions, respectively, while it took less than a second on the original API.",
            "cite_spans": [
                {
                    "start": 197,
                    "end": 198,
                    "text": "4",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 251,
                    "end": 254,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Na\u00efve Migration"
        },
        {
            "text": "In the following, we first describe our approach to identifying the root-causes of this degradation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Na\u00efve Migration"
        },
        {
            "text": "Determining the root-cause of problems in FaaS applications is challenging [4] since FaaS platforms offer no out-of-the-box facilities for remote-debugging and -profiling. Instead, developers have to rely on application and system log information which can be limited in volume, making debugging and profiling tasks tedious and cumbersome.",
            "cite_spans": [
                {
                    "start": 75,
                    "end": 78,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Regression Detection"
        },
        {
            "text": "As a first step of refactoring towards a more FaaS-aware implementation, we, therefore, created a simple, lightweight profiling tool that instruments Open-Whisk's logging facilities and allows to easily include start-and endpoints of initialize ():",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regression Detection"
        },
        {
            "text": "topen (\" init \") topen (\" flask \") flask () tclose (\" flask \") ... tclose (\" init \")",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regression Detection"
        },
        {
            "text": "relevant functional sections in the code. An accompanying evaluation tool allows to easily analyze respective runtimes 5 . Using these tools, we instrumented the migrated application with a set of tracepoints, see Fig. 2 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 214,
                    "end": 220,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "Fig. 2. Example of instrumented code"
        },
        {
            "text": "We placed each trace-point at potential bottlenecks and points of interest within the code. In particular, we measured object creation, database connection initialization, overall initialization, execution [5] , and serialization and deserialization times. Figure 3 shows exemplary results of these measurements for a simple sensor query, before and after refactoring.",
            "cite_spans": [
                {
                    "start": 206,
                    "end": 209,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [
                {
                    "start": 257,
                    "end": 265,
                    "text": "Figure 3",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Fig. 2. Example of instrumented code"
        },
        {
            "text": "We were quickly able to pin down the root causes of the observed performance degradation based on the gathered information. In particular, we observed that in the initial, na\u00efve approach, the API implementation took substantial time to (re-) initialize certain libraries on every single request. Large portions of these initialization overheads could be attributed to Flask and the Cassandra driver. Accordingly, the inefficient pattern of continuous re-initialization for both Flask and the Cassandra driver was a particular subject of refactoring, described further in the next section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. Example of instrumented code"
        },
        {
            "text": "The data from the regression detection provided a road-map to address the performance issues in the na\u00efvely migrated application. Based on the identified bottlenecks, the following measures particularly helped us to significantly reduce FaaS-specific overheads:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Refactoring"
        },
        {
            "text": "Reuse: We initially focused on reducing the re-initialization of objects and libraries on every single request, see the Reuse tactic in Sect. 4. Specifically, we moved the initialization of most libraries away from the OpenWhisk handler so that initialized libraries remain in memory. We faced some minor challenges as the OpenWhisk runtime did not offer simple mechanisms to execute code before a handler call. However, Python packages allow code execution on imports through including the code to be executed in the init method, which enabled us to shift all expensive initializations to the OpenWhisk runtime creation. These steps already reduced performance degradations for warm 6 execution environments significantly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Refactoring"
        },
        {
            "text": "Precompute: Based on a more in-depth analysis of the execution times, we identified that the initialization of both Flask and the Cassandra driver still created notable performance impacts during cold-starts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Refactoring"
        },
        {
            "text": "For Flask, we managed to precompile most of the Flask object state through the pickle api 7 , which we could store as part of the deployment artifact. Using the precompiled object allows that most of the dynamic computation which Flask performs during server initialization can be removed. The effects of this can be seen in the left part of Fig. 3 , see the Precompute tactic in Sect. 4.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 342,
                    "end": 348,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Refactoring"
        },
        {
            "text": "We tried to follow a similar strategy for the Cassandra driver. However, we could not reduce the initialization time significantly with this method. Furthermore, we tried to disable thread-pooling and other functionality that is unnecessary in a FaaS context, but these steps also slightly reduced the initialization time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Refactoring"
        },
        {
            "text": "Strip: To address the Cassandra driver's performance issues, we observed that the Cassandra driver is not used for every request. For instance, an API method only returning sensor metadata based on several query parameters does not need access to the timeseries data stored in Cassandra and could, therefore, be included in a \"Cassandra-less\" function. Thus, we decided to strip away the Cassandra driver splitting the Flask API into two functions. Of course, this step did not help to reduce the start-up time for Cassandra-related requests but significantly improved the request-response time for all other requests. Significantly decreasing the Cassandra-related overheads for API methods with timeseries functionality, however, would have required us to replace or rewrite the Cassandra library. Even though this would have gone beyond the scope of our migration project, this nonetheless illustrates the need for more lightweight, and possibly less feature-rich libraries and drivers in the FaaS context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Refactoring"
        },
        {
            "text": "Beyond those explicitly mentioned above, we also experimented with further approaches of adjusting our code and the underlying runtime to FaaS-specific givens, which mostly took a similar line, albeit with less significant impacts. Altogether, however, our experiences can be synthesized into five general tactics for FaaSification. Each of these tactics implies different prerequisites, the potential for performance improvements, and development costs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "Precompute: This tactic precomputes intermediate results that are included as static content in the deployment package of a function. The tactic requires that the intermediate result does not depend on runtime information and that the size of the intermediate result is comparatively small due to FaaS platform limitations -e.g., 3-250MB for AWS Lambda 8 . In addition, it increases cold-start times with the size of a deployment package [9] . The tactic affects all invocations of a function handler and requires additional development efforts.",
            "cite_spans": [
                {
                    "start": 438,
                    "end": 441,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "Reuse: This tactic caches intermediate results over multiple invocations of a function handler on the same function container. It requires that multiple executions occur on the same function container. This tactic is quite simple to implement by storing intermediate results in global class variables of a function handler or on the ephemeral storage available. However, it benefits only a subset of executions, namely those that actually run on the same function container repeatedly. Thus, Reuse becomes less effective with increasing numbers of cold starts. Different approaches for experiment-driven analysis of cold/warm start ratios [3, 5, 9] can indicate the effectiveness of this tactic to developers.",
            "cite_spans": [
                {
                    "start": 639,
                    "end": 642,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 643,
                    "end": 645,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 646,
                    "end": 648,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "Strip: Strip implies that the developer removes source code from the function handler that is initialized but not used on the execution paths of any invocation. It requires that such source code exists and is identifiable by developers. While all invocations benefit, the tactic implies additional development efforts due to profiling and exhaustive testing. We envision that system providers will begin offering specialized lightweight client libraries for short-lived ephemeral compute environments like FaaS platforms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "Be Lazy: This tactic is applicable for function handlers with multiple initializations that are not required on all execution paths. The application developer can conditionally initialize by relying on conditional statements in a function handler. As an alternative, a developer can decompose a function into multiple focused functions [1] . The potential for performance improvements depends on the distribution of the different execution paths. It implies additional development efforts and potentially changes the application on an architectural level.",
            "cite_spans": [
                {
                    "start": 336,
                    "end": 339,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "Replace: Application developers can resort to re-implementing third-party libraries. A particular form of replacement could be the inclusion of lightweight database connectors within FaaS platforms, allowing FaaS application developers to offload respective functionalities from their code-base. This tactic has no prerequisites and a high potential for improvement but can imply significant development costs. In a FaaS context, the potential additional costs of featurerich client libraries in terms of higher execution latency and monetary execution costs motivate coexisting lightweight clients with a reduced set of features.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "Besides, we argue that a high degree of automation is achievable in order to reduce the development efforts for the different tactics significantly. However, it remains an open question on which level of the technology stack each tactic is applied best. For example, a tactic might be best applied automatically by the cloud platform, integrated with application frameworks, or supported by additional developer tooling in support of FaaSification. We argue that future work should discuss and give guidance on the different associated trade-offs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Migration Tactics"
        },
        {
            "text": "In this paper, we introduced five tactics in support of migrating legacy--applications to FaaS, that we synthesized from a real-world migration effort. We argue that a high degree of automation is achievable in order to reduce the development efforts for migrations in the future. We additionally see that an extension to current FaaS platforms by offloading expensive operations like database connections to the platform could be an area for investigation. Further, we argue that application framework developers could support FaaS bestpractices like lazy loading directly. Lastly, we see an opportunity for third-party library vendors to offer more lightweight options aligned with the FaaS context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "The serverless trilemma: function composition for serverless computing",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Baldini",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software",
            "volume": "",
            "issn": "",
            "pages": "89--103",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Providing open environmental data-the scalable and web-friendly way",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "C"
                    ],
                    "last": "Borges",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Pallas",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Peise",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "J"
                    ],
                    "last": "Bungartz",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kranzlm\u00fcller",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Weinberg",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Weism\u00fcller",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Advances and New Trends in Environmental Informatics",
            "volume": "",
            "issn": "",
            "pages": "21--37",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-99654-7_2"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "An investigation of the impact of language runtime on the performance and cost of serverless functions",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jackson",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Clynch",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "3rd International Workshop on Serverless Computing",
            "volume": "",
            "issn": "",
            "pages": "154--160",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The ifs and buts of less is more: a serverless computing reality check",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kuhlenkamp",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Werner",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Tai",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of The International Conference on Cloud Engineering",
            "volume": "",
            "issn": "",
            "pages": "21--24",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Benchmarking elasticity of FaaS platforms as a foundation for objective-driven design of serverless applications",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kuhlenkamp",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Werner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "C"
                    ],
                    "last": "Borges",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Ernst",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wenzel",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "34th ACM/SIGAPP Symposium on Applied Computing. Association for Computing Machinery",
            "volume": "",
            "issn": "",
            "pages": "284--291",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A mixed-method empirical study of function-as-a-service software development in industrial practice",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Leitner",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Wittern",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Spillner",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Hummer",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "J. Syst. Softw",
            "volume": "149",
            "issn": "",
            "pages": "340--359",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Improving application migration to serverless computing platforms: latency mitigation with keep-alive workloads",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Lloyd",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vu",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Leavesley",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 3rd International Workshop on Serverless Computing",
            "volume": "",
            "issn": "",
            "pages": "195--200",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Cold start influencing factors in function as a service",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Manner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Endreb",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Heckel",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Wirtz",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "International Conference on Utility and Cloud Computing Companion (UCC Companion)",
            "volume": "",
            "issn": "",
            "pages": "181--188",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Cold start influencing factors in function as a service",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Manner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Endre\u00df",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Heckel",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Wirtz",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 3rd International Workshop on Serverless Computing",
            "volume": "",
            "issn": "",
            "pages": "181--188",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Comparison of cold-start initialization times. \"Na\u00efve\" refers to the initial migration, see Sect. 3.1. \"Refactored\" refers to the code-base after the changes described in Sect. 3.3 (Precompute). Results a based on 200 sensor range queries.",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgments. The work in this paper was partially performed in the context of the SMILE and BloGPV.Blossom projects. BloGPV.Blossom is partially funded by the German Federal Ministry for Economic Affairs and Energy (BMWi) under grant no. 01MD18001E. SMILE is funded by the German Federal Ministry of Education and Research (BMBF) as part of the Software-Campus 2.0 grand, project number 01IS17052. The authors assume responsibility for the content.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}