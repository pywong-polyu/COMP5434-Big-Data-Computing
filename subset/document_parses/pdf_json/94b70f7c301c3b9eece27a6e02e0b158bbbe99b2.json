{
    "paper_id": "94b70f7c301c3b9eece27a6e02e0b158bbbe99b2",
    "metadata": {
        "title": "Reachability and Top-k Reachability Queries with Transfer Decay",
        "authors": [
            {
                "first": "Elena",
                "middle": [
                    "V"
                ],
                "last": "Strzheletska",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Riverside"
                    }
                },
                "email": "elenas@cs.ucr.edu"
            },
            {
                "first": "Vassilis",
                "middle": [
                    "J"
                ],
                "last": "Tsotras",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Riverside"
                    }
                },
                "email": "tsotras@cs.ucr.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "The prevalence of location tracking systems has resulted in large volumes of spatiotemporal data generated every day. Addressing reachability queries on such datasets is important for a wide range of applications (surveillance, public health, social networks, etc.) A spatiotemporal reachability query identifies whether a physical item (or information etc.) could have been transferred from the source object OS to the target object OT during a time interval I (either directly, or through a chain of intermediate transfers). In previous research on spatiotemporal reachability queries, the number of such transfers is not limited, and the weight of a piece of transferred information remains the same. This paper introduces novel reachability queries, which assume a scenario of information decay. Such queries arise when the value of information that travels through the chain of intermediate objects decreases with each transfer. To address such queries efficiently over large spatiotemporal datasets, we introduce the RICCdecay algorithm. Further, the decay scenario leads to an important extension: if there are many different sources of information, the aggregate value of information an object can obtain varies. As a result, we introduce a top-k reachability problem, identifying the k objects with the highest accumulated information. We also present the RICCtopK algorithm that can efficiently compute top-k reachability with transfer decay queries. An experimental evaluation shows the efficiency of the proposed algorithms over previous approaches.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Abstract-The prevalence of location tracking systems has resulted in large volumes of spatiotemporal data generated every day. Addressing reachability queries on such datasets is important for a wide range of applications (surveillance, public health, social networks, etc.) A spatiotemporal reachability query identifies whether a physical item (or information etc.) could have been transferred from the source object OS to the target object OT during a time interval I (either directly, or through a chain of intermediate transfers). In previous research on spatiotemporal reachability queries, the number of such transfers is not limited, and the weight of a piece of transferred information remains the same. This paper introduces novel reachability queries, which assume a scenario of information decay. Such queries arise when the value of information that travels through the chain of intermediate objects decreases with each transfer. To address such queries efficiently over large spatiotemporal datasets, we introduce the RICCdecay algorithm. Further, the decay scenario leads to an important extension: if there are many different sources of information, the aggregate value of information an object can obtain varies. As a result, we introduce a top-k reachability problem, identifying the k objects with the highest accumulated information. We also present the RICCtopK algorithm that can efficiently compute top-k reachability with transfer decay queries. An experimental evaluation shows the efficiency of the proposed algorithms over previous approaches.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Index Terms-spatio-temporal data, reachability query, top-k, access methods.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Answering reachability queries on large spatiotemporal datasets is important for a wide range of applications, such as security monitoring, surveillance, public health, epidemiology, social networks, etc. Nowadays, with the perpetuation of Covid-19, the reachability and trajectory analysis are as important as ever, since efficient contact tracing helps to control the spread of the disease.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Given two objects O S and O T , and a time interval I, a spatiotemporal reachability query identifies whether information (or physical item etc.) could have been transferred from O S to O T during I (typically indirectly through a chain of intermediate transfers). The time to exchange information (or physical items etc.) between objects affects the problem solution and it is application specific. An 'instant exchange' scenario (where information can be instantly transferred and retransmitted between objects) is assumed in [1] , but may not be the case in many real world applications. On the other hand, [2] and [3] consider two reachability scenarios without the 'instant exchange' assump-tion: reachability with processing delay and transfer delay. After two objects encountered each other, the contacted object may have to spend some time to process the received information before being able to exchange it again (processing delay). In other applications, for the transfer of information to occur, two objects are required to stay close to each other for some period of time (transfer delay); we call such elongated contact a meeting. To contract the virus, one has to be exposed to an infected person for a brief period of time; to exchange messages through Bluetooth, two cars have to travel closely together for some time.",
            "cite_spans": [
                {
                    "start": 528,
                    "end": 531,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 610,
                    "end": 613,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 618,
                    "end": 621,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "While the problems discussed above considered different reachability scenarios, they had a common feature: the value of information carried by the object that initiated the information transmission process and the value of information obtained by any reached object was assumed to remain unchanged. In this paper, we remove this assumption, since for some applications it may not be valid. For example, if two persons communicate over the phone (or a Bluetooth-enabled device), some information may be lost due to faulty connection. We name a reachability problem, where the value of the transmitted item experiences a decay with each transfer, as reachability with transfer decay. The formal definition of the new problem is given in Section III. Note that in this paper will still assume the transfer delay scenario as this is more realistic.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "The information decay scenario leads to the second problem we introduce, namely top-k reachability with decay. Consider a group of objects (people, cars, etc...), each of which possesses a different piece of information, and starts its transmission to other objects independently of each other. The objects that initiated the process form a set of source objects. Each of the source objects may carry information of a different value (and different weight), and during a contact, a decay of each piece of information may not be the same. As time progresses, any object may receive one or more items that originally came from different sources. It is reasonable to compute the combined weight of all the items collected by each object and rank the objects according to their aggregate weights. Objects with the most aggregated information may be of special interest. A top-k reachability query with decay finds the k objects with the highest aggregate weights.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In this paper we present two algorithms: RICCdecay and RICCtopK, that can efficiently compute reachability and top-k reachability with transfer decay queries on large spatiotemporal datasets. RICCdecay consists of two stages, preprocessing and query processing, while RICCtopK performs topk query processing using the index from RICCdecay. The rest of the paper is structured as follows: Section II is an overview of related work while Section III defines the two problems. Section IV describes the RICCdecay algorithm and its preprocessing phase, while Sections V and VI present the query processing for the reachability with decay and the topk reachability problems respectively. Section VII contains the experimental evaluation and Section VIII concludes the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "II. RELATED WORK Graph Reachability. A large number of works is proposed for the static graph reachability problem. The efficient approaches balance the preprocessing with the query processing, and are categorized in [4] as those, that use: (i) transitive closure compression [5] , [6] , (ii) hop labeling [7] , [8] , [9] , and (iii) refined online search [10] , [11] . In our model, the reachability question can be represented as a variation of a shortest path query. The state-of-the-art algorithm for solving shortest path problems on road networks is Contraction Hierarchies (CH) [12] . CH benefits from creating a hierarchy of nodes on the basis of their importance for the given road network. In our problem, there is no node preference between the graph nodes, and thus applying for it CH would be inefficient.",
            "cite_spans": [
                {
                    "start": 217,
                    "end": 220,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 276,
                    "end": 279,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 282,
                    "end": 285,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 306,
                    "end": 309,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 312,
                    "end": 315,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 318,
                    "end": 321,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 356,
                    "end": 360,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 363,
                    "end": 367,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 585,
                    "end": 589,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Evolving Graphs. Evolving graphs have recently received increased attention The DeltaGraph [13] , is an external hierarchical index structure used for efficient storing and retrieving of historical graph snapshots. For analyzing distance and reachability on temporal graphs, [14] utilizes graph reachability labeling, while for large dynamic graphs, [15] constructs a reachability index, based on a combination of labeling, ordering, and updating techniques. These methods work with datasets of a different nature, compared with spatiotemporal.",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 95,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 275,
                    "end": 279,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 350,
                    "end": 354,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Spatiotemporal Databases. A survey on spatiotemporal access methods appears on in [16] . They often involve some variation on hierarchical trees [17] - [21] , some form of a gridbased structure [22] , [23] , or indexing in parametric space [24] , [25] . The existing spatiotemporal indexes support traditional range and nearest neighbor queries and not the reachability queries we examine here. Some of the recent more complex queries were focused on querying/identifying the behavior and patterns of moving objects: discovering moving clusters [26] , [27] , flock patterns [28] , and convoy queries [29] .",
            "cite_spans": [
                {
                    "start": 82,
                    "end": 86,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 145,
                    "end": 149,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 152,
                    "end": 156,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 194,
                    "end": 198,
                    "text": "[22]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 201,
                    "end": 205,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 240,
                    "end": 244,
                    "text": "[24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 247,
                    "end": 251,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 545,
                    "end": 549,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 552,
                    "end": 556,
                    "text": "[27]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 574,
                    "end": 578,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 600,
                    "end": 604,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Spatiotemporal Reachability Queries. The first disk-based solutions for the spatiotemporal reachability problem, Reach-Grid and ReachGraph appeared in [1] . These are indexes on the contact datasets that enable faster query times. In Reach-Grid, during query processing only a necessary portion of the contact network is constructed and traversed. In ReachGraph, the reachability at different scales is precomputed and then reused at query time. ReachGraph makes the assumption that a contact between two objects can be instantaneous, and thus during one time instance, a chain of contacts may occur, which allows it to be smaller in size and thus reduces query time. ReachGrid does not require the 'instant exchange' assumption.",
            "cite_spans": [
                {
                    "start": 151,
                    "end": 154,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In [2] , two novel types of the 'no instant exchange' spatiotemporal reachability queries were introduced: reachability queries with processing and transfer delays (meetings). The proposed solution to the first type utilized CH [12] for path contraction. Later, [3] considered the second type of delays and introduced two algorithms, RICCmeetMin and RICCmeet-Max. To reduce query processing time, these algorithms precompute the shortest valid (RICCmeetMin), and the longest possible meetings (RICCmeetMax) respectively. Neither one of them can accommodate reachability queries with decay.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 6,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 228,
                    "end": 232,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 262,
                    "end": 265,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Spatiotemporal Top-k Queries. While many works have considered variations of spatial and spatiotemporal top-k queries [30] - [36] , no previous work addresses the decay scenario.",
            "cite_spans": [
                {
                    "start": 118,
                    "end": 122,
                    "text": "[30]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 125,
                    "end": 129,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In this section, we define two novel spatiotemporal reachability problems: the problem of reachability with decay and its extension, the problem of top-k reachability with decay.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "III. PROBLEM DESCRIPTION"
        },
        {
            "text": "Let O = {O 1 , O 2 , ..., O n } be a set of moving objects, whose locations are recorded for a long period of time at discrete time instants t 1 , t 2 , ..., t i , ..., with the time interval between consecutive location recordings \u2206t = t k+1 \u2212 t k (k = 1, 2, ...) being constant. A trajectory of a moving object O i is a sequence of pairs (l i , t k ), where l i is the location of object O i at time t k . Two objects, O i and O j , that at time t k are respectively at positions l i and l j , have a contact (denoted as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Background"
        },
        {
            "text": "where d cont is the contact distance (a distance threshold given by the application), and dist(l i , l j ) is the Euclidean distance between the locations of objects O i and O j at time t k .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Background"
        },
        {
            "text": "The reachability with transfer delay scenario (which we follow here) requires to discretize the time interval between consecutive position readings [t k , t k+1 ) by dividing it into a series of non-overlapping subintervals [\u03c4 0 , \u03c4 1 ), ..., [\u03c4 i , \u03c4 i+1 )... , [\u03c4 r\u22121 , \u03c4 r ) of equal duration \u2206\u03c4 = \u03c4 i+1 \u2212 \u03c4 i , such that \u03c4 0 = t k and \u03c4 r = t k+1 . We say that two objects, O i and O j , had a meeting < O i , O j , I m > during the time interval I m = [\u03c4 s , \u03c4 f ] if they had been within the threshold distance d cont from each other at each time instant \u03c4 k \u2208 [\u03c4 s , \u03c4 f ]. The duration of this meeting is m = \u03c4 f \u2212 \u03c4 s . We call a meeting valid if its duration m \u2265 m q \u2206\u03c4 (where m q is the query specifies required meeting duration -time, needed for the objects to complete the exchange).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Background"
        },
        {
            "text": "f , and \u03c4 sj+1 \u2265 \u03c4 fj for j = 0, 1, ..., k\u22121. A reachability query determines whether object O T (the target) is reachable from object O S (the source) during time interval I.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Background"
        },
        {
            "text": "Consider example in Fig. 1 . Table ( a) shows the actual meetings between all objects during one time block, which is given as a meetings graph in (b). A materialized reachability graph shows how the information is being dispersed. Suppose object O 1 is the source object and the required meeting duration m q = 2\u2206\u03c4 . Then graph G 2 in (c) is the materialized (m q )-reachability graph for O 1 on data from (a). By looking at G 2 , one can discover all objects that can be (m q )-reached by object O 1 during the time interval I = [\u03c4 0 , \u03c4 8 ]. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 20,
                    "end": 26,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 29,
                    "end": 36,
                    "text": "Table (",
                    "ref_id": null
                }
            ],
            "section": "A. Background"
        },
        {
            "text": "In the reachability with transfer delay scenario, to complete the transfer, it is necessary for the objects to stay within the contact distance for a time interval that is at least as long as the required meeting duration m q . However, even if a meeting between objects O i and O j satisfied the m q requirement, under some circumstances, the transfer may still fail to occur, or the value of the transferred item may go down (e.g., a complete or partial signal loss during the communication). We consider a new type of reachability scenario, namely reachability with transfer decay, that accounts for such events.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "Let d denote the rate of transfer decay -a part of information lost during one transfer (d \u2208 [0, 1)). Then p = 1 \u2212 d (p \u2208 (0, 1]) will define the portion of the transfered information. Suppose, the weight of the item carried by a source object O S is w. Then, during a valid meeting, O S can transfer this item to some object O i . However, considering the decay, if d > 0, the value of information, obtained by O i lessens and becomes wp. With each further transfer, the value of the received item will continue to decrease. This process can be modeled with an exponential decay function.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "We denote the number of transfers (hops), that is required to pass the information from object",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "be a function that calculates the weight of an item after h transfers. Assuming that the transfer decay d and thus p are constant for the same item, g w (h) can be defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "The number of transfers h in equation (1), that an item has to complete in order to be delivered from object O S to object O i , depends on the time \u03c4 j when it is being evaluated, and thus denoted as h(O 3 ) = 1. The case with p = 1 corresponds to the reachability with transfer delay problem [3] . If p < 1, the value of g w (h) decreases exponentially with each transfer. Let \u03bd denote the threshold weight. If after some transfer, the weight of the item becomes smaller than the threshold weight \u03bd, we disregard that event by assigning to the newly transferred item the weight of 0. We say, that h is the allowed number of hops (transfers) if it satisfies the threshold weight inequality",
            "cite_spans": [
                {
                    "start": 294,
                    "end": 297,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "We denote the maximum allowed number of transfers that satisfies inequality (2) as h max . Let f w : R \u2192 R be a function that assigns the weight to an item carried by object O i at time \u03c4 j , and denote it as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": ") as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "The table in Fig. 1 (a) shows the meetings between objects",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 13,
                    "end": 19,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "Here we assume again that O 1 is the source object, m q = 2\u2206\u03c4 and d = 0.2 ( thus p = 0.8). To illustrate the difference between the actual weight of an item g w and its assigned weight f w , the values g w , f w1 , and f w2 are computed for each object at time instants from \u03c4 0 to \u03c4 8 and recorded in the table (see Fig. 2 ). The values for the assigned weight functions f w1 and f w2 are computed for \u03bd = 0.6 and \u03bd = 0.7 respectively. The graph G 3 in Figure 1 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 317,
                    "end": 323,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 454,
                    "end": 462,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "if there exists a chain of subsequent valid and successful (under m q , d conditions) meetings We assume that the values of d and \u03bd are query specified. An (m q , d)-reachability query Q md : {O S , O T , w, d, I, m q , \u03bd} determines whether the target object O T is reachable from the source object O S , that caries an item whose weight is w, during time interval I = [\u03c4 s , \u03c4 f ], given required meeting duration m q , rate of transfer decay d, and threshold weight \u03bd, and reports the earliest time instant when O T was reached.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Reachability with Decay"
        },
        {
            "text": "We now consider the problem of top-k reachability with transfer decay. Let S = {O S1 , O S2 , ..., O Sq }, W = {w 1 , w 2 , ..., w q }, and D = {d 1 , d 2 , ..., d q } be the sets of source objects, weights, and decays respectively. Each object O Sr \u2208 S carries a different piece of information (or physical item), whose weight is w r , and is able to transfer this information following the (m q , d)-reachability scenario. The transfer decay for the item carried by object O Sr is d r .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "As the objects move through the network, source objects O Sr encounter other objects, and may pass information to them. Since each source object owns a different piece of information, the transferred weight depends on both, the number of hops and the source that it came from. Let h r (h r \u2265 0) be the number of hops required for object O Sr to pass the information to object O i . Then we can calculate the actual weight of an item r after h r transfers using equation (1) as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "where r = (1, 2, ..., q). As in the previous problem, we require that each threshold weight inequality has been satisfied:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "for r = (1, 2, ..., q) and threshold weight \u03bd.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "Let h max(r) be the maximum allowed number of transfers that satisfies the inequality above for each r = (1, 2, ..., q). Similarly to (3), function f w(r) assigns weight to the r th item carried by object",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": ") as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "Furthermore, each object may receive more than one item. We denote the aggregate weight function F w : R \u2192 R that assigns weight to the collection of items carried by object O i at time \u03c4 j as F w (O (\u03c4j ) i ), and define it as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "A top-k reachability with decay query Q topK is given in the form {S, W, D, I, m q , \u03bd, k}. The goal of Q topK is to find k objects with the highest aggregate weight F w (computed according to 5), that was obtained during the time interval I.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "IV. PREPROCESSING As with other reachability problems discussed above, there are two naive approaches to solve (m q , d)-reachability problem: (i) 'no-preprocessing', and (ii)'precompute all'. Neither one of them is feasible for large graphs: the first does not ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "Weight, assigned to an item carried by O",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "Contraction parameter and grid resolution involve any preprocessing, and thus too slow during the query processing, while the second requires too much time for preprocessing and too much space for storing the preprocessed data. To overcome the disadvantages of the second approach and still achieve fast query processing, we precompute and store only some data as described below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "In order to simplify the presentation, we assume that the minimum meeting duration \u00b5 (\u00b5 \u2264 m q ) is known before the preprocessing, and set m q = \u00b5, thus fixing it. However, the proposed algorithm can be extended to work with any query specified m q by combining it with RICCmeetMax [3] .",
            "cite_spans": [
                {
                    "start": 282,
                    "end": 285,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "Suppose, our datasets contain records of objects' locations in the form (t, object id, location), ordered by the location reporting time t. We start the preprocessing by dividing the time domain into a non-overlapping time intervals of equal duration (time blocks). Each time block (denoted as B k ) contains all records whose reporting times belong to the corresponding time period. The number of the reporting times in each block is the contraction parameter C. How to find an optimal value of C will be discussed in Section VII.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "For each time block, during the preprocessing, the following steps have to be completed: (i) computing candidate contacts, (ii) verifying contacts (performed for each t k ), (iii) identifying meetings, (iv) computing reachability, and (v) index construction. Steps (i), (ii), (iii), and (v) are similar to those in [3] ; we discuss them briefly, while concentrating on step (iv), which is the most challenging step of preprocessing.",
            "cite_spans": [
                {
                    "start": 315,
                    "end": 318,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "During the preprocessing, information regarding each object O i is saved in a data structure named objectRecord(O i ), which is created at the beginning of each time block B k and deleted after all the needed information is written on the disk at the end of B k . ObjectRecord(O i ) has the following fields: Object id, Cell id (the object's placement in the grid with side H when it was first seen during B k ), ContactsRec (a list of the contacts of O i during B k ), M eetingsRec (a list of meetings of O i during B k ). The grid side H is another parameter (in addition to the contraction parameter C), which needs to be optimized. We will discuss this question in Section VII. In addition, for each time block we maintain a hashing scheme, that enables to access each object's information by the object's id.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Top-k Reachablility with Decay"
        },
        {
            "text": "Two objects O i and O j are candidate contacts at reporting time t k if the distance between them at that time is no greater than candidate contact distance d cc = 2d max + d cont (where d max is the largest distance that can be covered by any object during \u2206t). Candidate contacts can potentially have a contact between t k and t k+1 . To force all candidate contacts of a given object O i to be in the same or neighboring with O i 's cells, at each t k we partition the area covered by the dataset into cells with side d cc . Now, to find all candidate contacts of object O i , we only need to compute the (Euclidean) distance between O i and objects in the same and neighboring cells.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Computing Contacts and Finding Meetings"
        },
        {
            "text": "Using our assumption that between consecutive reporting times objects move linearly, at t k+1 , we can verify if there were indeed any contacts between each pair of candidate contacts during the time interval [t k , t k+1 ). If a contact occurred, it is saved in the list ContactsRec of objectRecord of each contacted object. If an object O i had O j for its contact at two or more consecutive time instants, these contacts are merged into a meeting, and written in the M eetingsRec list of (O i ). At the end of each time block, a meeting duration m is computed for each meeting. All meetings with m < \u00b5 (with the exception of boundary meetings) are pruned, while all the remaining meetings are recorded into file Meetings. Boundary meetings (meetings that either start at the beginning or finish at the end of B k ) are recorded regardless of their duration since they may span more than one block, which needs to be verified during the query processing.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Computing Contacts and Finding Meetings"
        },
        {
            "text": "To speed up the query time, during the preprocessing, for each object O i , we precompute all objects that are (\u00b5, d)reachable from O i during B k . Here we are facing a challenge: to find, which objects can be (\u00b5, d)-reached by O i , we need to know the transfer decay d and weight threshold \u03bd, which are assumed to be unknown at the preprocessing time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Computing Reachability"
        },
        {
            "text": "To overcome an issue of unknown d and \u03bd, we turn our problem of reachability with decay into hop-reachability problem. Recall that one of the requirements for object O T to be reachable from object O S is that each meeting in the chain of meetings from O S to O T has to be a successful meeting.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Computing Reachability"
        },
        {
            "text": "It follows from (2), that after each meeting, for each companion object O i , the following condition must hold:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Computing Reachability"
        },
        {
            "text": "Thus, the allowed number of transfers (or hops) h for a successful meeting should satisfy the following inequality:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Computing Reachability"
        },
        {
            "text": "h \u2264 log p \u03bd w , stopping at some points, where information needs to be analyzed. In our case, the x-dimension is the time-dimension, and y-dimension is the order in which the meetings are discovered. We demonstrate how the algorithm works on the Example in Fig. 3 , and later provide a pseudo-code and detailed explanation. Consider the data in the table (a1). It contains records of actual meetings between all objects during one time block. (a2)-(a6) describe how reached objects and meetings are being discovered. The information about the 'reachability' status of each object is recorded into a temporary table, which is created at the beginning of each block. A row is added to the table for each reached object at the time when it is reached, and it is updated with any new event. The development of the reachability table is shown in (b1)-(b6).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 257,
                    "end": 263,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "B. Computing Reachability"
        },
        {
            "text": "We show how to compute all objects that are reached by object O 1 during the given time block, assuming that \u00b5 = 2\u2206\u03c4 . At the beginning of the block, the sweep line is positioned at \u03c4 = 0, and only object O 1 is reached (with h min = 0), which is recorded in table (b1). During the given time block, O 1 has only one meeting, < O 1 , O 3 , [0, 3] > which is placed on the plane (a2). As a result of this meeting, object ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Computing Reachability"
        },
        {
            "text": "The process for computing all objects that are (h min )reachable by O S during one time block is generalized in Algorithm 1. Procedure UpdateHmin initializes and then updates the table that records the reachability status of each reached object. The S ReachHop set keeps all objects for which all h min values as well as the earliest reached time had been computed and finalized. Those objects that were found to be reached, but not in S ReachHop yet, are placed in the priority queue S P Q , where priority to the objects is given according to their 'reached' times. When an object (say object O i ) that has the earliest reached time (\u03c4 R (O i )) is extracted from S P Q , it is placed into S ReachHop (lines 10, 11). At this time, all meetings of objects that can be reached by O i (but not in S ReachHop ) are analyzed (lines 13 -23). As a result, both \u03c4 R (O j ) (and their priority in S P Q ) as well as their h min values can be changed (lines 19 and 21) . This algorithm has to be performed for each object of the dataset that is active during the given time block. The set of reached objects S \u2032 reached is initialized with object O S at the beginning of the query processing. We start reading file Reached (Hop) ). The process continues until O T is added to S \u2032 reached while reading some block B i (i < f ) or the last block B f is reached.",
            "cite_spans": [
                {
                    "start": 951,
                    "end": 961,
                    "text": "19 and 21)",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 1216,
                    "end": 1221,
                    "text": "(Hop)",
                    "ref_id": null
                }
            ],
            "section": "24: return S Reached"
        },
        {
            "text": "If at the end of processing B f , S \u2032 reached does not contain the target O T , the query processing can be aborted, otherwise it moves to the file Meetings. Now the process of identifying reached objects inside each block is the same as the one described in Algorithm 1. If there is a meeting between objects O i and O j , that ends at the end of the time block, but is shorter than m q , we check if it continues in the next block, and merge two meetings into one if needed. Also, if object ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "If by the end of B i , O T was not found to be reached, and B i < B f , the search switches to Reached(Hop). This process continues until O T is confirmed to be reached by the information from Meetings, or the last block B f is processed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "VI. TOP-K REACHABILITY: QUERY PROCESSING To process top-k reachability queries efficiently, we will use the preprocessed data and index structure from RIC-Cdecay, described in the previous section. For that reason, we named our top-k reachability query processing algorithm RICCtopK. The top-k query Q topK is issued in the form {S, W, D, [\u03c4 s , \u03c4 f ], \u00b5, \u03bd, k}, where S = {O S1 , O S2 , ..., O Sq }, W = {w 1 , w 2 , ..., w q }, and D = {d 1 , d 2 , ..., d q } are the sets of source objects, weights, and decays respectively. To make use of the precomputed data from RICCdecay, the topk reachability with decay problem has to be translated into top-k hop-reachability problem. Hence, for each source object O Sr \u2208 S, we compute h max(r) by applying inequality (6) to each triple {O Sr , w r , d r } as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "where p r = 1 \u2212 d r , and r = {1, 2, ...q}. Now each top-k query can be thought of as written in the form h max(2) , ..., h max(q) }. Note that the top-k query processing is the extension of the reachability with decay query processing algorithm, and thus we will avoid repeating some details concerning the use of the index structure during the query processing that were described earlier.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 106,
                    "end": 114,
                    "text": "h max(2)",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "24: return S Reached"
        },
        {
            "text": "First, the set of Top-k Candidates is initialized by adding to it all source objects. We start reading file Reached(Hop) from time block B s , checking all records for each source object from set S (in order of their appearance in the file). Once an object, that was reached by at least one source, is discovered, it is added to Top-k Candidates. For each top-k candidate O i , we keep the information about the source object(s), that it was reached by and h min(r) required to transfer information from each source to O i . The search continues in this manner until time block B f is processed, after which the weight of each object from Top-k Candidates is computed. Note, that this is not the actual weight F w of an object, but the maximum weight F max that this object may receive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "Next, the query processing moves to the file Meetings. Here, the algorithm maintains two structures: Top-k Candidates and Top-k, that have to be updated at the end of each block. Topk Candidates contains: (i) the ids of all reached objects, (ii) their corresponding maximum weights F max , as well as (iii) the current weight F w of each candidate top-k object. At the beginning, the weight F w of each source object O Sr is set to its initial weight w r , while the rest of the objects' weights F w are set to 0. Top-k is initialized by adding to it k source objects from set S with the top k weights; the weight F w of each top-k object is recorded as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "Let us denote the lowest weight F w among the objects in Top-k as F w min. If Top-k contains k objects, and the object with the smallest value carries weight F w min, any object O i , such that F max (O i ) < F w min, cannot be among the top-k.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "In file Meetings, the query processing starts from time block B s . After one time block is processed, the aggregate weight F w of objects from Top-k Candidates that were involved in some transfers, may increase, and has to be updated. This may lead to changes in Top-k. After Top-k and F w min are updated, all objects O i from Top-k Candidates, such that F max (O i ) < F w min, can be removed from the set of candidates. When the work on B s is completed, we proceed to the next block. This process continues until either the last time block B f of the query is reached or the size of Top-k Candidates is reduced to the size of Top-k. The final state of Top-k answers the query.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "24: return S Reached"
        },
        {
            "text": "For example, consider the top-k query with three source object O 1 , O 2 , and O 7 , whose corresponding weights are 3, 4, and 3. Suppose, the query interval [\u03c4 s , \u03c4 f ] is contained in time blocks B 1 -B 5 . Fig. 5 illustrates the example. The query answering begins in Reached(Hop). The relevant data is read from blocks B 1 -B 5 , and by the end of B 5 , the superset of all objects that can be reached by the source object is identified. These objects are Top-k Candidates. They are recorded in the Top-k Candidates table, together with their maximum possible aggregate weight F max (b1). Since at this stage the aggregate weight F w is known only for the source objects, the objects O 1 , O 2 , and O 7 are placed in the Top-k (c1). The query processing moves to B 1 in file Meetings (a2). At the end of B 1 , the aggregate weight of some objects F w VII. EXPERIMENTAL EVALUATION We proceed with the results of the experimental evaluation of RICCdecay and RICCtopK. Since there are no other algorithms for processing spatiotemporal reachability queries with decay, we compare against a modified version of RICCmeetMin [3] that enables it to answer such queries. All experiments were performed on a system running Linux with a 3.4GHz Intel CPU, 16 GB RAM, 3TB disk and 4K page size. All programs were written on C++ and compiled using gcc version 4.8.5 with optimization level 3.",
            "cite_spans": [
                {
                    "start": 1124,
                    "end": 1127,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 210,
                    "end": 216,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "24: return S Reached"
        },
        {
            "text": "All experiments were performed on six realistic datasets of two types: Moving Vehicles (MV) and Random Walk (RW). The MV datasets were created by the Brinkhoff data generator [37] , which generates traces of objects, moving on real road networks. For the underlying network we used the San Francisco Bay road network, which covers an area of about 30000 km 2 . These sets contain information about 1000, 2000, and 4000 vehicles respectively (denoted as M V 1 , M V 2 , and M V 4 ). The location of each vehicle is recorded every \u2206t = 5 seconds during 4 months, which results in 2, 040, 000 records for each object. The size of each dataset (in GB) appears in Table II . For the experiments on these sets, d cont = 100 meters (for a (class 1) Bluetooth connection). For the RW datasets, we created our own generator, which utilizes the modified random waypoint model [38] , and is often used for modeling movements of mobile users. In our model, 90% of individuals are moving, while the remaining 10% are stationary. At the beginning of the first trip, each user chooses whether to move or not (in the ratio of 9 : 1). Each out of 90% moving users chooses the direction, speed (between 1.5m/s and 4m/s), and duration of the next trip, and then completes it. At the end of the trip, each person determines the parameters for the next trip, and so on. RW datasets consist of trajectories of 10000, 20000, and 40000 individuals respectively (denoted as RW 1 , RW 2 , and RW 4 ). Each set covers an area of 100 km 2 . The location of each user is recorded every \u2206t = 6 sec for a period of one month (432,000 records for each person). We set d cont = 10 meters (to identify physical contacts or contacts in the range of a Bluetooth-enabled devices).",
            "cite_spans": [
                {
                    "start": 175,
                    "end": 179,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 866,
                    "end": 870,
                    "text": "[38]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [
                {
                    "start": 659,
                    "end": 667,
                    "text": "Table II",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "A. Datasets"
        },
        {
            "text": "The performance was evaluated in terms of disk I/Os during query processing. The ratio of a sequential I/O to a random I/O is system dependent; for our experiments this ratio is 20:1 (20 sequential I/Os take the same time as 1 random). We thus present the equivalent number of random I/Os using this ratio.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Datasets"
        },
        {
            "text": "The values of the contraction parameter C and the grid resolution H, that are used for the preprocessing, depend on the datasets. For each dataset, the parameters C and H were tuned on the 5% subset as follows. We performed the preprocessing of each subset for different values of (C, H), and tested the performance of RICCdecay on a set of 200 queries. The length of each query was picked uniformly at random between 500 and 3500 sec for the MV, and between 600 and 4200 sec for the RW datasets. The h max value was picked uniformly at random from 1 to 4 (we stopped at h max = 4 since the higher the h max , the less information is caried by the reached object and thus presents less interest). The parameters C and H were varied as follows: grid resolution H -from 500 to 40000 meters for MV datasets, and from 250 to 2000 m for RW datasets; contraction parameter C -from 0.5 to 30 min. For each dataset, the pair (C, H) that minimized the number of I/Os was used for the rest of the experiments. For example, for M V 1 we used C = 14 min and H = 20000 m, while for RW 4 we used C = 2 min nd H = 500 m.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Parameter Optimization"
        },
        {
            "text": "The sizes of the auxiliary files and the index sizes for RICCmeetMin and RICCdecay appear in Table II . RICCdecay uses about 13.5% more space compare to RICCmeetMin since it records more information into the file Reached(Hop). (For each reached object, in addition to its id, it saves its hop value.) The time needed to preprocess one hour of data for RICCdecay ranges from 14 sec for M V 1 to 91 min for RW 4 . For comparison, the preprocessing time for RICCmeetMin ranges from 13 sec for M V 1 to 56 min for RW 4 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 93,
                    "end": 101,
                    "text": "Table II",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "C. Preprocessing Space and Time"
        },
        {
            "text": "The performance of RICCdecay was tested on sets of 100 queries of different time intervals and various h max = 1, 2, 3, 4, while \u00b5 was set to 2 sec, and the initial weight w of the item carried by O S was set to 1 for all the experiments. Increasing query length answer reachability queries with decay.) We ran a set of 100 queries varying h max from 1 to 4; each query's interval was picked uniformly at random from 500 to 3500 sec for the MV datasets, and from 600 to 4200 sec for RW datasets.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Query Processing"
        },
        {
            "text": "The results are presented in Fig. 6 (a1 \u2212 b3). RICCdecay accesses from 1.8 (for M V 2 dataset) to 11.5 (for RW 4 dataset) times less pages than RICCmeetMin. The biggest advantage of RICCdecay is achieved for h max = 1 for all datasets, and in general, the smaller the h max , the better is the performance of the RICCdecay algorithm. When answering a query Q mh , it reads file Reached(Hop) first. File Meetings needs to be read only if during traversing file Reached(Hop), the target object appears among the objects, reached by the source (i.e. if O T \u2208 S \u2032 Reached ). However, S \u2032 Reached is a superset of the set of objects that can be reached by O S during the query interval I. We say that a query is pruned, if it aborts after reading file Reached(Hop) because of not finding the target among the reached objects. By precomputing the hop value of each reached object, Reached(Hop) gives more accurate information, than RICCmeet, which reduces the size of S \u2032 Reached . The smaller the h max , the less objects are in S \u2032 Reached , and thus the higher percent of queries can be pruned. Increasing Query Length. Now we test the performance of RICCdecay for various query lengths and compare with that of RICCmeetMin. Each test was run on a set of 100 queries varying query length from 500 to 3500 sec for M V , and from 600 to 4200 sec for RW datasets. The h max value for each query was picked uniformly at random from 1 to 4. The results are shown in Fig. 7 . For these sets of queries, RICCdecay outperforms RICCmeetMin in all the tests, accessing about 44% less pages in average, and this result does not change significantly from one dataset to another.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 29,
                    "end": 35,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF10"
                },
                {
                    "start": 1458,
                    "end": 1464,
                    "text": "Fig. 7",
                    "ref_id": null
                }
            ],
            "section": "D. Query Processing"
        },
        {
            "text": "Top-K Reachability Queries. All the queries considered in this section until now were one-to-one queries: they had one source and one target object. Top-k queries that we described in Section III may have more than one source and one target objects. Multiple sources lead to the increase in the search space, while multiple undefined targets prohibit from the early query suspension. In addition, the need to calculate and compare the aggregate weights of the reached objects makes it impossible to prune a query (suspend it after just searching the file Reached(Hop)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Query Processing"
        },
        {
            "text": "For each of our top-k experiments, we used sets of 100 queries, where query length was 3500 sec for M V datasets and 4200 sec for RW datasets. The number of source objects was set 4: S = {O S1 , O S2 , O S3 , O S4 }, and each weight was assigned a value of 1. Further, D = {0.10, 0.15, 0.20, 0.25}, \u03bd = 0.6, and k was randomly picked from 4 to 20. The area covered by each dataset is very large, so to force objects to be reached by several sources, for each query, we picked source objects from the same cell (with the side equal to d cc ) at the beginning of the query interval. The results (see Fig. 8 ) indicate that for top-k queries RICCmeetMin accesses in average about 37% more pages than RICCtopK for the M V , and about 30% more pages for RW datasets. The advantage of RICCtopK owes to both, the RICCdecay index, and RICCtopK query processing. Information from the preprocessing allows for computing the maximum possible aggregate score F max using information from file Reached(Hop), while RICCtopK reduces the number of objects that have to be accessed when the query reads the file Meetings. VIII. CONCLUSIONS We presented two novel reachability problems: reachability with transfer decay and top-k reachability with transfer decay. To process these queries efficiently, we designed two new algorithms: RICCdecay and RICCtopK. The RICCmeetMin algorithm [3] was modified to answer the same types of queries, and served as a benchmark. We tested our algorithms on six realistic datasets, varying query duration and the maximum allowed number of hops. The performance comparison showed that RICCdecay and RICCtopK can answer the new types of queries more efficiently than RICCmeetMin.",
            "cite_spans": [
                {
                    "start": 1366,
                    "end": 1369,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 598,
                    "end": 604,
                    "text": "Fig. 8",
                    "ref_id": "FIGREF12"
                }
            ],
            "section": "D. Query Processing"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Efficient reachability query evaluation in large spatiotemporal contact datasets",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Shirani-Mehr",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "B"
                    ],
                    "last": "Kashani",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Shahabi",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "PVLDB",
            "volume": "5",
            "issn": "9",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "RICC: fast reachability query processing on large spatiotemporal datasets",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "V"
                    ],
                    "last": "Strzheletska",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "J"
                    ],
                    "last": "Tsotras",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "SSTD",
            "volume": "",
            "issn": "",
            "pages": "3--21",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Efficient processing of reachability queries with meetings",
            "authors": [],
            "year": 2017,
            "venue": "Proceedings of the 25th ACM SIGSPATIAL",
            "volume": "22",
            "issn": "",
            "pages": "1--22",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Scarab: scaling reachability computation on large graphs",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Jin",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Ruan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Dey",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "Y"
                    ],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ACM SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "169--180",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Efficient Managemet on Transitive Relationships in Large Data and Knowledge Bases",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Agrawal",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Borgida",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "V"
                    ],
                    "last": "Jagadish",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "ACM SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "253--262",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Dual labeling: Answering graph reachability queries in constant time",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "He",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "S"
                    ],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "X"
                    ],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "IEEE ICDE",
            "volume": "",
            "issn": "",
            "pages": "75--75",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Reachability and distance queries via 2-hop labels",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Cohen",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Halperin",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kaplan",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Zwick",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "SIAM Journal on Computing",
            "volume": "32",
            "issn": "5",
            "pages": "1338--1355",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "3-hop: a high-compression indexing scheme for reachability query",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Jin",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Xiang",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Ruan",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Fuhry",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ACM SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "813--826",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Path-hop: efficiently indexing large graphs for reachability queries",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Cai",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "K"
                    ],
                    "last": "Poon",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ACM CIKM",
            "volume": "",
            "issn": "",
            "pages": "119--128",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "GRAIL: scalable reachability index for large graphs",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yildirim",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Chaoji",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Zaki",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "276--284",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "PReaCH: A Fast Lightweight Reachability Index Using Pruning and Contraction Hierarchies",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Merz",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Sanders",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ESA Symp",
            "volume": "",
            "issn": "",
            "pages": "701--712",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Contraction hierarchies: faster and simpler hierarchical routing in road networks",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Geisberger",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Sanders",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Schultes",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Delling",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "7th Intl. Conf. on Experimental algorithms",
            "volume": "",
            "issn": "",
            "pages": "319--333",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Efficient snapshot retrieval over historical graph data",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Khurana",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Deshpande",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IEEE ICDE",
            "volume": "",
            "issn": "",
            "pages": "997--1008",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Characterising Temporal Distance and Reachability in Mobile and Online Social Networks",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Musolesi",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Mascolo",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Latora",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ACM SIGCOMM Comp. Comm. Review",
            "volume": "40",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Reachability queries on large dynamic graphs: a total order approach",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "D"
                    ],
                    "last": "Zhu",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Xiao",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ACM SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "1323--1334",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Spatio-temporal Access Methods: Part2 (2003 -2010)",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nguyen-Dinh",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "G"
                    ],
                    "last": "Aref",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "F"
                    ],
                    "last": "Mokbel",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "33",
            "issn": "",
            "pages": "46--55",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "On indexing mobile objects",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Kollios",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gunopulos",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Tsotras",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "ACM PODS",
            "volume": "",
            "issn": "",
            "pages": "261--272",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Novel approaches in query processing for moving object trajectories",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Pfoser",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Jensen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Theodoridis",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "VLDB",
            "volume": "",
            "issn": "",
            "pages": "395--406",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Efficient indexing of spatiotemporal objects",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hadjieleftheriou",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Kollios",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "J"
                    ],
                    "last": "Tsotras",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gunopulos",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "EDBT",
            "volume": "",
            "issn": "",
            "pages": "251--268",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "The bdual-tree: Indexing moving objects by space filling curves in dual space",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yiu",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Tao",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Mamoulis",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "VLDB J",
            "volume": "17",
            "issn": "3",
            "pages": "379--400",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "St2b-tree: A self-tunable spatio-temporal b+-tree index for moving objects",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Ooi",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Tan",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nascimento",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "ACM SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "29--42",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Stripes: An efficient index for predicted trajectories",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "M"
                    ],
                    "last": "Patel",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "P"
                    ],
                    "last": "Chakka",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "ACM SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "635--646",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Lugrid: Update-tolerant gridbased indexing for moving objects",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Xiong",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "F"
                    ],
                    "last": "Mokbel",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "G"
                    ],
                    "last": "Aref",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "MDM",
            "volume": "13",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Indexing spatiotemporal trajectories with efficient polynomial approximation",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Ni",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ravishankar",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "IEEE TKDE",
            "volume": "19",
            "issn": "5",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Efficient trajectory joins using symbolic representations",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bakalov",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hadjieleftheriou",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Keogh",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Tsotras",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "MDM",
            "volume": "",
            "issn": "",
            "pages": "86--93",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Continuous clustering of moving objects",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Jensen",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Ooi",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "IEEE TKDE",
            "volume": "19",
            "issn": "9",
            "pages": "1161--1174",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "On discovering moving clusters in spatio-temporal data",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Kalnis",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Mamoulis",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bakiras",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "SSTD",
            "volume": "",
            "issn": "",
            "pages": "364--381",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "On-line discovery of flock patterns in spatio-temporal data",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "R"
                    ],
                    "last": "Vieira",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bakalov",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "J"
                    ],
                    "last": "Tsotras",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ACM GIS",
            "volume": "",
            "issn": "",
            "pages": "286--295",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Discovery of convoys in trajectory databases",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Jeung",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yiu",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Jensen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Shen",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "PVLDB",
            "volume": "1",
            "issn": "",
            "pages": "1068--1080",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Joint top-k spatial keyword query processing",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Yiu",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cong",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Jensen",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "IEEE TKDE",
            "volume": "24",
            "issn": "10",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Efficient continuously moving top-k spatial keyword query processing",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Yiu",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Jensen",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cong",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Data Engineering (ICDE), 2011 IEEE 27th Int. Conf. on. IEEE",
            "volume": "",
            "issn": "",
            "pages": "541--552",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Spatial keyword query processing: an experimental evaluation",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cong",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Jensen",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proc. VLDB Endowment",
            "volume": "6",
            "issn": "",
            "pages": "217--228",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Efficient processing of top-k spatial preference queries",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Rocha-Junior",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Vlachou",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Doulkeridis",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "N\u00f8rv\u00e5g",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proc. VLDB",
            "volume": "4",
            "issn": "",
            "pages": "93--104",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Top-k spatial preference queries in directed road networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Attique",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cho",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Jin",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Chung",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "ISPRS Int. Journal of Geo-Inf",
            "volume": "5",
            "issn": "10",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Efficient computation of top-k frequent terms over spatio-temporal ranges",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ahmed",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hasan",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kashyap",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Hristidis",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "J"
                    ],
                    "last": "Tsotras",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 2017 ACM ICMD",
            "volume": "",
            "issn": "",
            "pages": "1227--1241",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Scalable top-k spatiotemporal term querying,\" in Data Eng",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Skovsgaard",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sidlauskas",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Jensen",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "148--159",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Generating traffic data",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Brinkhoff",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "IEEE Data Eng. Bull",
            "volume": "26",
            "issn": "2",
            "pages": "19--25",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Dynamic source routing in ad hoc wireless networks",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Maltz",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Mobile Computing",
            "volume": "353",
            "issn": "1",
            "pages": "153--181",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "(a) Record of meetings; (b) G 1 -meetings graph; (c) G 2materialized reachability with 'transfer delay' graph; (d) G 3materialized reachability with 'transfer decay' graph; (source object O 1 , m q = 2\u2206\u03c4 , d = 0.2, \u03bd = 0.6, I = [\u03c4 0 , \u03c4 8 ]).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "\u03c4j i ). Consider example in Fig. 1. Suppose again that m q = 2\u2206\u03c4 and object O 1 is the source object. It can reach object O 3 by \u03c4 = 6 with 3 hops, while it requires only one hop for object O 1 to reach O 3 by \u03c4 = 8. So,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "The actual weight of an item g w and its assigned weights f w1 and f w2 , calculated on data from Table 1(a) (source object O 1 , p = 0.8, \u03bd = 0.6 for f w1 and \u03bd = 0.7 for f w2 ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Computing (h min )-reachable objects from O 1 (\u00b5 = 2).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "to the time \u03c4 = 2 -time, when object O 3 was reached. Next, all meetings of O 3 that are either active at \u03c4 = 2 or start after this time, are materialized. These are meetings < O 3 , O 2 , [1, 5] > and < O 3 , O 4 , [5, 7] >. Consider the first meeting: < O 3 , O 2 , [1, 5] >. Even though it begins at \u03c4 = 1, the retransmission does not start until \u03c4 = 2, since only at this time O 3 becomes reached. As a result of these two meeting with object O 3 , O 2 and O 4 become reached at \u03c4 = 4 and \u03c4 = 7 respectively, with h min = 2 ((a3), (b3)). The line changes its position to \u03c4 = 4. This process continues until the sweep line reaches the end of the time block. Note that the earliest reached time for an object may change, also an object's h min value may decrease with time. For example, object O 4 was reached by O 2 with h min = 3 at \u03c4 = 6 ((a4), (b4)), however as a result of the meeting with object O 3 , its h min value went down to h min = 2 at \u03c4 = 7 ((a3), (b3)). Algorithm 1 Reach(h min ) 1: Input: OS 2: procedure UpdateHmin (Oi, \u03c4s, \u03c4 f , h) 3: for for each \u03c4 k \u2208 [\u03c4s, \u03c4 f ] do hmin(Oi, \u03c40, \u03c4 end , \u221e) \u22b2 \u03c40 and \u03c4 end are the first and last time units of a block 7: procedure REACHHOP(OS ) 8: time = 0, \u03c4R(OS ) = 0, UpdateHmin(OS , \u03c40, \u03c4 end , 0), SP Q = {OS }, S ReachHop = {\u2205} 9: while ((SP Q) = {\u2205} and time \u2264 \u03c4 end ) do 10: Oi = ExtractMin (SP Q) 11: S ReachHop = S ReachHop \u222a Oi, time = \u03c4R (Oi) 12: for each Oj that had a valid meeting with Oi do \u03c4Rnew(Oj ) \u2265 \u03c4R(Oj ) do 16: read next meeting Mij =< Oi, Oj , [\u03c4s, \u03c4 f ] > 17: compute \u03c4Rnew(Oj ) 18: if \u03c4Rnew(Oj ) < \u03c4R(Oj ) then 19: Update (SP Q, Oj ), h = hmin(\u03c4R(Oj ) = \u221e then \u03c4R(Oj ) = \u03c4 end+1 21: UpdateHmin(Oj , \u03c4Rnew, \u03c4R(Oj ) \u2212 1, h)) 22: if (Mij = last meeting < Oi, Oj > in B k ) then 23: \u03c4Rnew(Oj ) = \u22121",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Two-level index on files Meetings and Reached(Hop). C. Index ConstructionThe index structure of RICCdecay is similar to the one of RICCmeet algorithms[3]: to enable an efficient search in the files Meetings and Reached(Hop) during the query processing, we create three index files: Meetings Index, Reached Index, and Time Block Index(Fig. 4). The records in Meetings Index are organized and follow the order of time blocks. Each record contains an object id and a pointer to the page with the first record for this object (for the given time block) in file Meetings. In the Reached Index, each record consists of an object id and a pointer to the page with the first record for this object for the given timeblock in file Reached(Hop). Each record in Time Block Index points to the beginning of a time block in Meetings Index and Reached Index. V. REACHABILITY QUERIES WITH DECAY: QUERY PROCESSING The reachability with decay query Q md is issued in the form Q md : {O S , O T , w, d, [\u03c4 s , \u03c4 f ], \u00b5, \u03bd}. (Recall that during the preprocessing, for simplicity, we set m q = \u00b5.) First, using equation (6), we rewrite the problem as hop-reachability problem, replacing w, d, and \u03bd from Q md with h max . The new query can be written as Q mh : {O S , O T , h max , [\u03c4 s , \u03c4 f ], \u00b5}. The processing of Q mh starts from computing the time blocks B s , ... , B f that contain data for the query interval I = [\u03c4 s , \u03c4 f ]. File Time Block Index (accessed only once per query) points to the pages in the Meetings Index and Reached Index that correspond to the required blocks. These index files (accessed once per time block) in turn point to the appropriate pages in files Meetings and Reached(Hop) respectively.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "O i was reached by the source object O S during the block B k with h min (O B k i ) = h 1 , and in a later block B m , object O j was reached by O i within h 2 hops, h min (O Bm j",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Fig.(a1)-(a4) show the time blocks in files Reached(Hop) and Meetings that are being processed at the given stage, tables (b1)-(b4) display the Top-k Candidates with their maximum possible aggregate weights F max and current aggregate weights F w . The last column of tables, (c1)-(c4), keeps track of the current state of the Top-k set. Both, Top-k Candidates and Top-k are created after Reached(Hop) is processed and updated after the corresponding time block of file Meetings is processed.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Top-K Query Processing (source objects:O 1 , O 2 , O 7 )is updated, and thus both, Top-k Candidates and Top-k are updated as well ((b2), (c2)). We notice that F w min(O 2 ) = 6. Thus all objects O i with F max (O i ) < 6 can be removed from the set of candidates. (Such objects are shown in gray in (b3) and (b4).) The next block is B 2 (a3), and after updating both tables ((b3) and (c3)), we exclude O 3 and O 5 from further consideration. After processing B 3 , we remove O 1 from Topk Candidates. Even though, the query interval ends only in B 5 , the query can be suspended as the size of Top-k Candidates is reduced to the size of Top-k.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Increasing maximum allowed number of transfers",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Fig. 7: Increasing query length",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Top-k reachablility queries",
            "latex": null,
            "type": "figure"
        },
        "TABREF2": {
            "text": "Notation used in the paper Instance of object Oi at time \u03c4j \u03c4R(Oi)Earliest time when object Oi was reached d, pTransfer decay and portion of transfered information h, hmax Actual and maximum allowed number of hops (transfers)",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Now the problem can be stated as follows: for each object O i , compute all objects, that are (\u00b5, h max )-reachable from O i . Moreover, for each object O j reached by O i , we find the minimum number of such transfers h min \u2264 h max .Our algorithm makes use of plane sweep algorithm, where an imaginary vertical line sweeps the xy-plane, left-to-right,",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "from block B s , retrieving all records for object O S . Recall that in Reached(Hop) every object O j that can be reached by object O i is recorded together with the smallest number of transfers h min that is required for O i to reach O j . Thus during the query processing, an object O j cannot be considered as reached during the block B k unless h min (O B k j ) \u2264 h max (where h min (O B k j ) is the value h min of min , provided that h min (O Bs j ) \u2264 h max . Next, we proceed to block B s+1 . This time, retrieving all the companions of each object from S \u2032 reached and updating it by either adding new objects or adjusting the h min value for the objects that are already in the set. Such adjustment may be needed if, for some object O i \u2208 S \u2032",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Size of datasets, auxiliary files and indexes",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "Increasing the Maximum Allowed Number of Transfers. In this set of experiments, we analyze the impact of h max on the performance of the RICCdecay, and compare RICCdecay with RICCmeetMin. (The last was modified to enable it toNumber of I/OsNumber of I/Os Number of I/Os",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}