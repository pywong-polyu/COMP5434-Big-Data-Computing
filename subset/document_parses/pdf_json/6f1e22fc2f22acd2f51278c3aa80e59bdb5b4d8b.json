{"paper_id": "6f1e22fc2f22acd2f51278c3aa80e59bdb5b4d8b", "metadata": {"title": "Microservice Disaster Crash Recovery: A Weak Global Referential Integrity Management", "authors": [{"first": "Maude", "middle": [], "last": "Manouvrier", "suffix": "", "affiliation": {"laboratory": "LAMSADE", "institution": "CNRS", "location": {"settlement": "Paris", "country": "France"}}, "email": "maude.manouvrier@dauphine.fr"}, {"first": "Cesare", "middle": [], "last": "Pautasso", "suffix": "", "affiliation": {"laboratory": "", "institution": "USI", "location": {"settlement": "Lugano", "country": "Switzerland"}}, "email": ""}, {"first": "Marta", "middle": [], "last": "Rukoz", "suffix": "", "affiliation": {"laboratory": "LAMSADE", "institution": "CNRS", "location": {"settlement": "Paris", "country": "France"}}, "email": ""}]}, "abstract": [{"text": "Microservices which use polyglot persistence (using multiple data storage techniques) cannot be recovered in a consistent state from backups taken independently. As a consequence, references across microservice boundaries may break after disaster recovery. In this paper, we give a weak global consistency definition for microservice architectures and present a recovery protocol which takes advantage of cached referenced data to reduce the amnesia interval for the recovered microservice, i.e., the time interval after the most recent backup, during which state changes may have been lost.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Microservices are small autonomous services, deployed independently, that implement a single, generally limited, business functionality [6, 14, 21, 23] . Microservices may need to store data. Different data storage pattern exist for microservices [21] . In the Database per Service pattern, defined in [19] : each microservice stores its persistent data in a private database. Each microservice has full control of a private database, persistent data being accessible to other services only via an API [24] . The invocation of a service API will result in transactions which only involve its database.", "cite_spans": [{"start": 136, "end": 139, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 140, "end": 143, "text": "14,", "ref_id": "BIBREF13"}, {"start": 144, "end": 147, "text": "21,", "ref_id": "BIBREF20"}, {"start": 148, "end": 151, "text": "23]", "ref_id": "BIBREF22"}, {"start": 247, "end": 251, "text": "[21]", "ref_id": "BIBREF20"}, {"start": 302, "end": 306, "text": "[19]", "ref_id": "BIBREF18"}, {"start": 502, "end": 506, "text": "[24]", "ref_id": "BIBREF23"}], "ref_spans": [], "section": "Introduction"}, {"text": "Relationships between related entities of an application based on a microservice architecture are represented by links: the state of a microservice can include links to other entities found on other microservice APIs [18] . Following the hypermedia design principle of the REST architectural style, these links can be expressed with Uniform Resource Identifiers (URIs) which globally address the referenced entities.", "cite_spans": [{"start": 217, "end": 221, "text": "[18]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Introduction"}, {"text": "Since microservices are autonomous, not only do they use the most appropriate database technology for persistent storage of their state, but they also operate following an independent lifecycle, when their database is periodically backed up. For an entire microservice architecture, in practice, it is not very feasible to take an atomic snapshot of the state of all microservices. Thus, in case of one microservice crashes, which then needs to be recovered from its backup, the overall state of the microservice architecture may become inconsistent after recovery [18] . After recovery, such inconsistency may manifest itself as broken links between different microservices. This paper presents a solution to ensure that the links between different entities managed by different microservices remain valid and intact even in the case of a database crash. The solution assumes that microservices referring to entities managed by other microservices will not only store the corresponding link, but also conserve a cached representation of the most recent known values. We present a recovery protocol when the crashed microservice can merge its own possibly stale backup with the possibly more recent cached representations obtained from other microservices. Thus, we revisit the definition of weak referential integrity across distributed microservice architectures.", "cite_spans": [{"start": 565, "end": 569, "text": "[18]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Introduction"}, {"text": "A database has a state, which is a value for each of its elements. The state of a database is consistent if it satisfies all the constraints [22] . Among constraints that ensure database consistency, referential integrity [8] is a database constraint that ensures that references between data are indeed valid and intact [4] . In a relational database, the referential integrity constraint states that a tuple/row in one relation referring, using a foreign key, to another relation, must refer to an existing tuple/row in that relation [11] . When a reference is defined, i.e. a value is assigned to a foreign key, the validity of the reference is checked, i.e. the referenced tuple should exist. In case of deletion, depending on the foreign key definition, the deletion of a tuple is forbidden if there are dependent foreignkey records, or the deletion of a record may cause the deletion of corresponding foreign-key records, or the corresponding foreign keys are set to null. Referential integrity is really broader and encompasses databases in general and not only relational ones [4] . Durability means that once a transaction, i.e. a set of update operations on the data, is committed, it cannot be abrogated. In the centralized databases systems, checkpoint and log are normally used to recover the state of the database in case of a system failure (e.g. the contents of main memory disappear due to a power loss and the content of a broken disk becoming illegible) [22] . Checkpoint is the point of synchronization between the database and transaction log file when all buffers are force-written to secondary storage [7] . For this kind of failure, the database can be reconstructed only if:", "cite_spans": [{"start": 141, "end": 145, "text": "[22]", "ref_id": "BIBREF21"}, {"start": 222, "end": 225, "text": "[8]", "ref_id": "BIBREF7"}, {"start": 321, "end": 324, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 536, "end": 540, "text": "[11]", "ref_id": "BIBREF10"}, {"start": 1085, "end": 1088, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 1473, "end": 1477, "text": "[22]", "ref_id": "BIBREF21"}, {"start": 1625, "end": 1628, "text": "[7]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Database Consistency, Durability, Backup and Disaster Crash Recovery"}, {"text": "-the log has been stored on another disk, separately from the failure one(s), -the log has been kept after a checkpoint, and -the log provides information to redo changes performed by transactions before the failure, and after the latest checkpoint.", "cite_spans": [], "ref_spans": [], "section": "Database Consistency, Durability, Backup and Disaster Crash Recovery"}, {"text": "To protect the database against media failures an up-to-date backup of the database, i.e. a copy of the database separate from the database itself, is used [22] . A backup of the database and its log can be periodically copied onto offline storage media [7] . In case of database corruption or device failure, the database can be restored from one of the backup copies, typically the most recent one [3] . In this case, the recovery is carried out using the backup and the log -see [15] , for more details. A database has a Disaster Crash when the main memory and the log, or a part of the log, are lost. Therefore, to recover the database, an old, maybe obsolete, backup of the database is used. Data which was not part of the backup will be lost. In case of a disaster crash, the system cannot guarantee the durability property. However, in a centralized database, recovery from a backup provides a database which has a consistent state.", "cite_spans": [{"start": 156, "end": 160, "text": "[22]", "ref_id": "BIBREF21"}, {"start": 254, "end": 257, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 400, "end": 403, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 482, "end": 486, "text": "[15]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Database Consistency, Durability, Backup and Disaster Crash Recovery"}, {"text": "Each database of a microservice can be seen as a centralized database. Seen across an entire microservice architecture, the microservice databases represent a distributed database system. A multidatabase is a distributed database system in which each site maintains complete autonomy. Federated multidatabase is a hybrid between distributed and centralized databases. It is a distributed system for global users and a centralized one for local users [7] . According to the definitions above, stateful microservice architectures can therefore be seen as a federated multidatabase.", "cite_spans": [{"start": 450, "end": 453, "text": "[7]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Microservices as a Federated Multidatabase"}, {"text": "A microservice database can store either a snapshot of the current state of the data, containing the most recent value of data, or an event log, i.e. the current state of the data can be rebuilt by replaying the log entries, which record the changes to the microservice state in the database transaction log. Let's consider an example of a microservice managing orders. Using the snapshot architecture, the current state of an order can be stored in a row of a relational table Order. When using the event sourcing (log) [17] , the application persists each order as a sequence of events e.g., listing the creation of the order, its update with customer details and the addition of each line item.", "cite_spans": [{"start": 521, "end": 525, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Microservices as a Federated Multidatabase"}, {"text": "Each microservice ensures the durability and the consistency of its database, like in centralized databases. In the microservice context, each microservice manages its own database and stores independent backup of its own database, in order to permit disaster recovery from backup. However, while managing consistent backup is simple in a centralized database, maintaining consistent backups with distributed persistence in a federated multidatabase is challenging, as shown in the survey of [13] . So a model providing global consistent backup is necessary for microservices.", "cite_spans": [{"start": 492, "end": 496, "text": "[13]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Microservices as a Federated Multidatabase"}, {"text": "Microservice architecture deals with breaking foreign key relationships [16] . Each microservice can refer to other microservices data through loosely coupled references (i.e., URLs or links), which can be dereferenced using the API provided by the microservice managing the referenced data. Microservices are independent and the managing reference integrity between them is challenging. As for the World Wide Web [9, 12] , there is no guarantee that a link retrieved from a microservice points to a valid URL [18] . In the following section, we propose a model providing global reference integrity for microservices.", "cite_spans": [{"start": 72, "end": 76, "text": "[16]", "ref_id": "BIBREF15"}, {"start": 414, "end": 417, "text": "[9,", "ref_id": "BIBREF8"}, {"start": 418, "end": 421, "text": "12]", "ref_id": "BIBREF11"}, {"start": 510, "end": 514, "text": "[18]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Microservices as a Federated Multidatabase"}, {"text": "In [18] , the authors have addressed the problem of backing up an entire microservice architecture and recovering it in case of a disaster crash affecting one microservice. They defined the BAC theorem, inspired from the CAP Theorem [5] , which states that when backing up an entire microservice architecture, it is not possible to have both availability and consistency.", "cite_spans": [{"start": 3, "end": 7, "text": "[18]", "ref_id": "BIBREF17"}, {"start": 233, "end": 236, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Microservice Disaster Recovery"}, {"text": "Let us consider the microservice architecture defined in [18] , where each microservice manages its own database and can refer to other microservices data through loosely coupled references. Each microservice does independent backup of its own database for the purpose of allowing disaster recovery from backup. Figure 1 presents an example of two microservices with their independent backup, data of the microservice Order referring data of microservice Customer. Database of each microservice is represented in gray and data in black. Each database contains three entities. Entities C/i (i \u2208 {1, 2, 3}) correspond to customers, described by a name, and are managed by microservice Customer. Entities O/i (i \u2208 {1, 2, 3}) correspond to orders and are managed by microservice Order. Each order O/i refers to a customer C/i. Backups of the database are represented in blue. The backup of microservice Customer only contains a copy of customers C/1 and C/2. The backup and the database of microservice Order are, on the contrary, synchronized.", "cite_spans": [{"start": 57, "end": 61, "text": "[18]", "ref_id": "BIBREF17"}], "ref_spans": [{"start": 312, "end": 320, "text": "Figure 1", "ref_id": null}], "section": "Microservice Disaster Recovery"}, {"text": "As explained in [18] , in case of disaster crash, independent backup may lead to broken link (see Fig. 2 ): no more customer C/3 exists after Customer recovery, then O/3 has a broken link.", "cite_spans": [{"start": 16, "end": 20, "text": "[18]", "ref_id": "BIBREF17"}], "ref_spans": [{"start": 98, "end": 104, "text": "Fig. 2", "ref_id": null}], "section": "Microservice Disaster Recovery"}, {"text": "A solution to avoid broken link is to synchronize the backup of all microservices, leading to limited autonomy of microservices and loss of data. In Fig. 3 , both order and customer C/3 and O/3 are lost after the recovery. Please note that broken link can also appear when a referenced data is deleted, e.g. when a customer is deleted in the local database of microservice Customer. In this case, the referential integrity is not respected. As aforementioned, several approaches indicate that microservice architecture implies some challenging problems of data integrity and consistency management [2, 18] , as well as the difficulty of managing consistent backups due to distributed persistence [13] . However, as far as we know, no approach proposes a solution to such problems. In the following, we present a solution that can bypass such referential integrity violation and broken links.", "cite_spans": [{"start": 598, "end": 601, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 602, "end": 605, "text": "18]", "ref_id": "BIBREF17"}, {"start": 696, "end": 700, "text": "[13]", "ref_id": "BIBREF12"}], "ref_spans": [{"start": 149, "end": 155, "text": "Fig. 3", "ref_id": "FIGREF1"}], "section": "Microservice Disaster Recovery"}, {"text": "In this work, we focus on referential integrity. We present a solution to help the user in the recovery of the system referential integrity in case of a disaster crash. We define the global consistency as a time-dependent property. We propose a new global consistency definition, called the weak global referential consistency.", "cite_spans": [], "ref_spans": [], "section": "Our Solution: A Weak Referential Integrity Management"}, {"text": "Our solution provides information about the global state in case of a disaster crash that the users can pinpoint exactly the location, and time interval, of missing data which needs to be manually repaired.", "cite_spans": [], "ref_spans": [], "section": "Our Solution: A Weak Referential Integrity Management"}, {"text": "In the following, we first present the context and assumptions (Subsect. 3.1), without taking disaster crash into consideration. Then, we introduce our definition of global consistency (Subsect. 3.2). Based on this definition, we show the ", "cite_spans": [], "ref_spans": [], "section": "Our Solution: A Weak Referential Integrity Management"}, {"text": "Backup of the local database of microservice \u00b5s ]t (i,k) , t (j,k ) ] Amnesia interval of an entity e method of recovery from a disaster crash affecting one microservice. All symbols used in this article can be found in Table 1 above.", "cite_spans": [], "ref_spans": [{"start": 220, "end": 227, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Our Solution: A Weak Referential Integrity Management"}, {"text": "In this article, microservice follows the pattern called Database per Service (defined in [19] ), where each microservice has full control of a private database, persistent data being accessible to other services only via an API. Each microservice also use an event-driven architecture, such as the one defined in [20] , consuming and publishing a sequence of state-changing events.", "cite_spans": [{"start": 90, "end": 94, "text": "[19]", "ref_id": "BIBREF18"}, {"start": 314, "end": 318, "text": "[20]", "ref_id": "BIBREF19"}], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "The following are our assumptions:", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "-Microservices are part of the same application.", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "-All microservices of an application trust each other.", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "-Each microservice \u03bcs has a database D storing a set of entities.", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "-Each entity e \u2208 D can be either a RESTful API resource, a relational tuple, a key-value record, a document or graph database item. -Each entity e has a Uniform Resource Identifier, URI e , that identifies the entity. -The state of each entity e is read, updated and deleted using standard HTTP protocol primitives (GET, PUT and DELETE). In addition, we introduce two additional operations: getReference, deleteReference. -Each microservice \u03bcs ensures the consistency and the durability of its own database D.", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "Taking into consideration the following ; handling the references between the different microservices and ensuring that the system is reliable when no failure occurs:", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "-Each microservice has its own clock. The clock of different microservices are not necessarily synchronized. -An entity e , managed by a microservice \u03bcs , can refer to another entity e managed by a microservice \u03bcs. -The reference from microservice \u03bcs to an entity e, managed by a microservice \u03bcs, is the couple (URI e , t j ) with the timestamp t j marking the date of the last update of entity e in D as it is known by the microservice \u03bcs , i.e. exactly when \u03bcs queries the microservice \u03bcs, using the clock of microservice \u03bcs.", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "There are 2 cases as far as reference storage is concerned:", "cite_spans": [], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "1. the minimalist case consists in just storing the reference and the most recent modified timestamp, i.e. couple (URI e , t j ); 2. the eager/self-contained backup case consists in storing a copy of the referenced entity state, that can be cached by \u03bcs . When microservice \u03bcs stores a copy of the referenced entity in its cache, this former copy is considered as detached, identical to detached entity in object-relational mapping using JPA specification [10] . Detached means that the copy is not managed by \u03bcs, microservice \u03bcs being responsible for keeping its cache up-to-date. Cached representation is only a representation of the original entity state, thus it may only contain a projection. For our solution, we assume that it is possible to reconstruct the original entity state from its cached representation.", "cite_spans": [{"start": 456, "end": 460, "text": "[10]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Context and Assumptions"}, {"text": "In case of no disaster crash, the global consistency can be defined as follows: Case of Snapshot Data Storage Pattern. When using the snapshot data storage pattern, each local database contains the current state of its microservice. In order to guarantee the referential integrity in the microservice architecture, a microservice \u03bcs, cannot delete an entity e, if there is an entity e managed by another microservice \u03bcs that refers to the entity e. We suggest a referential integrity mechanism based on dependency counters, as follows:", "cite_spans": [], "ref_spans": [], "section": "Global Consistency"}, {"text": "-Each entity e managed by a microservice \u03bcs is associated with a dependency counter d e . This counter indicates how many other entities managed by other microservices refer to entity e. It is initially set at 0. -When a microservice \u03bcs wants to create the entity e that refers an entity e managed by \u03bcs, it sends a getReference message to microservice \u03bcs. The corresponding dependency counter d e is incremented. Then, \u03bcs sends the couple (URI e , t j ) back to \u03bcs , with t j , the date of the most recent update of entity e. -When microservice \u03bcs receives the information about e, it creates the entity e . -When microservice \u03bcs deletes an entity e that refers e, it sends a message deleteReference to microservice \u03bcs, indicating that the reference to e does not exist any more. d e is therefore decremented. -Microservice \u03bcs cannot delete an entity e if its dependency counter is d e > 0.", "cite_spans": [], "ref_spans": [], "section": "Global Consistency"}, {"text": "It retains the most recent value of entity e with its most recent update time, t j , and flags the entity by \u22a5 indicating that e must be deleted when its dependency counter reaches the value of 0.", "cite_spans": [], "ref_spans": [], "section": "Global Consistency"}, {"text": "According to Definition 1, a reliable microservice system using the referential integrity mechanism based on dependency counters, will always be globally consistent.", "cite_spans": [], "ref_spans": [], "section": "Global Consistency"}, {"text": "When choosing event sourcing as data storage pattern [20] , each local database contains an event log, which records all changes of the microservice state. Thus, it is possible to rebuild the current state of the data by replaying the event log. In this case, we propose the following referential integrity mechanism:", "cite_spans": [{"start": 53, "end": 57, "text": "[20]", "ref_id": "BIBREF19"}], "ref_spans": [], "section": "Case of Event Sourcing Data Storage Pattern."}, {"text": "-When a microservice \u03bcs wants to create the entity e that refers an entity e managed by \u03bcs, it sends a getReference message to microservice \u03bcs. When \u03bcs receives the information about e, it creates the entity e and a creation event, associated with the corresponding reference (URI e , t j ), is stored in the log of \u03bcs . -When an entity e of microservice \u03bcs must be deleted, instead of deleting it, the microservice \u03bcs flags it by \u22a5, and a deletion event, associated with the related timestamp, is stored in its log, representing the most recent valid value of entity e.", "cite_spans": [], "ref_spans": [], "section": "Case of Event Sourcing Data Storage Pattern."}, {"text": "Thus, it is easy to prove that global consistency state can be obtained from the logs. For each couple (URI e , t j ) of a referenced entity e, timestamp t j must appear in the event log of microservice \u03bcs. Moreover the most recent record associated with entity e, corresponding to an update or deletion of e, in the event log of \u03bcs, has a timestamp t i \u2265 t j , with t j , any timestamp appearing in any reference couple (URI e , t j ) stored in the event log of any other microservice referencing e.", "cite_spans": [], "ref_spans": [], "section": "Case of Event Sourcing Data Storage Pattern."}, {"text": "As explained in Sect. 2.3, disaster crash can occur in microservice architectures. In the following, we consider disaster crash affecting only one microservice.", "cite_spans": [], "ref_spans": [], "section": "Fault Tolerant Management of Microservice Referential Integrity"}, {"text": "To protect the local database from media-failure, each microservice stores an up-to-date backup of its database, i.e. a copy of the database separate from the database itself. Each microservice individually manages the backup of its database. The way in which microservices independently manage their backup is out of the scope of this paper.", "cite_spans": [], "ref_spans": [], "section": "Fault Tolerant Management of Microservice Referential Integrity"}, {"text": "A disaster crash of a microservice \u03bcs means that its local database and its log are lost and we have to recover the database from a past backup. The backup provides a consistent state of the local database. However, as the database has been recovered from a past backup, data could have been lost. In order to provide a state of the local database as close as possible to the one of the database before the failure, data cached by other microservices can be used. When a microservice \u03bcs refers to an entity managed by another microservice \u03bcs, it can store a detached copy of the referenced entity. Therefore, these detached copies can be used to update the state of the database obtained after recovery from the backup.", "cite_spans": [], "ref_spans": [], "section": "Fault Tolerant Management of Microservice Referential Integrity"}, {"text": "In the following, we present the concepts used to manage disaster crash, our recovery protocol, how to optimize it and we define the Weak Global Referential Integrity.", "cite_spans": [], "ref_spans": [], "section": "Fault Tolerant Management of Microservice Referential Integrity"}, {"text": "To manage disaster crash, our assumptions are:", "cite_spans": [], "ref_spans": [], "section": "Backup and Recovery, Amnesia Interval and New Epoch."}, {"text": "-Each entity of the local database of microservice \u03bcs is associated with an epoch identity E k . An epoch is a new period after a disaster crash recovery. A new epoch E k begins at the first access of an entity after recovery. Therefore, a timestamp t (i,k) associated with an entity e represents the ith timestamp related to epoch E k . k = 0 when no crash has occurred, k > 0 otherwise. The value of k always increases, being associated with time. -When a backup B of the local database of microservice \u03bcs is done, operation BCK, the backup is associated with clock epoch identity E k , and with a creation timestamp t (i,k ) , such that: all entities e, stored in backup B, have an updated timestamp t (j,k ) \u2264 t (i,k ) . Epoch E k associated with backup and epoch E k associated with the local database are such that: k \u2264 k. -As long as there is no disaster crash, the local database and the backup are associated with the same epoch identity. -In case of disaster crash of microservice \u03bcs, when the local database is locally recovered from an past obsolete backup created at time t (c,k ) , it is known that local database has an amnesia interval starting from t (c,k ) . This amnesia interval is associated with all entities saved in the backup and lasts until such entities are accessed again (see Definition 2).", "cite_spans": [], "ref_spans": [], "section": "Backup and Recovery, Amnesia Interval and New Epoch."}, {"text": "-Each entity of the recovered database is associated with a timestamp related to epoch E k of the backup. This timestamp remains as long as no updates have been carried out. A new epoch E k begins at the first reading or written access of an entity, k containing the current date. A written operation, PUT, overwrites whatever value was recovered. However, epoch should also be updated after a reading operation, GET. Any other microservice reading from the state of the recovered entity will establish a causal dependency, which would be in conflict with further more recent recovered values from the previous epoch (see [1] for more details).", "cite_spans": [{"start": 622, "end": 625, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Backup and Recovery, Amnesia Interval and New Epoch."}, {"text": "An amnesia interval of microservice \u03bcs is a time interval indicating that a disaster crash has occurred for the local database of \u03bcs. This interval is associated with each entity managed by \u03bcs. An amnesia interval ]t (i,k ) , t (j,k) ] of an entity e means that:", "cite_spans": [], "ref_spans": [], "section": "Definition 2. Amnesia Interval"}, {"text": "-Epoch E k is the epoch associated with the backup used for the database recovery. -Timestamp t (i,k ) corresponds to the time of most recent known update of e.", "cite_spans": [], "ref_spans": [], "section": "Definition 2. Amnesia Interval"}, {"text": "It is either the timestamp associated with the backup used for recovery, or the timestamp of a cached copy of e stored in a microservice referring entity e. -Timestamp t (j,k) corresponds to the first reading or written operation on e from another microservice \u03bcs , after t (i,k ) (k < k).", "cite_spans": [], "ref_spans": [], "section": "Definition 2. Amnesia Interval"}, {"text": "Weak Global Referential Integrity. After a crash recovery, data can be lost, so we define a weak global referential integrity of the microservice architecture. Weak means that either the global referential integrity has been checked, verifying Definition 1, or an amnesia is discovered; data has been lost as well as the interval of time when the data was lost. This makes it possible to focus on the manual data recovery and reconstruction effort within the amnesia interval. \u2022 or t ( ,\u03ba) \u2208 ]t (i,k ) , t (j,k) ], with ]t (i,k ) , t (j,k) ] the amnesia interval associated with the referenced entity e, after a disaster crash of \u03bcs that manages e.", "cite_spans": [], "ref_spans": [], "section": "Definition 2. Amnesia Interval"}, {"text": "Consider a scenario of two microservices \u03bcs and \u03bcs , \u03bcs referencing an entity managed by \u03bcs (see Fig. 4 ), but without storing any cache of the referenced entity. In figures, only timestamps of one entity of microservice \u03bcs are considered, timestamps and epoch identities being only represented by numbers. In Fig. 4 , at time t (1, 1) an entity is created by microservice \u03bcs ; operation PUT. A backup B is made, storing entities of microservice \u03bcs created before t (2, 1) ; operation BCK. Microservice \u03bcs refers the entity of \u03bcs created at time t (1, 1) ; operation GET. An update of the entity is carried out by the microservice \u03bcs at time t (2, 1) ; operation PUT. When disaster crash appears to \u03bcs (see red flash), \u03bcs must recover using the backup, update of time t (2, 1) is lost, therefore it has amnesia that begins from t (1, 1) . An update is done to the entity, then a new epoch 2 begins and timestamp t (1, 2) is associated to the updated value. The amnesia interval is then updated to ]t (1, 1) , t (1, 2) ]. If \u03bcs does another GET to refresh the referenced value, the up-to-date timestamp t (1, 2) is sent by \u03bcs.", "cite_spans": [{"start": 329, "end": 332, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 333, "end": 335, "text": "1)", "ref_id": "BIBREF0"}, {"start": 466, "end": 469, "text": "(2,", "ref_id": "BIBREF1"}, {"start": 470, "end": 472, "text": "1)", "ref_id": "BIBREF0"}, {"start": 548, "end": 551, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 552, "end": 554, "text": "1)", "ref_id": "BIBREF0"}, {"start": 644, "end": 647, "text": "(2,", "ref_id": "BIBREF1"}, {"start": 648, "end": 650, "text": "1)", "ref_id": "BIBREF0"}, {"start": 770, "end": 773, "text": "(2,", "ref_id": "BIBREF1"}, {"start": 774, "end": 776, "text": "1)", "ref_id": "BIBREF0"}, {"start": 830, "end": 833, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 834, "end": 836, "text": "1)", "ref_id": "BIBREF0"}, {"start": 914, "end": 917, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 918, "end": 920, "text": "2)", "ref_id": "BIBREF1"}, {"start": 1000, "end": 1003, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 1004, "end": 1006, "text": "1)", "ref_id": "BIBREF0"}, {"start": 1011, "end": 1014, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 1015, "end": 1017, "text": "2)", "ref_id": "BIBREF1"}, {"start": 1104, "end": 1107, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 1108, "end": 1110, "text": "2)", "ref_id": "BIBREF1"}], "ref_spans": [{"start": 97, "end": 103, "text": "Fig. 4", "ref_id": null}, {"start": 307, "end": 316, "text": "In Fig. 4", "ref_id": null}], "section": "Definition 2. Amnesia Interval"}, {"text": "Recovery Protocol. When a disaster crash occurs to a microservice \u03bcs, \u03bcs informs all other services of its recovery. Moreover, when microservices stored copies of the entities they refer to, in their cache, the amnesia interval associated with each recovered entity of \u03bcs can be reduced using cached replicas. In order to do so, the steps are:", "cite_spans": [], "ref_spans": [], "section": "Definition 2. Amnesia Interval"}, {"text": "-After the recovery of \u03bcs, an event indicating that there is amnesia is sent, or broadcast, to other microservices. -When a microservice \u03bcs receives an amnesia event from microservice \u03bcs, managing an entity e it refers to; if it has stored a replica of e in its cache, then \u03bcs sends the replica of the entity it refers to, to \u03bcs. In Fig. 5 , \u03bcs stores an up-to-date value of the referenced entity, after the backup of \u03bcs ; operation GET. After the recovery from the past backup of time t (1, 1) , \u03bcs sends an event about its amnesia, associated with interval ]t (1,1) , ]. After receiving this amnesia event, \u03bcs sends its up-to-date value, associated with t (2,1) > t (1, 1) , to \u03bcs ; event reply. \u03bcs stores this up-to-date value, associated with timestamp t (2, 1) , and updates the amnesia interval to ]t (2, 1) , ]. After a update is done to the entity, a new epoch 2 begins and timestamp t (1, 2) is associated to the updated value ; operation PUT. The amnesia interval is then updated to ]t (2,1) , t (1, 2) ].", "cite_spans": [{"start": 488, "end": 491, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 492, "end": 494, "text": "1)", "ref_id": "BIBREF0"}, {"start": 668, "end": 671, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 672, "end": 674, "text": "1)", "ref_id": "BIBREF0"}, {"start": 759, "end": 762, "text": "(2,", "ref_id": "BIBREF1"}, {"start": 763, "end": 765, "text": "1)", "ref_id": "BIBREF0"}, {"start": 807, "end": 810, "text": "(2,", "ref_id": "BIBREF1"}, {"start": 811, "end": 813, "text": "1)", "ref_id": "BIBREF0"}, {"start": 894, "end": 897, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 898, "end": 900, "text": "2)", "ref_id": "BIBREF1"}, {"start": 1006, "end": 1009, "text": "(1,", "ref_id": "BIBREF0"}, {"start": 1010, "end": 1012, "text": "2)", "ref_id": "BIBREF1"}], "ref_spans": [{"start": 333, "end": 339, "text": "Fig. 5", "ref_id": "FIGREF4"}], "section": "Definition 2. Amnesia Interval"}, {"text": "After a disaster crash of \u03bcs: either \u03bcs is immediately available after its local recovery, or it expects information sent by other microservices that refer its entities before the disaster crash, to provide a more recent database snapshot than the past used backup, updating the value stored in the backup with the copy stored in the cache of the other microservices.", "cite_spans": [], "ref_spans": [], "section": "Availability vs Consistency."}, {"text": "If we are uncertain that all microservices will answer the amnesia event or if \u03bcs ignores or partially knows which microservices refer to (case 1), \u03bcs can wait for a defined timeout.", "cite_spans": [], "ref_spans": [], "section": "Availability vs Consistency."}, {"text": "If we assume that all microservices are available and will answer to the amnesia event (case 2), \u03bcs waits until all microservices have sent their reply to the amnesia event.", "cite_spans": [], "ref_spans": [], "section": "Availability vs Consistency."}, {"text": "After the timeout (case 1) or the reception of all responses (case 2), the recovery is ended and \u03bcs is available.", "cite_spans": [], "ref_spans": [], "section": "Availability vs Consistency."}, {"text": "When dependency counters are used (see Sect. 3.2) and if we are sure that the identity of all microservices that refer to \u03bcs is known after the disaster crash: an optimization of the recovery process can be used. In this case, an amnesia event is sent only to all microservices referring to \u03bcs, instead of broadcast, and \u03bcs waits until all the aforementioned microservices reply. To do so, the address of each microservice referring to \u03bcs should be stored by \u03bcs, when the dependency counter is updated. Each referencing microservice can either send the value it stores in its cache, or a message indicating that it is no longer concerned by the amnesia, because it currently does not refer to any entity of \u03bcs.", "cite_spans": [], "ref_spans": [], "section": "Availability vs Consistency."}, {"text": "The choice between the aforementioned steps depends on the focus on availability (\u03bcs is available as soon as possible after its disaster crash, with a large amnesia interval) or on consistency (we prefer to wait in order to provide a more recent snapshot than the one used for the recovery before making \u03bcs available).", "cite_spans": [], "ref_spans": [], "section": "Availability vs Consistency."}, {"text": "In this paper, we have focused on preserving referential integrity within microservice architecture during disaster recovery. We have introduced a definition of weak global referential consistency and a recovery protocol taking advantage of replicas found in microservice caches. These are merged with local backup to reduce the amnesia interval of the recovered microservice. The approach has been validated under several assumptions: direct references to simple entities, single crashes and no concurrent recovery of more than one failed microservice.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "In this paper we focused on reliability aspects, whereas as part of future work we plan to assess the performance implications of our approach in depth. We will also address more complex relationships between microservices, e.g., transitive or circular dependencies, which may span across multiple microservices. While microservice architecture is known for its ability to isolate failures, which should not cascade across multiple microservices, it remains an open question how to apply our approach to perform the concurrent recovery of multiple microservices which may have failed independently over an overlapping period of time.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Causal memory: definitions, implementation, and programming", "authors": [{"first": "M", "middle": [], "last": "Ahamad", "suffix": ""}, {"first": "G", "middle": [], "last": "Neiger", "suffix": ""}, {"first": "J", "middle": ["E"], "last": "Burns", "suffix": ""}, {"first": "P", "middle": [], "last": "Kohli", "suffix": ""}, {"first": "P", "middle": ["W"], "last": "Hutto", "suffix": ""}], "year": 1995, "venue": "Distrib. Comput", "volume": "9", "issn": "1", "pages": "37--49", "other_ids": {"DOI": ["10.1007/BF01784241"]}}, "BIBREF1": {"ref_id": "b1", "title": "Microservices: the evolution and extinction of web services? Microservices", "authors": [{"first": "L", "middle": [], "last": "Baresi", "suffix": ""}, {"first": "M", "middle": [], "last": "Garriga", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "3--28", "other_ids": {"DOI": ["10.1007/978-3-030-31646-4_1"]}}, "BIBREF2": {"ref_id": "b2", "title": "Coordinating backup/recovery and data consistency between database and file systems", "authors": [{"first": "S", "middle": [], "last": "Bhattacharya", "suffix": ""}, {"first": "C", "middle": [], "last": "Mohan", "suffix": ""}, {"first": "K", "middle": ["W"], "last": "Brannon", "suffix": ""}, {"first": "I", "middle": [], "last": "Narang", "suffix": ""}, {"first": "H", "middle": ["I"], "last": "Hsiao", "suffix": ""}, {"first": "M", "middle": [], "last": "Subramanian", "suffix": ""}], "year": 2002, "venue": "ACM SIGMOD International Conference on Management of data", "volume": "", "issn": "", "pages": "500--511", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Referential integrity is important for databases", "authors": [{"first": "M", "middle": [], "last": "Blaha", "suffix": ""}], "year": 2005, "venue": "Modelsoft Consulting Corp", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "CAP twelve years later: how the \"rules\" have changed", "authors": [{"first": "E", "middle": [], "last": "Brewer", "suffix": ""}], "year": 2012, "venue": "Computer", "volume": "45", "issn": "2", "pages": "23--29", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "From monolithic to microservices: an experience report from the banking domain", "authors": [{"first": "A", "middle": [], "last": "Bucchiarone", "suffix": ""}, {"first": "N", "middle": [], "last": "Dragoni", "suffix": ""}, {"first": "S", "middle": [], "last": "Dustdar", "suffix": ""}, {"first": "S", "middle": ["T"], "last": "Larsen", "suffix": ""}, {"first": "M", "middle": [], "last": "Mazzara", "suffix": ""}], "year": 2018, "venue": "IEEE Softw", "volume": "35", "issn": "3", "pages": "50--55", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Database Systems. ke-3", "authors": [{"first": "T", "middle": [], "last": "Connoly", "suffix": ""}, {"first": "C", "middle": [], "last": "Begg", "suffix": ""}], "year": 1998, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "7th International Conference on Very Large Data Bases (VLDB)", "authors": [{"first": "C", "middle": ["J"], "last": "Date", "suffix": ""}], "year": 1981, "venue": "", "volume": "", "issn": "", "pages": "2--12", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Referential integrity of links in open hypermedia systems", "authors": [{"first": "H", "middle": ["C"], "last": "Davis", "suffix": ""}], "year": 1998, "venue": "9th ACM Conference on Hypertext and Hypermedia: Links, Objects, Time and Space", "volume": "", "issn": "", "pages": "207--216", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Java persistence API", "authors": [{"first": "L", "middle": [], "last": "Demichiel", "suffix": ""}, {"first": "M", "middle": [], "last": "Keith", "suffix": ""}], "year": 2006, "venue": "JSR", "volume": "220", "issn": "", "pages": "", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Fundamentals of Database Systems", "authors": [{"first": "R", "middle": [], "last": "Elmasri", "suffix": ""}, {"first": "S", "middle": [], "last": "Navathe", "suffix": ""}], "year": 2010, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Fixing the \"broken-link\" problem: the W3objects approach", "authors": [{"first": "D", "middle": [], "last": "Ingham", "suffix": ""}, {"first": "S", "middle": [], "last": "Caughey", "suffix": ""}, {"first": "M", "middle": [], "last": "Little", "suffix": ""}], "year": 1996, "venue": "Comput. Netw. ISDN Syst", "volume": "28", "issn": "", "pages": "1255--1268", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Drivers and barriers for microservice adoptiona survey among professionals in Germany", "authors": [{"first": "H", "middle": [], "last": "Knoche", "suffix": ""}, {"first": "W", "middle": [], "last": "Hasselbring", "suffix": ""}], "year": 2019, "venue": "Enterp. Model. Inf. Syst. Architect. (EMISAJ)", "volume": "14", "issn": "", "pages": "1--1", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Microservices a definition of this new architectural term", "authors": [{"first": "J", "middle": [], "last": "Lewis", "suffix": ""}, {"first": "M", "middle": [], "last": "Fowler", "suffix": ""}], "year": 2014, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "ARIES: a transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging", "authors": [{"first": "C", "middle": [], "last": "Mohan", "suffix": ""}, {"first": "D", "middle": [], "last": "Haderle", "suffix": ""}, {"first": "B", "middle": [], "last": "Lindsay", "suffix": ""}, {"first": "H", "middle": [], "last": "Pirahesh", "suffix": ""}, {"first": "P", "middle": [], "last": "Schwarz", "suffix": ""}], "year": 1992, "venue": "ACM Trans. Database Syst. (TODS)", "volume": "17", "issn": "1", "pages": "94--162", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Building Microservices: Designing Fine-Grained Systems", "authors": [{"first": "S", "middle": [], "last": "Newman", "suffix": ""}], "year": 2015, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "The dark side of event sourcing: managing data conversion", "authors": [{"first": "M", "middle": [], "last": "Overeem", "suffix": ""}, {"first": "M", "middle": [], "last": "Spoor", "suffix": ""}, {"first": "S", "middle": [], "last": "Jansen", "suffix": ""}], "year": 2017, "venue": "24th International Conference on Software Analysis, Evolution and Reengineering (SANER)", "volume": "", "issn": "", "pages": "193--204", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "Consistent disaster recovery for microservices: the BAC theorem", "authors": [{"first": "G", "middle": [], "last": "Pardon", "suffix": ""}, {"first": "C", "middle": [], "last": "Pautasso", "suffix": ""}, {"first": "O", "middle": [], "last": "Zimmermann", "suffix": ""}], "year": 2018, "venue": "IEEE Cloud Comput", "volume": "5", "issn": "1", "pages": "49--59", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Pattern: database per service", "authors": [{"first": "C", "middle": [], "last": "Richardson", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Pattern: event sourcing", "authors": [{"first": "C", "middle": [], "last": "Richardson", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Architectural patterns for microservices: a systematic mapping study", "authors": [{"first": "D", "middle": [], "last": "Taibi", "suffix": ""}, {"first": "V", "middle": [], "last": "Lenarduzzi", "suffix": ""}, {"first": "C", "middle": [], "last": "Pahl", "suffix": ""}], "year": 2018, "venue": "CLOSER", "volume": "", "issn": "", "pages": "221--232", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Database Systems: The Complete Book, 1st edn", "authors": [{"first": "J", "middle": ["D"], "last": "Ullman", "suffix": ""}, {"first": "H", "middle": [], "last": "Garcia-Molina", "suffix": ""}, {"first": "J", "middle": [], "last": "Widom", "suffix": ""}], "year": 2001, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Microservices tenets", "authors": [{"first": "O", "middle": [], "last": "Zimmermann", "suffix": ""}], "year": 2016, "venue": "Comput. Sci. Res. Dev", "volume": "32", "issn": "", "pages": "301--310", "other_ids": {"DOI": ["10.1007/s00450-016-0337-0"]}}, "BIBREF23": {"ref_id": "b23", "title": "Introduction to microservice API patterns (MAP)", "authors": [{"first": "O", "middle": [], "last": "Zimmermann", "suffix": ""}, {"first": "M", "middle": [], "last": "Stocker", "suffix": ""}, {"first": "D", "middle": [], "last": "L\u00fcbke", "suffix": ""}, {"first": "C", "middle": [], "last": "Pautasso", "suffix": ""}, {"first": "U", "middle": [], "last": "Zdun", "suffix": ""}], "year": 2019, "venue": "Joint Post-Proceedings of the First and Second International Conference on Microservices", "volume": "78", "issn": "", "pages": "1--4", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "An example of microservice architecture with independent backup (Color figure online) The link from the Order microservice to entity C/3 is broken after the recovery of Customer microservice from an old backup", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Synchronized backup of an entire microservice architecture", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Weak global consistency After a disaster crash recovery of a microservice \u03bcs, the system checks a weak global consistency iff: -(local database consistency) each local database is locally consistent in the traditional sense of a database, i.e. all its integrity constraints are satisfied. and -(weak global referential integrity) the timestamp value associated with each reference is either less than or equal to the timestamp value of the corresponding referenced entity or included in an amnesia interval. Formally: for each couple (URI e , t ( ,\u03ba) ) associated with an entity of \u03bcs referencing another entity e of \u03bcs: \u2022 either t ( ,\u03ba) \u2264 t (i,k ) , with t (i,k ) the most recent update timestamp of e in \u03bcs, epochs \u03ba and k being comparable (\u03ba \u2264 k ); Example of a scenario with 2 microservices, without cached data. P UT represents a state change of the referenced entity. BCK indicates when a backup snapshot is taken. LR shows when the microservice is locally recovered from the backup. (Color figure online)", "latex": null, "type": "figure"}, "FIGREF3": {"text": "-When microservice \u03bcs receives replies carrying information from \u03bcs about its entity e, it compares the value of e, associated with timestamp t (i,k ) , with the value, associated with timestamp t (j,k) , it stored, if epochs k and k are comparable. Then, it retains the more up-to-date value and shrinks the amnesia interval associated with e if necessary. -Once a read operation or an update operation is done on e, a new epoch begins, and the first timestamp associated with this new epoch represents the end of the amnesia interval. -The beginning of the amnesia interval can still be shifted if more up-to-date values are received from belated replies from other cached replicas.", "latex": null, "type": "figure"}, "FIGREF4": {"text": "Recovery scenario using cached data more recent than the backup.", "latex": null, "type": "figure"}, "TABREF0": {"text": "Table of symbols", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Symbol </td><td>Description\n</td></tr><tr><td>\u00b5s </td><td>Microservice\n</td></tr><tr><td>D </td><td>Database of microservice \u00b5s\n</td></tr><tr><td>e </td><td>Entity of a database D\n</td></tr><tr><td>URIe </td><td>Uniform Resource Identifier of an entity e\n</td></tr><tr><td>tj </td><td>Date of the last update of an entity e in D\n</td></tr><tr><td>de </td><td>Dependency counter associated with entity e\n</td></tr><tr><td>Ek </td><td>Epoch identity, k being a timestamp\nith timestamp related to epoch Ek\n</td></tr><tr><td>t(i,k) </td><td>\u00a0</td></tr><tr><td>B </td><td>Backup of the local database of microservice \u00b5s\n</td></tr><tr><td>]t(i,k), t(j,k\u2032)] </td><td>Amnesia interval of an entity e\n</td></tr></table></body></html>"}}, "back_matter": [{"text": "Acknowledgements. The authors would like to thank Guy Pardon, Eirlys Da Costa Seixas and the referees of the article for their insightful feedback.", "cite_spans": [], "ref_spans": [], "section": "acknowledgement"}]}