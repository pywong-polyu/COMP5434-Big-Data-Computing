{
    "paper_id": "a32a98cf8d29aab912ba857af9e8160a24ae9bf5",
    "metadata": {
        "title": "Basic Pattern Graphs for the Efficient Computation of Its Number of Independent Sets",
        "authors": [
            {
                "first": "Guillermo",
                "middle": [],
                "last": "De Ita",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Benem\u00e9rita Universidad Aut\u00f3noma de Puebla",
                    "location": {
                        "settlement": "Puebla",
                        "country": "Mexico"
                    }
                },
                "email": "deita@cs.buap.mx"
            },
            {
                "first": "Miguel",
                "middle": [],
                "last": "Rodr\u00edguez",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Benem\u00e9rita Universidad Aut\u00f3noma de Puebla",
                    "location": {
                        "settlement": "Puebla",
                        "country": "Mexico"
                    }
                },
                "email": "mrodriguez@cs.buap.mx"
            },
            {
                "first": "Pedro",
                "middle": [],
                "last": "Bello",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Benem\u00e9rita Universidad Aut\u00f3noma de Puebla",
                    "location": {
                        "settlement": "Puebla",
                        "country": "Mexico"
                    }
                },
                "email": "pbello@cs.buap.mx"
            },
            {
                "first": "Meliza",
                "middle": [],
                "last": "Contreras",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Benem\u00e9rita Universidad Aut\u00f3noma de Puebla",
                    "location": {
                        "settlement": "Puebla",
                        "country": "Mexico"
                    }
                },
                "email": "mcontreras@cs.buap.mx"
            }
        ]
    },
    "abstract": [
        {
            "text": "The problem of counting the number of independent sets of a graph G (denoted as i(G)) is a classic #P-complete problem. We present some patterns on graphs that allows us the polynomial computation of i(G).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "For example, we show that for a graph G where its set of cycles can be arranged as embedded cycles, i(G) can be computed in polynomial time. Particularly, our proposal counts independent sets on outerplanar graphs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Counting problems are not only mathematically interesting, but they arise in many applications. For example, if we want to know the probability that a formula in propositional calculus is true, or the probability that a graph remains connected given a probability of failure of an edge, we have to count to approximate such probabilities.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Regarding hard counting problems, the computation of the number of independent sets of a graph has been a key for determining the frontier between efficient counting and intractable counting procedures. Vadhan [8] showed that counting the number of independent sets in graphs of maximum degree 4 is #Pcomplete. Greenhill [3] refined the previous result showing that counting the number of independent sets on graphs of degree 3 is also #P-complete.",
            "cite_spans": [
                {
                    "start": 210,
                    "end": 213,
                    "text": "[8]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 311,
                    "end": 320,
                    "text": "Greenhill",
                    "ref_id": null
                },
                {
                    "start": 321,
                    "end": 324,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Following the line of exact algorithms, Dahll\u00f6f [1] has designed a method for counting independent sets and whose exact algorithm has a worst-case upper bound of O(1.3247 n ), n being the number of vertices of the input graph. While Okamoto [5] has shown a linear-time algorithm for counting the number of independent sets for chordal graphs. Efficient algorithms for counting independent sets have been achieved after to capture structure relations lying in the topology of the graphs, allowing to design special mathematical patterns for counting independent set only on those topologies.",
            "cite_spans": [
                {
                    "start": 48,
                    "end": 51,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 241,
                    "end": 244,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "On the other hand, many combinatorial problems ask about embeddings of graphs into other objects [4] . For instance, the polynomial time solvable graph planarity problem ask whether a given graph G can be embedded in the plane in such a way that no two edges intersect (except at a common endpoint). In our case, we are interested in a particular subclass of planar graphs, those graphs whose set of vertices can be arranged as incident with the outerface, this class of graphs are called outerplanar graphs. We present here, a novel algorithm for counting the number of independent sets on outerplanar graphs.",
            "cite_spans": [
                {
                    "start": 97,
                    "end": 100,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Let G = (V, E) be an undirected graph with vertex set V and set of edges E. Two vertices v and w are called adjacent if there is an edge {v, w} \u2208 E, connecting them. Sometimes, the shorthand notation of u v is used for denoting the edge",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Notation"
        },
        {
            "text": "A path from v to w is a sequence of edges: v 0 v 1 , v 1 v 2 , . . . , v n\u22121 v n such that v = v 0 and v n = w and v k is adjacent to v k+1 , for 0 \u2264 k < n. The length of the path is n. A simple path is a path where v 0 , v 1 , . . . , v n\u22121 , v n are all distinct. A cycle is a nonempty path such that the first and last vertices are identical, and a simple cycle is a cycle in which no vertex is repeated, except that the first and last vertices are identical. A graph G is acyclic if it has no cycles. P n , C n , R n , K n , N n denote respectively, a path graph, a simple cycle, a start with one center node, the complete graph and the set of n nodes without any edge, all of those graphs have n vertices.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Notation"
        },
        {
            "text": "Given",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Notation"
        },
        {
            "text": "that is, a connected component is not a proper subgraph of any other connected subgraph of G. Note that, in a connected component, for every pair of its vertices x, y, there is a path from x to y. If an acyclic graph is also connected, then it is called a free tree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Notation"
        },
        {
            "text": "Given a graph G = (V, E), S \u2286 V is an independent set in G if for every two vertices v 1 , v 2 in S, {v 1 , v 2 } / \u2208 E. Let I(G) denote the set of all independent sets of G. An independent set S \u2208 I(G) is maximal if it is not a subset of any larger independent set and, it is maximum if it has the largest size among all independent sets in I(G). The determination of the maximum independent set has received much attention since it is a NP-complete problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Notation"
        },
        {
            "text": "The corresponding counting problem on independent sets, denoted by i(G), consists of counting the number of independent sets of a graph G. i(G) is a #Pcomplete problem for graphs G where \u0394(G) \u2265 3. i(G) remains #P-complete when it is restricted to 3-regular graphs [3] . There are different polynomial procedures for computing i(G) when \u0394(G) \u2264 2 [1, 6, 7] . In fact, all of them have linear-time complexity. In the following sections, we present exact combinatorial procedures for computing i(G) according to special patterns existing on the graphs.",
            "cite_spans": [
                {
                    "start": 264,
                    "end": 267,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 345,
                    "end": 348,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 349,
                    "end": 351,
                    "text": "6,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 352,
                    "end": 354,
                    "text": "7]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Notation"
        },
        {
            "text": ". . , k are the connected components of G [6] , then the total time complexity for computing i(G), denoted as T (i(G)), is given by the maximum rule as T (i(G)) = max{T (i(G i )): G i is a connected component of G}. Thus, a first helpful decomposition of the graph is done via its connected components and from here on, we consider as an input graph only one connected component. We start analyzing the most simple cases for one connected component. We associate to each vertex v i \u2208 V a pair (\u03b1 i , \u03b2 i ) where \u03b1 i expresses the number of sets in I(G i ) where the vertex v i does not appear, while \u03b2 i conveys the number of sets in",
            "cite_spans": [
                {
                    "start": 42,
                    "end": 45,
                    "text": "[6]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Basic Graph Patterns for the Efficient Counting of Independent Sets"
        },
        {
            "text": "The first pair (\u03b1 1 , \u03b2 1 ) is (1, 1) since for the induced subgraph G 1 = {v 1 }, I(G 1 ) = {\u2205, {v 1 }}. If we know the value for (\u03b1 i , \u03b2 i ) for any i < n, and as the next induced subgraph G i+1 is built from G i adding the vertex v i+1 and the edge",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Graph Patterns for the Efficient Counting of Independent Sets"
        },
        {
            "text": "applying the recurrence equation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Graph Patterns for the Efficient Counting of Independent Sets"
        },
        {
            "text": "If we perform a linear search on the sequential graph G starting at an extreme, e.g. beginning at v 1 and moving to its incident vertex while the recurrence (1) is applied, then in linear time on the number of vertices, the formula i(P n ) = i(G n ) = \u03b1 n + \u03b2 n = F n+2 is obtained, and where F n is the nth\u2212Fibonacci number.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Graph Patterns for the Efficient Counting of Independent Sets"
        },
        {
            "text": "In order to process the number of independent sets on a path we will use computing threads or just threads. A computing thread is a sequence of pairs (\u03b1 i , \u03b2 i ), i = 1, . . . , n used for computing the number of independent sets on a path of n vertices.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Graph Patterns for the Efficient Counting of Independent Sets"
        },
        {
            "text": "Let G = (V, E) be a tree. Traversing G in depth first build a rooted tree, whose root node is any vertex v \u2208 V , where v was the initial node for beginning the depth first search. We denote with (\u03b1 v , \u03b2 v ) the pair associated with the node v (v \u2208 G). We compute i(G) while we are traversing by G in post-order. Algorithm Count Ind Sets trees(G Input: G -a tree graph. Output: The number of independent sets of G Procedure:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case B:"
        },
        {
            "text": "Traversing G in post-order, and when a node v \u2208 G is left, assign:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case B:"
        },
        {
            "text": "If v is a parent node with a list of child nodes associated, i.e., u 1 , u 2 , ..., u k are the child nodes of v, as we have already visited all child nodes, then each pair (\u03b1 uj , \u03b2 uj ) j = 1, ..., k has been determined based on recurrence (1). Then, let",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case B:"
        },
        {
            "text": "Notice that this step includes the case when v has just one child node.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case B:"
        },
        {
            "text": "This procedure returns the number of independent sets of G in time O(n + m) which is the necessary time for traversing G in post-order. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case B:"
        },
        {
            "text": ", (x 6 , x 8 )} is a tree, we consider the post-order search and let x 1 be the root node of the tree. The number of independent sets at each level of the tree is shown in Fig. 1(a) . The procedure Count Ind Sets trees returns for \u03b1 x1 = 41, \u03b2 x1 = 36 and the total number of independent sets is: i(G) = 41 + 36 = 77.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 172,
                    "end": 181,
                    "text": "Fig. 1(a)",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Case B:"
        },
        {
            "text": "Other basic case is when G = (V, E), n = m = |V | = |E| is a simple cycle, i.e. every vertex in V has degree two. In this case, the cycle can be decomposed as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case C:"
        },
        {
            "text": "Observe that every independent set of G is an independent set of G , that is, I(G) \u2286 I(G ) since G has one edge more than G . Thus, if S \u2208 I(G ) and v 1 \u2208 S and v m \u2208 S then S is not an independent set of G. Then, I(G) can be built from I(G ) by eliminating those independent sets containing the vertices: v 1 and v m , that is expressed in the following equation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case C:"
        },
        {
            "text": "For counting independent sets on a simple cycle, we can use two threads, one of those for computing i(G ) and the other thread for computing |{S \u2208 I(G ) : v 1 \u2208 S \u2227 v m \u2208 S}|. This last value can be computed fixing on I(G ) the independent sets where v 1 is involved, which is done by computing a thread (\u03b1 i , \u03b2 i ), i = 1,..., m where the pair (\u03b1 1 , \u03b2 1 ) = (0, 1), considering in this way only the independent sets of I(G ) where v 1 appears. We apply (1) for computing the new series: (\u03b1 i , \u03b2 i ), i = 2, . . . ,m and also, in order to consider only the independent sets where v m appears, the final pair (\u03b1 m , \u03b2 m ) is taken only as (0, \u03b2 m ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case C:"
        },
        {
            "text": "In the following examples, we denote with \u2192 the application of recurrence (1) on (\u03b1 i , \u03b2 i ) in order to obtain (\u03b1 i+1 , \u03b2 i+1 ). And, if we express the new series in terms of Fibonacci numbers, we have that (\u03b1 1 ,\u03b2 1 ) = (0, 1) = (F 0 ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case C:"
        },
        {
            "text": ", and the value for the final pair (\u03b1 m ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case C:"
        },
        {
            "text": "Thus, the following theorem is inferred. 6 }, so G is G without edge c 6 . As G is a sequence of 6 vertices then i(G ) = F 6+2 = 21. While the value for |{S \u2208 I(G ) : x 1 \u2208 S \u2227 x 6 \u2208 S}| is F 6\u22122 = 3. Then, i(G) = 21 \u2212 3 = 18 the computing is shown in Fig. 1(b) .",
            "cite_spans": [
                {
                    "start": 41,
                    "end": 42,
                    "text": "6",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 252,
                    "end": 261,
                    "text": "Fig. 1(b)",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Case C:"
        },
        {
            "text": "All the above graph topologies (case A, B and C) represent basic graph patterns that can be recognized and processed to compute its number of independent sets in linear-time. We call Linear NI to the linear procedure that consists of the above three cases (A, B and C). Linear NI will be applied to process any acyclic graph or simple cycles that we find as part of a more complex graph. In fact, in [2] a polynomial-time algorithm has been shown to compute i(G) when G has linear compositions of the above patterns. We can now ask if there exists a family of cyclic connected graphs whose number of independent sets can be computed efficiently, in the next section, we show some families that fulfill this requirement.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. If G is a simple cycle with n vertices then the number of independent sets of G, expressed in terms of the Fibonacci numbers, is"
        },
        {
            "text": "Let G = (V, E) be a connected graph with n = |V |, m = |E| and such that \u0394(G) \u2265 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "In order to recognize more graph patterns for the efficient computation of i(G), we present the case of the computation of i(G) for outerplanar graphs. For this case, we introduce concepts about the decomposition of a graph by its set of embedded cycles.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "If a depth-first search (abbreviated as df s) is applied over G, starting the search, for example, with the vertex v r \u2208 V of minimum degree, and selecting among different potential vertices to visit the vertex with minimum degree first and with minimum value in its label as a second criterion, we obtain an unique depth-first graph G (into the set of all possible depth-first graphs), which we will denote as G = df s(G). This df s also builds an unique spanning tree T G with v r as the root node. In time O(m + n), the df s allows us to detect if G has cycles or not, and the edges forming each cycle. The edges in T G are called tree edges, whereas the edges in E(G)\\E(T G ) are called back edges. Let e \u2208 E(G)\\E(T G ) be a back edge, the union of the path in T G between the endpoints of e with the edge e itself forms a simple cycle, such cycle is called a basic (or fundamental) cycle of G with respect to T G . Each back edge e = {x, y} holds the maximum path contained in the basic cycle that it is part of. We will call to such maximum path, the internal path of a fundamental cycle. Assuming that x is visited first than y during the df s, we say that x is the start-vertex and y is the end-vertex of the back edge.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "According to our particular depth-first search G = df s(G) on G, we denote C = {C 1 , C 2 , ..., C t } as the set of fundamental cycles found during such depthfirst search. Notice that the combination of the procedure for trees and the processing of cycles (Eq. 2) can be applied for computing i(G) if G is a graph where the depth-first search generates a tree and a set of independent fundamental cycles.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "If two distinct base cycles C i and C j from C have common edges then we say that both cycles are intersected, that is, C i C j form a new cycle, where denotes the symmetric difference operation between the set of edges in both cycles. In fact,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": ") forms a composed cycle. If two cycles are non-intersected we say that they are independent. I.e. two independent cycles (C i , C j ) hold (E(C i ) \u2229 E(C j )) = \u2205. Notice that t = m \u2212 n + 1 is the dimension of the Z Z 2 -vector space with the symmetric difference on the edge sets as addition, and C is a base in that Z Z 2 -vector space.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "For an outerplanar graph G o , the cycles in G o can be considered as embedded cycles, see e.g. Fig. 2 . In order to recognize when two cycles C i and C j can be expressed as embedded cycles, we use the or-exclusive operation. Given two intersected cycles C i , C j , we say that",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 96,
                    "end": 102,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "being C k a new cycle distinct to C i and C j and \u2295 is the or-exclusive operation between the edges of the cycles.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "If the cycles C i and C j hold the previous three conditions, we say that C i is embedded into C j . Meanwhile, C j is a cycle that semi-encloses C i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recognition of Embedded Cycles"
        },
        {
            "text": "An outerplanar graph G o could be redrawn in a planar way, where any pair of basic cycles is independent, or one of them is embedded into the other. Thus, G o is planar, and all its vertices are not enclosed by any edge. Generating a planar drawing is often viewed as a separate problem, in part because drawing algorithms tend to create a planar embedding as a first step, and in part because drawing can be application dependent. In particular, a graph G o is outerplanar if K 4 and K 2,3 are forbidden as a minus of G o . Outerplanar graphs can be recognized in linear-time [9] .",
            "cite_spans": [
                {
                    "start": 577,
                    "end": 580,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Processing Outerplanar Graphs"
        },
        {
            "text": "The embedding is a transitive characteristic among embedded cycles. If C i is embedded into C j , and C j is embedded into C k , then C i is embedded into C k . On the other hand, if C i and C j are two independent cycles, e.g. (E(C i ) \u2229 E(C j )) = \u2205, but there exists a cycle C k such that C i and C j are embedded into C k , e.g. (V (C i ) \u2282 V (C k )) and (V (C j ) \u2282 V (C k )), then we say that (C k , C j , C i ) is a tuple of embedded cycles.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Processing Outerplanar Graphs"
        },
        {
            "text": "A maximal list of embedded cycles D = (C 1 , C 2 , . . . , C k ) is a tuple of cycles such that for i < k, C i+1 is embedded into C i , i = 1, . . . , k \u2212 1, or there exists C j in the tuple with j < i \u2264 k such that C i is embedded into C j . In a maximal list of embedded cycles D = (C 1 , C 2 , . . . , C k ), the cycles are ordered by setting first the most external cycle followed by its internal cycle until arriving to C k , which is the most internal cycle of the set of embedded cycles. Notice that a maximal list of embedded cycles D is also a graph that we denote by D.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Processing Outerplanar Graphs"
        },
        {
            "text": "Given a maximal list D = (C 1 , C 2 , . . . , C k ) of embedded cycles, the spanning tree of D is called the path of D and it is denoted by P D . We consider an orientation on P D ; from left to right, or from down to up, according to the drawing of D. The first vertex v 0 of P D is called the initial vertex of D. Meanwhile, the last vertex v f of P D is called the final vertex of D. We will denote as (\u03b1 i , \u03b2 i ) to the pair associated to the vertex v i \u2208 V (P D ). Given a maximal list of embedded cycles D, we present in this section how to compute i(D). Proof. We present as proof a linear-time algorithm for the computation of i(D).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Processing Outerplanar Graphs"
        },
        {
            "text": "A main thread, denoted by Lp, is associated to P D . This thread is always active during all the counting process. The computation of i(D) is done by traversing in depth-first order the path P D from its initial node v 0 to its final node v f . The cycles in D are visited from the most external to the internal cycles according to the depth-first search. Each cycle C i , i = 1, 2, . . . , k has a corresponding computing thread L Ci . The computation of i(C i ) follows the case (C) for a simple cycle, described in the previous section. Recurrence (1) is applied on the current pairs (\u03b1 i , \u03b2 i ) LC \u2192 (\u03b1 i + \u03b2 i , \u03b1 i ) LC when a new vertex v i+1 of P D is visited. Each time that an initial vertex of a cycle C i is visited, the pair (0, \u03b2 l ) is associated to the thread L Ci , where \u03b2 l is the value of the second component of the pair (\u03b1 l , \u03b2 l ) associated to Lp, see e.g. Figs. 2(b) and 2(d). When the computation arrives to the endvertex v of a cycle C j with corresponding pairs (\u03b1 v , \u03b2 v ) Cj , then the pair (0, \u03b2 v ) is subtracted to all current computing thread. Afterwards, the computing thread L Cj is closed and stops from being in the computation of i(D). When a cycle C j has been computed, C j may be contracted in only one vertex v Cj , and the pair (\u03b1 Cj , \u03b2 Cj ), which resulted from the processing of the cycle C j , is associated to v Cj . This process continues processing all cycle in D until the depth-first search arrives to the final vertex v f of D. If (\u03b1 f , \u03b2 f ) is the pair associated to v f , then",
            "cite_spans": [
                {
                    "start": 551,
                    "end": 554,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Processing Outerplanar Graphs"
        },
        {
            "text": "We illustrate in the following example, the computation of i(D) when D is a maximal list of embedded cycles. Fig. 2(a) , we show the input list of embedded cycles D. In Fig. 2(b) , as the first cycle of the list is computed, then two computing threads are formed. The path of D is visited in linear way, and at the same time, the recurrence (1) is applied on the current pairs of the computing threads, see Fig. 2(c) . Finally, Fig. 2(d) shows the final process of computing on all active threads giving as a result that i(D) = 40 + 18 = 58.",
            "cite_spans": [
                {
                    "start": 341,
                    "end": 344,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 109,
                    "end": 118,
                    "text": "Fig. 2(a)",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 169,
                    "end": 178,
                    "text": "Fig. 2(b)",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 407,
                    "end": 416,
                    "text": "Fig. 2(c)",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 428,
                    "end": 437,
                    "text": "Fig. 2(d)",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Processing Outerplanar Graphs"
        },
        {
            "text": "All outerplanar graph can be decomposed in a set of maximal list embedded cycles. For this, let us consider as input to G o = (V, E) an outerplanar graph. We associate a tree T , called the embedding tree of G o . Given an embedding tree T of a maximal list of embedded cycles, the final vertex v f of the list is selected as the root node of T , which make to T a rooted embedding tree. The construction of T satisfies the following properties. Each node v t of an embedding tree T is formed by a maximal list of embedded cycles, where the final vertex v f of the list of embedded cycles will be the root node for the subtree T vt \u2282 T . We show in Fig. 3 a decomposition of an outerplanar graph G o in its set of maximal embedded cycles, and the formation of the embedding tree T of G o . Proof. We present as proof a polynomial time algorithm for the computation of i(G o ). A pre-order search on the embedding tree T follows the linear-time procedure developed in the case (B) of the previous section for computing the number of independent sets on tree topologies. Meanwhile, the algorithm presented in Theorem (3) is applied for computing i(v t ) when a node v t \u2208 V (T ) is visited. The combination of both procedures builds a method for the computation of i(T ) in polynomial time on the size of the input graph G o .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 649,
                    "end": 655,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Example 3. In"
        },
        {
            "text": "Computing the number of independent sets of a graph G, denoted as i(G), is a classic #P-complete problem for graphs of degree 3 or higher. We establish that if the depth-first graph of a given graph G has no intersected cycles, then the computation of i(G) is a tractable problem. We have presented a novel algorithm for computing i(G) for any outerplanar graph G.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        },
        {
            "text": "Our proposal for computing i(G) do not impose restrictions on the degree of the graph, but rather, it depends on its topological structure. Those previous cases allows to establish a finer border between the classes FP and #P for the problem of counting independent sets. Furthermore, our proposal can be adapted to consider other counting problems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "An algorithm for counting maximum weighted independent sets and its applications",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Dahll\u00f6f",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Jonsson",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Proceedings of Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms",
            "volume": "",
            "issn": "",
            "pages": "292--298",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A worst-case time upper bound for counting the number of independent sets",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "De Ita",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "L\u00f3pez-L\u00f3pez",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "CAAN 2007",
            "volume": "4852",
            "issn": "",
            "pages": "85--98",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-77294-1_9"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "The complexity of counting colourings and independent sets in sparse graphs and hypergraphs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Greenhill",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Comput. Complex",
            "volume": "9",
            "issn": "1",
            "pages": "52--72",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The NP-completeness column: an ongoing guide",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "S"
                    ],
                    "last": "Johnson",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "J. Algorithms",
            "volume": "6",
            "issn": "3",
            "pages": "434--451",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Linear-time counting algorithms for independent sets in chordal graphs",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Okamoto",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Uno",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Uehara",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "WG 2005",
            "volume": "3787",
            "issn": "",
            "pages": "433--444",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "On the hardness of approximate reasoning",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Roth",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Artif. Intell",
            "volume": "82",
            "issn": "1",
            "pages": "273--302",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Randomized Algorithms: Approximation. Generation, and Counting. Distinguished Dissertations",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Russ",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-4471-0695-1"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "The complexity of counting in sparse, regular, and planar graphs",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Vadhan",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "SIAM J. Comput",
            "volume": "31",
            "issn": "2",
            "pages": "398--427",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Recognizing outerplanar graphs in linear time",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Wiegers",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "WG 1986",
            "volume": "246",
            "issn": "",
            "pages": "165--176",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-17218-1_57"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Let P n = G = (V, E) be a graph consisting of a single sequence of nodes (path), i.e. V = {1, 2, ..., n} and there exists an edge e i = {i, i + 1}, i = 1, . . . , n \u2212 1, for each pair of sequential vertices. We build the family f i = {G i }, i = 1, . . . , n where each G i = (V i , E i ) is the induced graph of G formed by just the first i vertices of V .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Counting independent sets over trees and cycles",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Computing i(D) with D a maximal list of embedded cycles Theorem 2. Given a maximal list of embedded cycles D, i(D) is computed in linear-time on the size of D.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "The nodes of T are maximal list of embedded cycles. 2. Two nodes v a , v b of T are adjacent only if the root vertex of v a is an internal vertex of the maximal embedding of v b . 3. For every vertex v \u2208 V (G o ), the subgraph T v \u2282 T induced by the maximal embedded cycles containing v is a tree.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "A decomposition of an outerplanar graph Go in its set of maximal embedded cycles Theorem 3. Let G o be an outerplanar graph and let T be the embedding tree of G o , then i(G o ) is computed in polynomial time on the size of G o .",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}