{
    "paper_id": "93640879d5934910e066f7eafc5093e3829ae443",
    "metadata": {
        "title": "Verifying a Solver for Linear Mixed Integer Arithmetic in Isabelle/HOL",
        "authors": [
            {
                "first": "Ralph",
                "middle": [],
                "last": "Bottesch",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Innsbruck",
                    "location": {
                        "settlement": "Innsbruck",
                        "country": "Austria"
                    }
                },
                "email": "ralph.bottesch@uibk.ac.at"
            },
            {
                "first": "Max",
                "middle": [
                    "W"
                ],
                "last": "Haslbeck",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Innsbruck",
                    "location": {
                        "settlement": "Innsbruck",
                        "country": "Austria"
                    }
                },
                "email": ""
            },
            {
                "first": "Alban",
                "middle": [],
                "last": "Reynaud",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "ENS Lyon",
                    "location": {
                        "settlement": "Lyon",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "Ren\u00e9",
                "middle": [],
                "last": "Thiemann",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Innsbruck",
                    "location": {
                        "settlement": "Innsbruck",
                        "country": "Austria"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "We implement a decision procedure for linear mixed integer arithmetic and formally verify its soundness in Isabelle/HOL. We further integrate this procedure into one application, namely into CeTA, a formally verified certifier to check untrusted termination proofs. This checking involves assertions of unsatisfiability of linear integer inequalities; previously, only a sufficient criterion for such checks was supported.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "To verify the soundness of the decision procedure, we first formalize the proof that every satisfiable set of linear integer inequalities also has a small solution, and give explicit upper bounds. To this end we mechanize several important theorems on linear programming, including statements on integrality and bounds. The procedure itself is then implemented as a branch-and-bound algorithm, and is available in several languages via Isabelle's code generator. It internally relies upon an adapted version of an existing verified incremental simplex algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The computational problem of deciding whether a system of linear inequalities with integer coefficients has an integral solution arises in many practical situations. Since it is NP-complete, no currently known algorithm can in general avoid searches of exponential length. Furthermore, while satisfiable instances always have short solutions that can be efficiently checked, there need not be short, efficiently-checkable proofs for the fact that an instance is unsatisfiable, unless NP = co-NP. (Contrast this with the related problem of deciding whether a system of linear inequalities with integer coefficients has a rational solutionthis problem is in P, and Farkas' lemma provides a short and efficiently checkable certificate that an unsatisfiable instance indeed has no solution.) Thus, if a solver declares that a given instance is unsatisfiable over the integers, the length of any proof for this fact may be exponential in the size of the input instance, in which case the computational effort required to check such a proof would be exponential as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Instead of repeatedly performing certification tasks that require immense amounts of data and computational effort, it may be more fruitful to formally verify the soundness of a solver once, so that it can then be trusted without instance-by-instance certification of its output. The implementation of such a solver, together with a formal proof of its soundness, is the goal of the present work. Specifically, we use Isabelle/HOL [19] to implement and prove the correctness of a branch-and-bound algorithm [21, Chapter 24.1] , and then use Isabelle's code generator [11] to obtain verified executable code. Along the way, we also give the first formalized proofs for several important results on integer programming.",
            "cite_spans": [
                {
                    "start": 431,
                    "end": 435,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 507,
                    "end": 511,
                    "text": "[21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 512,
                    "end": 525,
                    "text": "Chapter 24.1]",
                    "ref_id": null
                },
                {
                    "start": 567,
                    "end": 571,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A concrete example of an application for our solver comes from termination analysis, where a program is given as input to a termination tool that tries to determine whether the given program terminates on all inputs. Since termination tools get patched and improved repeatedly, maintaining an up-to-date formal proof of soundness would be extremely difficult. Therefore, the approach that is typically used is to have the (unverified) termination tool output a certificate for its analysis, which can then be checked by a verified certificate checker. One such certificate checker is CeTA [5, 24] . It has been verified in Isabelle/HOL, so that whenever it accepts a proof of termination for some program, the formal proof of CeTA's soundness ensures that the program does indeed terminate.",
            "cite_spans": [
                {
                    "start": 589,
                    "end": 592,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 593,
                    "end": 596,
                    "text": "24]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As an example, consider a program to compute the binary logarithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "int log2(int x) { int n := 0; while (x > 0) { x := x div 2; n := n + 1; } return n; } This program can be translated into an integer transition system and termination can be proved by showing that the value of x is decreased by at least 1 in every loop iteration. This property can be expressed in linear integer arithmetic (LIA): it is equivalent to the validity of formula (1) , where x and n represent the new values of x and n, respectively, after an iteration of the loop.",
            "cite_spans": [
                {
                    "start": 375,
                    "end": 378,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "x > 0 \u2227 2x",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "x \u2227 x 2x + 1 \u2227 n = n + 1 \u2212\u2192 x x + 1 (1) Validity of (1) is equivalent to unsatisfiability of the negated formula, which is simply a conjunction of linear inequalities:",
            "cite_spans": [
                {
                    "start": 36,
                    "end": 39,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "x > 0 \u2227 2x",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "x \u2227 x 2x + 1 \u2227 n = n + 1 \u2227 x < x + 1 (2) A sufficient condition for the unsatisfiability of (2) over the integers (LIA) is the unsatisfiability of the same system over the rationals (LRA); the latter can be shown, for instance, via the simplex algorithm [9] . Indeed, a verified implementation [23] of the simplex algorithm is currently integrated into CeTA [5] . However, whereas (2) is unsatisfiable over the integers, it has a rational solution",
            "cite_spans": [
                {
                    "start": 37,
                    "end": 40,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 254,
                    "end": 257,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 294,
                    "end": 298,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 358,
                    "end": 361,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "For such examples, considering the problem over the rationals may prohibit CeTA from detecting unsatisfiability over the integers. Therefore, in this paper we develop a verified theory solver for LIA (in fact, for linear mixed integer arithmetic, where only a user-specified part of the solution is required to be integral). The verified solver takes a conjunction of strict and nonstrict linear inequalities as input, and decides whether they are simultaneously solvable. We fully integrate the LIA solver into CeTA, so that the new version can handle all instances that are unsatisfiable over the integers and not only those that are unsatisfiable over the rationals as well. Of course, the LIA solver can also be used as a stand-alone theory solver, e.g., to perform verified SMT solving.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We verify our LIA solver in two major steps.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "1. First, we show that for every set of LIA constraints it suffices to search for small solutions. To this end, we formally verify an a priori bound in the style of Papadimitriou [20] : If there is an integer solution to a set of LIA constraints, then there is also one that is bounded by b := n(ma) 2m+1 , where n is the number of variables, m the number of inequalities, and a the largest absolute value of any number occurring in the inequalities. To be more precise, the small solution satisfies |x| \u2264 b for each variable x.",
            "cite_spans": [
                {
                    "start": 179,
                    "end": 183,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our verified upper bound matches the one given in a textbook [21, Thm. 17.1] (which is considerably lower than the one by Papadimitriou). 1 Specifically, we establish a bound of (n + 1)!a n (with no dependence on m). To prove this bound in Isabelle/HOL we mostly follow the textbook proofs and formalize several important results from linear programming, often with additional statements on bounds and integrality. These results include: the fundamental theorem of linear inequalities, the Farkas-Minkowski-Weyl theorem, Carath\u00e9odory's theorem, and the decomposition theorem for polyhedra. Note that the bound on the size of solutions also implies the fact that the problem of deciding satisfiability for linear integer inequalities is in NP. 2. Using the upper bound, we can decide satisfiability via a finite search. For instance, for formula (2) we have n = 4, a = 2 and m = 6 (the equality counts as two inequalities), and we know that if (2) is satisfiable, then there is an integer solution with absolute values at most 1920.",
            "cite_spans": [
                {
                    "start": 61,
                    "end": 65,
                    "text": "[21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 66,
                    "end": 76,
                    "text": "Thm. 17.1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To perform this search, we implement and verify a basic branch-and-bound algorithm. It is based on an incremental version of the simplex algorithm by Dutertre and de Moura [10] , which is used to deliver candidate solutions and to prune the search tree by detecting unsatisfiability in LRA. Although the incremental simplex algorithm has recently been verified in Isabelle/HOL [3] , its integration into the branch-and-bound algorithm is not immediate: the branch-and-bound algorithm requires frequent updates of bounds on variables, and this operation is not supported by the existing verified incremental simplex algorithm.",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 176,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 377,
                    "end": 380,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Note that our verified LIA solver is missing several possible optimizations [6, 7, 14] , some of which might be integrated in future work. Therefore, it clearly cannot compete with state-of-the-art (unverified) solvers. Still, our experimental results show that there are some examples from SMT-LIB where our solver is successful, but both CVC4 [2] and Z3 [16] fail.",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 79,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 80,
                    "end": 82,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 83,
                    "end": 86,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 345,
                    "end": 348,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 356,
                    "end": 360,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We give some preliminaries on linear (integer) programming and Isabelle in Sect. 2. Afterwards, we present our formalization of linear programming and the mentioned bound in Sect. 3. The branch-and-bound algorithm with the adaptation of the incremental simplex algorithm are covered in Sect. 4. We provide experimental results in Sect. 5 and conclude in Sect. 6 .",
            "cite_spans": [
                {
                    "start": 360,
                    "end": 361,
                    "text": "6",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Structure."
        },
        {
            "text": "The collection of theorems on polyhedra and small solutions is available as part of the archive of formal proofs (AFP) in the entry on linear inequalities [4] , and the branch-and-bound algorithm is part of IsaFoR/CeTA [24] . All of the theorems of this paper are linked to the formalization on an accompanying website. It also provides details on the experiments. http://cl-informatik.uibk.ac.at/software/ceta/experiments/lia/ Related Work. Allamigeon and Katz [1] have implemented the simplex algorithm in Coq and used it to give constructive proofs of a number of important theorems about convex polyhedra. The overlap between our work and [1] consists of formalizations of basic facts concerning cones and polyhedra, the fundamental theorem of linear inequalities, and Farkas' lemma. However, whereas in [1] a simplex algorithm for optimization problems is implemented in order to be used in constructive mathematical proofs, we formalize theorems concerning integer programming, including bounds on the size of solutions, and use these together with the previously Isabelle-verified simplex algorithm to obtain formally verified, yet efficient, software.",
            "cite_spans": [
                {
                    "start": 155,
                    "end": 158,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 219,
                    "end": 223,
                    "text": "[24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 462,
                    "end": 465,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 643,
                    "end": 646,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Structure."
        },
        {
            "text": "There is also a formalization of theorems about polyhedra in HOL Light, due to Harrison [12] , but it contains neither a formalization of the simplex algorithm nor does it cover integer programming.",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 92,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Structure."
        },
        {
            "text": "Cooper's algorithm has been formalized by Nipkow [18] in Isabelle/HOL. Although this algorithm also solves linear integer arithmetic, it internally works completely differently and its formalization requires different proofs; therefore, we do not see any overlap between the two works. We nevertheless consider the verified version of Cooper's algorithm in our experiments.",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 53,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Structure."
        },
        {
            "text": "Finally, we mention two general-purpose verified solvers. Carlier et al. [8] used Coq to implement and verify an algorithm for solving constraint satisfaction problems over finite domains. As with [1] , the resulting implementation can be used in principle, but is not efficient enough to compete with unverified implementations of the same algorithm. Narkawicz and Mu\u00f1oz [17] used PVS to verify a general branch-and-bound algorithm; a C++ implementation of this algorithm is described in [22] . In contrast to our work, this implementation was not automatically generated from a formal, verified algorithm specification, but was coded separately. Furthermore, in order to use the general branch-andbound algorithm, one must first tailor it to an application domain by specifying a number of functions that must respect certain specifications, whereas every part of our LIA solver (both branch-and-bound and simplex) has been formally verified. Thus, while the algorithm we verify lacks the generality of the one in [17] , our implementation retains a higher degree of reliability than the one in [22] , due to being entirely generated from a formally verified algorithm, and it is nevertheless reasonably efficient.",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 76,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 197,
                    "end": 200,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 372,
                    "end": 376,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 489,
                    "end": 493,
                    "text": "[22]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1016,
                    "end": 1020,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1097,
                    "end": 1101,
                    "text": "[22]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Structure."
        },
        {
            "text": "We briefly review some linear programming and Isabelle background.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We assume familiarity with vector spaces. Although our Isabelle theorems use a more general type, here we present our results in the context of Euclidean spaces (R n ). We denote the usual inner product in R n by '\u00b7'.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Programming"
        },
        {
            "text": "A (non-strict) linear inequality is an inequality of the form a \u00b7 x \u2264 b, where a, x \u2208 R n (a a row vector, x a column vector) and b \u2208 R. A system of linear inequalities can therefore be written as Ax \u2264 b, with A \u2208 R m\u00d7n and b \u2208 R m a column vector. A system of linear inequalities is a mixed integer system if, for some I \u2286 {1, . . . , n}, it is required that x i \u2208 Z for all i \u2208 I. We also define strict linear inequalities to be inequalities of the form ax < b, with a, x and b as before.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Programming"
        },
        {
            "text": "In this work we consider mixed integer systems of linear inequalities containing both non-strict and strict inequalities.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Programming"
        },
        {
            "text": "For reference, we collect below the definitions of several important concepts from linear algebra that are needed in order to state the theorems that we formalize. These definitions can be found in textbooks on linear programming such as [21, Chapters 7.1-2 and 16.2].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Programming"
        },
        {
            "text": "In words, a polyhedron is the intersection of a finite collection of affine half-spaces.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Half-spaces, hyperplanes, polyhedra). For"
        },
        {
            "text": "C \u2286 R n is a cone if, for all x, y \u2208 C and \u03bb, \u03bc \u2265 0, we have \u03bbx + \u03bcy \u2208 C. A cone C is generated by the set of vectors X if C = {\u03bb 1 v 1 + . . . + \u03bb m v m | \u03bb 1 , . . . , \u03bb m \u2265 0, {v 1 , . . . , v m } \u2286 X}, and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2 (Cones). A non-empty set"
        },
        {
            "text": "More precisely,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Convex hull, polytopes, integer hull). The convex hull of a vector set X is the set of all convex linear combinations of vectors from X."
        },
        {
            "text": "The convex hull of a finite set of vectors is called a (convex) polytope. Finally, if P is a polyhedron, then the integer hull of P , denoted P I , is the convex hull of the set of integral vectors of P . (Integral vectors are vectors whose coordinates with respect to the standard basis are integers.)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Convex hull, polytopes, integer hull). The convex hull of a vector set X is the set of all convex linear combinations of vectors from X."
        },
        {
            "text": "For our formalization work we use the theorem prover Isabelle. Knowledge of Isabelle will be helpful, but is not necessary in order to read the paper, as we have tried to make the formal source listings accessible even to a reader with a purely mathematical background.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Isabelle"
        },
        {
            "text": "Nevertheless, we briefly explain the meaning of some important notation here. First, we have carrier_vec n = R n , carrier_mat m n = R m\u00d7n , and denote the zero-vector of dimension n by 0 n . Often, the statement that a vector or a matrix has a certain property will be expressed as membership in the set of all vectors or matrices with that property: Bounded_vec bnd is the set of vectors (of finite dimension) with entries bounded in absolute value by bnd (similarly Bounded_ mat bnd ), indexed_Ints_vec I is the set of vectors v with v i \u2208 Z for all i \u2208 I, and, finally, Z v is the set of vectors (of finite dimension) with integer entries (similarly, Z m is a set of matrices). We also have a notation for sets defined by some set of vectors or by a matrix: finite_cone X denotes the cone generated by the finite set X; other examples are cone X , polyhedral_cone A and polyhedron A b, all with the obvious meanings.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Isabelle"
        },
        {
            "text": "We discuss our formalization of several results that are needed in order to formally prove the soundness of a branch-and-bound-based solver for mixed-integer linear systems of inequalities. The main theorem for this purpose states that if a mixed integer system of linear inequalities can be described using only integers, then it has a solution if and only if it also has a solution involving only numbers of bounded size.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Main Formalized Theorems"
        },
        {
            "text": "assumes A1 \u2208 carrier_mat nr1 n and A2 \u2208 . . . and ... and Bnd \u2265 0 and {A1,A2} \u2286 Zm \u2229 Bounded_mat Bnd and {b1,b2} \u2286 Zv \u2229 Bounded_vec Bnd and x \u2208 indexed_Ints_vec I and A1x \u2264 b1 and A2x < b2",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4. small_mixed_integer_solution:"
        },
        {
            "text": "In order to derive this result, we require formalizations of several results from the theory of linear inequalities, beginning with the fundamental theorem of linear inequalities. This theorem states that for any finite set of vectors A and vector b, either b is in the cone generated by a subset of A, or there exists a hyperplane {x | c \u00b7 x = 0} separating b from A and containing some number of vectors of A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4. small_mixed_integer_solution:"
        },
        {
            "text": "assumes A \u2286 carrier vec n and finite A and b \u2208 carrier vec n shows (\u2203B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "To prove the theorem, one first considers an algorithm that iteratively applies a procedure that takes a subset of vectors from A and produces either the cone containing b from the theorem statement, or the separating hyperplane, or a new set of vectors from A. In case of the third outcome, the output set is used as the input for the next iteration. Thus, starting from some valid set of vectors, the above algorithm either never terminates (if the third outcome occurs in every iteration), or it produces an object satisfying the theorem statement. The proof is completed by showing that an infinite execution cannot occur.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "The above argument could in principle be formalized in Isabelle by defining a function that incorporates the algorithm, and then proving that the function is well-defined (which implies the termination of the algorithm on all inputs). However, we are really only interested in the algorithm's termination; the fact that some input is mapped to a certain output is irrelevant for the proof of the theorem. Furthermore, we only need that the algorithm terminates when the set of input vectors is valid (i.e., of the right cardinality and linearly independent), but, due to the limitations of the Isabelle function-package [13] , the domain of a function cannot be restricted in this manner. Consequently, we formalize the proof without modeling the algorithm as an Isabelle function. Instead, we define a relation on pairs of valid subsets of A: The pair (J , J) is in the relation if and only if, starting with J as input, one iteration of the algorithm produces output J . In other words, the relation encodes all iterations of the algorithm where the third outcome occurs. Since A is finite, termination is equivalent to the fact that the above relation has no cycles. The latter fact is established by a proof by contradiction (here, our formalization closely follows the textbook proof [21, Chapter 7.1]).",
            "cite_spans": [
                {
                    "start": 620,
                    "end": 624,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "We also need to formalize three corollaries of Theorem 5. First, we have the theorem of Carath\u00e9odory, which follows directly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "Next, we have the Farkas-Minkowski-Weyl theorem, which states that a cone is polyhedral if and only if it is finitely generated. Theorem 7. farkas_minkowsky_weyl_theorem:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "The proofs of Theorems 7 and 5 in [21] contain some simplifying assumptions that can be made without loss of generality. Of course, in Isabelle we must provide the full details of every proof, which often entails a non-trivial amount of additional formalization work. For example, the textbook proof of the \"\u2212\u2192\"implication of Theorem 7 only covers the case where X spans R n . One way to recover this part of the theorem in full generality is to identify the span of X with R m for some m < n, apply the \"\u2212\u2192\"-implication for dimension m, and then extend the half-spaces (of span X) that define the polyhedral cone, into R n . In fact, this argument is essentially the justification for the wlog that is given in the book. Unfortunately, the Isabelle vector/matrix library we use does not support identifying an arbitrary proper subspace of R n with a Euclidean subspace of lower dimension: Even if we prove some statement for carrier_vec m , we cannot apply it to some arbitrary m-dimensional subspace of R n . Instead, our formalization of the general case involves adding suitable dummy vectors to X until the set spans all of R n , so that we can apply the full-dimension implication for carrier_vec n . This is one of several situations where filling in the \"obvious\" steps of a proof in a way that can be formally expressed in Isabelle requires some creativity.",
            "cite_spans": [
                {
                    "start": 34,
                    "end": 38,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "The third corollary is the decomposition theorem for polyhedra, stating that every polyhedron can be written as the sum of a polytope and a polyhedral cone: Theorem 8. decomposition_theorem_polyhedra:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "For both Farkas-Minkowski-Weyl (Theorem 7) and the decomposition theorem, the fact that we used a set-based matrix/vector library proved to be beneficial. To show the \"\u2212\u2192\"-implication of Theorem 7, one defines a matrix, the dimension of which is a function of X (and can therefore not be independently fixed just by the type of X). Constructing matrices of dimensions that depend on the value of some variable is easy when using carrier_mat , but would be very difficult with matrix libraries which utilize Harrison's encoding of dimensions in types [12] . In the case of the decomposition theorem for polyhedra, the proof involves adding a new component to each vector from a set of n-dimensional vectors and then reasoning about the resulting set of (n + 1)-dimensional vectors, while maintaining the correspondence between the two sets. Here, the use of carrier_vec makes it possible to easily switch between dimensions and reason about objects such as \"the vector formed of the first n components of some (n + 1)-dimensional vector\".",
            "cite_spans": [
                {
                    "start": 550,
                    "end": 554,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "Since the set of (real) solutions of a system of linear inequalities is a polyhedron, the decomposition theorem for polyhedra allows us to write any solution vector x as y + z, with y an element of a polytope (and therefore bounded), and z an element of a finitely generated cone. This suggests the following approach to proving Theorem 4 (small_mixed_integer_solution ): If x is such that x i \u2208 Z for all i \u2208 I, we may try to replace z with a vector z of the same cone, with bounded entries, such that (y + z ) i \u2208 Z for all i \u2208 I (thus, y + z would be the desired bounded solution). This approach does in fact work, but it clearly requires a more powerful version of the decomposition theorem, since the one we have shown so far says nothing about bounds or integrality. The proof of the new decomposition theorem also requires a bounded integer version of Theorem 7. This latter theorem in turn is based on a modified version of Theorem 5 which describes more precisely how separating hyperplanes can be computed so that the normal vectors are integral and with components of bounded size.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. fundamental theorem of linear inequalities: 2"
        },
        {
            "text": "assumes A \u2208 carrier_mat nr n and b \u2208 carrier_vec nr and P = polyhedron A b shows \u2203Q X. X \u2286 carrier_vec n \u2227 Q \u2286 carrier_vec n \u2227 finite (X \u222a Q)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "The '\u2212\u2192'-implication of this stronger version of the decomposition theorem for polyhedra states that if A and b have bounded integer entries, then the finite sets Q and X can be chosen such that they contain only bounded vectors and, furthermore, such that X contains only integral vectors. The integrality of the vectors in X is the crucial ingredient necessary for constructing the vector z as required and completing the proof of Theorem 4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "In [21] , only a weaker version of Theorem 4 is proved; it covers only the case of non-strict linear inequalities with integral solutions. Although our result trivially implies this weaker form, we have formalized the proof from the textbook as well, for the sake of completeness.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 7,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "This proof relies on a decomposition theorem for the integer hull of a polyhedron, which also requires bounded integer versions of Theorem 7 and the decomposition theorem for polyhedra. Only a rough sketch is given in the book as to how the bounded integer versions of these theorems can be obtained. When formalizing this part, however, we encounter the following issue: In the course of a proof, it will be necessary to add new vectors to a set until it has a certain property, or to add half-spaces to a collection until its intersection coincides with some polyhedron. This suffices if we only wish to prove the existence of a set of vectors with some property, or of a specific representation of a polyhedron, but if we also need to prove bounds on the numbers needed to describe these objects, it becomes crucial which vectors or half-spaces are chosen, because some choices, while valid, will lead to results that do not respect the desired bounds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "For a concrete example, we return to the \"\u2212\u2192\"-implication of Theorem 7 (Farkas-Minkowski-Weyl), this time in its bounded integer version:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "As mentioned earlier in this section, this implication is proved for the case where the span of X is R n , which is then used to prove the general implication, but the switch from the special to the general case involves adding vectors to X until the set spans the entire space, and then applying the full-dimension statement to obtain the half-spaces that define the polyhedral cone. Now, the vectors that are added to X can affect the size of the entries of the resulting matrix A, and the fact that these vectors can also be chosen in such a way that the entries of A are bounded in terms of only Bnd and n, is not obvious, and in fact requires a careful construction. Whereas such matters are simply glossed over in the textbook, resolving the wlogs in the proof of the bounded version of Theorem 5 and of Theorem 7 resulted in Isabelle proofs of 176 lines and 110 lines, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "In the end, we achieve the following formalized version of the textbook theorem [21, Thm. 17.1] .",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 84,
                    "text": "[21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 85,
                    "end": 95,
                    "text": "Thm. 17.1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Theorem 9. decomposition_theorem_polyhedra_1:"
        },
        {
            "text": "assumes A \u2208 carrier_mat nr n \u2229 Zm \u2229 Bounded_mat Bnd and b \u2208 carrier_vec nr \u2229 Zv \u2229 Bounded_vec Bnd and x \u2208 carrier_vec n \u2229 Zv and Ax \u2264 b shows \u2203y. y \u2208 carrier_vec n \u2229 Zv \u2227 Ay \u2264 b \u2227 y \u2208 Bounded_vec (fact (n+1) * (max 1 Bnd)^n)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 11. small_integer_solution_nonstrict_via_decomp:"
        },
        {
            "text": "In order to formalize the proofs of the main theorems, we collect a number of basic lemmas concerning cones, convex hulls, integer hulls, normal vectors and bases of vector spaces. On the one hand, these lemmas include very basic statements that would not normally require separate proofs, but were needed for the formalization, such as the fact that a set of vectors is a subset of the cone it generates, or that a convex combination of two vectors of a cone belongs to the cone. On the other hand, our supporting lemmas include statements that appear in standard mathematical texts, such as the fact stated in Lemma 12 that any linearly independent set of vectors can be extended to a basis of the vector space. We mention that we have proved all of these facts only for Euclidean vector spaces, making heavy use of the fact that the dimension is finite, because this case suffices for our application.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Additional Formalized Theorems"
        },
        {
            "text": "shows \u2203ys. set ys \u2286 set (unit_vecs n) \u2227 lin_indpt_list (xs @ ys) \u2227 length (xs @ ys) = n We note that in Lemma 12, @ is list concatenation and unit_vecs n refers to the standard basis of R n . Of course, a linearly independent set can be extended in many other ways, but we use vectors from the standard basis because they allow us to obtain the same number bounds as for the original linearly independent set. Adding the standard basis vectors is also the reason for using max 1 Bnd instead of Bnd in many theorems that mention upper bounds. Indeed, the \"max 1 \"-operation often cannot be dropped. For instance, consider the \"\u2190\u2212\"implication of Theorem 7 and the degenerate case where the matrix A is empty or just contains zeros. Then the entries of A are bounded by 0 and the cone is the whole space. Thus, for generating this cone one needs at least n non-zero vectors, e.g., the unit vectors. And these do not have all their entries bounded by 0, but by max 1 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 12. expand_to_basis: assumes lin_indpt_list xs"
        },
        {
            "text": "A notable exception, without \"max 1 \", is our main Theorem 4 (small_mixed_ integer_solution ). This result is first proved with the \"max 1 \" expression in the bounds. The version without the max -operation is then established by proving that the theorem also holds in all degenerate cases (where the bound is 0).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 12. expand_to_basis: assumes lin_indpt_list xs"
        },
        {
            "text": "Aside from the main theorems and supporting lemmas, we also formally prove two variants of Farkas' lemma. We do not need these for our work on the verified linear arithmetic solver, but obtaining them did not entail a prohibitively large additional effort, and they may be useful for other formalizations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 12. expand_to_basis: assumes lin_indpt_list xs"
        },
        {
            "text": "Although there already exists an entry for Farkas' lemma in the AFP, its proof there is based not on the fundamental theorem of linear inequalities (Theorem 5), but on a separate formalization of the simplex algorithm (one that has been formalized solely for rational numbers). Since here we use Theorem 5, we obtain a version of a lemma that allows for the use of a more general type than just the rationals. (In Isabelle, type annotation is denoted by :: . Below, a is a type variable that stands for the type of the entries of a matrix/vector; it can be any type with the suitable algebraic properties.) ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 12. expand_to_basis: assumes lin_indpt_list xs"
        },
        {
            "text": "Finally, we remark that, while the first of the two variants of Farkas' lemma follows easily from Theorem 5, the second variant (which, in [21] , has a three-line proof that is based on the first variant) is somewhat more difficult to formalize. This is because its proof involves concatenating matrices and deducing inequalities involving the resulting matrix from facts about its components. Such operations require laborious low-level manipulations of vector inequalities, turning a three-line textbook proof into 102 lines of Isabelle code.",
            "cite_spans": [
                {
                    "start": 139,
                    "end": 143,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 12. expand_to_basis: assumes lin_indpt_list xs"
        },
        {
            "text": "Algorithm 1 shows the Isabelle/HOL function bnb , which is our implementation of a branch-and-bound algorithm for solving LIA problems. It takes as parameters a list of constraints cs , the list of variables Is that should get an integer assignment and (total) functions lb and ub that map the variables in Is to their lower and upper integer bounds. bnb returns either a satisfying assignment which maps variables to rational numbers and all variables in Is to integers, or None , if the mixed integer problem is unsatisfiable within the bounds lb and ub . bnb first uses the simplex algorithm to find a rational solution of the constraints within the bounds. If the constraints are already unsatisfiable in the rational numbers or if the solution is already integral for all values in Is , then bnb terminates accordingly. Otherwise, there exists an x \u2208 Is where v x (the value assigned to x in the rational solution v ) is not an integer. We update the bounds on x once in lb and once in ub and branch by running bnb with the new upper bound and then with the new lower bound.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "To verify bnb in Isabelle/HOL we have to show that it always terminates. Note that in every recursive call, we either decrease one of the upper bounds ub or increase one of the lower bounds lb . This fact is used to show that in every function bnb :: constraint list \u21d2 var list \u21d2 (var \u21d2int) \u21d2 (var \u21d2int) \u21d2 (var \u21d2rat) option where bnb cs Is lb ub = case simplex (bounds_to_constraints Is lb ub @ cs) of",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "None \u21d2 Some v | Some x \u21d2 case bnb cs Is lb (ub(x := v x )) of Some sol \u21d2 Some sol | None \u21d2 bnb cs Is (lb(x := v x )) ub Algorithm 1: A simple implementation of a branch-and-bound algorithm recursive call, the range of possible values decreases for some x , and, hence, so does the search space. Thus, we use the following measure (of the size of the search space) to prove termination in Isabelle/HOL:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "We then prove two theorems about bnb : any detected solution is valid, and whenever bnb delivers None , no solution exists within the range that is specified by the lower-and upper-bounds. The expression v |= mcs (set cs, set Is) means that the solution v satisfies all of the constraints in cs and that all x \u2208 Is are assigned integer values by v . Here, compute_bound is an algorithm that extracts the relevant parameters (number of variables, maximal absolute value in constraints) and then calculates the upper bound as in Sect. 3. One complication comes from the fact that there are two different representations of constraints: the statements regarding bounds have been proved for constraints given in matrix-vector form, Ax \u2264 b or Ax < b with integral matrix A and integral vector b, whereas the input to the branchand-bound algorithm is a set of constraints, where each constraint is represented via a (sparse) linear polynomial with rational entries, e.g., x 5 + 1 10 x 1041 \u2264 7 3 . Hence, compute_bound internally also normalizes the constraints, e.g., by canceling fractions, and by renaming the variables so that the indices of variables with non-zero coefficients form a contiguous block: x 0 , . . . , x n\u22121 . The normalized constraints can then easily be translated into matrix-vector-form, which enables a lifting of Theorem 4 (small_mixed_integer_solution ) to constraints that are represented via sparse polynomials.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "lemma compute_bound:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "assumes v |=mcs (set cs, Is) shows \u2203 v. v |=mcs (set cs, Is) \u2227 (\u2200 i \u2208 Is. |v i| \u2264 compute_bound cs)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "At this point, it is easy to combine the results of bnb with compute_bound to finally show that branch_and_bound is a complete and sound decision procedure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "Either it returns some assignment, which is then a solution to the mixed integer problem; or it returns None , and the mixed integer problem is unsatisfiable. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Branch-and-Bound Algorithm"
        },
        {
            "text": "One problem of the branch-and-bound algorithm from the previous section is in the way it invokes the simplex algorithm: although in every iteration only a single constraint changes, the simplex algorithm is always started from scratch. Therefore, in this section we optimize the branch-and-bound algorithm to use an already existing verified incremental version of the simplex algorithm [3, 15] , which returns a state instead of only returning a satisfying assignment or stating unsatisfiability. The state contains for instance a tableau, i.e., a list of equations which is essential for the simplex algorithm. By reusing the state, expensive operations like creating the tableau can be avoided, making the incremental simplex very attractive to be used within the branch-and-bound algorithm.",
            "cite_spans": [
                {
                    "start": 387,
                    "end": 390,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 391,
                    "end": 394,
                    "text": "15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Using the Incremental Version of Simplex"
        },
        {
            "text": "A complication arises, since the verified incremental simplex algorithm was developed to be used in a DPLL(T)-solver, where all constraints are known beforehand and the constraints are not changed throughout one DPLL(T) run. Therefore, the incremental interface does not allow for changing constraints or adding new ones. As a consequence, an integration of the incremental simplex into the branch-and-bound algorithm is not immediate, since there the bounds are changed in every iteration.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using the Incremental Version of Simplex"
        },
        {
            "text": "Our solution is a slight extension of the incremental simplex algorithm. To be more precise, we write a function which changes exactly one constraint in the state in a way that the relevant invariants of the incremental interface still hold. This extension allows us to reuse all the existing soundness properties and proofs of the incremental simplex algorithm without modifications. It is specifically tailored for running the branch-and-bound algorithm. We choose this approach instead of adding a feature to change arbitrary constraints in the incremental simplex interface, since such a feature would require a major rewrite.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using the Incremental Version of Simplex"
        },
        {
            "text": "Since the algorithmic structure and the soundness statement of the modified branch-and-bound algorithm is completely identical to the one of Sect. 4.1, we just refer to the formalization for further details.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using the Incremental Version of Simplex"
        },
        {
            "text": "We tested two versions of our solver (based on incremental/non-incremental simplex) by comparing them with two well-established SMT-solvers, Z3 and CVC4. Testing was done on a subset of the non-incremental 3 QF LIA (quantifier-free linear integer arithmetic) 4 benchmark set from SMT-LIB. For this experiment we had two goals in mind: 1. to see whether it is worthwhile to use the nonincremental version of simplex as a sub-routine in the branch-and-bound algorithm, and 2. to get an idea about the extent to which our verified, non-optimized solver can handle practical examples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Benchmarking"
        },
        {
            "text": "We did not go through the effort of making our solver compliant with the language of SMT-LIB, as we felt that for the above two goals, it would suffice to write a simple converter that could handle a reasonable portion of the QF LIA benchmarks. Thus, we obtained a dataset of 1192 benchmarks, comprising 18% of the 6489 benchmarks in QF LIA. (More specifically, the following sub-folders were fully converted to a format that is readable by our solver: 20180326-Bromberger, miplib2003, pb2010, pidgeons, prime-cone, and slacks.) All solvers were tested on this dataset, on the same hardware, with a 60s-timeout per benchmark. Z3 version 4.4.0pre-2, CVC4 version 1.5-4, and the 2019-05-09 release of SMT-LIB were used.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Benchmarking"
        },
        {
            "text": "The only other verified LIA solver that we are aware of is an Isabelle formalization of Cooper's algorithm in the AFP. This algorithm solves a more general problem than linear integer arithmetic (namely linear arithmetic with arbitrary quantifiers over integer variables). We obtained an implementation with minimal changes to make code generation possible (just as we produced executables for our own solver). Evaluation. Our branch-and-bound implementation solves 37% of the dataset with incremental simplex as a sub-routine, and 31% with non-incremental simplex (Table 1 ). Since we have only implemented a naive branch-and-bound algorithm, without any additional heuristics for pruning the search space, it is unsurprising that its performance cannot match that of more mature solvers. Somewhat surprising is the fact that some benchmarks are solved by our solvers but not by Z3 or CVC4: of the benchmarks solved by incremental bnb, 28 are not solved by Z3, 29 are not solved by CVC4, and 8 are solved by neither Z3 nor CVC4.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 565,
                    "end": 573,
                    "text": "(Table 1",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Benchmarking"
        },
        {
            "text": "Interestingly, the non-incremental simplex-based solver can handle a few instances that the incremental simplex-based solver does not. Although using an incremental simplex leads to better overall results, it appears that reusing valuations from previous simplex runs can sometimes lead the search astray in such a way that simple solutions are missed. The phenomenon of a search proceeding in the wrong direction and missing a simple solution may also be the reason why some instances cannot be handled by either Z3 or CVC4, despite being solved by our solver.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Benchmarking"
        },
        {
            "text": "Cooper's algorithm is known to have a very high asymptotic complexity, which means that its performance is not a matter of optimizing an implementation. As such, the outcome of our experiments with regards to Cooper's algorithm is as expected, showing that this algorithm is not usable on medium-sized examples in practice.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Benchmarking"
        },
        {
            "text": "We have developed a verified solver for linear mixed integer arithmetic, and have formalized important results on linear integer programming that were needed in order to prove the soundness of the solver. To the extent of our knowledge, the main mathematical theorems of which we formalized proofs had not been previously verified in any formal system, and our solver is the first verified LIA solver that is also usable in practice. The two parts of our formalization amount to 9813 lines of Isabelle code and took roughly 10 person-months to implement.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion and Future Work"
        },
        {
            "text": "Currently, our solver is essentially \"proof of concept\" software, and there are a number of known optimizations that could improve it, e.g., preprocessing of constraints, integration of cutting planes, unit-cube-tests, etc. [6, 7, 14] . We have also used run-time profiling in order to establish which sub-routines our solver spends most time on, and have identified parts of the incremental simplex algorithm that we could further modify in order to improve running times.",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 227,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 228,
                    "end": 230,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 231,
                    "end": 234,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion and Future Work"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "A formalization of convex polyhedra based on the simplex method",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Allamigeon",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "D"
                    ],
                    "last": "Katz",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ITP 2017",
            "volume": "10499",
            "issn": "",
            "pages": "28--45",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-66107-0_3"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "CAV 2011",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Barrett",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "",
            "volume": "6806",
            "issn": "",
            "pages": "171--177",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-22110-1_14"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Verifying an incremental theory solver for linear arithmetic in Isabelle/HOL",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bottesch",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "W"
                    ],
                    "last": "Haslbeck",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "FroCoS 2019",
            "volume": "11715",
            "issn": "",
            "pages": "223--239",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-29007-8_13"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Linear inequalities. Archive of Formal Proofs",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bottesch",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Reynaud",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Certifying safety and termination proofs for integer transition systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Brockschmidt",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "J C"
                    ],
                    "last": "Joosten",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Yamada",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "CADE 2017",
            "volume": "10395",
            "issn": "",
            "pages": "454--471",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-63046-5_28"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A reduction from unbounded linear mixed arithmetic problems into bounded problems",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bromberger",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IJCAR 2018",
            "volume": "10900",
            "issn": "",
            "pages": "329--345",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-94205-6_22"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "New techniques for linear arithmetic: cubes and equalities",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bromberger",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Weidenbach",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Form. Methods Syst. Des",
            "volume": "51",
            "issn": "3",
            "pages": "433--461",
            "other_ids": {
                "DOI": [
                    "10.1007/s10703-017-0278-7"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "A certified constraint solver over finite domains",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Carlier",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Dubois",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gotlieb",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "FM 2012",
            "volume": "7436",
            "issn": "",
            "pages": "116--131",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-32759-9_12"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Linear Programming and Extensions",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "B"
                    ],
                    "last": "Dantzig",
                    "suffix": ""
                }
            ],
            "year": 1963,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "A fast linear-arithmetic solver for DPLL(T)",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Dutertre",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "De Moura",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "CAV 2006",
            "volume": "4144",
            "issn": "",
            "pages": "81--94",
            "other_ids": {
                "DOI": [
                    "10.1007/11817963_11"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Code generation via higher-order rewrite systems",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Haftmann",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "FLOPS 2010",
            "volume": "6009",
            "issn": "",
            "pages": "103--117",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-12251-4_9"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The HOL light theory of Euclidean space",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Harrison",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "J. Autom. Reasoning",
            "volume": "50",
            "issn": "",
            "pages": "173--190",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-012-9250-9"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Partial and nested recursive function definitions in higher-order logic",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Krauss",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Autom. Reasoning",
            "volume": "44",
            "issn": "4",
            "pages": "303--336",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-009-9157-2"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Cutting planes in integer and mixed integer programming",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Marchand",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Martin",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Weismantel",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "A"
                    ],
                    "last": "Wolsey",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Discrete Appl. Math",
            "volume": "123",
            "issn": "1-3",
            "pages": "397--446",
            "other_ids": {
                "DOI": [
                    "10.1016/S0166-218X(01)00348-1"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "An incremental simplex algorithm with unsatisfiable core generation. Archive of Formal Proofs",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Mari\u0107",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Spasi\u0107",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Z3: an efficient SMT solver",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "De Moura",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Bj\u00f8rner",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "TACAS 2008",
            "volume": "4963",
            "issn": "",
            "pages": "337--340",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-78800-3_24"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A formally verified generic branching algorithm for global optimization",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Narkawicz",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Mu\u00f1oz",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "VSTTE 2013",
            "volume": "8164",
            "issn": "",
            "pages": "326--343",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-54108-7_17"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Linear quantifier elimination",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Autom. Reasoning",
            "volume": "45",
            "issn": "2",
            "pages": "189--212",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-010-9183-0"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Isabelle/HOL -A Proof Assistant for Higher-Order Logic",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Wenzel",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "2283",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-45949-9"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "On the complexity of integer programming",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "H"
                    ],
                    "last": "Papadimitriou",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "J. ACM",
            "volume": "28",
            "issn": "4",
            "pages": "765--768",
            "other_ids": {
                "DOI": [
                    "10.1145/322276.322287"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Theory of Linear and Integer Programming",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Schrijver",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "A rigorous generic branch and bound solver for nonlinear problems",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Smith",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Mu\u00f1oz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Narkawicz",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Markevicius",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "17th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC)",
            "volume": "",
            "issn": "",
            "pages": "71--78",
            "other_ids": {
                "DOI": [
                    "10.1109/SYNASC.2015.20"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Formalization of incremental simplex algorithm by stepwise refinement",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Spasi\u0107",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Mari\u0107",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "FM 2012",
            "volume": "7436",
            "issn": "",
            "pages": "434--449",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-32759-9_35"
                ]
            }
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Certification of termination proofs using CeTA",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sternagel",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Berghofer",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Urban",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "TPHOLs 2009",
            "volume": "5674",
            "issn": "",
            "pages": "452--468",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-03359-9_31"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Farkas_Lemma: fixes A :: a mat and b :: a vec assumes A \u2208 carrier_mat n nr and b \u2208 carrier_vec n shows (\u2203x. x \u2265 0nr \u2227 Ax = b) \u2190\u2192 (\u2200y. y \u2208 carrier_vec n \u2227 A T y \u2265 0nr \u2212\u2192 yb \u2265 0) Lemma 14. Farkas_Lemma : fixes A :: a mat and b :: a vec assumes A \u2208 carrier_mat nr nc and b \u2208 carrier_vec nr",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "lemma branch_and_bound_sat:assumes bnb cs Is lb ub = Some v shows v |=mcs (set cs, set Is) lemma branch_and_bound_unsat: assumes bnb c Is lb ub = Noneand \u2200 i \u2208 set Is. lb i \u2264 v i \u2227 v i \u2264 ub i shows v |=mcs (setcs, set Is) At this point we connect the branch-and-bound algorithm with the bounds from Sect. 3 to obtain a decision procedure for linear (mixed) integer arithmetic: definition branch_and_bound cs Is = (let B = compute_bound cs in bnb cs Is (\u03bb_. \u2212B) (\u03bb_. B))",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "lemma branch_and_bound: branch_and_bound cs Is = Some v =\u21d2 v |=mcs (set cs, set Is) branch_and_bound cs Is = None =\u21d2 v. v |=mcs (set cs, set Is)",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Experimental resultsSat Unsat Total",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "This research was supported by the Austrian Science Fund (FWF) project Y757. The authors are listed in alphabetical order regardless of individual contributions or seniority.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        },
        {
            "text": "Open Access This chapter is licensed under the terms of the Creative Commons Attribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made.The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "annex"
        }
    ]
}