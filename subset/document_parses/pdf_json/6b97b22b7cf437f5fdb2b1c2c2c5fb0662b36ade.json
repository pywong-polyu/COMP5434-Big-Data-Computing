{
    "paper_id": "6b97b22b7cf437f5fdb2b1c2c2c5fb0662b36ade",
    "metadata": {
        "title": "Using Market Basket Analysis to Find Semantic Duplicates in Ontology",
        "authors": [
            {
                "first": "Irina",
                "middle": [],
                "last": "Astrova",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Tallinn University of Technology",
                    "location": {
                        "addrLine": "Akadeemia tee 21",
                        "postCode": "12618",
                        "settlement": "Tallinn",
                        "country": "Estonia"
                    }
                },
                "email": ""
            },
            {
                "first": "Arne",
                "middle": [],
                "last": "Koschel",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Applied Sciences and Arts Hannover",
                    "location": {
                        "addrLine": "Ricklinger Stadtweg 120",
                        "postCode": "30459",
                        "settlement": "Hannover",
                        "country": "Germany"
                    }
                },
                "email": "akoschel@acm.org"
            },
            {
                "first": "Su",
                "middle": [
                    "Ling"
                ],
                "last": "Lee",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Applied Sciences and Arts Hannover",
                    "location": {
                        "addrLine": "Ricklinger Stadtweg 120",
                        "postCode": "30459",
                        "settlement": "Hannover",
                        "country": "Germany"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "This paper proposes a novel approach to detecting semantic duplicates in an ontology that was integrated from many other ontologies. The proposed approach is based on using: (1) a query log that was issued against the ontology; and (2) the Apriori and FP algorithms from market basket analysis, where sales transactions are viewed as queries and items in a sales transaction are viewed as search terms in a query. To prove the viability of the proposed approach, the paper also presents the results of four experiments that were conducted on the OntoLife ontology.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The main purpose of ontology-based data integration is to solve the semantic heterogeneity problem in data integration. Semantic heterogeneity refers to the ambiguous interpretation of similar terms, which are being used to describe the meaning of data in heterogeneous resources such as websites or databases. However, during an ontologybased data integration, the newly merged ontology can contain semantic duplicates, e.g., similar attributes. These attributes can cause incomplete query results.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As an example, consider a user who submits the following query against the Wikipedia ontology: \"Which performers were born in Chicago?\" In response to this query, the query-answering system will return only one result (viz. Michael Ian Black). However, if it were known that actor and comedian are subclasses of performer and that their attributes birthplace, birth place, city of birth, place of birth and origin are semantic duplicates of performer's location, the query-answering system could return 163 additional results [1] . Thus, the recall of query results can be greatly improved by finding similar attributes.",
            "cite_spans": [
                {
                    "start": 526,
                    "end": 529,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we propose to use market basket analysis to find similar attributes. In market basket analysis, two items (or products) are considered to be similar if the purchase patterns of their customers are similar. Analogously, two attributes are considered to be similar if the querying patterns of their users are similar [2] . Continuing the example with the Wikipedia ontology: If it were known that there are many users who have asked about the actor's birth place together with the actor's name and birth date, and that there are many users who have asked about the actor's origin together with the actor's name and birth date, we could conclude that attributes birth place and origin in a class actor are similar to each other.",
            "cite_spans": [
                {
                    "start": 330,
                    "end": 333,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Baskets are defined as sets of products bought together by customers in sales transactions during their visits to supermarkets or online shops. Market basket analysis examines the buying behaviour of customers and it is used to identify similar products based on the purchase patterns. A typical example of similar products are Becks and Heineken beers. At the first sight, these two products may appear dissimilar as they do not have many common customers: the customers buy either Becks or Heineken, but not both. However, it was observed that together with Becks and Heineken, many of the customers buy the same products such as chips, sausages and pretzels. Based on this observation, a similarity measure is defined as two products are found to be similar, if the purchase patterns of their customers are similar.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Market Basket Analysis"
        },
        {
            "text": "The aim of market basket analysis is that of finding sets of items (products) that appear together in (are related to) many baskets. Let products be attributes in an ontology (search terms in queries issued against the ontology), baskets be queries and a sales transaction database be a query log. While market basket analysis aims at finding frequent itemsets, this information is often presented as a set of \"if-then\" rules called association rules. For example, if customers buy Heineken, then they also buy chips, sausages and pretzels.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Market Basket Analysis"
        },
        {
            "text": "To prove the applicability of market basket analysis to finding similar attributes in an ontology, we experimented with three algorithms:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Market Basket Analysis"
        },
        {
            "text": "\u2022 ICD (Iterated Contextual Distance) algorithm [17] : This is an array-based algorithm, which returns the distances between attributes. \u2022 Apriori algorithm [3] : This is an array-based algorithm, which returns association rules. \u2022 FP (Frequent Pattern) Growth algorithm [15] : This is a tree-based algorithm, which returns association rules.",
            "cite_spans": [
                {
                    "start": 47,
                    "end": 51,
                    "text": "[17]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 156,
                    "end": 159,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 270,
                    "end": 274,
                    "text": "[15]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Market Basket Analysis"
        },
        {
            "text": "In our experiments, we looked for sets of attributes that appear together in many queries, by analysing many-to-many relationships between the querying patterns and the user behaviours. We assumed that users who have similar questions in mind tend to submit similar queries, which have similar querying patterns.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Market Basket Analysis"
        },
        {
            "text": "In our previous work [2, 16] , we used the ICD and Apriori algorithms to detect semantic duplicates in an ontology. In this paper, we employ the FP Growth algorithm, which is an improvement of the Apriori algorithm. The Apriori algorithm finds frequent itemsets and consequently querying patterns, by generating candidate itemsets. In contrast, the FP Growth algorithm finds querying patterns without the need for candidate generation, rather by constructing an FP tree, which maintains the associations between frequent itemsets.",
            "cite_spans": [
                {
                    "start": 21,
                    "end": 24,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 25,
                    "end": 28,
                    "text": "16]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Market Basket Analysis"
        },
        {
            "text": "OntoLife [4] is an ontology for semantically managing personal information. This ontology has 110 attributes called datatype properties in the OWL terminology. It was developed by Intelligent System and Knowledge Processing Research Group (ISKP) by merging 10 other ontologies: We selected OntoLife for our experiments because it is from an easy-to-understand application domain. Furthermore, the ontology has many attributes and is merged out of many other ontologies from the same application domain. Thus, it is likely to have semantic duplicates.",
            "cite_spans": [
                {
                    "start": 9,
                    "end": 12,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "OntoLife"
        },
        {
            "text": "To run the Apriori and FP Growth algorithms against the OntoLife ontology, we made a number of assumptions about how data are stored and manipulated when searching for frequent itemsets (similar attributes):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Assumptions"
        },
        {
            "text": "\u2022 In market basket analysis, a basket contains only a small set of products from all products available in the supermarket or online shop. Similarly, it is also assumed that users do not inquire about all attributes in the ontology at once in a single query. \u2022 In market basket analysis, a basket can contain any number of products. Similarly, it is also assumed that a query can contain any number of attributes (i.e., the query can be of any size). \u2022 In market basket analysis, the details on sales transactions such as the date of purchase, product price and product quantities are ignored. Similarly, the values of attributes in the ontology are ignored. \u2022 In market basket analysis, the order of products in a sales transaction is ignored.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Assumptions"
        },
        {
            "text": "Similarly, the order of attributes in a query is ignored. \u2022 In market basket analysis, sales transactions are mined for a long period of time (at least for 6 months). As a result, the sales transaction database is large. Similarly, it is also assumed that the log of queries issued against the ontology is large. \u2022 All queries are taken into account, regardless of whether they return results or not.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Assumptions"
        },
        {
            "text": "As input, the Apriori and FP Growth algorithms took the query log. This log was the result of the past user interactions with the OntoLife ontology. Figure 1 shows an excerpt of the query log, which comprises 30 queries. These queries are written in SPARQL and contain 41 attributes, which constitute approximately 37% of the total attributes in the ontology. The shortest query has one attribute, whereas the longest query has 5 attributes. Not only can queries be distinguished by their size, but also by their frequency occurrence in the query log. A unique query appears only once in the query log. An example of a unique query is: \"Who have \"rain man\" as their nickname?\" In contrast, repeated queries are the queries, which appear more than once in the query log. They queried on the same attributes but possibly with different values or in a different order. An example of repeated queries is: \"Who were injured on November 22, 2009, were 50% disabled by that injury and worked in the public sector?\" and \"Who were injured on January 2, 1989, worked in the government sector and were 20% disabled by that injury?\".",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 149,
                    "end": 157,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Query Log"
        },
        {
            "text": "The query log was converted into a sales transaction database, which contains 30 sales transactions (one sales transaction per query) represented as rows. Figure 2 shows an excerpt of the sales transaction database. In this database, each query is identified by TID (transaction identifier). For each row, if an attribute does not appear in the query, it will not appear in the corresponding row either.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 155,
                    "end": 163,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Query Log"
        },
        {
            "text": "The Apriori and FP Growth algorithms find frequent itemsets, by pruning those itemsets whose support is lower than a user-defined minimum support threshold. After that, the algorithms generate strong association rules from the frequent itemsets, by pruning those association rules whose confidence is lower than a user-defined minimum confidence threshold. We conducted four experiments with different values for the minimum support threshold and the minimum confidence threshold because these values had impact on the results of our experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Minimum Support Threshold and Minimum Confidence Threshold"
        },
        {
            "text": "A support reveals the probability of occurrence of an attribute set X in queries. A frequent itemset has a support, which is greater than or equal to the minimum support threshold, where P denotes the probability. A confidence refers to a conditional probability. This is the probability that an attribute set Y occurs in queries given that an attribute set X has already occurred in the same queries. A confidence is used to generate strong association rules from the frequent itemsets that meet the minimum confidence threshold.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Minimum Support Threshold and Minimum Confidence Threshold"
        },
        {
            "text": "Like in market basket analysis, false positives and false negatives are inevitable when the thresholds are set either too low or too high, respectively. For example, when the minimum support threshold was too low, false positives tended to occur as those originally infrequent attributes were falsely found as frequent. When the minimum support threshold was too high, false negatives tended to occur where those originally frequent attributes were falsely found as infrequent. Figure 3 shows the results of our first experiment, where the minimum support threshold was 12% and the minimum confidence threshold was 55%. In this experiment, 24 strong association rules were generated by the algorithms. Two pairs of attributes were found similar:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 478,
                    "end": 486,
                    "text": "Figure 3",
                    "ref_id": null
                }
            ],
            "section": "Minimum Support Threshold and Minimum Confidence Threshold"
        },
        {
            "text": "1. specificDate and sickness_injuryDesc; 2. resource's title and resource's name.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 1"
        },
        {
            "text": "Among the strong association rules, we looked for sets of attributes that frequently appeared together in the consequents (right-hand sides) of those rules. When we found such rules, we had candidates for similar attributes that appeared in the antecedents (left-hand sides) of those rules. For example, the consequents of Rule 17 and Rule 20 (marked in blue in Fig. 3) suggested a pair of similar attributes: resource's title and resource's name. Furthermore, the consequents of Rule 11 and Rule 14 (marked in red in Fig. 3) suggested another pair of similar attributes: specificDate and sickness_in-juryDesc. However, intuitively these attributes were not similar and thus, such a finding was a false positive. One possible reason for this false positive was the small size of the query log (which contained only 30 queries).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 362,
                    "end": 369,
                    "text": "Fig. 3)",
                    "ref_id": null
                },
                {
                    "start": 518,
                    "end": 525,
                    "text": "Fig. 3)",
                    "ref_id": null
                }
            ],
            "section": "Experiment 1"
        },
        {
            "text": "The size of the query log was a crucial factor that could affect the experiment results. This is because the two algorithms assume that a sales transaction database is large. It was observed that there was yet another pair of similar attributes but it was not found (false negative): publication's description and biography's description. Again, due to the small size of the query log, there were no common query patterns, which inquired both attributes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 1"
        },
        {
            "text": "There was no significant difference in the runtime between the algorithms, as both took about 16 ms, but in the made count. In particular, the Apriori algorithm made 70 counts on the itemsets, whereas the FP Growth made 30 counts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 1"
        },
        {
            "text": "In summary, using the first experiment results, the OntoLife ontology could be refined. In particular, OWL has a construct owl:equivalentProperty to specify that resource's title is a semantic duplicate of resource's name. Figure 4 shows the results of our second experiment, where the minimum support threshold was 12% and the minimum confidence threshold was 90%. In this experiment, 16 strong association rules were generated by the algorithms. One pair of attributes was found similar: specificDate and sickness injuryDesc. However, it was the same false positive discovered before.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 223,
                    "end": 231,
                    "text": "Figure 4",
                    "ref_id": null
                }
            ],
            "section": "Experiment 1"
        },
        {
            "text": "Since the minimum support threshold was still 12%, the algorithms showed the same runtime and made the same count on the itemsets as they did in the first experiment. Figure 5 shows the results of our third experiment, where the minimum support threshold was 10% and the minimum confidence threshold was 90%. In this experiment, 51 strong association rules were generated by the algorithms. Four pairs of attributes were found similar:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 167,
                    "end": 175,
                    "text": "Figure 5",
                    "ref_id": null
                }
            ],
            "section": "Experiment 2"
        },
        {
            "text": "1. specificDate and sickness injuryDesc; 2. disab percentage and hasGovernmentalInvolvement; 3. hasGovernmentalInvolvement and sector; 4. disab percentage and sector.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 3"
        },
        {
            "text": "However, all these pairs were false positives. The first pair was caused by the small size of the query log. The second pair was caused by redundant association rules: Rule 13 and Rule 30. (An association rule is redundant if a more general rules with the same or a higher confidence exists, i.e., if it has the same consequent but one or more items were removed from the antecedent.) The third pair was also caused by redundant association rules: Rule 17 and Rule 33. The fourth pair was discovered due to the transitivity. Since disab percentage is similar to hasGovernmentalInvolvement and hasGovernmentalInvolvement is similar to sector, so is disab percentage similar to sector.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 3"
        },
        {
            "text": "In the third experiment, the FP Growth algorithm was again faster than the Apriori algorithm. In particular, the former ran 16 ms, whereas the latter ran about 31 ms. During its run, the Apriori algorithm made 131 counts on the itemsets, whereas the FP Growth made 30 counts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 3"
        },
        {
            "text": "In the fourth experiment, the minimum support threshold was 28% and the minimum confidence threshold was 55%. Here no strong association rules were generated by the algorithms. Therefore, we concluded that this minimum support threshold was too high it pruned all the frequent itemsets.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 4"
        },
        {
            "text": "In the fourth experiment, the FP Growth algorithm was again faster than the Apriori algorithm. In particular, the former ran about 1 ms, whereas the latter ran about 3 ms. During its run, the Apriori algorithm made 3 counts on the itemsets, whereas the FP Growth made 30 counts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment 4"
        },
        {
            "text": "Different approaches to finding similar attributes in an ontology have been proposed in the literature [18] . These approaches fall into four main categories:",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 107,
                    "text": "[18]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "\u2022 Term-based approach: In this approach, two attributes are considered to be similar if their names are similar. However, many false negatives and false positives can be found in the presence of synonyms and homonyms. Synonyms are different terms used to name same attributes (e.g., \"bear\" and \"support\"). Homonyms are same terms used to name different attributes. They have the same spelling but different meanings (e.g., \"bear\" can refer to an animal or can mean \"support\", depending on the contexts they are used in). \u2022 Value-based approach: In this approach, two attributes are considered to be similar if their values are similar. This approach can detect semantic duplicates in an ontology more accurately than the term-based approach. However, without information about data instances, this approach is not feasible. \u2022 Structure-based approach: In this approach, two attributes are considered to be similar if their structures are similar. Structures can be either internal or external. Examples of internal structures are data types, cardinalities, domains and transitivity of the attributes. However, internal structures are the subject of false negatives and false positives. For example, many attributes can have the same data types, but they are not necessarily similar. In case of external structures, an ontology is viewed as a graph, where vertices represent concepts and edges represent semantic relations between those concepts. This approach attempts to find similar classes and attributes, by identifying the structural isomorphism between sub-graphs of an ontology. For example, three types of relations can be identified between classes: taxonomic, mereologic and all the involved relations. In the taxonomic structure, the graph depicts the subClassOf relations. These relations indicate that the connected concepts are similar. One of the common similarity measures is to count the number of edges in the taxonomy between two classes to determine their similarity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "In the mereologic structure, the graph depicts the PartOf relations. In all the involved relations structure, classes are related via their attribute definitions. External structures are also the subject of false negatives and false positives. For example, it is difficult to distinguish the PartOf relations from the subClassOf relations. \u2022 Context-based approach: In this approach, two attributes are considered to be similar if the contexts of their usage are similar. However, it can be difficult to identify similar contexts. In this paper, we proposed to use market basket analysis to solve this problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "During an ontology-based data integration, the newly merged ontology such as OntoLife can contain semantic duplicates (e.g., similar attributes). These attributes can cause incomplete query results. In this paper, we focused on finding semantic duplicates in the OntoLife ontology. The approach we proposed is as follows: (1) the Apriori or FP Growth algorithm is applied to find strong association rules derived from a query log, where each query is a set of search terms being attributes in the ontology, and (2) candidates for semantic duplicates are determined as antecedents of the strong association rules having similar consequents. In addition, we conducted a number of experiments on the query log, which was a list of queries posed by users to inquire the OntoLife ontology. The Apriori algorithm scanned the query log multiple times for generating candidate itemsets. In contrast, FP Growth algorithm scanned the query log only twice for constructing an FP tree. In all our experiments, the FP Growth algorithm made a constant of 30 counts on the itemsets. In contrast, the Apriori algorithm made a number of counts, which varied from 3 to 131 counts, depending on the minimum support threshold. The more counts the Apriori algorithm made, the longer time it ran. Despite the different runtime (the FP Growth algorithm was faster than the Apriori algorithm), it was observed that the algorithms returned the same results.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Overall, the results of our experiments showed that market basket analysis in general and the Apriori and FP Growth algorithms in particular are capable of finding similar attributes in an ontology, although user involvement is required to identify the optimal values for the minimum support threshold and the minimum confidence threshold.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Automatic detection of duplicated attributes in ontology",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Astrova",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Koschel",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ICEIS 2009: Proceedings of the 11th International Conference on Enterprise Information Systems",
            "volume": "DISI",
            "issn": "",
            "pages": "283--286",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Improving query results with automatic duplicate detection",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Astrova",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the Second Workshop on Very Large Digital Libraries, VLDL 2009: A Workshop in conjunction with the European Conference on Digital Libraries",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Fast algorithms for mining association rules",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Agrawal",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Srikant",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Readings in Database Systems",
            "volume": "",
            "issn": "",
            "pages": "580--592",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "OntoLife: An Ontology for Semantically Managing Personal Information",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Kargiot",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Kontopoulos",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "ISO lists for Countries and Languages Ontology",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Mining frequent patterns without candidate generation: a frequent-pattern tree approach",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Data Min. Knowl. Discov",
            "volume": "8",
            "issn": "1",
            "pages": "53--87",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "How the Apriori Algorithm can help to find semantic duplicates in ontology",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Astrova",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Koschel",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "L"
                    ],
                    "last": "Lee",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Knowledge-Based Software Engineering",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Context-based similarity measures for categorical database",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Das",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Mannila",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Proceedings of PKDD",
            "volume": "",
            "issn": "",
            "pages": "201--210",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Ontology Matching",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Shvaiko",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Euzenat",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "TABREF0": {
            "text": "Person [5]: This ontology provides a formal vocabulary description of people. Family Tree [7]: This ontology models the application domain of family that defines people's relationships such as children and parents. It does not have any attributes. 4. Relationship [8]: This ontology defines other relationships between people such as friends, colleagues and tutors. It does not have any attributes. 5. ISO lists for Countries and Languages [9]: This ontology models the application domain of people's countries and their languages. It does not have any attributes. 6. Project [10]: This ontology describes research projects and people who are involved into those projects. It has 6 attributes such as project title, start and end dates. 7. Research [11]: This ontology describes the hierarchy of research projects (e.g., related projects can include cloud computing and data mining). It does not have any attributes. 8. Publication [12]: This ontology models the application domain of people's publications. It has 27 attributes such as book title, edition of publication and publi-Biography [14]: This is the largest ontology. It has 77 attributes. It describes the people's demographics, their profiles and contacts. Furthermore, it describes the CV-related information such as people's education and qualifications, skills and working experiences as well as injuries that people have got at work.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgement. Irina Astrova's work was supported by the Estonian Ministry of Education and Research institutional research grant IUT33-13.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}