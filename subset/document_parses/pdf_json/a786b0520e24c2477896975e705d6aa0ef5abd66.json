{
    "paper_id": "a786b0520e24c2477896975e705d6aa0ef5abd66",
    "metadata": {
        "title": "SNexpression: A Symbolic Calculator for Symmetric Net Expressions",
        "authors": [
            {
                "first": "Lorenzo",
                "middle": [],
                "last": "Capra",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 di Milano",
                    "location": {
                        "settlement": "Milan",
                        "country": "Italy"
                    }
                },
                "email": "lorenzo.capra@unimi.it"
            },
            {
                "first": "Massimiliano",
                "middle": [],
                "last": "De Pierro",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 di Torino",
                    "location": {
                        "settlement": "Turin",
                        "country": "Italy"
                    }
                },
                "email": "massimiliano.depierro@unito.it"
            },
            {
                "first": "Giuliana",
                "middle": [],
                "last": "Franceschinis",
                "suffix": "",
                "affiliation": {},
                "email": "giuliana.franceschinis@uniupo.it"
            }
        ]
    },
    "abstract": [
        {
            "text": "The paper presents SNexpression: a tool for the symbolic structural analysis of Symmetric Nets (SN). It can operate at a low level, handling expressions required to compute the structural properties of interest, but features also a net-based way of interaction allowing to submit commands referring directly to the net structure avoiding error prone input of low level expressions. The User Interface implements a command line interpreter and provides also a multi-page notebook to keep track of the submitted commands and their result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The SNexpression tool has been developed with the aim of providing support to the structural analysis of Symmetric Nets (SN), a High-Level Petri Net (HLPN) formalism, without unfolding the net, allowing one to work at symbolic and parametric 1 level. A recently added feature is the possibility of deriving a set of symbolic ordinary differential equations (Symbolic ODE -SODE) from a Stochastic SN (SSN) model, making it possible an efficient computation of the average marking of colored tokens into places. A first version of SNexpression was presented in [6] , but significant improvements/extensions have been implemented since then.",
            "cite_spans": [
                {
                    "start": 559,
                    "end": 562,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The theoretical work behind the tool has been published in a few papers defining the language for expressing the structural relations in symbolic form and the operators to be applied to the SN arc functions to derive several structural relations [5, 7] or to generate a set of SODE from a model satisfying certain properties [3, 4] . The basic idea consists of using a syntax similar to the SN arc expressions one, to symbolically represent structural relations useful for checking invariance properties, to deduce model behavioral properties, etc. Each symbolic structural relation is representative of several structural relations defined on the model unfolding: the latter can be derived from the former by instantiating it on specific colors. This approach has advantages: the compact representation, the similarity of the languages used to describe the model and that used to express the structural properties, and to some extent the possibility to apply it to models with parametric color class size, hence providing results that are valid for a family of similar models.",
            "cite_spans": [
                {
                    "start": 246,
                    "end": 249,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 250,
                    "end": 252,
                    "text": "7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 325,
                    "end": 328,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 329,
                    "end": 331,
                    "text": "4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "SNs were introduced (with the name Well-Formed Nets) in [8] . It is a formalism, similar to Colored Petri Nets, featuring a syntax designed to naturally make symmetries explicit when the modelled system is symmetric (e.g. composed of several similarly behaving entities). A little SN model is depicted in Fig. 1 , it is a small portion of a Distributed Memory fault tolerance mechanism model presented in [2] ; the picture has been drawn with the GreatSPN GUI [1] and then (manually) translated into the textual format accepted by SNexpression (file with .sn extension). The automatic export from the GreatSPN GUI to the SNexpression net format is a planned future work. This is a natural choice since GreatSPN has been the first tool to support Symmetric Nets, moreover the GUI has been designed to allow extensions to the syntax (in SNexpression arc function terms may have both guards and filters) and handle several formalisms. For the sake of space in this section we shall only describe in some detail the color structure of a SN, assuming that the reader is familiar with PN and HLPN formalisms and the definition of places, transitions, input, output and inhibitor arcs, marking. The color structure of a SN is built upon the basic color classes C = {C i , i = 1, . . . , n} which are finite and disjoint sets 2 , may be (circularly) ordered or partitioned into static subclasses C i,j . Transition and place color domains are defined as Cartesian products of classes : D = C ei i , e i \u2265 0, i = 1, . . . , n (class C i appears e i times in the product). The color domain cd(p) of place p defines the possible colors (tuples of color elements from cd(p)) of the tokens in its marking; the color domain cd(t) of transition t defines its possible firing modes: these are tuples of color elements, and distinct typed variable names (var(t)) are used to refer to such elements in any tuple in cd(t).",
            "cite_spans": [
                {
                    "start": 56,
                    "end": 59,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 405,
                    "end": 408,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 460,
                    "end": 463,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 305,
                    "end": 311,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Definitions and Notation"
        },
        {
            "text": "Let us consider the model in Fig. 1 : C = {A, B, C, D}, classes A and D are partitioned into static subclasses; the cd(DM input) = A 2 , B, C, D and a tuple in this place could be dmt1, dmt2, dmv3, val2, rdok ; cd(CheckCM P ) = A, B, C (var(CheckCM P ) = {a, b, c}) and one possible firing mode, also called instance, of this transition is a = dmt1, b = dmv2, c = val1. The enabling conditions of a transition instance and the effect of its firing depend on the functions on its input, inhibitor and output arcs. Guards can be associated with transitions, to constrain the set of valid instances. Transition CheckCM P has several input and output places and its instances must satisfy predicate a \u2208 A 1 ; the function on the arc from DM input is S A{1}\u2212a, a, b, c, S D{4} , while the functions on the arcs connecting it to place DM master are a, b . The domain of an arc function linking place p to transition t is cd(t), whereas its codomain is Bag[cd(p)] 3 . Its general form is:",
            "cite_spans": [
                {
                    "start": 957,
                    "end": 958,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 29,
                    "end": 35,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "GreatSPN notation"
        },
        {
            "text": ". . , f k denoting the Cartesian product of class functions f i . Each class-function f is a linear function defined on a subset of variables of var(t) of the same type. Let var Ci (t) be the subset of var(t) of type C i , and C i the set of static subclasses of C i , then f :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GreatSPN notation"
        },
        {
            "text": "in this context denotes the projection of a transition instance on the k th element of type C i in its color domain; symbol ! denotes the successor operator mapping the value of v k to its successor (the type of v k must be ordered). S i,q /S i is a constant function mapping to the set C i,q /C i . Boolean expressions g i (guards) on var(t) may be associated with transitions or individual tuples; their terms are standard predicates checking whether two variables hold the same value, or if a variable \"belongs\" to a given static subclass; if g i is false for a given transition instance, the associated tuple evaluates to the empty-multiset. Scalars in class-functions must be such that no negative coefficients result from the evaluation of any color satisfying the guard possibly associated with the corresponding tuple/transition. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GreatSPN notation"
        },
        {
            "text": "q are allowed) and on their coefficients which cannot be negative, while the extensions are the use of intersection of basic class functions as tuple elements, and the possibility to use a predicate also as a filter placed as a prefix in front of a tuple (filtering out the elements not satisfying the filter predicate from the tuple evaluation). A number of unary and binary operators are defined on these expressions, which are useful when defining structural properties on SN models. The SNexpression tool implements a calculus on L and provides several off-the-shelf formulas to compute interesting structural properties of SN models.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GreatSPN notation"
        },
        {
            "text": "To the best of our knowledge no other tools implement a general calculus for structural analysis of HLPNs. Even very advanced tools, e.g. Snoopy [9] , take advantage of symmetry properties in the color structure to efficiently perform the net unfolding [10] , but do not exploit it for structural analysis.",
            "cite_spans": [
                {
                    "start": 145,
                    "end": 148,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 253,
                    "end": 257,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "GreatSPN notation"
        },
        {
            "text": "The architecture of SNexpression is organized in three layers, depicted in Fig. 2 : the Library for Symbolic Calculus (LSC), the SN management framework (SNF), and the Command Line Interface (CLI). The LSC is a sort of Computer Algebra System that handles base-level SN expressions. The SNF middle layer manages more abstract objects, such as structural relation formulae, directly derived from a SN definition that may be loaded into the system; it also provides the algorithms needed to automatically derive the SODE for a given SSN model, based on a manipulation of SSN annotations. The CLI is a shell surrounding both the library and the SN framework, through which the user can operate directly on base-level expressions, using the CLI as a sort of symbolic calculator, or at a higher level, performing structural analysis of (S)SN models previously loaded.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 75,
                    "end": 81,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Tool Architecture and Functions"
        },
        {
            "text": "To help the users operation during a session the CLI provides a multipage textual notebook where it is possible to annotate and save formulae to be submitted, or results, or comments, in other words anything useful to support multi-step complex analysis. Since the format of the LSC output is pretty similar to the syntax of CLI input, copy-and-paste from the notebook to the command window and vice-versa may be conveniently used.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tool Architecture and Functions"
        },
        {
            "text": "SNexpression is implemented in Java. The LSC is distributed as a standalone jar file, so that programmers can use it in other projects. Its API is available at URL: www.di.unito.it/ \u223c depierro/SNexpression/libAPI, we plan to make the LSC soon available as open-source project. At the current release, the CLI and the SNF are built as a unique executable, but we plan to make also the SNF accessible through a public API. Since the CLI reads from the standard input, it might be integrated in other tools. The following sections discuss the functions of the three layers of the tool architecture in more detail.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tool Architecture and Functions"
        },
        {
            "text": "The major functionalities and the design of the LSC are summarized here. The library implements a (parametric) rewriting system: algebraic rules are used to rewrite symbolic expressions composed of terms of L, and the associated set of operators: sum, difference, intersection, composition, transpose. Rewriting stops when no more rules apply, in which case the resulting term is considered in \"normal form\". Final expressions manipulated by the LSC match a sort of disjunctive normal form, where only SN functions, guards, filters and sum/intersection operators may occur.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The LSC: A Computer Algebra System for SN Expressions"
        },
        {
            "text": "With respect to earlier versions, the LSC currently supports both set-and bag-expressions (i.e. espressions returning multisets), with the only exception of composition, which is partially implemented for bag-expressions: its complete definition is work in progress. The support operator provides a convenient bridge between bag-and set-expressions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The LSC: A Computer Algebra System for SN Expressions"
        },
        {
            "text": "Thanks to its modular layout and intuitive API, the LSC may also be used as a standalone component. As a direct consequence of its design, it is possible to directly build and manipulate objects (terms) at three different levels: class-functions, guards/filters, and function-tuples. Each level has its own set of operators, similar among the levels. Guards/Filters (standard predicates), class-functions, and single function-tuples have a canonical representative, which coincides with their normal form. There is no canonical form for sums (bags) of function-tuples: in general, however, equivalence between expressions may be syntactically checked by using the difference operator.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The LSC: A Computer Algebra System for SN Expressions"
        },
        {
            "text": "Library Architecture and API. The library consists of around one hundred Java classes/interfaces, divided in ten packages. The adopted design has many advantages. Ease of extension/maintenance: changes or updates (e.g., adding new language elements) are low-cost. Modular testing/debugging: every single element of the language can be managed in a uniform way. Efficiency: term normalization complexity is alleviated by a reduced use of recursion (the normalization times for many examples, some of which very complex, vary from msec. to sec.).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The LSC: A Computer Algebra System for SN Expressions"
        },
        {
            "text": "A code snippet illustrating the several steps needed to create and normalize a SN expression (the transpose of a tuple composition) is listed in Fig. 3 . A (simplified) UML class-diagram describing the top of the LSC type hierarchy, and its connections to the lower levels, can be found in the tool home page, together with a small portion of the library's API concerning simplification methods.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 145,
                    "end": 151,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "The LSC: A Computer Algebra System for SN Expressions"
        },
        {
            "text": "The SNF implements the method to load a SN description and those to compute some symbolic structural relations on it, listed in Table 1 : some relations are functions on sets, others return multisets. For the structural relations computation it exploits the functions implemented in the library (difference, transpose, composition) on one hand, and the information on the loaded SN structure on the other hand: the model structure allows to select transition pairs that might be in import wncalculus . color . ColorClass ; import wncalculus . classfunction .*; import wncalculus . guard .*; import wncalculus . tuple .*; // ... ColorClass C = new ColorClass (\"C\" , true ); // ordered class C s.t. |C| > 1 Interval i1 = new Interval (3 ,8) structural conflict or causal connection relation, then the arc functions labeling the involved arcs are processed through the symbolic calculus implemented by the LSC. For the mutual exclusion structural relation an ad-hoc computation algorithm [7] is applied after pre-processing the selected arc expressions through the library methods.",
            "cite_spans": [
                {
                    "start": 732,
                    "end": 738,
                    "text": "(3 ,8)",
                    "ref_id": null
                },
                {
                    "start": 985,
                    "end": 988,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 128,
                    "end": 135,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "The Symmetric Nets Management Framework"
        },
        {
            "text": "Finally, the SNF implements the algorithm to derive a set of Symbolic Ordinary Differential Equations from a (partially unfolded) SN [3, 4] : it exploits the library to compute the (multiset) transpose of the arc expressions and to derive the enabling degree of homogeneous sets of transition instances. It operates with just one command print ode after having loaded the SN to be translated. A file .ode is produced, including the set of SODE (one for each model place) ready to be solved using Rstudio.",
            "cite_spans": [
                {
                    "start": 133,
                    "end": 136,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 137,
                    "end": 139,
                    "text": "4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "The Symmetric Nets Management Framework"
        },
        {
            "text": "The CLI is the user interface of the tool: despite its simplicity it provides the essential commands to access the main functions of the LSC and of the SNF implementing four kinds of commands: definition of classes or language expressions; application of operators to expressions and simplification; loading a SN and computing some structural relations on it; derivation of a set of SODE from a SN, which in turn needs the computation of some structural relations. The syntax of all commands is described in the manual: Table 1 summarizes the main types of commands; a few detailed examples are described in Sect. 3. By convention the color classes are denoted with capital letters (A, B, C, . ..) while small letters, possibly indexed with an integer, denote variables whose type is the corresponding capital letter class (e.g. a or a 2 of type A). Classes may be partitioned into static subclasses denoted by the class capital letter followed by an integer index (e.g. A{1} subclass of A). Classes have finite cardinality, but it can be defined to be parametric (by default any class has a parametric cardinality n greater than or equal to two; when a class is partitioned into static subclasses only one subclass may have parametric cardinality). Domains are Cartesian products of color classes, if one class appears more than once in a domain, it is listed once followed by the number of repetitions. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 520,
                    "end": 527,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 682,
                    "end": 693,
                    "text": "(A, B, C, .",
                    "ref_id": null
                }
            ],
            "section": "The Command Line Interface"
        },
        {
            "text": "Conflict SC(t1, t2, p) or SC(t1, t2)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Structural properties"
        },
        {
            "text": "Causal Connection SCC(t1, t2, p)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Self-Conflict SC(t, p) or SC(t)"
        },
        {
            "text": "Mutual Exclusion SME(t1, t2, p)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Self-Conflict SC(t, p) or SC(t)"
        },
        {
            "text": "Added By (set/ multiset) AB/ABmset(t, p)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Self-Conflict SC(t, p) or SC(t)"
        },
        {
            "text": "Removed By (set/multiset)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Self-Conflict SC(t, p) or SC(t)"
        },
        {
            "text": "Derivation of a set of SODE print ode",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RB/RBmset(t, p)"
        },
        {
            "text": "The expressions can be interpreted as functions mapping into multisets or functions mapping on sets, the latter case is the default. The prefix mset: indicates that an expression denotes a function mapping on multisets. The expressions syntax takes the form of a sum of tuples, each tuple may be prefixed with a filter and suffixed with a guard (both filter and guard take the form of SN standard predicates). The tuple elements are intersections ( * ) of basic functions: projection, complement, successor, constant (whole class or one static subclass).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RB/RBmset(t, p)"
        },
        {
            "text": "Operators can be applied to expressions: there are two unary operators, support and transpose, and two binary operators, difference and composition. The support operator can be applied to a multiset-expression to obtain the corresponding expression mapping on sets; the transpose operator is available both for expressions mapping on multisets and for those mapping on sets: the result of its application is an expression of the same type. The difference can be applied to any pair of expressions (of the same type) while the composition is completely implemented for expressions mapping on sets and on a significant subset of multiset expressions. These operators are the basis for the SN structural analysis implemented in the SN Management Framework. For instance the structural conflict between two transitions t 1 and t 2 sharing an input place p is computed as follows: I(t, p) and O(t, p) are respectively the expressions on the input and output arcs connecting p and t. This could be useful to identify the groups of immediate transitions that are potentially in conflict and define how such conflicts should be solved.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 876,
                    "end": 883,
                    "text": "I(t, p)",
                    "ref_id": null
                }
            ],
            "section": "RB/RBmset(t, p)"
        },
        {
            "text": "To support the user in performing experiments with the tool, the CLI embeds a multi-page notebook: it is possible to copy-and-paste commands annotated in the notebook to the command window and then copy-and-paste results from the command window back in the notebook. When the color classes involved in the expressions processed by the tool have parametric cardinality, the result of a computation is not a single expression but a list of expressions, each with associated a different range of possible values for the classes cardinality: indeed one of the strong points of the tool is its ability to handle expressions without necessarily fixing the color classes sizes, so that the obtained result is valid for a family of models differing only in the size of (some) color classes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RB/RBmset(t, p)"
        },
        {
            "text": "The goal of this section is to show on a few practical examples some features of SNexpression. Let us consider the relay race model in Fig. 4 (described in [7] ), representing a set of teams (class C), each composed of four athletes (ordered class N , |N | = 4), competing in a relay race. Some symbolic structural properties of interest are the causal connection and structural conflict involving transition Run and the immediate transitions pass, W in and notW in; these properties are useful (among others) for model validation purposes, or to correctly define immediate transition weights. Let us consider the commands summary in Table 2   Table 2 . Examples of structural relation expressions. 1) computes the instances c, n , n of pass that may enable an instance c 1, n 1 of Run: through Running; the result shows that such instances involve an athlete of the same team (c 1) with sequence number n equal to the predecessor 4 of n 1, provided that n = n 1 (i.e. the team has not run the last section yet). 2) computes the instances c, n , n of pass enabling instance c 1 of W in: the result has a filter and denotes the instances involving the same team c 1, and the last section runner (the predecessor of n ). 3) computes the structural auto-conflicts among different instances of W in, while the result of 4) shows that W in and notW in are mutually exclusive: indeed, W inner is input place for notW in and inhibitor place (with arc function S C ) for W in. In SSNs with immediate transitions it is useful to check for confusion, i.e., situations where the model is underspecified (a situation solved by using priorities). In our example, this may arise due to the fact that different instances of W in are in conflict with each other. There would be confusion if an instance of pass fired while an instance of W in is enabled: this could cause the enabling of another instance of W in in conflict with the former. 5) shows how to obtain the confusing instances of pass by composing the results of 2) and 3): in this case the SNF is not involved.",
            "cite_spans": [
                {
                    "start": 156,
                    "end": 159,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 135,
                    "end": 141,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 634,
                    "end": 651,
                    "text": "Table 2   Table 2",
                    "ref_id": null
                }
            ],
            "section": "Use Cases: Exploiting SNexpression"
        },
        {
            "text": "Other structural relations can be computed on the model in Fig. 1 , whose arc functions are a bit more complex as illustrated by relations 6) and 7) in Table 2 . The resulting expressions have the same domain as the 2 nd parameter of SC, namely A, B, C for 6) and A\u02c62, B, C, D for 7). The terms are pair-wise disjoint: this enhances readability and interpretation.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 59,
                    "end": 65,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 152,
                    "end": 159,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Use Cases: Exploiting SNexpression"
        },
        {
            "text": "The tool can be used for other purposes. A recent implementation concerns the automatic generation of Symbolic ODE from an SSN model (command print ode). The technique applies only to models whose underlying stochastic process is density dependent. One condition for an SSN to satisfy such property is the coverage of places by P-invariants. In [4] an application to a botnet model has been illustrated (this is one of the examples that can be downloaded from the tool's web page). SNexpression can be used to check if a given P-indexed vector of multiset expressions defines a set of colored Pinvariants, and possibly prove the coverage of all place instances. The expressions in the P-indexed vector denote functions from the place color domains to the P-invariant's domain. (ConnectBotN et, ConnBot) . The same result holds for all transitions, thus pinv[] is a P-invariant: it represents |L| invariants, indicating that the number of tokens with second component l \u2208 L is constant, and have the correct label in C. In the tool web page other P-invariants for this model are available.",
            "cite_spans": [
                {
                    "start": 345,
                    "end": 348,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [
                {
                    "start": 777,
                    "end": 802,
                    "text": "(ConnectBotN et, ConnBot)",
                    "ref_id": null
                }
            ],
            "section": "Use Cases: Exploiting SNexpression"
        },
        {
            "text": "SNexpression implements a symbolic calculus useful for studying the structure of a Symmetric Net and deriving information on its behavioral properties. It has also been used to derive a set of SODE from an SSN model for performance analysis purposes. Several extensions are planned: completing the composition of bag-expressions, further automation of net structural calculus (e.g., checking P-invariants or building Extended Conflict Sets), automatizing the SN partial unfolding procedure which is a preliminary step for the generation of the SODE from a SN model, providing access to the different software layers with suitable APIs. Finally, we plan to build a bridge between GreatSPN and SNexpression.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions and Installation Instructions"
        },
        {
            "text": "A free version of the tool is available: download the archive SNEx.zip from the project homepage www.di.unito.it/ \u223c depierro/SNexpression, unzip its content into a folder. The extracted file structure contains the main program SnexCLI.jar and, in the folder lib, the library SNexLib.jar. To launch the tool in an OS shell run: java -jar <path to SNexCLI.jar> (JRE 1.8 or above is necessary). At the project's web page, the user can find a reference manual and some examples to immediately start using it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions and Installation Instructions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Principles of Performance and Reliability Modeling and Evaluation",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "G"
                    ],
                    "last": "Amparore",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Balbo",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Beccuti",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Donatelli",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "227--254",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-30599-8_9"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Memory fault tolerance software mechanisms: design and configuration support through SWN models",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ballarini",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Capra",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Pierro",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "3rd International Conference on Application of Concurrency to System Design ACSD 2003",
            "volume": "",
            "issn": "",
            "pages": "111--121",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A tool for the automatic derivation of symbolic ODE from symmetric net models",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Beccuti",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Capra",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Follia",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pernice",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "27th IEEE International Symposium MASCOTS 2019",
            "volume": "",
            "issn": "",
            "pages": "36--48",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Deriving symbolic ordinary differential equations from stochastic symmetric nets without unfolding",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Beccuti",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Capra",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pernice",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "EPEW 2018",
            "volume": "11178",
            "issn": "",
            "pages": "30--45",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-02227-3_3"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A high level language for structural relations in well-formed nets",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Capra",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "ICATPN 2005. a high level language for structural relations in well-formed nets",
            "volume": "3536",
            "issn": "",
            "pages": "168--187",
            "other_ids": {
                "DOI": [
                    "10.1007/11494744_11"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A tool for symbolic manipulation of arc functions in symmetric net models",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Capra",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the 7th International Conference VALUETOOLS 2013",
            "volume": "",
            "issn": "",
            "pages": "320--323",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Computing structural properties of symmetric nets",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Capra",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 15th International Conference on Quantitative Evaluation of Systems",
            "volume": "15",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Stochastic well-formed coloured nets for symmetric modelling applications",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Chiola",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Dutheillet",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Franceschinis",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Haddad",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "IEEE Trans. Comput",
            "volume": "42",
            "issn": "11",
            "pages": "1343--1360",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Snoopy -a unifying petri net tool",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Heiner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Herajy",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rohr",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schwarick",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "PETRI NETS 2012",
            "volume": "7347",
            "issn": "",
            "pages": "398--407",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-31131-4_22"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "An efficient method for unfolding colored Petri nets",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Heiner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Winter Simulation Conference, WSC 2012",
            "volume": "295",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "2}isA 2 +sm{1..3}isA 3 classN circular n1..4 [n 1 ++ = n 2 ] c, n 1 ++ SNexpression CLI and .sn notation S A{1} \u2212 a, a, b, c, S D{4} S A{1}, b, c, S D{4} [a in A{1}] MBOX := A\u02c62, B, C, D classA := {3, 2, 3} setN {4}ordered c, !n 1 [!n 1 != n 2] Fig. 1. A fragment of a distributed memory SSN model.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "contains examples of arc expressions involving several classes; in the table examples of functions operating on ordered classes (see Fig. 4) are also shown. The calculus on which SNexpression operates, handles expressions of a language (L) introduced in [5], very similar to arc functions but with additional constraints and a couple of extensions: the constraints are on the basic class functions (only",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "SN framework and the symbolic calculus on expressions Implements a set of textual commands to access to the functionalities Architecture of SNexpression.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "= Membership . build ( d_1 , sd2 , true , dom ); // d_1 \\ in D {2} Tuple t1 , t2 ; t1 = new Tuple ( dom , c_1 , comp_c_1 , c_2 , d_1 ); // <c_1 ,S -c_1 ,! c_2 , d_1 > t2 = new Tuple ( null , g1 , dom , comp_c_1 , c_2 , inter ); // <S -c_1 ,! c_2 ,(S -d_1 * S_D {2}) >[ d_1 in D {2}] TupleComposition tcom = new TupleComposition (t1 , t2 ); TupleTranspose tcom_trans = new TupleTranspose ( tcom ); List < LogicalExpr > result = tcom_trans . simplify () ; System . out . println ( result ); Snippet showing creation and simplification of \"function-tuple\" expressions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "ordered) class set C ordered and its subclasses set M := {10, 3, [4, n]} Show class definition class(A) Symbol definition Define domain symbol dom := A\u02c62, B, C\u02c63 Define expression symbol exp := @A\u02c63 < a 1 * S \u2212 a 2, (a 1 + a 2) * S \u2212 a 3 > (with domain prefix) ( * : intersection, a i and S \u2212 a j: basic functions)may include a filter @D\u02c62[d 1! = d 2, d 2 in D{1}] < d 2, S \u2212 d 1 > and a guard @A\u02c63 < a 1, a 3 > [a 3 in M {2}] Define multiset expression mexp := @C, D mset : 2 < d 1, c 1 > + < S D, c 1 > Operators application support (applies to bag-expressions) <<mset expression>> transpose expression difference expression1 \u2212 expression2 composition expression1.expression2 implementation for bag-expressions is not yet complete simplify expression s(e) rewrites an expression into a normalized form simplify and fold sf (e) merges terms or expressions ( = constraints) Symmetric Nets Framework commands Nets management commands Load net load \"DistMem.sn\" Input/output/inhib. places and arc expr I(t) / O(t) / H(t) Symbols for arc (bag-)expressions I(t,p) / O(t,p) / H(t,p)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "An SN model of a relay race.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "SCC(pass, Run, Running) = @C, N c 1, !3n 1, S \u2212 n 1 2) SCC(pass, W in, F inished) = @C[n 1 = !3n 2] c 1, S N, S N 3) SC(W in) = @C S \u2212 c 1 4) SME(W in, notW in, W inner) = @C, N\u02c62 S C 5) s(fscc2.f sc3) = @C[n 1 =!3n 2] S \u2212 c 1, S N, S N where fscc2 := @C[n 1 =!3n 2] c 1, S N, S N , fsc3 := @C S \u2212 c 6) SC(RD MST, CheckCMP ) = ( a 1, S A, S B, S C, S D{4} + (S A{1} * S \u2212 a 1), a 1, b 1, c 1, S D{4} )[a 1 in A{1}] 7) SC(CheckCM P, RD MST ) = a 2, b 1, c 1 [a 1! = a 2, d 1 in D{4}, a 1 in A{1}, a 2 in A{1}] + a 1, S B, S C [d 1 in D{4}, a 1 in A{1}]",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "An example of P-vector of expressions C, L \u2192 Bag[L] is: pinv[NoConBot] := @C, L mset : l [c in C{1} + c in C{2}]; pinv[ConBot] := @C, L mset : l [c in C{2}]; pinv[InactBot] := @C, L mset : l [c in C{3} + c in C{4}]; pinv[ActBot] := @C, L mset : l [c in C{3} + c in C{4}]. In order to prove that this vector corresponds to a set of P-invariants we need to show, for each transition t, that the sum over all places of the compositions of P-invariant's function (pinv[p]) with the difference O(t, p) \u2212 I(t, p) results in the null function. Due to space constraints we show only the result for transition ConnectBot: s(pinv[NoConBot].f 4 + pinv[ConBot].f 5) = null where f 4 := @C, Lmset :< 0 C , 0 L > \u2212I(ConnectBotN et, N oConnBot) and f 5 := O",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Summary of the main commands implemented in the CLI.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}