{
    "paper_id": "72431b6decbbfe12d8b055b7fb20765d83c3b240",
    "metadata": {
        "title": "Alternating Finite Automata with Limited Universal Branching",
        "authors": [
            {
                "first": "Chris",
                "middle": [],
                "last": "Keeler",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Queen's University",
                    "location": {
                        "postCode": "K7L 2N8",
                        "settlement": "Kingston",
                        "region": "ON",
                        "country": "Canada"
                    }
                },
                "email": "keeler@cs.queensu.ca"
            },
            {
                "first": "Kai",
                "middle": [],
                "last": "Salomaa",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Queen's University",
                    "location": {
                        "postCode": "K7L 2N8",
                        "settlement": "Kingston",
                        "region": "ON",
                        "country": "Canada"
                    }
                },
                "email": "ksalomaa@cs.queensu.ca"
            }
        ]
    },
    "abstract": [
        {
            "text": "We consider measures that limit universal parallelism in computations of an alternating finite automaton (AFA). Maximum pared tree width counts the largest number of universal branches in any computation and acceptance width counts the number of universal branches in the best accepting computation, i.e., in the accepting computation with least universal parallelism. We give algorithms to decide whether the maximum pared tree width or the acceptance width of an AFA are bounded by an integer k. For a constant k the algorithm for maximum pared tree width operates in polynomial time. An AFA with m states and acceptance width k can be converted to an NFA with (m + 1) k states. We consider corresponding lower bounds for the transformation. The tree width of an AFA counts the number of all (existential and universal) branches of the computation. We give upper and lower bounds for converting an AFA of bounded tree width to a DFA.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Deterministic and nondeterministic finite automata (DFA and NFA) are well understood models for which a significant number of results are known. As a generalization of nondeterminism, alternation was introduced in [1] , and has since been studied extensively for Turing machines [5, 6, 23] , and pushdown automata [1, 20] .",
            "cite_spans": [
                {
                    "start": 214,
                    "end": 217,
                    "text": "[1]",
                    "ref_id": null
                },
                {
                    "start": 279,
                    "end": 282,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 283,
                    "end": 285,
                    "text": "6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 286,
                    "end": 289,
                    "text": "23]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 314,
                    "end": 317,
                    "text": "[1,",
                    "ref_id": null
                },
                {
                    "start": 318,
                    "end": 321,
                    "text": "20]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The power of alternation in finite automata (AFAs) was first studied by Chandra, Kozen, and Stockmeyer [1] , later by King [15] and Hromkovi\u010d [10] , and state complexity trade-offs with NFAs and DFAs were given by Fellah et al. [3] . However, results on alternating finite automata remain relatively sparse compared to alternating pushdown automata and alternating (infinite) automata, and little effort has been made towards examining restricted computations within the context of alternation.",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 106,
                    "text": "[1]",
                    "ref_id": null
                },
                {
                    "start": 123,
                    "end": 127,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 142,
                    "end": 146,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Restricted amounts of nondeterminism have been measured in various ways, including but not limited to ambiguity [19] , tree width [11, 22] , and string path width [13] . These so-called \"measures of nondeterminism\" examine some aspect of an automaton's computations. For example, the number of partial, or accepting computations on a given string. For a particular regular language and model, the state complexity is a measure of how complicated it is for that model to capture that language. The state complexity is combined with these measures of restricted nondeterminism, yielding tradeoffs between the amount of nondeterminism and the number of states required.",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 116,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 130,
                    "end": 134,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 135,
                    "end": 138,
                    "text": "22]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 163,
                    "end": 167,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "An automaton is said to alternate when it switches from an existential state to a universal state (or vice versa) [1] . There exists an exponential state complexity blow-up between two-way AFAs with at most k alternations and two-way AFAs with at most k + 1 alternations, and in general this hierarchy is infinite [7] . The emptiness problem for AFAs was shown to be PSPACE-Complete for general alphabets [8, 12] . More recently, the state complexity of various operations on AFAs has also been studied [9] .",
            "cite_spans": [
                {
                    "start": 114,
                    "end": 117,
                    "text": "[1]",
                    "ref_id": null
                },
                {
                    "start": 314,
                    "end": 317,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 405,
                    "end": 408,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 409,
                    "end": 412,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 503,
                    "end": 506,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we focus on the original model of AFAs (introduced by Chandra, Kozen, and Stockmeyer) where the states are either existential or universal [1, 7, 10, 12, 15, 23] , rather than the one where states are labeled with boolean functions [18] . However, both of these models recognize exactly the regular languages. We also do not consider states or transitions with negation, though there is only a linear blow-up between our model and the one which can perform negation [3] .",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 157,
                    "text": "[1,",
                    "ref_id": null
                },
                {
                    "start": 158,
                    "end": 160,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 161,
                    "end": 164,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 165,
                    "end": 168,
                    "text": "12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 169,
                    "end": 172,
                    "text": "15,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 173,
                    "end": 176,
                    "text": "23]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 247,
                    "end": 251,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 481,
                    "end": 484,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This paper is organized as follows. Section 2 recalls several definitions, and fixes our model for alternating finite automata. Section 2.1 introduces the notions of acceptance width and maximal pared tree width, and provides several initial results and bounds for these new metrics. Section 3 gives a polynomial transformation for an NFA to simulate an AFA with bounded parallelism, shows that the decidability of several decision problems for AFAs with finite acceptance width, and gives algorithms to decide whether an AFA's maximal pared tree width or acceptance width is bounded by a given constant. Section 4 presents unary witness languages with finite acceptance width (with respect to the number of states) which require only a small number of states to be recognized by an AFA, but require an exponential number of states to be recognized by an NFA or DFA. Finally, Sect. 4.1 introduces a non-unary witness language, and provides another exponential state complexity blow-up; this time between AFAs with bounded tree width (with respect to the number of states), and NFAs and DFAs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "An AFA is a 6-tuple, A = (Q e , Q u , \u03a3, \u03b4, q 0 , F ) where Q e (the existential state set) and Q u (the universal state set) are finite sets of states such that Q e \u2229 Q u = \u2205, \u03a3 is the input alphabet, \u03b4 : (Q e \u222a Q u ) \u00d7 \u03a3 \u2192 2 Qe\u222aQu is the transition function, q 0 \u2208 Q e \u222aQ u is the initial state, and F \u2286 Q e \u222aQ u is the set of final states. We use \u03b5 to mean the empty string, and A q to mean A with a different specified starting state, q \u2208 Q e \u222a Q u . Note that the standard NFA model can be seen as an AFA where Q e contains all of the states, and Q u is empty. We must further specify the language of an AFA, to account for the differences caused by universal states. We do this by defining them bottom-up with respect to their states. Definition 1. Let A = (Q e , Q u , \u03a3, \u03b4, q 0 , F ) be an AFA, and A q be a copy of the AFA with q \u2208 Q e \u222a Q u as the initial state. We point out that \u03b5 \u2208 L(A q ) if q \u2208 F . Consider q \u2208 Q e \u222a Q u , a \u2208 \u03a3 where \u03b4(q, a) = {p 1 , . . . , p n }. Then for x \u2208 \u03a3 * , define:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The language of A is defined as L(A) = L(A q0 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The computation tree of an AFA A on \u03b5 from q \u2208 Q e \u222a Q u , denoted T A,q,\u03b5 is the singleton node (q, \u03b5). The computation tree of an AFA A on cv from q, denoted T A,q,cv , such that q \u2208 Q e \u222a Q u , c \u2208 \u03a3, v \u2208 \u03a3 * is defined inductively as the tree:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "-whose internal nodes are labeled by a tuple (p, a), for p \u2208 Q, a \u2208 \u03a3 (i.e., each internal node is labeled by a state and character) -which is rooted by a node (q, c) -where the trees rooted at the children of (q, c) are",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "If a computation tree of an AFA A on a string x starts on the initial state of A, then we omit the state label, denoting it as T A,x . We use the notation leaves(T ) to mean the (depth-first) ordered tuple of leaves in the computation tree T . The computation tree of an NFA is defined similarly, except its nodes are always labeled by existential states [11] . We define the paring of a computation tree, which serves as the transformation around which our new measures are defined. For an AFA A = (Q e , Q u , \u03a3, \u03b4, q 0 , F ) and a string x \u2208 \u03a3 * , a pared computation tree of T A,x is defined as a tree where for each node (q, a) \u2208 T A,x :",
            "cite_spans": [
                {
                    "start": 355,
                    "end": 359,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "-if q \u2208 Q e then keep only one child node, and -if q \u2208 Q u then keep all child nodes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Since there is a choice made on each of the existential nodes, the same computation tree can result in many different pared computation trees. A pared tree represents a possible computation of the AFA A. At nodes labeled by existential states, the pared tree follows one (nondeterministically chosen) way to continue the computation. The nodes labeled by universal states have children labeled by all states reachable from that state in the next computation step. Note that every pared tree of an NFA will only have one leaf, since all of its states are existential. We denote the set of all pared computation trees on a tree T as \u2702(T ). A pared computation tree is accepting if all of its leaves are labeled by accepting states (implying that no leaf is the failure node), and a string x is accepted by an AFA if and only if A has an accepting pared computation tree in \u2702(T A,x ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Without loss of generality, we assume that all of an AFA's universal states are reachable. However, since emptiness for AFAs is PSPACE-Complete, we cannot assume that all of an AFA's states are useful in the sense that they can be used in an accepting computation. Since a universal state with at most one outgoing transition per character is no different than using an existential state, we also assume that every universal state has multiple outgoing transitions on at least one character.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "For a regular language L, sc(L), (respectively, nsc(L), asc(L)), is the state complexity, (respectively, nondeterministic and alternating state complexity) of L.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The tree width [11] of an AFA A on a string x, denoted tw(A, x), is the number of leaves in the computation tree of A on x. That is, tw(A, x) = |leaves(T A,x )|.",
            "cite_spans": [
                {
                    "start": 15,
                    "end": 19,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Tree Width of Alternating Machines"
        },
        {
            "text": "Since the notion of tree width is originally based on the computation tree of an NFA, and our AFA definition extends the original notion of computation trees, it seems natural to look at \"alternating tree widths\".",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tree Width of Alternating Machines"
        },
        {
            "text": ", is the minimum number of leaves of any accepting pared computation tree of T A,x . The maximum pared tree width of A on a string x \u2208 \u03a3 * , denoted mptw(A, x), is the maximum number of leaves of any pared computation tree of T A,x . Formally, these are:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tree Width of Alternating Machines"
        },
        {
            "text": "Since the (original) tree width does not perform the paring operation, we get that for any AFA A and string x, aw(A, x) \u2264 mptw(A, x) \u2264 tw(A, x). We also get the following condition for equality between the measures, which occurs when the paring operation does not change the computation tree. Remark 1. Let A be an AFA, and x a string. Then mptw(A, x) = tw(A, x) if and only if each node in T A,x with more than one child is labeled by some universal state in A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tree Width of Alternating Machines"
        },
        {
            "text": "We extend the acceptance width and maximum pared tree width functions as functions on integers in the normal manner: If, for a string x, there are no accepting computation trees, then aw(A, x) = 0. Since the emptiness problem is PSPACE-complete for AFAs [8] , and these results hold even for unary languages, then we get the following equivalence.",
            "cite_spans": [
                {
                    "start": 254,
                    "end": 257,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Tree Width of Alternating Machines"
        },
        {
            "text": "A be an AFA. Then it is PSPACE-complete to decide whether or not aw(A) = 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Remark 2 ([8]). Let"
        },
        {
            "text": "If an m-state AFA has finite tree width, then its tree width is at most 2 m\u22122 [22] . Since, on any string, the acceptance width and maximal pared tree width of an AFA are upper-bounded by the tree width, we get the following conditional upper bound. Alternatively, we could replace the computation trees by directed acyclic graphs by merging any nodes on the same state on the same level. However, in this case, the acceptance width and maximal pared tree width of an m-state AFA would be at most m.",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 82,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Remark 2 ([8]). Let"
        },
        {
            "text": "Normally, an NFA may require an exponential state blow-up to simulate an AFA [3] . It is known that the emptiness problem for NFAs can be solved in linear time, with respect to the number of states, using a breadth first search [4] . The transformation from Lemma 1 then yields a polynomial-time algorithm to decide emptiness for a finite acceptance width AFA. Using the transformation from Lemma 1, but modifying which states of the NFA are accepting, we can also decide whether the maximal pared tree width of an AFA is bounded.",
            "cite_spans": [
                {
                    "start": 77,
                    "end": 80,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Decision Problems for Pared Tree Width and Acceptance Width"
        },
        {
            "text": "Using similar ideas from the characterization of NFAs with finite tree width [22] , we are able to characterize AFAs with finite maximal pared tree width. Modifying existing algorithms for deciding finiteness of an NFA's tree width [14] , we are also able to decide finiteness of an AFA's maximal pared tree width in polynomial time. The general membership problem is P-complete for AFAs [12] , and this holds even for finite unary languages. In fact, this P-completeness is even stronger, as it holds for all cycle-free AFAs.",
            "cite_spans": [
                {
                    "start": 77,
                    "end": 81,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 232,
                    "end": 236,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 388,
                    "end": 392,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. Let A be an m-state AFA and k a constant. Then we can decide whether or not the maximal pared tree width of A is at most k in O(m k ) time."
        },
        {
            "text": "Since an m-state cycle-free AFA has at most m \u2212 1 states being evaluated in parallel, then the membership problem for AFAs with bounded parallel computations is also P-complete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 4 ([14]). Let"
        },
        {
            "text": "We can also decide whether the pared acceptance width of an AFA is finitely bounded by some number.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 5 ([12]). Let A be a finite maximal pared tree width AFA. Then for a string x, it is P-complete to decide whether x \u2208 L(A)."
        },
        {
            "text": "While it is decidable whether the acceptance width of an AFA is bounded by an integer k, the algorithm presented in Theorem 2 is not an efficient one and we cannot expect to have an efficient algorithm for this problem 2 . For a given AFA A and k \u2208 N we can construct an AFA A that begins the computation by a universal step with k+1 choices, where the first computation simulates A and the remaining k computations always accept deterministically. Then aw(A ) \u2264 k if and only if L(A) = \u2205 and deciding the emptiness of an AFA is PSPACE-complete [8] .",
            "cite_spans": [
                {
                    "start": 545,
                    "end": 548,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 2. Let A be an AFA, and k \u2208 N. Then it is decidable whether the acceptance width of A is bounded by k."
        },
        {
            "text": "For any AFA A with finite tree width, the acceptance width of A must also be finite. Under this restriction, we can decide whether the acceptance width of A is finite using the construction from Theorem 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2. Let A be an AFA, and k \u2208 N. Then it is decidable whether the acceptance width of A is bounded by k."
        },
        {
            "text": "Since the acceptance width of an AFA is only upper bounded by its tree width, it is possible that an AFA has infinite tree width and finite acceptance width. In this case, we do not have an upper bound for the acceptance width.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 6. Let A be an m-state AFA with finite tree width. By Corollary 1, the acceptance width is then at most 2 m\u22122 . Since the acceptance width of A is finite if and only if it is at most 2 m\u22122 , then it is decidable whether the acceptance width of A is finite. We do this by using Theorem 2 with an input value of 2 m\u22122 ."
        },
        {
            "text": "As a result, it is not immediately obvious whether the finiteness of an AFA's acceptance width is decidable in general. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Question 1. Let A be an m-state AFA with infinite tree width and finite acceptance width k. Is there any expression in m which bounds k?"
        },
        {
            "text": "Let I be a set of integers, and LCM (I) be the least common multiple of all elements in I. We define L \u2200I as the set of all unary strings whose lengths are the product of all integers in I. The state complexity is, of course, maximal with respect to the size of the input set when its elements are pairwise coprime. Proof. Let I = {p 1 , . . . , p n } be a set of integers whose elements are pairwise coprime. We give the AFA recognizing L \u2200I in Fig. 1 , whose tree width and number of states matches the claim. Since I's elements are pairwise coprime,",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 323,
                    "end": 339,
                    "text": "Let I = {p 1 , .",
                    "ref_id": null
                },
                {
                    "start": 446,
                    "end": 452,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "State Complexity"
        },
        {
            "text": "p i . And by Lemma 2, sc(L \u2200I ) = nsc(L \u2200I ) = LCM (I).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "State Complexity"
        },
        {
            "text": "Recognizing that the state complexity blow-up in Lemma 3 is exactly Landau's function [2, 21] , we get the following exponential state complexity trade-off between AFAs with finite tree width (and therefore also finite acceptance width) and NFAs. A similar idea and result was also given by Kupferman et al. [17] , though it was formulated to capture the unary language a n+i , for i \u2265 0.",
            "cite_spans": [
                {
                    "start": 86,
                    "end": 89,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 90,
                    "end": 93,
                    "text": "21]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 308,
                    "end": 312,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "State Complexity"
        },
        {
            "text": "Theorem 3 ([2,17,21] ). Let I be a set of pairwise coprime integers, and A be an (m \u2212 1)-state AFA recognizing L \u2200I with tree width |I|. Then any NFA equivalent to A will require at least e (1+o(1))\u00b7 \u221a m ln m states.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 10,
                    "end": 20,
                    "text": "([2,17,21]",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "State Complexity"
        },
        {
            "text": "While Landau's function gives a lower bound for the state complexity blowup of simulating a restricted tree width AFA with an NFA, it is only given in terms of the number of states.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "State Complexity"
        },
        {
            "text": "Let I = {p 1 , . . . , p n } be a set of pairwise coprime integers, for some n \u2208 N. Let A be an m-state AFA such that A has acceptance width n and recognizes L \u2200I . Then any NFA equivalent to A will require at least ( m n\u00b7pn ) n states. In the general case, for every m, there exists an m-state AFA which cannot be simulated by any NFA with fewer than 2 m states [3] , and any equivalent DFA needs 2 2 m states [1] . However, to get this double-exponential state complexity blow-up, the m-state AFA needs a tree width much larger than m.",
            "cite_spans": [
                {
                    "start": 363,
                    "end": 366,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 411,
                    "end": 414,
                    "text": "[1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "Let P = {p 1 , . . . , p n } be a set of n prime numbers. We define L 2P , the set of all unary strings whose lengths are a product of at least two distinct primes from P.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "Lemma 5. There exists an AFA A recognizing L 2P with 1+ n(n\u22121)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "states 3 and a maximal pared tree width of 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "We extend L 2P , defining L kP as the set of all unary strings whose lengths are a product of at least k distinct primes from P, for some constant k.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "such that (\u2200i) 1 \u2264 i \u2264 k, y \u2261 0 (mod r i )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "Using similar ideas as the proof from Lemma 5 but operating on an arbitrary number of elements instead of only two, we get the following result. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4."
        },
        {
            "text": "For two strings v, v \u2208 \u03a3 * , we say that v and v are disjoint if they do not share any symbols. We extend this notion to tuples of strings, such that a tuple of strings W is disjoint if and only if all pairs of strings x, x \u2208 W are disjoint. A bitstring b 1 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n is a string for representing some boolean value across a set of n elements. We define the cardinality of a bistring as the number of 1s appearing in that bitstring.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Universal Infix Language"
        },
        {
            "text": "The universal infix language of an ordered string tuple W consists of strings that contain each x \u2208 W as an infix. We define a labeling function h W : \u03a3 * \u2192 {0, 1} n which takes as input a string s \u2208 \u03a3 * and an n-tuple W, and produces the bitstring b 1 \u00b7 \u00b7 \u00b7 b n , where b i = 1 if and only if the i th element of W is an infix of s, for 1 \u2264 i \u2264 n. More formally, the universal infix language over a tuple of strings W and an alphabet \u03a3 is defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Universal Infix Language"
        },
        {
            "text": "An AFA with small amounts of alternation can recognize this language with relatively few states, and limited universal branching. Proof. Let W = (x 1 , . . . , x n ) be an ordered, disjoint tuple of strings, and let x i [j] be the j th character of the i th string. We give the general structure for an AFA in This AFA has tree width n, and only alternates between universal and existential states once. The only final state is the one at the end of all the branches. And, excepting the initial state, we define the transition function deterministically. If the machine is reading x i , has read up to x i [j], and then encounters some mismatched symbol, then the computation path currently in state i.j will return to state i, indicating that the infix must be restarted.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Universal Infix Language"
        },
        {
            "text": "However, a DFA for L \u2200W needs exponentially more states than an AFA. Furthermore, the addition of nondeterminism does not improve this bound. [2] xn [2] \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u03a3 Fig. 2 . AFA for a universal infix language over (x1, . . . , xn)",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 145,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 149,
                    "end": 152,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [
                {
                    "start": 167,
                    "end": 173,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "Universal Infix Language"
        },
        {
            "text": "Combining Lemmas 7, 8, and 9, we get the following theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Universal Infix Language"
        },
        {
            "text": "There exists an m-state AFA A (where m can be arbitrarily large) with tree width n such that any equivalent NFA needs (m \u2212 n) \u00b7 2 n\u22121 states. The AFA A can be chosen to alternate only once between universal and existential states. We note that the alphabet size of A depends on n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "We give the following constructive example to help clarify the state blow-up from Theorem 4. W = (aa, b, c) , and A = (Q, {a, b, c}, \u03b4, q 0 , {111}) be the DFA given in Fig. 3, which recognizes L \u03b1(aa,b,c) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 93,
                    "end": 107,
                    "text": "W = (aa, b, c)",
                    "ref_id": null
                },
                {
                    "start": 169,
                    "end": 205,
                    "text": "Fig. 3, which recognizes L \u03b1(aa,b,c)",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Theorem 4."
        },
        {
            "text": "To make counting of states easier, below we assume that an AFA computation step always has at most two choices (i.e. computation step is either undefined, is deterministic, or has exactly two existential or universal choices). This assumption can be made with only a constant factor blow-up of the automaton's state complexity [16] .",
            "cite_spans": [
                {
                    "start": 327,
                    "end": 331,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Example 1. Let"
        },
        {
            "text": "A be an m-state AFA with tree width n. Then A has an equivalent DFA B with at most (m + 1) n \u00b7 (2 n \u2212 1) states.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 10. Let"
        },
        {
            "text": "Combining the upper and lower bounds from Lemmas 8, 9 and 10, we get the following state complexity range for simulating a finite tree width AFA with a DFA. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 10. Let"
        }
    ],
    "bib_entries": {
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Finite automata and unary languages",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chrobak",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "Theoret. Comput. Sci",
            "volume": "47",
            "issn": "",
            "pages": "149--158",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Constructions for alternating finite automata",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Fellah",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "J\u00fcrgensen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Int. J. Comput. Math",
            "volume": "35",
            "issn": "1-4",
            "pages": "117--132",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Problems on finite automata and the exponential time hypothesis",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Fernau",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Krebs",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Algorithms",
            "volume": "10",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "The state complexity of alternating automata",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Fijalkow",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2018",
            "volume": "",
            "issn": "",
            "pages": "414--421",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Checking finite traces using alternating automata. Formal Methods Syst",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Finkbeiner",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Sipma",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Des",
            "volume": "24",
            "issn": "2",
            "pages": "101--127",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "An alternating hierarchy for finite automata",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Geffert",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Theor. Comput. Sci",
            "volume": "445",
            "issn": "",
            "pages": "1--24",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "On emptiness and counting for alternating finite automata",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Holzer",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Developments in Language Theory II",
            "volume": "",
            "issn": "",
            "pages": "88--97",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Operations on boolean and alternating finite automata",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hospod\u00e1r",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jir\u00e1skov\u00e1",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Kraj\u0148\u00e1kov\u00e1",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "CSR 2018",
            "volume": "10846",
            "issn": "",
            "pages": "181--193",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-90530-3_16"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "On the power of alternation in automata theory",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hromkovi\u010d",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "J. Comput. Syst. Sci",
            "volume": "31",
            "issn": "1",
            "pages": "28--39",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Communication complexity method for measuring nondeterminism in finite automata",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hromkovi\u010d",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Seibert",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Karhum\u00e4ki",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Klauck",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schnitger",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Inform. Comput",
            "volume": "172",
            "issn": "2",
            "pages": "202--217",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A note on the space complexity of some decision problems for finite automata",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Ravikumar",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Inf. Process. Lett",
            "volume": "40",
            "issn": "1",
            "pages": "25--31",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Branching measures and nearly acyclic NFAs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Keeler",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "DCFS 2017",
            "volume": "10316",
            "issn": "",
            "pages": "202--213",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Nondeterminism growth and state complexity",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Keeler",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "; M"
                    ],
                    "last": "Salomaa",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jir\u00e1skov\u00e1",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Hospod\u00e1r",
            "volume": "11612",
            "issn": "",
            "pages": "210--222",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-23247-4_16"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Alternating multihead finite automata (extended abstract)",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "N"
                    ],
                    "last": "King",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "ICALP 1981",
            "volume": "115",
            "issn": "",
            "pages": "506--520",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-10843-2_40"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Measures of parallelism in alternating computation trees (extended abstract)",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "N"
                    ],
                    "last": "King",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Proceedings of the 13th Annual ACM Symposium on Theory of Computing",
            "volume": "",
            "issn": "",
            "pages": "189--201",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Counting with automata",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kupferman",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ta-Shma",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "Y"
                    ],
                    "last": "Vardi",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Short Paper Presented at the 15th Annual IEEE Symposium on Logic in Computer Science (LICS 2000",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Succinct representation of regular languages by boolean automata",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "L"
                    ],
                    "last": "Leiss",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Theor. Comput. Sci",
            "volume": "13",
            "issn": "",
            "pages": "323--330",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Descriptional complexity of nfa of different ambiguity",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Leung",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Int. J. Found. Comput. Sci",
            "volume": "16",
            "issn": "5",
            "pages": "975--984",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "A grammatical characterization of alternating pushdown automata",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Moriya",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Theor. Comput. Sci",
            "volume": "67",
            "issn": "1",
            "pages": "75--85",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Unambiguous finite automata over a unary alphabet",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Okhotin",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Inf. Comput",
            "volume": "212",
            "issn": "",
            "pages": "15--36",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "State complexity of finite tree width nfas",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Palioudakis",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "G"
                    ],
                    "last": "Akl",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Autom. Lang. Comb",
            "volume": "17",
            "issn": "2-4",
            "pages": "245--264",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Tree-size bounded alternation",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "L"
                    ],
                    "last": "Ruzzo",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "J. Comput. Syst. Sci",
            "volume": "21",
            "issn": "2",
            "pages": "218--235",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "{aw(A, )}, and mptw(A) = sup \u2208N {mptw(A, )}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "A be an m-state AFA with finite tree width. Then aw(A) \u2264 mptw(A) \u2264 2 m\u22122 .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "However, an NFA can simulate any finite acceptance width AFA with at most a polynomial blow-up in the number of states. An m-state AFA A with acceptance width k can be simulated by an NFA where the states are k-tuples of states of A and transitions of the NFA simulate at most k parallel computations of A. Lemma 1. Let A be an m-state AFA, such that aw(A) \u2264 k, for some constant k. Then (m + 1) k states are sufficient for an NFA to simulate A.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "A be an m-state AFA with finite acceptance width k, for some constant k. Then in O(m k ) time we can decide whether L(A) = \u2205.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Let A = (Q u , Q e , \u03a3, \u03b4, q 0 , F ) be an AFA. Then mptw(A) > 2 m\u22122 if and only if there exists some state q \u2208 Q u and character c \u2208 \u03a3 such that |\u03b4(q, c)| \u2265 2 and q is involved in a cycle.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "A = (Q u , Q e , \u03a3, \u03b4, q 0 , F ) be an m-state AFA. Then we can decide whether or not the maximal pared tree width of A is bounded by some constant k in O(m 3 \u00b7 |\u03a3|) time 1 .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "A such that tw(A) / \u2208 O(1), does there exist an algorithm to decide whether or not aw(A) \u2208 O(1)?",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Let I be a set of integers. Then sc(L \u2200I ) = nsc(L \u2200I ) = LCM (I).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Let I = {p 1 , . . . , p n } be a set of n integers. If the elements of I are pairwise coprime, then there exists an AFA A recognizing L \u2200I with 1 + n i=1 p i states and tree width n such that sc(L(A)) = nsc(L(AFA for L \u2200P where P = {p1, . . . , pn}. Universal states are marked with an additional label 'u', and existential states are given as normal.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "For every k \u2265 2, there exists an AFA A recognizing L kP with 1 + n k + n i=1 (p i \u2212 1) states and a maximal pared tree width of k.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Let W = (x 1 , . . . , x n ) be an ordered, disjoint tuple of strings. Then there exists an AFA recognizing L \u03b1W with 2 + n i=1 |x i | states and tree width n.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "which recognizes L \u03b1W with 1 universal and 1 + n i=1 |x i | existential states.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Let W = (x 1 , . . . , x n ) be a disjoint tuple of strings. Then sc(L \u03b1W ) = 2 n + 2 n\u22121 \u00b7 n i=1 (|x i | \u2212 1).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "Let W = (x 1 , . . . , x n ) be a disjoint tuple of strings. Then nsc(L \u03b1W ) = 2 n + 2 n\u22121 \u00b7 n i=1 (|x i | \u2212 1).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF14": {
            "text": "12-State DFA for L \u03b1(aa,b,c) Corollary 7. Let A be an m-state AFA with tree width n. Then 2 n\u22121 \u00b7 (m \u2212 n) \u2264 sc(L(A)) \u2264 (2 n \u2212 1) \u00b7 (m + 1) n .",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "We thank the referees for their helpful and thoughtful comments. But, due to the short deadline for submitting the proceedings version, we will try to implement some revisions for a later journal version.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgments. Research supported by NSERC grant OGP0147224."
        }
    ]
}