{
    "paper_id": "dd40405504421d8ab202a1ec8346fb01204c59c7",
    "metadata": {
        "title": "Reasoning About Strong Inconsistency in ASP",
        "authors": [
            {
                "first": "Carlos",
                "middle": [],
                "last": "Menc\u00eda",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Oviedo",
                    "location": {
                        "settlement": "Gij\u00f3n",
                        "country": "Spain"
                    }
                },
                "email": "menciacarlos@uniovi.es"
            },
            {
                "first": "(",
                "middle": [
                    "B"
                ],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Joao",
                "middle": [],
                "last": "Marques-Silva",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Toulouse",
                    "location": {
                        "settlement": "Toulouse",
                        "country": "France"
                    }
                },
                "email": "joao.marques-silva@univ-toulouse.fr"
            }
        ]
    },
    "abstract": [
        {
            "text": "The last decade has witnessed remarkable improvements in the analysis of inconsistent formulas, namely in the case of Boolean Satisfiability (SAT) formulas. However, these successes have been restricted to monotonic logics. Recent work proposed the notion of strong inconsistency for a number of non-monotonic logics, including Answer Set Programming (ASP). This paper shows how algorithms for reasoning about inconsistency in monotonic logics can be extended to the case of ASP programs, in the concrete case of strong inconsistency. Initial experimental results illustrate the potential of the proposed approach.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The last decade and a half witnessed a remarkable evolution in algorithms for reasoning about inconsistency. This is the case with algorithms for the extraction and enumeration of minimal unsatisfiable subsets (MUSes) [4] [5] [6] 8, 9, 33, 34, 37, 42] and minimal correction subsets (MCSes) [3, 6, 21, 26, 27, 36, 39, 40, 45] , but also algorithms for maximum satisfiability (MaxSAT) [1, 2, 18, 35, 41] . This work was motivated by earlier important advances [7, 17, 28, 29, 32, 48] . Although most of this work was proposed in the context of propositional formulas it is also the case that most of the algorithms are amenable to generalization for different fragments of First-Order Logic (FOL). These algorithms specifically addressed monotonic logics, with propositional logic as a concrete example.",
            "cite_spans": [
                {
                    "start": 218,
                    "end": 221,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 222,
                    "end": 225,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 226,
                    "end": 229,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 230,
                    "end": 232,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 233,
                    "end": 235,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 236,
                    "end": 239,
                    "text": "33,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 240,
                    "end": 243,
                    "text": "34,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 244,
                    "end": 247,
                    "text": "37,",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 248,
                    "end": 251,
                    "text": "42]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 291,
                    "end": 294,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 295,
                    "end": 297,
                    "text": "6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 298,
                    "end": 301,
                    "text": "21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 302,
                    "end": 305,
                    "text": "26,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 306,
                    "end": 309,
                    "text": "27,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 310,
                    "end": 313,
                    "text": "36,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 314,
                    "end": 317,
                    "text": "39,",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 318,
                    "end": 321,
                    "text": "40,",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 322,
                    "end": 325,
                    "text": "45]",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 384,
                    "end": 387,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 388,
                    "end": 390,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 391,
                    "end": 394,
                    "text": "18,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 395,
                    "end": 398,
                    "text": "35,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 399,
                    "end": 402,
                    "text": "41]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 459,
                    "end": 462,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 463,
                    "end": 466,
                    "text": "17,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 467,
                    "end": 470,
                    "text": "28,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 471,
                    "end": 474,
                    "text": "29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 475,
                    "end": 478,
                    "text": "32,",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 479,
                    "end": 482,
                    "text": "48]",
                    "ref_id": "BIBREF48"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In the case of non-monotonic logics, minimal inconsistency is uninteresting [16] , because of non-monotonicity. Recent work proposed the concept of strong inconsistency for non-monotonic logics [15, 16] , which enabled demonstrating that well-known properties of inconsistent sets in monotonic logics also apply in the case of strong inconsistency, with a reference example being the minimal hitting set relationship between minimal inconsistent subsets and minimal correction subsets [46] . Nevertheless, a limitation of this earlier work is that the algorithms proposed aim at being illustrative, consisting of simple set enumeration approaches, known not to scale in practice [34] .",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 80,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 194,
                    "end": 198,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 199,
                    "end": 202,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 485,
                    "end": 489,
                    "text": "[46]",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 679,
                    "end": 683,
                    "text": "[34]",
                    "ref_id": "BIBREF33"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This paper changes this state of affairs. Concretely, the paper proposes novel simple insights, which enable any algorithm for reasoning about inconsistency in the monotonic cases, to also be applicable to reasoning about strong inconsistency in the non-monotonic cases. The paper demonstrates the proposed ideas in the concrete setting of Answer Set Programming (ASP) [14, 22] , but these can be applied in other settings provided mild conditions hold. The significance of being able to reason efficiently about (strong) inconsistency in ASP should be highlighted. Whereas SAT reasoners represent a remarkable (and unique) problem solving technology, ASP blends efficient problem solving (by exploiting the technologies that are the hallmark of SAT solvers) with a well-established and widely used knowledge representation paradigm. The proposed algorithms enable new applications of ASP based on reasoning about (strong) inconsistency.",
            "cite_spans": [
                {
                    "start": 369,
                    "end": 373,
                    "text": "[14,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 374,
                    "end": 377,
                    "text": "22]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Boolean Satisfiability. We consider definitions and notation standard in Boolean Satisfiability (SAT) [10] . Concretely, we consider propositional formulas in conjunctive normal form (CNF), defined as a conjunction, or set, of clauses F = {c 1 , ..., c m } over a set of variables V (F) = {x 1 , ..., x n } where a clause is a disjunction of literals, and a literal is a variable x or its negation \u00acx. An interpretation is a mapping \u00b5: V (F) \u2192 {0, 1}. If \u00b5 satisfies F, it is referred to as a model of F. F G means that all the models of F are models of G. A minimal (resp. maximal) model is such that the set of variables assigned value 1 (resp. 0) is irreducible. A formula is satisfiable (F \u22a5) if it has a model; and otherwise unsatisfiable (F \u22a5). In the latter case, the following definitions apply: MUSes are minimal explanations of unsatisfiability, while MCSes are irreducible sets of clauses whose removal renders satisfiability. The complement of an MCS is a maximal satisfiable subset (MSS). MUSes and MCSes are hitting set duals: Every MCS is a minimal hitting set of all MUSes and vice versa [11, 46] .",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 106,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1104,
                    "end": 1108,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1109,
                    "end": 1112,
                    "text": "46]",
                    "ref_id": "BIBREF46"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": ", (\u00acx 2 )}; and three MCSes:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Minimal Sets over a Monotone Predicate. Several problems in propositional logic can be reduced to computing a minimal set over a monotone predicate (MSMP) [37, 38] Answer Set Programming & Strong Inconsistency. We review basic concepts in ASP. A more detailed account can be found in [14, 22] .",
            "cite_spans": [
                {
                    "start": 155,
                    "end": 159,
                    "text": "[37,",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 160,
                    "end": 163,
                    "text": "38]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 284,
                    "end": 288,
                    "text": "[14,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 289,
                    "end": 292,
                    "text": "22]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A (normal) logic program P = {r 1 , ..., r n } is a finite set of rules of the following form: a \u2190 b 1 , ..., b m , not c m+1 , ..., not c n , where a, b i and c i are atoms. A literal is an atom or its default negation not a. Extended logic programs may include classical negation (\u00ac). For a rule r, body(r) denotes the literals b 1 , ..., b m , not c m+1 , ..., not c n and head(r) denotes the literal a. We write B + (r) for b 1 , ..., b m and B \u2212 (r) for c m+1 , ..., c n . A rule is a fact if it has an empty body. Further, we allow choice rules of the form n \u2264 {a 1 , ..., a k }, with n \u2265 0. A program is ground if it does not contain any variables. A ground instance of a program P , denoted grd(P ), is a ground program obtained by substituting the variables of P by all constants from its Herbrand universe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The semantics of ASP programs can be defined via a reduct [25] . A set I of ground atoms is a model of a program P if head(r) \u2208 I whenever B + (r) \u2286 I and B \u2212 (r) \u2229 I = \u2205 for every r \u2208 grd(P ). The reduct of P w.r.t. the set I, denoted P I , is defined as",
            "cite_spans": [
                {
                    "start": 58,
                    "end": 62,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The set I is an answer set of P if I is a minimal model of P I . The inclusion of choice rule n \u2264 {a 1 , ..., a k } guarantees that any answer set contains at least n atoms from {a 1 , ..., a k }. A program P is consistent if it has at least one consistent answer set; otherwise, P is inconsistent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "This paper focuses on the analysis of inconsistent ASP programs. Throughout, we will consider that programs are partitioned into two subsets: P = B \u222a S, where B denotes background knowledge, assumed to be consistent and which cannot be relaxed, and S denotes the set of rules that can be dropped to achieve consistency. In contrast to propositional logic, logical entailment is not monotonic in ASP. Hence, supersets of an inconsistent program are not necessarily inconsistent, and a subset of a consistent program may be inconsistent. This way, MUSes and MCSes as defined for propositional logic do not capture their intended meaning and properties. To overcome this drawback, the notion of strong inconsistency [15, 16] 2 was recently proposed: Given an inconsistent pro-",
            "cite_spans": [
                {
                    "start": 713,
                    "end": 717,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 718,
                    "end": 721,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "In other words, strong inconsistency denotes that all supersets (up to P ) of a given subprogram are inconsistent. Minimal explanations and corrections of inconsistent ASP programs can be defined in terms of strong inconsistency, as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The complement of an MSICS is a maximal consistent subset. Besides, every MSIS is a minimal hitting set of the set of all MSICSes and vice versa [15, 16] .",
            "cite_spans": [
                {
                    "start": 145,
                    "end": 149,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 150,
                    "end": 153,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Definition 2 (MSIS/MSICS). Given an inconsistent program"
        },
        {
            "text": "Related Work. Debugging ASP programs has attracted a large body of research (see [20] for a survey). Systems as spock [24] or Ouroboros [43, 44] , based on meta-programming, enable pinpointing errors causing inconsistency, as unsupported atoms or unsatisfied rules. On the other hand, DWASP [19] allows for interactively debugging ASP programs by exploiting unsatisfiable cores. In contrast, our goal is computing MSISes and MSICSes, in the case of strong inconsistency. Our work is closely related to [30, 31] , which extended a number of algorithms for MSSes in SAT to maximal consistent subsets in ASP (and so MSICSes). Herein, we focus on computing MSISes as well, and on enumerating both kinds of sets. To our best knowledge, the only proposed approach for computing MSISes [15, 16] relies on exhaustive set enumeration and was not evaluated empirically.",
            "cite_spans": [
                {
                    "start": 81,
                    "end": 85,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 118,
                    "end": 122,
                    "text": "[24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 136,
                    "end": 140,
                    "text": "[43,",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 141,
                    "end": 144,
                    "text": "44]",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 291,
                    "end": 295,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 502,
                    "end": 506,
                    "text": "[30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 507,
                    "end": 510,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 779,
                    "end": 783,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 784,
                    "end": 787,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Definition 2 (MSIS/MSICS). Given an inconsistent program"
        },
        {
            "text": "Strong inconsistency exhibits a monotonicity property, that all the supersets (up to P ) of a strongly P -inconsistent program are strongly P -inconsistent too:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Strong Inconsistency and MSMP"
        },
        {
            "text": "Throughout, for a given program P = B \u222a S, and R \u2286 S, SAT + (B, S, R) indicates whether there is a superset of R (up to S) that together with B is consistent, i.e. it is true iff there exists R , with R \u2286 R \u2286 S, such that P = B \u222a R is consistent. Noticeably, SAT + (B, S, R) is false iff B \u222a R is strongly P -inconsistent. We show that computing an MSIS is an instance of MSMP. Computing an MSICS can also be reduced to MSMP. The proof is analogous, by defining p(W) SAT + (B, S, S\\W) with W \u2286 R, and R S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Strong Inconsistency and MSMP"
        },
        {
            "text": "The reductions above enable computing MSISes and MSICSes by using any algorithm for MSMP and an oracle implementing SAT + (B, S, R).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "Extracting a Single Minimal Set. Algorithms for computing a single minimal set in MSMP include Deletion [17] , Progression [37] or QuickXplain [32] , among others [8] . Herein we focus on the deletion-based approach, shown in Algorithm 1.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 108,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 123,
                    "end": 127,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 143,
                    "end": 147,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 163,
                    "end": 166,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "Given an inconsistent program P = B\u222aS, by setting the predicate to p(W) \u00acSAT + (B, S, W) with W \u2286 R, and R S, Algorithm 1 proceeds as follows: Starting with M = R, the algorithm iteratively picks a rule u \u2208 M and tests whether B \u222a (M\\{u}) is strongly P -inconsistent. If it is, u is removed from M; otherwise u is kept in M. After considering all the rules in R, M is an MSIS.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "An MSICS of P can be computed using basic linear search (BLS) [6, 36] : Starting with S = \u2205, iteratively pick a rule in u \u2208 S\\S and test whether SAT + (B, S, S \u222a{u}) holds. If it does, B \u222a(S \u222a{u}) is not strongly P -inconsistent, and u is added to S. On termination, the set of rules not added to S is an MSICS (and S is a maximal consistent subset). Besides, if the oracle for SAT + (B, S, S \u222a {u}) returns a witness after positive answers, all the elements in S satisfied can be added to S, saving some predicate tests. BLS is equivalent to Algorithm 1 using the predicate p(W) SAT + (B, S, S\\W), with W \u2286 R, and R S. Enumerating Minimal Sets. MARCO [33] is a successful approach for enumerating MUSes and MCSes of CNF formulas. This algorithm exploits the hitting set duality between MUSes and MCSes. Since this relationship also holds between MSISes and MSICSes, MARCO can be adapted to ASP, as shown in Algorithm 2. For a given inconsistent program P = B \u222a S, the algorithm associates a propositional variable p i with each rule r i \u2208 S, and maintains a CNF formula H defined on these variables. The formula H, initially empty, serves to subsequently avoid considering any superset (resp. subset) of previously found MSISes (resp. MSICSes). Iteratively, a maximal model MxM of H is computed, which induces the set of rules R whose associated variables are set to 1 in MxM. Then, if the program B\u222aR is strongly P -inconsistent (i.e. if SAT + (B, S, R) does not hold), an MSIS M \u2286 R of P is extracted (e.g. by using Algorithm 1, with R R), whose supersets are blocked by adding a negative clause on its associated variables to H. Otherwise, R is a maximal consistent subset, and so S\\R is an MSICS of P , whose subsets are blocked by adding a positive clause on its associated variables to H. The process is repeated until H becomes unsatisfiable, with the guarantee that all MSISes and MSICSes of P have been computed.",
            "cite_spans": [
                {
                    "start": 62,
                    "end": 65,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 66,
                    "end": 69,
                    "text": "36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 652,
                    "end": 656,
                    "text": "[33]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "Algorithm 2 is organized to give (heuristic) preference to finding MSISes quickly. We refer to it as eMax. A variant giving preference to finding MSICSes can be easily obtained, by computing minimal models of H (instead of maximal ones) and extracting an MSICS whenever SAT + (B, S, R) holds. This variant is referred to as eMin.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "Implementing SAT + (B, S, R) . It remains to discuss the way SAT + (B, S, R) can be implemented in ASP. We invoke an ASP solver on an modified program which includes selector atoms and choice rules. This approach was used in [30, 31] to compute maximal consistent subsets. For a set of atoms A, choice(A) denotes the rule 0 \u2264 {a 1 , .., a k }, with a i \u2208 A. Modern ASP solvers allow choice rules, and their inclusion does not increase the complexity beyond NP [47] .",
            "cite_spans": [
                {
                    "start": 225,
                    "end": 229,
                    "text": "[30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 230,
                    "end": 233,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 460,
                    "end": 464,
                    "text": "[47]",
                    "ref_id": "BIBREF47"
                }
            ],
            "ref_spans": [
                {
                    "start": 19,
                    "end": 28,
                    "text": "(B, S, R)",
                    "ref_id": null
                }
            ],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "For a given program P = B \u222a S, we first build the program P s = B \u222a S s , where S s is obtained from S as follows: for each rule r i \u2208 S we introduce a fresh atom s i , and add the rule head(r i ) \u2190 body(r i ), s i to S s . Note that if the fact s i is added to P s , the rule r i is activated, and relaxed otherwise. For a given subset R \u2286 S, we use s(R) to denote the set of selector atoms for rules in R in S s , i.e. s(R) = {s i | r i \u2208 R}. Then, the test SAT + (B, S, R) is solved by invoking an ASP solver on the program P = P s \u222a \u222a s\u2208s(R) {s} \u222a choice(s(S\\R)). Notice that each rule r \u2208 R is active in P . Besides, the inclusion of the rule choice(s(S\\R)) allows for activating any (or none) of the rules in S\\R when looking for answer sets of P . Hence, P is consistent iff the program B \u222a R is not strongly P -inconsistent. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Minimal Explanations and Corrections"
        },
        {
            "text": "This section reports an initial experimental assessment of the proposed approaches. We implemented a prototype in Python 2.7, interfacing the ASP solver clingo [23] (v. 5.4.0), and ran a series of experiments on a Linux machine (2.26 GHz, 128 GB). Each process was limited to 3600 s and 4 GB. Below, ComputeMSIS (resp. ComputeMSICS) is Algorithm 1 using the predicate shown in Sect. 3 for computing an MSIS (resp. MSICS). Besides, witnesses are used in the extraction of MSICSes as an optimization, as described earlier. On the other hand, eMax corresponds to Algorithm 2, giving preference to finding MSISes quickly, and eMin is the variant that gives preference to MSIC-Ses. In these cases, maximal and minimal models are computed using the tool mcsls [36] 3 .",
            "cite_spans": [
                {
                    "start": 160,
                    "end": 164,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 754,
                    "end": 758,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [],
            "section": "Preliminary Results"
        },
        {
            "text": "Similarly to earlier work [31] , we built a number of instances. We considered three problem domains (common in ASP competitions): Graceful graphs, Knight tour with holes and Solitaire. Each instance is an inconsistent ASP program P = B \u222a S, where B contains the rules encoding the problem domain (assumed correct) and S contains the facts specific for each instance. Given the complexity of the tasks to solve, the instances are reasonably small. The benchmarks are as follows: 1) Graceful graphs: Given a graph (V, E) the goal is to label its vertices with distinct integers in the range 0..|E| so that each edge is labeled with the absolute difference between the labels of its vertices and all edge labels are distinct. S contains the facts indicating the edges, so |S| = |E|. We considered values of |V | \u2208 {10, 20} and |E| \u2208 {10, 20, 50}. 2) Knight tour with holes: Given The results are summarized in Fig. 1. Figure 1a shows, for each instance, the running times needed for computing a single MSIS and an MSICS. ComputeMSIS and ComputeMSICS solved, respectively, 295 and 317 instances. The results vary across the set of instances, although in more cases computing an MSICS was performed faster than computing an MSIS. Figure 1b compares eMax and eMin. In this case, complete enumeration was achieved for 172 and 167 instances respectively. However, as the plot indicates, there is no clear winner. Figure 2 shows the number of reported minimal sets over the whole benchmark set. By the time limit eMax reports 9008 MSISes and 12081 MSICSes, whereas eMin computes 5684 MSISes and 20057 MSICSes. As shown in Fig. 2a , eMax is much more efficient at computing MSISes, whereas eMin finds MSICSes faster (see Fig. 2b ). Thus, each variant is effective at its intended purpose. These results suggest that a combination may be a good option for obtaining both sets quickly.",
            "cite_spans": [
                {
                    "start": 26,
                    "end": 30,
                    "text": "[31]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [
                {
                    "start": 908,
                    "end": 925,
                    "text": "Fig. 1. Figure 1a",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1226,
                    "end": 1235,
                    "text": "Figure 1b",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1406,
                    "end": 1414,
                    "text": "Figure 2",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 1614,
                    "end": 1621,
                    "text": "Fig. 2a",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 1712,
                    "end": 1719,
                    "text": "Fig. 2b",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Preliminary Results"
        },
        {
            "text": "Recent work proposed the concept of strong inconsistency [15, 16] , which provides a way of reasoning about inconsistency in non-monotonic logics. This paper shows how the large body of work for reasoning about (minimal) inconsistency in monotonic logics, originally developed in the context of SAT, can be readily applied to the case of reasoning about strong inconsistency in non-monotonic logics. Furthermore, the paper applies these insights to the case of ASP. Experimental results illustrate the scope and applicability of the proposed approach.",
            "cite_spans": [
                {
                    "start": 57,
                    "end": 61,
                    "text": "[15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 62,
                    "end": 65,
                    "text": "16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Solving (weighted) partial maxSAT through satisfiability testing",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ans\u00f3tegui",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Bonet",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "SAT 2009",
            "volume": "5584",
            "issn": "",
            "pages": "427--440",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-02777-2_39"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "SAT-based MaxSAT algorithms",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ans\u00f3tegui",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Bonet",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Artif. Intell",
            "volume": "196",
            "issn": "",
            "pages": "77--105",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Relaxation search: a simple way of managing optional clauses",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bacchus",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Davies",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Tsimpoukelli",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Katsirelos",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "835--841",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Using minimal correction sets to more efficiently compute minimal unsatisfiable sets",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bacchus",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Katsirelos",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "CAV 2015",
            "volume": "9207",
            "issn": "",
            "pages": "70--86",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-21668-3_5"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Finding a collection of MUSes incrementally",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bacchus",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Katsirelos",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "CPAIOR 2016",
            "volume": "9676",
            "issn": "",
            "pages": "35--44",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-33954-2_3"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Discovery of minimal unsatisfiable subsets of constraints using hitting set dualization",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bailey",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "J"
                    ],
                    "last": "Stuckey",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "PADL 2005",
            "volume": "3350",
            "issn": "",
            "pages": "174--186",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-30557-6_14"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Diagnosing and solving over-determined constraint satisfaction problems",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "R"
                    ],
                    "last": "Bakker",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Dikker",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Tempelman",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "M"
                    ],
                    "last": "Wognum",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "IJCAI",
            "volume": "",
            "issn": "",
            "pages": "276--281",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Towards efficient MUS extraction",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Belov",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Lynce",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "AI Commun",
            "volume": "25",
            "issn": "2",
            "pages": "97--116",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Recursive online enumeration of all minimal unsatisfiable subsets",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bend\u00edk",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "\u010cern\u00e1",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Bene\u0161",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ATVA 2018",
            "volume": "11138",
            "issn": "",
            "pages": "143--159",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-01090-4_9"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Handbook of Satisfiability",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Biere",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Heule",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Van Maaren",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "185",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Consistent subsets of inconsistent systems: structure and behaviour",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Birnbaum",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "L"
                    ],
                    "last": "Lozinskii",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "J. Exp. Theor. Artif. Intell",
            "volume": "15",
            "issn": "1",
            "pages": "25--46",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Checking safety by inductive generalization of counterexamples to induction",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Bradley",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Manna",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "173--180",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Property-directed incremental invariant generation. Formal",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Bradley",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Manna",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Aspects of Comput",
            "volume": "20",
            "issn": "4-5",
            "pages": "379--405",
            "other_ids": {
                "DOI": [
                    "10.1007/s00165-008-0080-9"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Answer set programming at a glance",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Brewka",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Eiter",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Truszczynski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Commun. ACM",
            "volume": "54",
            "issn": "12",
            "pages": "92--103",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Strong inconsistency in nonmonotonic reasoning",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Brewka",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Thimm",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ulbricht",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IJCAI",
            "volume": "",
            "issn": "",
            "pages": "901--907",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Strong inconsistency",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Brewka",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Thimm",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ulbricht",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Artif. Intell",
            "volume": "267",
            "issn": "",
            "pages": "78--117",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Locating minimal infeasible constraint sets in linear programs",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "W"
                    ],
                    "last": "Chinneck",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "W"
                    ],
                    "last": "Dravnieks",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "ORSA J. Comput",
            "volume": "3",
            "issn": "2",
            "pages": "157--168",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Solving MAXSAT by solving a sequence of simpler SAT instances",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Davies",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bacchus",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "CP 2011",
            "volume": "6876",
            "issn": "",
            "pages": "225--239",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-23786-7_19"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Interactive debugging of non-ground ASP programs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Dodaro",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gasteiger",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Musitsch",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ricca",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shchekotykhin",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "LPNMR 2015. LNCS (LNAI)",
            "volume": "9345",
            "issn": "",
            "pages": "279--293",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-23264-5_24"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Answering the \"why\" in answer set programming -a survey of explanation approaches",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Fandinno",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Theory Pract. Log. Program",
            "volume": "19",
            "issn": "2",
            "pages": "114--203",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "An efficient diagnosis algorithm for inconsistent constraint sets",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Felfernig",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schubert",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zehentner",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "AI EDAM",
            "volume": "26",
            "issn": "1",
            "pages": "53--62",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Answer Set Solving in Practice",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gebser",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kaminski",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Kaufmann",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schaub",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Clingo = ASP + control: extended report",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gebser",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kaminski",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Kaufmann",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schaub",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "A meta-programming technique for debugging answer-set programs",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gebser",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "P\u00fchrer",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schaub",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Tompits",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "448--453",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "The stable model semantics for logic programming",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gelfond",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Lifschitz",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "ICLP/SLP",
            "volume": "",
            "issn": "",
            "pages": "1070--1080",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Boosting MCSes enumeration",
            "authors": [
                {
                    "first": "\u00c9",
                    "middle": [],
                    "last": "Gr\u00e9goire",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Izza",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lagniez",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IJCAI",
            "volume": "",
            "issn": "",
            "pages": "1309--1315",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "An experimentally efficient method for (MSS, CoMSS) partitioning",
            "authors": [
                {
                    "first": "\u00c9",
                    "middle": [],
                    "last": "Gr\u00e9goire",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lagniez",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Mazure",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "2666--2673",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Extracting MUSes",
            "authors": [
                {
                    "first": "\u00c9",
                    "middle": [],
                    "last": "Gr\u00e9goire",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Mazure",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Piette",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "387--391",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Extracting MUCs from constraint networks",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Hemery",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lecoutre",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Sais",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Boussemart",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "ECAI",
            "volume": "",
            "issn": "",
            "pages": "113--117",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "On minimal corrections in ASP",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Janota",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "On minimal corrections in ASP",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Janota",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "45--54",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "QUICKXPLAIN: preferred explanations and relaxations for overconstrained problems",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Junker",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "167--172",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Fast, flexible MUS enumeration",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "H"
                    ],
                    "last": "Liffiton",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Previti",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Malik",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Constraints",
            "volume": "21",
            "issn": "2",
            "pages": "223--250",
            "other_ids": {
                "DOI": [
                    "10.1007/s10601-015-9183-0"
                ]
            }
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Algorithms for computing minimal unsatisfiable subsets of constraints",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "H"
                    ],
                    "last": "Liffiton",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Sakallah",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "J. Autom. Reasoning",
            "volume": "40",
            "issn": "1",
            "pages": "1--33",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-007-9084-z"
                ]
            }
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Algorithms for weighted Boolean optimization",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Manquinho",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Planes",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "SAT 2009",
            "volume": "5584",
            "issn": "",
            "pages": "495--508",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "On computing minimal correction subsets",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Heras",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Janota",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Previti",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Belov",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IJCAI",
            "volume": "",
            "issn": "",
            "pages": "615--622",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Minimal sets over monotone predicates in Boolean formulae",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Janota",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Belov",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "CAV 2013",
            "volume": "8044",
            "issn": "",
            "pages": "592--607",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-39799-8_39"
                ]
            }
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Minimal sets on propositional formulae. Problems and reductions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Janota",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Menc\u00eda",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Artif. Intell",
            "volume": "252",
            "issn": "",
            "pages": "22--50",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "MCS extraction with sublinear oracle queries",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Menc\u00eda",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ignatiev",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Previti",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "SAT 2016",
            "volume": "9710",
            "issn": "",
            "pages": "342--360",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-40970-2_21"
                ]
            }
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Literal-based MCS extraction",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Menc\u00eda",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Previti",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "IJCAI",
            "volume": "",
            "issn": "",
            "pages": "1973--1979",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "Iterative and core-guided MaxSAT solving: a survey and assessment",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Morgado",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Heras",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "H"
                    ],
                    "last": "Liffiton",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Planes",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Constraints",
            "volume": "18",
            "issn": "4",
            "pages": "478--534",
            "other_ids": {
                "DOI": [
                    "10.1007/s10601-013-9146-2"
                ]
            }
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "Core-guided minimal correction set and core enumeration",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Narodytska",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Bj\u00f8rner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "V"
                    ],
                    "last": "Marinescu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sagiv",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IJCAI",
            "volume": "",
            "issn": "",
            "pages": "1353--1361",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "Catching the ouroboros: on debugging nonground answer-set programs",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Oetsch",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "P\u00fchrer",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Tompits",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Theory Pract. Log. Program",
            "volume": "10",
            "issn": "4-6",
            "pages": "513--529",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "Debugging non-ground ASP programs with choice rules, cardinality and weight constraints",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Polleres",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Fr\u00fchst\u00fcck",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schenner",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Friedrich",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "LPNMR 2013",
            "volume": "8148",
            "issn": "",
            "pages": "452--464",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-40564-8_45"
                ]
            }
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Premise set caching for enumerating minimal correction subsets",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Previti",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Menc\u00eda",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "J\u00e4rvisalo",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "6633--6640",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "A theory of diagnosis from first principles",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Reiter",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "Artif. Intell",
            "volume": "32",
            "issn": "1",
            "pages": "57--95",
            "other_ids": {}
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "Extending and implementing the stable model semantics",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Simons",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Niemel\u00e4",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Soininen",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Artif. Intell",
            "volume": "138",
            "issn": "1-2",
            "pages": "181--234",
            "other_ids": {}
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "Explanation-based generalisation of failures",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "De Siqueira",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "L"
                    ],
                    "last": "Puget",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "339--344",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "MUS/MCS). M \u2286 F is a minimal unsatisfiable subset (MUS) if and only if M \u22a5 and for all M M, M \u22a5. C \u2286 F is a minimal correction subset (MCS) if and only if (F\\C) \u22a5 and for all C C, F\\C \u22a5.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Deletion-based minimal set computation Input: p: Monotone predicate, R: Reference set Output: M: Minimal set 1 M \u2190 R; // M is over-approximation 2 foreach u \u2208 M do // Inv: p(M) 3 if p(M \\ {u}) then // Do we need u? 4 M \u2190 M \\ {u}; // If not, drop it 5 return M; // Final M is a minimal set Proof. Let p(W) \u00acSAT + (B, S, W) with W \u2286 R, and R S. We prove that p is monotone and that any minimal set over p is an MSIS of P = B \u222a S. Monotonicity: If p(W) holds, B \u222aW is strongly P -inconsistent. By Proposition 1, for all W , with W \u2286 W \u2286 S, B \u222aW is strongly P -inconsistent, so p(W ) holds. Correctness: Let M be a minimal set for which p(M) holds, i.e. B\u222aM is strongly P -inconsistent. Since M is minimal, for any M M, p(M ) does not hold, i.e. B \u222a M is not strongly P -inconsistent. Thus, by Definition 2, M is an MSIS.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Minimal set enumeration Input: P = B \u222a S: Inconsistent ASP program Output: MSISes and MSICSes of P 1 I \u2190 {pi | ri \u2208 S}; , M xM ) \u2190 ComputeMaximalModel(H); 5 if not st then return 6 R \u2190 {ri | pi \u2208 MxM}; // Pick selected rules 7 if not SAT + (B, S, R) then 8 M \u2190 ComputeMSIS(B, S, R); // Extract MSIS from R 9 ReportMSIS(M ); 10 b \u2190 {\u00acpi | ri \u2208 M }; // Block the MSIS 11 else 12 ReportMSICS(S \\ R); 13 b \u2190 {pi | pi \u2208 I \\ MxM}; // Block the MSICS 14 H \u2190 H \u222a {b};",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Let P = B \u222a S be the program in Example 2, and consider the test SAT + (B, S, {r 1 }). We first build P s = {a \u2190 not a, not b, s 1 ., b \u2190 not a, s 2 ., \u00acb \u2190 s 3 .}. Then, we define P = P s \u222a {s 1 .} \u222a choice({s 2 , s 3 }). P is consistent (with the unique answer set {b, s 1 , s 2 }), indicating that {r 1 } is not strongly P -inconsistent.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Running times",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Number of reported sets (eMin vs eMax) an N \u00d7 N board with H holes, the problem asks if a knight chess piece can visit all non-hole positions of the boards exactly once returning to the initial position. S consists of facts with the positions of holes, so |S| = H. We considered values of N \u2208 {7, 8} and H \u2208 {10, 20, 30}. 3) Solitaire: Given a 7 \u00d7 7 board, with 2 \u00d7 2 corners removed (i.e. with 33 squares), an initial configuration is specified by facts empty(L) and full(L), indicating if each square L is empty or contains a stone. A stone can be moved by two squares if it jumps over another stone, which is removed. The goal is to perform T steps. S contains the facts empty(L) and full(L), so |S| = 33. We considered values of T \u2208 {8, 10, 12, 14, 16, 18}. For each configuration, we built 20 random instances, making 360 in all.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "1 . In this setting, a predicate p: 2 R \u2192 {0, 1}, defined over a reference set R, is monotone if whenever p(R 0 ) holds, then p(R 1 ) also holds, with R 0 \u2286 R 1 \u2286 R. M \u2286 R is a minimal set over a predicate p if p(M) holds",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}