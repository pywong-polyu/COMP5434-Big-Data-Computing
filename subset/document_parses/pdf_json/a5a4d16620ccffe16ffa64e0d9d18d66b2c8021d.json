{"paper_id": "a5a4d16620ccffe16ffa64e0d9d18d66b2c8021d", "metadata": {"title": "A Probabilistic Beam Search Approach to the Shortest Common Supersequence Problem", "authors": [{"first": "Christian", "middle": [], "last": "Blum", "suffix": "", "affiliation": {"laboratory": "ALBCOM", "institution": "", "location": {}}, "email": "cblum@lsi.upc.edu"}, {"first": "Carlos", "middle": [], "last": "Cotta", "suffix": "", "affiliation": {"laboratory": "Lenguajes y Ciencias de la Computaci\u00f3n, ETSI Inform\u00e1tica", "institution": "Universidad de M\u00e1laga", "location": {"settlement": "M\u00e1laga", "country": "Spain"}}, "email": "ccottap@lcc.uma.es"}, {"first": "Antonio", "middle": ["J"], "last": "Fern\u00e1ndez", "suffix": "", "affiliation": {"laboratory": "Lenguajes y Ciencias de la Computaci\u00f3n, ETSI Inform\u00e1tica", "institution": "Universidad de M\u00e1laga", "location": {"settlement": "M\u00e1laga", "country": "Spain"}}, "email": ""}, {"first": "Jos\u00e9", "middle": ["E"], "last": "Gallardo", "suffix": "", "affiliation": {"laboratory": "Lenguajes y Ciencias de la Computaci\u00f3n, ETSI Inform\u00e1tica", "institution": "Universidad de M\u00e1laga", "location": {"settlement": "M\u00e1laga", "country": "Spain"}}, "email": ""}]}, "abstract": [{"text": "The Shortest Common Supersequence Problem (SCSP) is a well-known hard combinatorial optimization problem that formalizes many real world problems. This paper presents a novel randomized search strategy, called probabilistic beam search (PBS), based on the hybridization between beam search and greedy constructive heuristics. PBS is competitive (and sometimes better than) previous state-of-the-art algorithms for solving the SCSP. The paper describes PBS and provides an experimental analysis (including comparisons with previous approaches) that demonstrate its usefulness.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "The Shortest Common Supersequence Problem (SCSP) is a very well-known problem in the area of string analysis. Basically, the SCSP consists of finding a minimal-length sequence s of symbols from a certain alphabet, such that all strings in a given set L can be embedded in s. The resulting combinatorial problem is enormously interesting for several reasons. Firstly, the SCSP constitutes a formalization of different real-world problems. For example, it has many implications in bioinformatics [1] : it is a problem with a close relationship to multiple sequence alignment [2] , and to probe synthesis during microarray production [3] . This does not exhaust the practical usefulness of the SCSP though, since it also has applications in planning [4] and data compression [5] , among other fields.", "cite_spans": [{"start": 494, "end": 497, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 573, "end": 576, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 631, "end": 634, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 747, "end": 750, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 772, "end": 775, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Introduction"}, {"text": "Another reason the SCSP has attracted interest lies in its \"cleanliness\", that is, it is an abstract formulation of different real-world problems that can nevertheless be studied from a theoretical point of view in a context-independent way. Indeed, theoretical computer scientists have analyzed in depth the problem, and we now have accurate characterizations of its computational complexity. These characterizations range from the classical complexity paradigm to the more recent parameterized complexity paradigm. We will survey some of these results in the next section as well, but it can be anticipated that the SCSP is intrinsically hard [6, 7, 8] under many formulations and/or restrictions.", "cite_spans": [{"start": 645, "end": 648, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 649, "end": 651, "text": "7,", "ref_id": "BIBREF6"}, {"start": 652, "end": 654, "text": "8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Introduction"}, {"text": "The practical impossibility of utilizing exact approaches for tackling this problem in general justifies the use of heuristics. Such heuristic approaches are aimed to producing probably-(yet not provably-) optimal solutions to the SCSP. Good examples of such heuristics are the Majority Merge (MM) algorithm, and related variants [9] , based on greedy construction strategies. More sophisticated heuristics have been also proposed, for instance, evolutionary algorithms (EAs) [9, 10, 11, 12] . In this work, we present a novel randomized search strategy (or metaheuristic) to tackle the SCSP termed probabilistic beam search (PBS). As the name indicates, this strategy is based in the framework of beam search, but also borrows some heuristic ideas from the greedy constructive heuristics mentioned before. In the following we will show that this strategy can satisfactorily compete in the SCSP arena, outperforming previous state-of-the-art approaches. As a first step, the next section will describe the SCSP in more detail.", "cite_spans": [{"start": 330, "end": 333, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 476, "end": 479, "text": "[9,", "ref_id": "BIBREF8"}, {"start": 480, "end": 483, "text": "10,", "ref_id": "BIBREF9"}, {"start": 484, "end": 487, "text": "11,", "ref_id": "BIBREF10"}, {"start": 488, "end": 491, "text": "12]", "ref_id": "BIBREF11"}], "ref_spans": [], "section": "Introduction"}, {"text": "First of all, let us introduce some notation that we use in the following. We write |s| for the length of string s (|s(1)s(2) . . . s(n)| = n, where s(j) \u2208 \u03a3 is the element at the j-th position of s) and for the empty string (| | = 0). Abusing the notation, |\u03a3| denotes the cardinality of set \u03a3. We use s \u03b1 for the total number of occurrences of symbol \u03b1 in string s (s(1)s(2) . . . s(n) \u03b1 = 1\u2264i\u2264n,s(i)=\u03b1 1). We write \u03b1s for the string obtained by appending the symbol \u03b1 in front of string s. Deleting symbol \u03b1 from the front of string s is denoted by s| \u03b1 , and is defined as s when s = \u03b1s , or s otherwise. We also use the | symbol to delete a symbol from the front of a set of strings: {s 1 , \u00b7 \u00b7 \u00b7 , s m }| \u03b1 = {s 1 | \u03b1 , \u00b7 \u00b7 \u00b7 , s m | \u03b1 }. Finally, s \u2208 \u03a3 * means that s is a finite length string of symbols in \u03a3.", "cite_spans": [], "ref_spans": [], "section": "The Shortest Common Supersequence Problem"}, {"text": "Let s and r be two strings of symbols taken from an alphabet \u03a3. String s can be said to be a supersequence of r (denoted as s r) using the following recursive definition:", "cite_spans": [], "ref_spans": [], "section": "The Shortest Common Supersequence Problem"}, {"text": "Plainly, s r implies that r can be embedded in s, meaning that all symbols in r are present in s in the very same order (although not necessarily consecutive). For example, given the alphabet \u03a3 = {a, b, c}, aacab acb. We can now state the SCSP as follows: an instance I = (\u03a3, L) for the SCSP is given by a finite alphabet \u03a3 and a set L of m strings {s 1 , \u00b7 \u00b7 \u00b7 , s m }, s i \u2208 \u03a3 * . The problem consists of finding a string s of minimal length that is a supersequence of each string in L (s s i , \u2200s i \u2208 L and |s| is minimal). For example, given I = ({a, b, c}, {cba, abba, abc}), a shortest common supersequence of I is abcba.", "cite_spans": [], "ref_spans": [], "section": "The Shortest Common Supersequence Problem"}, {"text": "The SCSP can be shown to be NP\u2212hard, even if strong constraints are posed on L, or on \u03a3. For example, it is NP\u2212hard in general when all s i have length two [5] , or when the alphabet size |\u03a3| is two [7] . In principle, these NP\u2212hardness results would have to be approached with caution, since they merely represent a worst case scenario. In this sense, a more sensible characterization of the hardness of the SCSP is provided by the framework of parameterized complexity [13] . This is done by approaching the problem from a multidimensional perspective, realizing its internal structure, and isolating some parameters. If hardness (that is, non-polynomial behavior) can be isolated within these parameters, the problem can be efficiently 1 solved for fixed values of them. This is the case for several NP\u2212hard problems such as Vertex Cover [14, 15] ; the term fixed-parameter tractable (FPT) is used to denote these problems. Non-FPT problems will fall under some class in the W \u2212hierarchy. Hardness for class W [1] -the first one above FPT in the hierarchy-is the current measure of intractability: problems in this class cannot be efficiently solved (i.e., in fixed polynomial time) for increasing sizes of the parameter.", "cite_spans": [{"start": 156, "end": 159, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 199, "end": 202, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 471, "end": 475, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 841, "end": 845, "text": "[14,", "ref_id": "BIBREF13"}, {"start": 846, "end": 849, "text": "15]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "The Shortest Common Supersequence Problem"}, {"text": "Several parameterizations are possible for the SCSP. Firstly, the maximum length k of the supersequence sought can be taken as a parameter. If the alphabet size is constant, or another parameter, then the problem turns in this case to be FPT, since there are at most |\u03a3| k supersequences, and these can be exhaustively checked. However, this is not very useful in practice because k max |s i |. If the number of strings m is used as a parameter, then SCSP is W [1]\u2212hard, and remains so even if |\u03a3| is taken as another parameter [1] , or is constant [8] . Failure of finding FPT results in this latter scenario is particularly relevant since the alphabet size in biological problems is fixed (e.g., there are just four nucleotides in DNA). Furthermore, the absence of FPT algorithms implies the absence of fully polynomial-time approximation schemes (FPTAS) for the corresponding problem.", "cite_spans": [{"start": 528, "end": 531, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 549, "end": 552, "text": "[8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "The Shortest Common Supersequence Problem"}, {"text": "The hardness results mentioned previously motivate the utilization of heuristics for tackling the SCSP. One of the most popular algorithms for this purpose is Majority Merge (MM). This is a greedy algorithm that constructs a supersequence incrementally by adding the symbol most frequently found at the front of the strings in L, and removing these symbols from the corresponding strings. More precisely:", "cite_spans": [], "ref_spans": [], "section": "Majority Merge Heuristics for the SCSP"}, {"text": "The myopic functioning of MM makes it incapable of grasping the global structure of strings in L. In particular, MM misses the fact that the strings can have different lengths [9] . This implies that symbols at the front of short strings will have more chances to be removed, since the algorithm has still to scan the longer strings. For this reason, it is less urgent to remove those symbols. In other words, it is better to concentrate in shortening longer strings first. This can be done by assigning a weight to each symbol, depending on the length of the string in whose front is located. Branke et al. [9] propose to use precisely this string length as weight, i.e., step 3 in the previous pseudocode would be modified to have", "cite_spans": [{"start": 176, "end": 179, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 608, "end": 611, "text": "[9]", "ref_id": "BIBREF8"}], "ref_spans": [], "section": "Majority Merge Heuristics for the SCSP"}, {"text": "This modified heuristic is termed Weighted Majority Merge (WMM), and its empirical evaluation indicates it can outperform MM on some problem instances in which there is no structure, or the structure is deceptive [9, 11] .", "cite_spans": [{"start": 213, "end": 216, "text": "[9,", "ref_id": "BIBREF8"}, {"start": 217, "end": 220, "text": "11]", "ref_id": "BIBREF10"}], "ref_spans": [], "section": "Majority Merge Heuristics for the SCSP"}, {"text": "In this work we also consider look-ahead versions of the WMM heuristic. For that purpose we use the notation LA-WMM(l), where l > 0 is a parameter that indicates the size (or depth) of the look-ahead. For example, LA-WMM(0) denotes the standard WMM heuristic, whereas LA-WMM(1) is obtained by choosing at each construction step the symbol that corresponds to the first symbol in the best possible sequence of two WMM construction steps. The value of a sequence of two construction steps is obtained by summing the two corresponding WMM weights (see Equation 2 ). In the following we will refer to these look-head values as the LA-WMM(l) weights.", "cite_spans": [{"start": 549, "end": 559, "text": "Equation 2", "ref_id": null}], "ref_spans": [], "section": "Majority Merge Heuristics for the SCSP"}, {"text": "In the following we present a probabilistic beam search (PBS) approach for the SCSP. This algorithm is based on the WMM heuristic outlined before. Beam search is a classical tree search method that was introduced in the context of scheduling [16] . The central idea behind beam search is to allow the extension of partial solutions in more than one way. The version of beam search that we implemented-see algorithm PBS below-works as follows: At each step of the algorithm is given a set B of partial solutions which is called the beam. At the start of the algorithm B only contains the empty partial solution (that is, B = { }). Let C denote the set of all possible children of the partial solutions in B. Note that a child of a string s is obtained by appending one of the symbols from \u03a3 to it. At each step, k ext different (partial) solutions from C are selected; each selection step is either performed probabilistically or deterministically. A chosen (partial) solution is either stored in set B compl in case it is a complete solution, or in the new beam B otherwise. At the end of each construction step the new beam B is reduced in case it contains more than k bw (called the beam width) partial solutions. This is done by evaluating the partial solutions in B by means of a lower bound LB(\u00b7), and by subsequently selecting the k bw partial solutions with the smallest lower bound values. In the following we explain the functions of algorithm PBS in more detail. First of all, let us define the following function that will be useful to calculate lower bounds of partial solutions:", "cite_spans": [{"start": 242, "end": 246, "text": "[16]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "Intuitively, s r = (r e , r r ) if r e is the longest initial segment of string r embedded by s and r r is the remaining part of r not embedded by s (i.e., r = r e r r ). Note that s r \u21d0\u21d2 s r = (r, ). Function Children of(B) produces the set C of all possible children of the partial solutions in B. Note that, given a partial solution s t , at most |\u03a3| children can be generated by appending each of the symbols from \u03a3 to s t . Children with unproductive characters (i.e., not contributing to embedding any string in L) are not added to C.", "cite_spans": [], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "Another important function of algorithm PBS is Choose From(C, d) . Upon invocation, this function returns one of the partial solutions from set C. This is done as follows. First, we calculate for each s t \u2208 C a heuristic value \u03b7(s t ) as follows:", "cite_spans": [], "ref_spans": [{"start": 47, "end": 64, "text": "Choose From(C, d)", "ref_id": null}], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "where \u03bd r (\u03b1 | s) is the rank of the weight \u03bd(\u03b1 | s) which the LA-WMM(l) heuristic assigns to the extension \u03b1 of string s (see Section 3). The rank of extending string s by symbol \u03b1 is obtained by sorting all possible extensions of string s with respect to their LA-WMM(l) weights in descending order. Note that the sum shown in Equation 4 is the sum of the ranks of the LA-WMM(l) weights that are used for constructing the partial solution s t . For example, in case s t can be constructed by always appending the symbol suggested by the LA-", "cite_spans": [], "ref_spans": [{"start": 329, "end": 339, "text": "Equation 4", "ref_id": null}], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "This way of defining the heuristic values has the effect that partial solutions obtained by mostly following the suggestions of the LA-WMM(l) heuristic have a greater heuristic value than others. Given the heuristic values we can define the probability of a (partial) solution s t from C to be chosen in function Choose From(C, d):", "cite_spans": [], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "However, instead of always choosing a partial solution s t \u2208 C probabilistically, we employ the following mixed strategy. First, a random number r \u2208 [0, 1] is drawn. If r < d (where d \u2208 [0, 1] is a parameter of the algorithm), the partial solution s * to be returned by function Choose From(C, d) is selected such that s * \u2190 argmax{p(s t ) | s t \u2208 C}. Otherwise, a partial solution is chosen by roulette-wheel-selection using the probabilities defined in Equation 5. 2 Finally, the lower bound LB(s t ) of a partial solution s t is calculated as follows: First, we calculate the set of remaining strings in L not embedded by s t as follows:", "cite_spans": [], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "Let M (\u03b1, R(s t )) be the maximum number of occurrences of symbol \u03b1 in any string in R(s t ):", "cite_spans": [], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "Clearly, every common supersequence for the remaining strings must contain at least M (\u03b1, R(s t )) copies of the symbol \u03b1. Thus a lower bound is obtained by summing the length of the partial solution s t and the maximum number of occurrences of each symbol of the alphabet in any string in R(s t ):", "cite_spans": [], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "Note that we use algorithm PBS in a multi-start fashion, that is, given a CPU time limit we apply algorithm PBS over and over again until the CPU limit is reached. The best solution found, denoted by s bsf , is recorded. In fact, this solution is one of the input parameters of algorithm PBS. It is used to exclude partial solutions whose lower bound value exceeds |s bsf | from further consideration.", "cite_spans": [], "ref_spans": [], "section": "Probabilistic Beam Search for the SCSP"}, {"text": "We implemented our algorithm in ANSI C++ using GCC 3.2.2 for compiling the software. Our experimental results were obtained on a PC with an AMD64X2 4400 processor and 4 Gb of memory. Two different sets of benchmark instances have been used in the experimentation. The first one-henceforth referred to as Set1-is composed of random strings with different lengths. To be precise, each instance is composed of eight strings, four of them of length 40, and the other four of length 80. Each of these strings is randomly generated, using an alphabet \u03a3. The benchmark set consists of 5 classes of each 5 instances characterized by different alphabet sizes, namely |\u03a3| = 2, 4, 8, 16, and 24. Accordingly, the benchmark set consists of 25 different problem instances. The same instances were used for experimentation, for example, in [11] .", "cite_spans": [{"start": 826, "end": 830, "text": "[11]", "ref_id": "BIBREF10"}], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "A second set of instances is composed of strings with a common source. To be precise, we have considered strings obtained from molecular sequences. The sequences considered comprise both DNA sequences (|\u03a3| = 4) and protein sequences (|\u03a3| = 20). In the first case, we have taken two DNA sequences of the SARS coronavirus from a genomic database 3 ; these sequences are 158 and 1269 nucleotides long. As to the protein sequences, we have considered three of them, extracted from Swiss-Prot 4 :", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "-Oxytocin: quite important in pregnant women, this protein causes contraction of the smooth muscle of the uterus and of the mammary gland. The sequence is 125-aminoacid long. -p53 : this protein is involved in the cell cycle, and acts as tumor suppressor in many tumor types; the sequence is 393-aminoacid long. -Estrogen: involved in the regulation of eukaryotic gene expression, this protein affects cellular proliferation and differentiation; the sequence is 595aminoacid long.", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "In all cases, problem instances are constructed by generating strings from the target sequence by removing symbols from the latter with probability p%. In our experiments, problem instances comprise 10 strings, and p \u2208{10%,15%,20%}.", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "First we wanted to find reasonable settings for the parameters of PBS. Remember that PBS has 4 parameters: k bw is the beam width; k ext is the number of children to be chosen from set C at each step; d is the parameter that controls the extent to which the choice of children from C is performed deterministically. If d = 1.0, this choice is always done deterministically, whereas when d = 0.0 the choice is always done by roulette-wheel-selection; Finally, l is the depth of the look-ahead function, that is, the parameter in LA-WMM(l) (see Section 3). In order to reduce the set of parameters to be considered for tuning we decided beforehand to set k ext = 2\u00b7 k bw . In preliminary experiments we found this setting to be reasonable. Concerning the remaining parameters we tested the following settings: k bw \u2208 {1, 10, 50}, d \u2208 {0.0, 0.25, 0.5, 0.75, 0.95}, and l \u2208 {0, 1, 2, 3}. First we studied the relation between parameters k bw and d, fixing parameter l to the maximum value 3 (that is, l = 3). We applied PBS with each combination of parameter values 5 times for 500 CPU seconds to each of the problem instances of Set1. This provided us with 25 results for each instance class (as characterized by the alphabet size). The averaged results for each instance class are shown in the graphics of Figure 1 . The results show that, in general, PBS needs some determinism in extension of partial solutions (d > 0.0), as well as a beam width greater than 1 (d > 1). However, in particular for the problem instances with a smaller alphabet size, the determinism should not be too high and the beam width should not be too big. Therefore, we decided for the settings d = 0.5 and k bw = 10 for all further experiments. Finally we performed experiments to decide for the setting of l, that is, the parameter of the look-ahead mechanism. We applied PBS with the four different settings of l (l \u2208 {0, 1, 2, 3} 5 times for 500 CPU seconds to each of the problem instances of Set1. This provides us with 25 results for each instance class. The averaged results for each instance class are shown in the graphics of Figure 2 . The results show that, in general, the setting of l = 3 is best. Especially when the alphabet size is rather large, the performance of PBS is better the higher l is. Only for \u03a3 = 2, the setting of l does not play much of a role. Therefore, we decided for the setting l = 3 for all further experiments.", "cite_spans": [], "ref_spans": [{"start": 1304, "end": 1312, "text": "Figure 1", "ref_id": "FIGREF0"}, {"start": 2110, "end": 2118, "text": "Figure 2", "ref_id": "FIGREF1"}], "section": "Algorithm Tuning"}, {"text": "We compare the results of PBS to 3 different algorithms: MM refers to a multistart version of the MM heuristic. This can be done as in case of ties during the solution construction they are broken randomly. Furthermore, WMM refers to a multi-start version of the WMM heuristic, and Hybrid MA-BS refers to an algorithm that is a hybrid between beam search and a memetic algorithm. Note that Hybrid MA-BS is a current state-of-the-art technique for the SCSP. The results for all three techniques are taken from [17] . The stopping criterion of MM, WMM, and Hybrid MA-BS was 600 CPU time seconds on a Pentium IV PC with 2400 MHz and 512 MB of memory. This corresponds roughly to the 350 CPU time seconds that we allowed on our machine for PBS.", "cite_spans": [{"start": 509, "end": 513, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Final Experimental Evaluation"}, {"text": "First, we present the results of PBS for the instances of Set1 in numerical form in Table 1 . The results show that PBS is always better than the basic greedy heuristics. With respect to the more sophisticated MA-BS algorithm, the results of PBS are roughly equivalent for |\u03a3| = 2. In the remaining instances, PBS improves significantly over the results of Hybrid MA-BS. Even the average performance of PBS is always better than the best performance of Hybrid MA-BS.", "cite_spans": [], "ref_spans": [{"start": 84, "end": 91, "text": "Table 1", "ref_id": "TABREF1"}], "section": "Final Experimental Evaluation"}, {"text": "As to the biological sequences, the results are shown in Table 2 . Again, PBS can be seen to be notoriously better than the greedy algorithms. With respect to MA-BS, PBS is capable of performing at the same level in most instances, systematically finding the optimal solutions. Only in the largest problem instances PBS starts to suffer from the curse of dimensionality. Notice nevertheless that PBS has still room for improvement. For example, using a larger beam width k bw = 100 (instead of k bw = 10), the results for the two harder SARS DNA instances are notably improved: for 15% gap, the mean result is 1269\u00b10.0 (i.e., systematically finding the optimal solution); for 20% gap, the mean result is 1483\u00b1143.1 (best result = 1294) which is much closer to optimal. Further finetuning of the parameters may produce even better results.", "cite_spans": [], "ref_spans": [{"start": 57, "end": 64, "text": "Table 2", "ref_id": null}], "section": "Final Experimental Evaluation"}, {"text": "We have introduced PBS, a novel metaheuristic that blends ideas from beam search and randomized greedy heuristics. Though relatively simple, and with just four parameters, PBS has been shown to be competitive with a much more complex hybrid metaheuristic for the SCSP that combines beam search and memetic algorithms. Furthermore, PBS has clearly outperformed this latter algorithm in one set of instances. In all cases, PBS has also been shown to be superior to two popular greedy heuristics for the SCSP. In general, PBS is a metaheuristic framework that can be applied to any optimization problem for which exist (1) a constructive mechanism for producing solutions and (2) a lower bound for evaluating partial solutions.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "The scalability of PBS is one of the features that deserves further exploration. As indicated by current results, an adequate parameterization of the algorithm can lead to improved results. The underlying greedy heuristic using within PBS, or the probabilistic choosing procedure can be also adjusted. The possibilities are manifold, and work is currently underway in this direction. An additional line of research is the hybridization of PBS with memetic algorithms. A plethora of models are possible in this sense, and using the same algorithmic template of the MA-BA hybrid would be a natural first step.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "An integrated complexity analysis of problems from computational biology", "authors": [{"first": "M", "middle": [], "last": "Hallet", "suffix": ""}], "year": 1996, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "The consensus string problem for a metric is NP-complete", "authors": [{"first": "J", "middle": [], "last": "Sim", "suffix": ""}, {"first": "K", "middle": [], "last": "Park", "suffix": ""}], "year": 2003, "venue": "Journal of Discrete Algorithms", "volume": "1", "issn": "1", "pages": "111--117", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "The shortest common supersequence problem in a microarray production setting", "authors": [{"first": "S", "middle": [], "last": "Rahmann", "suffix": ""}], "year": 2003, "venue": "Bioinformatics", "volume": "19", "issn": "", "pages": "156--161", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Theory and algorithms for plan merging", "authors": [{"first": "D", "middle": [], "last": "Foulser", "suffix": ""}, {"first": "M", "middle": [], "last": "Li", "suffix": ""}, {"first": "Q", "middle": [], "last": "Yang", "suffix": ""}], "year": 1992, "venue": "Artificial Intelligence", "volume": "57", "issn": "2-3", "pages": "143--181", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Complexity of common subsequence and supersequence problems and related problems", "authors": [{"first": "V", "middle": [], "last": "Timkovsky", "suffix": ""}], "year": 1990, "venue": "Cybernetics", "volume": "25", "issn": "", "pages": "565--580", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "The parameterized complexity of sequence alignment and consensus", "authors": [{"first": "H", "middle": [], "last": "Bodlaender", "suffix": ""}, {"first": "R", "middle": [], "last": "Downey", "suffix": ""}, {"first": "M", "middle": [], "last": "Fellows", "suffix": ""}, {"first": "H", "middle": [], "last": "Wareham", "suffix": ""}], "year": 1994, "venue": "Theoretical Computer Science", "volume": "147", "issn": "1-2", "pages": "31--54", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "More on the complexity of common superstring and supersequence problems", "authors": [{"first": "M", "middle": [], "last": "Middendorf", "suffix": ""}], "year": 1994, "venue": "Theoretical Computer Science", "volume": "125", "issn": "", "pages": "205--228", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "On the parameterized complexity of the fixed alphabet shortest common supersequence and longest common subsequence problems", "authors": [{"first": "K", "middle": [], "last": "Pietrzak", "suffix": ""}], "year": 2003, "venue": "Journal of Computer and System Sciences", "volume": "67", "issn": "1", "pages": "757--771", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Improved heuristics and a genetic algorithm for finding short supersequences", "authors": [{"first": "J", "middle": [], "last": "Branke", "suffix": ""}, {"first": "M", "middle": [], "last": "Middendorf", "suffix": ""}, {"first": "F", "middle": [], "last": "Schneider", "suffix": ""}], "year": 1998, "venue": "OR-Spektrum", "volume": "20", "issn": "", "pages": "39--45", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Searching for shortest common supersequences by means of a heuristic based genetic algorithm", "authors": [{"first": "J", "middle": [], "last": "Branke", "suffix": ""}, {"first": "M", "middle": [], "last": "Middendorf", "suffix": ""}], "year": 1996, "venue": "Proceedings of the Second Nordic Workshop on Genetic Algorithms and their Applications", "volume": "", "issn": "", "pages": "105--114", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "A comparison of evolutionary approaches to the shortest common supersequence problem", "authors": [{"first": "C", "middle": [], "last": "Cotta", "suffix": ""}], "year": 2005, "venue": "Computational Intelligence and Bioinspired Systems", "volume": "3512", "issn": "", "pages": "50--58", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Memetic algorithms with partial lamarckism for the shortest common supersequence problem", "authors": [{"first": "C", "middle": [], "last": "Cotta", "suffix": ""}], "year": 2005, "venue": "Artificial Intelligence and Knowledge Engineering Applications: a Bioinspired Approach. Number 3562 in Lecture Notes in Computer Science", "volume": "", "issn": "", "pages": "84--91", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Parameterized Complexity", "authors": [{"first": "R", "middle": [], "last": "Downey", "suffix": ""}, {"first": "M", "middle": [], "last": "Fellows", "suffix": ""}], "year": 1998, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Vertex cover: further observations and further improvements", "authors": [{"first": "J", "middle": [], "last": "Chen", "suffix": ""}, {"first": "I", "middle": [], "last": "Kanj", "suffix": ""}, {"first": "W", "middle": [], "last": "Jia", "suffix": ""}], "year": 1999, "venue": "Proceedings of the 25th International Workshop on Graph-Theoretic Concepts in Computer Science. Number 1665 in Lecture Notes in Computer Science", "volume": "", "issn": "", "pages": "313--324", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "A general method to speed up fixed-parametertractable algorithms", "authors": [{"first": "R", "middle": [], "last": "Niedermeier", "suffix": ""}, {"first": "P", "middle": [], "last": "Rossmanith", "suffix": ""}], "year": 2000, "venue": "Information Processing Letters", "volume": "73", "issn": "", "pages": "125--129", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Filtered beam search in scheduling", "authors": [{"first": "P", "middle": ["S"], "last": "Ow", "suffix": ""}, {"first": "T", "middle": ["E"], "last": "Morton", "suffix": ""}], "year": 1988, "venue": "International Journal of Production Research", "volume": "26", "issn": "", "pages": "297--307", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Hybridization of memetic algorithms with branch-and-bound techniques", "authors": [{"first": "J", "middle": ["E"], "last": "Gallardo", "suffix": ""}, {"first": "C", "middle": [], "last": "Cotta", "suffix": ""}, {"first": "A", "middle": ["J"], "last": "Fern\u00e1ndez", "suffix": ""}], "year": 2006, "venue": "IEEE Transactions on Systems, Man, and Cybernetics", "volume": "", "issn": "", "pages": "", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "The z-axis of each graphic shows the average performance of PBS with the parameter settings as specified by the x-axis (parameter d) and the y-axis (parameter kbw)", "latex": null, "type": "figure"}, "FIGREF1": {"text": "The y-axis of each graphic shows the average performance (and its standard deviation) of PBS with the parameter setting of l as specified by the x-axis", "latex": null, "type": "figure"}, "TABREF0": {"text": "return argmin {|s| |s \u2208 B compl }", "latex": null, "type": "table"}, "TABREF1": {"text": "Results for the instances of Set1", "latex": null, "type": "table", "html": "<html><body><table><tr><td>2 </td><td>112.0 </td><td>112.0 \u00b1 0.1 </td><td>0.0 </td><td>114.8 </td><td>114.8 \u00b1 0.0 </td><td>-2.5\n</td></tr><tr><td>4 </td><td>152.6 </td><td>153.4 \u00b1 0.7 </td><td>0.0 </td><td>157.8 </td><td>157.8 \u00b1 0.0 </td><td>-2.8\n</td></tr><tr><td>8 </td><td>212.4 </td><td>213.8 \u00b1 0.9 </td><td>0.0 </td><td>208.2 </td><td>208.2 \u00b1 0.0 </td><td>2.6\n</td></tr><tr><td>16 </td><td>283.8 </td><td>286.1 \u00b1 2.0 </td><td>0.0 </td><td>272.8 </td><td>273.4 \u00b1 0.5 </td><td>4.4\n</td></tr><tr><td>24 </td><td>330.2 </td><td>333.9 \u00b1 2.3 </td><td>0.0 </td><td>324.0 </td><td>325.2 \u00b1 0.7 </td><td>2.6\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>Hybrid MA-BS mean \u00b1 \u03c3 </td><td>\u00a0</td><td>PBS\n</td><td>\u00a0</td></tr><tr><td>|\u03a3| </td><td>best </td><td>\u00a0</td><td>i.% </td><td>best </td><td>mean \u00b1 \u03c3 </td><td>i.%\n</td></tr><tr><td>2 </td><td>110.6 </td><td>110.7 \u00b1 0.0 </td><td>1.2 </td><td>110.8 </td><td>110.9 \u00b1 1.7 </td><td>1.0\n</td></tr><tr><td>4 </td><td>145.6 </td><td>146.4 \u00b1 0.5 </td><td>4.6 </td><td>144.8 </td><td>145.4 \u00b1 1.5 </td><td>5.2\n</td></tr><tr><td>8 </td><td>191.6 </td><td>192.6 \u00b1 1.4 </td><td>9.9 </td><td>186.4 </td><td>187.2 \u00b1 1.7 </td><td>12.4\n</td></tr><tr><td>16 </td><td>242.8 </td><td>244.0 \u00b1 1.0 </td><td>14.7 </td><td>240.4 </td><td>241.9 \u00b1 3.4 </td><td>15.4\n</td></tr><tr><td>24 </td><td>280.2 </td><td>281.2 \u00b1 0.8 </td><td>15.8 </td><td>276.4 </td><td>277.9 \u00b1 4.0 </td><td>16.8\n</td></tr></table></body></html>"}, "TABREF2": {"text": "Table 2. Results of the different algorithms for the biological sequences", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>\u00a0</td><td>MM </td><td>\u00a0</td><td>WMM </td><td>158-nucleotide SARS sequence\n</td><td>Hybrid MA-BS </td><td>\u00a0</td><td>PBS\n</td><td>\u00a0</td></tr><tr><td>gap% best </td><td>mean \u00b1 \u03c3 </td><td>best </td><td>mean \u00b1 </td><td>\u03c3 </td><td>best </td><td>mean \u00b1 </td><td>\u03c3 </td><td>best </td><td>mean </td><td>\u00b1 \u03c3\n</td></tr><tr><td>10% </td><td>158 </td><td>158.0 \u00b1 0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0\n</td></tr><tr><td>15% </td><td>160 </td><td>160.0 \u00b1 0.0 </td><td>231 </td><td>231.0 \u00b1 </td><td>0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0\n</td></tr><tr><td>20% </td><td>228 </td><td>229.6 \u00b1 1.8 </td><td>266 </td><td>266.0 \u00b1 </td><td>0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0 </td><td>158 </td><td>158.0 \u00b1 </td><td>0.0\n</td></tr></table></body></html>"}}, "back_matter": []}