{
    "paper_id": "a00d3e0f288f1e29a9b3d81b6bd9ca165760a94c",
    "metadata": {
        "title": "On the k-synchronizability of Systems",
        "authors": [
            {
                "first": "Cinzia",
                "middle": [],
                "last": "Di",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS",
                    "location": {
                        "postCode": "I3S",
                        "settlement": "Sophia Antipolis",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "Giusto",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS",
                    "location": {
                        "postCode": "I3S",
                        "settlement": "Sophia Antipolis",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "Laetitia",
                "middle": [],
                "last": "Laversa",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS",
                    "location": {
                        "postCode": "I3S",
                        "settlement": "Sophia Antipolis",
                        "country": "France"
                    }
                },
                "email": "laetitia.laversa@univ-cotedazur.fr"
            },
            {
                "first": "Etienne",
                "middle": [],
                "last": "Lozes",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS",
                    "location": {
                        "postCode": "I3S",
                        "settlement": "Sophia Antipolis",
                        "country": "France"
                    }
                },
                "email": "etienne.lozes@univ-cotedazur.fr"
            }
        ]
    },
    "abstract": [
        {
            "text": "We study k-synchronizability: a system is k-synchronizable if any of its executions, up to reordering causally independent actions, can be divided into a succession of k-bounded interaction phases. We show two results (both for mailbox and peer-to-peer automata): first, the reachability problem is decidable for k-synchronizable systems; second, the membership problem (whether a given system is k-synchronizable) is decidable as well. Our proofs fix several important issues in previous attempts to prove these two results for mailbox automata.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Asynchronous message-passing is ubiquitous in communication-centric systems; these include high-performance computing, distributed memory management, event-driven programming, or web services orchestration. One of the parameters that play an important role in these systems is whether the number of pending sent messages can be bounded in a predictable fashion, or whether the buffering capacity offered by the communication layer should be unlimited. Clearly, when considering implementation, testing, or verification, bounded asynchrony is preferred over unbounded asynchrony. Indeed, for bounded systems, reachability analysis and invariants inference can be solved by regular model-checking [5] . Unfortunately and even if designing a new system in this setting is easier, this is not the case when considering that the buffering capacity is unbounded, or that the bound is not known a priori . Thus, a question that arises naturally is how can we bound the \"behaviour\" of a system so that it operates as one with unbounded buffers? In a recent work [4] , Bouajjani et al. introduced the notion of k-synchronizable system of finite state machines communicating through mailboxes and showed that the reachability problem is decidable for such systems. Intuitively, a system is k-synchronizable if any of its executions, up to reordering causally independent actions, can be chopped into a succession of k-bounded interaction phases. Each of these phases starts with at most k send actions that are followed by at most k receptions. Notice that, a system may be k-synchronizable even if some of its executions require buffers of unbounded capacity.",
            "cite_spans": [
                {
                    "start": 695,
                    "end": 698,
                    "text": "[5]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1054,
                    "end": 1057,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As explained in the present paper, this result, although valid, is surprisingly non-trivial, mostly due to complications introduced by the mailbox semantics of communications. Some of these complications were missed by Bouajjani et al. and the algorithm for the reachability problem in [4] suffers from false positives. Another problem is the membership problem for the subclass of k-synchronizable systems: for a given k and a given system of communicating finite state machines, is this system k-synchronizable? The main result in [4] is that this problem is decidable. However, again, the proof of this result contains an important flaw at the very first step that breaks all subsequent developments; as a consequence, the algorithm given in [4] produces both false positives and false negatives.",
            "cite_spans": [
                {
                    "start": 286,
                    "end": 289,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 533,
                    "end": 536,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 745,
                    "end": 748,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this work, we present a new proof of the decidability of the reachability problem together with a new proof of the decidability of the membership problem. Quite surprisingly, the reachability problem is more demanding in terms of causality analysis, whereas the membership problem, although rather intricate, builds on a simpler dependency analysis. We also extend both decidability results to the case of peer-to-peer communication.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Outline. Next section recalls the definition of communicating systems and related notions. In Section 3 we introduce k-synchronizability and we give a graphical characterisation of this property. This characterisation corrects Theorem 1 in [4] and highlights the flaw in the proof of the membership problem. Next, in Section 4, we establish the decidability of the reachability problem, which is the core of our contribution and departs considerably from [4] . In Section 5, we show the decidability of the membership problem. Section 6 extends previous results to the peer-to-peer setting. Finally Section 7 concludes the paper discussing other related works. Proofs and some additional material are available at https://hal.archives-ouvertes.fr/hal-02272347.",
            "cite_spans": [
                {
                    "start": 240,
                    "end": 243,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 455,
                    "end": 458,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A communicating system is a set of finite state machines that exchange messages: automata have transitions labelled with either send or receive actions. The paper mainly considers as communication architecture, mailboxes: i.e., messages await to be received in FIFO buffers that store all messages sent to a same automaton, regardless of their senders. Section 6, instead, treats peer-to-peer systems, their introduction is therefore delayed to that point.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Let V be a finite set of messages and P a finite set of processes. A send action, denoted send(p, q, v), designates the sending of message v from process p to process q. Similarly a receive action rec(p, q, v) expresses that process q is receiving message v from p. We write a to denote a send or receive action. Let S = {send(p, q, v) | p, q \u2208 P, v \u2208 V} be the set of send actions and R = {rec(p, q, v) | p, q \u2208 P, v \u2208 V} the set of receive actions. S p and R p stand for the set of sends and receives of process p respectively. Each process is encoded by an automaton and by abuse of notation we say that a system is the parallel composition of processes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Definition 1 (System). A system is a tuple S = (L p , \u03b4 p , l 0 p ) | p \u2208 P where, for each process p, L p is a finite set of local control states, \u03b4 p \u2286 (L p \u00d7 (S p \u222a R p ) \u00d7 L p ) is the transition relation (also denoted l a \u2212 \u2192 p l ) and l 0 p is the initial state.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Definition 2 (Configuration). Let S = (L p , \u03b4 p , l 0 p ) | p \u2208 P , a configuration is a pair ( l, Buf) where l = (l p ) p\u2208P \u2208 \u03a0 p\u2208P L p is a global control state of S (a local control state for each automaton), and Buf = (b p ) p\u2208P \u2208 (V * ) P is a vector of buffers, each b p being a word over V.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We write l 0 to denote the vector of initial states of all processes p \u2208 P, and Buf 0 stands for the vector of empty buffers. The semantics of a system is defined by the two rules below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "[SEND]",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A send action adds a message in the buffer b of the receiver, and a receive action pops the message from this buffer. An execution e = a 1 \u00b7 \u00b7 \u00b7 a n is a sequence of actions in S \u222a R such that ( l 0 , Buf 0 ) a1 \u2212 \u2192 \u00b7 \u00b7 \u00b7 an \u2212 \u2212 \u2192 ( l, Buf) for some l and Buf.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "As usual e = \u21d2 stands for a1 \u2212 \u2192 \u00b7 \u00b7 \u00b7 an \u2212 \u2212 \u2192. We write asEx(S) to denote the set of asynchronous executions of a system S. In a sequence of actions e = a 1 \u00b7 \u00b7 \u00b7 a n , a send action",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "and there is \u2265 1 such that a i and a j are the th actions of e with these properties respectively. A send action a i is unmatched if there is no matching reception in e. A message exchange of a sequence of actions e is a set either of the form v = {a i , a j } with a i a j or of the form v = {a i } with a i unmatched. For a message v i , we will note v i the corresponding message exchange. When v is either an unmatched send(p, q, v) or a pair of matched actions {send(p, q, v), rec(p, q, v)}, we write proc S (v) for p and proc R (v) for q. Note that proc R (v) is defined even if v is unmatched. Finally, we write procs(v) for {p} in the case of an unmatched send and {p, q} in the case of a matched send.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "An execution imposes a total order on the actions. We are interested in stressing the causal dependencies between messages. We thus make use of message sequence charts (MSCs) that only impose an order between matched pairs of actions and between the actions of a same process. Informally, an MSC will be depicted with vertical timelines (one for each process) where time goes from top to bottom, that carry some events (points) representing send and receive actions of this process (see Fig. 1 ). An arc is drawn between two matched events. We will also draw a dashed arc to depict an unmatched send event. An MSC is, thus, a partially ordered set of events, each corresponding to a send or receive action.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 487,
                    "end": 493,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Preliminaries"
        },
        {
            "text": "A message sequence chart is a tuple (Ev, \u03bb, \u227a), where -Ev is a finite set of events, \u03bb : Ev \u2192 S \u222a R tags each event with an action, -\u227a= (\u227a po \u222a \u227a src ) + is the transitive closure of \u227a po and \u227a src where:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "\u2022 \u227a po is a partial order on Ev such that, for all process p, \u227a po induces a total order on the set of events of process p, i.e., on \u03bb \u22121 (S p \u222a R p ) \u2022 \u227a src is a binary relation that relates each receive event to its preceding send event : * for all events r \u2208 \u03bb \u22121 (R), there is exactly one events s such that s \u227a src r * for all events s \u2208 \u03bb \u22121 (S), there is at most one event r such that s \u227a src r * for any two events s, r such that s \u227a src r, there are p, q, v such that \u03bb(s) = send(p, q, v) and \u03bb(r) = rec(p, q, v).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "We identify MSCs up to graph isomorphism (i.e., we view an MSC as a labeled graph). For a given well-formed (i.e., each reception is matched) sequence of actions e = a 1 . . . a n , we let msc(e) be the MSC where Ev = [1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": ".n], \u227a po is the set of pairs of indices (i, j) such that i < j and {a i , a j } \u2286 S p \u222a R p for some p \u2208 P (i.e., a i and a j are actions of a same process), and \u227a src is the set of pairs of indices (i, j) such that a i a j . We say that e = a 1 . . . a n is a linearisation of msc(e), and we write asT r(S) to denote {msc(e) | e \u2208 asEx(S)} the set of MSCs of system S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "Mailbox communication imposes a number of constraints on what and when messages can be read. The precise definition is given below, we now discuss some of the possible scenarios. For instance: if two messages are sent to a same process, they will be received in the same order as they have been sent. As another example, unmatched messages also impose some constraints: if a process p sends an unmatched message to r, it will not be able to send matched messages to r afterwards (Fig. 1a) ; or similarly, if a process p sends an unmatched message to r, any process q that receives subsequent messages from p will not be able to send matched messages to r afterwards (Fig. 1b) . When an MSC satisfies the constraint imposed by mailbox communication, we say that it satisfies causal delivery. Notice that, by construction, all executions satisfy causal delivery.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 479,
                    "end": 488,
                    "text": "(Fig. 1a)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 666,
                    "end": 675,
                    "text": "(Fig. 1b)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "Definition 4 (Causal Delivery). Let (Ev, \u03bb, \u227a) be an MSC. We say that it satisfies causal delivery if the MSC has a linearisation e = a 1 . . . a n such that for any two events i \u227a j such that a i = send(p, q, v) and a j = send(p , q, v ), either a j is unmatched, or there are i , j such that a i a i , a j a j , and i \u227a j .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "Our definition enforces the following intuitive property. Proposition 1. An MSC msc satisfies causal delivery if and only if there is a system S and an execution e \u2208 asEx(S) such that msc = msc(e).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "We now recall from [4] the definition of conflict graph depicting the causal dependencies between message exchanges. Intuitively, we have a dependency whenever two messages have a process in common. For instance an SS \u2212\u2192 dependency between message exchanges v and v expresses the fact that v has been sent after v, by the same process.",
            "cite_spans": [
                {
                    "start": 19,
                    "end": 22,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "Definition 5 (Conflict Graph). The conflict graph CG(e) of a sequence of actions e = a 1 \u00b7 \u00b7 \u00b7 a n is the labeled graph (V, { XY \u2212\u2192} X,Y \u2208{R,S} ) where V is the set of message exchanges of e, and for all X,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "Notice that each linearisation e of an MSC will have the same conflict graph. We can thus talk about an MSC and the associated conflict graph. (As an example see Figs. 1c and 1d.)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (MSC)."
        },
        {
            "text": "In this section, we define k-synchronizable systems. The main contribution of this part is a new characterisation of k-synchronizable executions that corrects the one given in [4] .",
            "cite_spans": [
                {
                    "start": 176,
                    "end": 179,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "In the rest of the paper, k denotes a given integer k \u2265 1. A k-exchange denotes a sequence of actions starting with at most k sends and followed by at most k receives matching some of the sends. An MSC is k-synchronous if there exists a linearisation that is breakable into a sequence of k-exchanges, such that a message sent during a k-exchange cannot be received during a subsequent one: either it is received during the same k-exchange, or it remains orphan forever.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Definition 6 (k-synchronous). An MSC msc is k-synchronous if:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "1. there exists a linearisation of msc e = e 1 \u00b7 e 2 \u00b7 \u00b7 \u00b7 e n where for all i \u2208 [1..n], e i \u2208 S \u2264k \u00b7 R \u2264k , 2. msc satisfies causal delivery, 3. for all j, j such that a j a j holds in e, a j a j holds in some e i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "An execution e is k-synchronizable if msc(e) is k-synchronous.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "We write sT r k (S) to denote the set {msc(e) | e \u2208 asEx(S) and msc(e) is k-synchronous}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Example 1 (k-synchronous MSCs and k-synchronizable Executions). 1. There is no k such that the MSC in Fig. 2a is k-synchronous. All messages must be grouped in the same k-exchange, but it is not possible to schedule all the sends first, because the reception of v 1 happens before the sending of v 3 . Still, this MSC satisfies causal delivery.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 102,
                    "end": 109,
                    "text": "Fig. 2a",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "be an execution. Its MSC, msc(e 1 ) depicted in Fig. 2b satisfies causal delivery. Notice that e 1 can not be divided in 1-exchanges. However, if we consider the alternative linearisation of msc(e 1 ):",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 48,
                    "end": 55,
                    "text": "Fig. 2b",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "k-synchronizable Systems"
        },
        {
            "text": ", we have that e 2 is breakable into 1exchanges in which each matched send is in a 1-exchange with its reception. Therefore, msc(e 1 ) is 1-synchronous and e 1 is 1-synchronizable. Remark that e 2 is not an execution and there exists no execution that can be divided into 1-exchanges. A k-synchronous MSC highlights dependencies between messages but does not impose an order for the execution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Comparison with [4] . In [4] , the authors define set sEx k (S) as the set of ksynchronous executions of system S in the k-synchronous semantics. Nonetheless as remarked in Example 1.2 not all executions of a system can be divided into k-exchanges even if they are k-synchronizable. Thus, in order not to lose any executions, we have decided to reason only on MSCs (called traces in [4] ).",
            "cite_spans": [
                {
                    "start": 16,
                    "end": 19,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 25,
                    "end": 28,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 383,
                    "end": 386,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Following standard terminology, we say that a set U \u2286 V of vertices is a strongly connected component (SCC) of a given graph (V, \u2192) if between any two vertices v, v \u2208 U , there exist two oriented paths v \u2192 * v and v \u2192 * v. The statement below fixes some issues with Theorem 1 in [4] .",
            "cite_spans": [
                {
                    "start": 279,
                    "end": 282,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Theorem 1 (Graph Characterisation of k-synchronous MSCs). Let msc be a causal delivery MSC. msc is k-synchronous iff every SCC in its conflict graph is of size at most k and if no RS edge occurs on any cyclic path.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Example 2 (A 5-synchronous MSC). Fig. 2c depicts a 5-synchronous MSC, that is not 4-synchronous. Indeed, its conflict graph (Fig. 2d ) contains a SCC of size 5 (all vertices are on the same SCC).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 33,
                    "end": 40,
                    "text": "Fig. 2c",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 124,
                    "end": 132,
                    "text": "(Fig. 2d",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "Comparison with [4] . Bouajjani et al. give a characterisation of k-synchronous executions similar to ours, but they use the word cycle instead of SCC, and the subsequent developments of the paper suggest that they intended to say Hamiltonian cycle (i.e., a cyclic path that does not go twice through the same vertex). It is not the case that a MSC is k-synchronous if and only if every Hamiltonian cycle in its conflict graph is of size at most k and if no RS edge occurs on any cyclic path. Indeed, consider again Example 2. This graph is not Hamiltonian, and the largest Hamiltonian cycle indeed is of size 4 only. But as we already discussed in Example 2, the corresponding MSC is not 4-synchronous.",
            "cite_spans": [
                {
                    "start": 16,
                    "end": 19,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "As a consequence, the algorithm that is presented in [4] for deciding whether a system is k-synchronizable is not correct as well: the MSC of Fig. 2c would be considered 4-synchronous according to this algorithm, but it is not.",
            "cite_spans": [
                {
                    "start": 53,
                    "end": 56,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [
                {
                    "start": 142,
                    "end": 149,
                    "text": "Fig. 2c",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "k-synchronizable Systems"
        },
        {
            "text": "We show that the reachability problem is decidable for k-synchronizable systems. While proving this result, we have to face several non-trivial aspects of causal delivery that were missed in [4] and that require a completely new approach.",
            "cite_spans": [
                {
                    "start": 191,
                    "end": 194,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "In other words, a system S is k-synchronizable if for every execution e of S, msc(e) may be divided into k-exchanges. Remark 1. In particular, a system may be k-synchronizable even if some of its executions fill the buffers with more than k messages. For instance, the only linearisation of the 1-synchronous MSC Fig. 2b that is an execution of the system needs buffers of size 2.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 313,
                    "end": 320,
                    "text": "Fig. 2b",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "For a k-synchronizable system, the reachability problem reduces to the reachability through a k-synchronizable execution. To show that k-synchronous reachability is decidable, we establish that the set of k-synchronous MSCs is regular. More precisely, we want to define a finite state automaton that accepts a sequence e 1 \u00b7 e 2 \u00b7 \u00b7 \u00b7 e n of k-exchanges if and only if they satisfy causal delivery.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "We start by giving a graph-theoretic characterisation of causal delivery. For this, we define the extended edges v XY v of a given conflict graph. The relation XY is defined in Fig. 3 with X, Y \u2208 {S, R}. Intuitively, v XY v expresses that event X of v must happen before event Y of v due to either their order on the same machine (Rule 1), or the fact that a send happens before its matching receive (Rule 2), or due to the mailbox semantics (Rules 3 and 4), or because of a chain of such dependencies (Rule 5). We observe that in the extended conflict graph, obtained applying such rules, a cyclic dependency appears whenever causal delivery is not satisfied. Fig. 5a and 5b depict an MSC and its associated conflict graph with some extended edges. This MSC violates causal delivery and there is a cyclic",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 177,
                    "end": 183,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 661,
                    "end": 668,
                    "text": "Fig. 5a",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Theorem 2 (Graph-theoretic Characterisation of Causal Delivery). An MSC satisfies causal delivery iff there is no cyclic causal dependency of the form v SS v for some vertex v of its extended conflict graph.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Let us now come back to our initial problem: we want to recognise with finite memory the sequences e 1 , e 2 . . . e n of k-exchanges that composed give an MSC that satisfies causal delivery. We proceed by reading each k-exchange one by one in sequence. This entails that, at each step, we have only a partial view of the global conflict graph. Still, we want to determine whether the acyclicity condition of Theorem 2 is satisfied in the global conflict graph. The crucial observation is that only the edges generated by Rule 4 may \"go back in time\". This means that we have to remember enough information from the previously examined kexchanges to determine whether the current k-exchange contains a vertex v that shares an edge with some unmatched vertex v seen in a previous k-exchange and whether this could participate in a cycle. This is achieved by computing two sets of processes C S,p and C R,p that collect the following information: a process q is in C S,p if it performs a send action causally after an unmatched send to p, or it is the sender of the unmatched send; a process q belongs to C R,p if it receives a message that was sent after some unmatched message directed to p. More precisely, we have:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "These sets abstract and carry from one k-exchange to another the necessary information to detect violations of causal delivery. We compute them in any local conflict graph of a k-exchange incrementally, i.e., knowing what they were at the end of the previous k-exchange, we compute them at the end of the current one. More precisely, let e = s 1 \u00b7 \u00b7 \u00b7 s m \u00b7 r 1 \u00b7 \u00b7 \u00b7 r m be a k-exchange, CG(e) = (V, E) its conflict graph and B : P \u2192 (2 P \u00d7 2 P ) the function that associates to each p \u2208 P the two sets B(p) = (C S,p , C R,p ). Then, the conflict graph CG(e, B) is the graph (V , E ) with V = V \u222a {\u03c8 p | p \u2208 P} and E \u2287 E as defined below. For each process p \u2208 P, the \"summary node\" \u03c8 p shall account for all past unmatched e = s1 \u00b7 \u00b7 \u00b7 sm \u00b7 r1 \u00b7 \u00b7 \u00b7 r m s1 \u00b7 \u00b7 \u00b7 sm \u2208 S * r1 \u00b7 \u00b7 \u00b7 r m \u2208 R * 0 \u2264 m \u2264 m \u2264 k ( l, Buf0) e = \u21d2 ( l , Buf) for some Buf for all p \u2208 P B(p) = (CS,p, CR,p) and B (p) = (C S,p , C R,p ), ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "These extra edges summarise/abstract the connections to and from previous k-exchanges. Equation (1) Example 4 (An Invalid Execution). Let e = e 1 \u00b7 e 2 with e 1 and e 2 the two 2-exchanges of this execution. such that e 1 = send(q, r, v 1 ) \u00b7 send(q, s, v 2 ) \u00b7 rec(q, s, v 2 ) and e 2 = send(p, s, v 3 ) \u00b7 rec(p, s, v 3 ) \u00b7 send(p, r, v 4 ) \u00b7 rec(p, r, v 4 ). Fig. 5a and 5c show the MSC and corresponding conflict graph of each of the 2-exchanges. Note that two edges of the global graph (in blue) \"go across\" kexchanges. These edges do not belong to the local conflict graphs and are mimicked by the incoming and outgoing edges of summary nodes. The values of sets C S,r and C R,r at the beginning and at the end of the k-exchange are given on the right. All other sets C S,p and C R,p for p = r are empty, since there is only one unmatched message to process r. Notice how at the end of the second k-exchange, r \u2208 C R,r signalling that message v 4 violates causal delivery.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 361,
                    "end": 375,
                    "text": "Fig. 5a and 5c",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Comparison with [4] . In [4] the authors define e,k = = \u21d2 cd in a rather different way: they do not explicitly give a graph-theoretic characterisation of causal delivery; instead they compute, for every process p, the set B(p) of processes that either sent an unmatched message to p or received a message from a process in B(p). They then make sure that any message sent to p by a process q \u2208 B(p) is unmatched. According to that definition, the MSC of Fig. 5b would satisfy causal delivery and would be 1-synchronous. However, this is not the case (this MSC does not satisfy causal delivery) as we have shown in Example 3. Due to to the above errors, we had to propose a considerably different approach. The extended edges of the conflict graph, and the graph-theoretic characterisation of causal delivery as well as summary nodes, have no equivalent in [4] .",
            "cite_spans": [
                {
                    "start": 16,
                    "end": 19,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 25,
                    "end": 28,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 855,
                    "end": 858,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [
                {
                    "start": 453,
                    "end": 460,
                    "text": "Fig. 5b",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Next lemma proves that Fig. 4 properly characterises causal delivery. Lemma 1. An MSC msc is k-synchronous iff there is e = e 1 \u00b7 \u00b7 \u00b7 e n a linearisation such that ( l 0 , B 0 ) e1,k = = \u21d2 cd \u00b7 \u00b7 \u00b7 en,k ==\u21d2 cd ( l , B ) for some global state l and some B : P \u2192 (2 P \u00d7 2 P ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 23,
                    "end": 29,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Note that there are only finitely many abstract configurations of the form ( l, B) with l a tuple of control states and B : P \u2192 (2 P \u00d7 2 P ). Moreover, since V is finite, the alphabet over the possible k-exchange for a given k is also finite. Therefore e,k = = \u21d2 cd is a relation on a finite set, and the set sT r k (S) of k-synchronous MSCs of a system S forms a regular language. It follows that it is decidable whether a given abstract configuration of the form ( l, B) is reachable from the initial configuration following a k-synchronizable execution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Theorem 3. Let S be a k-synchronizable system and l a global control state of S. The problem whether there exists e \u2208 asEx(S) and Buf such that ( l 0 , Buf 0 ) e = \u21d2 ( l, Buf) is decidable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "Remark 2. Deadlock-freedom, unspecified receptions, and absence of orphan messages are other properties that become decidable for a k-synchronizable system because of the regularity of the set of k-synchronous MSCs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Decidability of Reachability for k-synchronizable Systems"
        },
        {
            "text": "We establish the decidability of k-synchronizability; our approach is similar to the one of [4] based on the notion of borderline violation, but we adjust it to adapt to the new characterisation of k-synchronizable executions (Theorem 1).",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 95,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Decidability of k-synchronizability for Mailbox Systems"
        },
        {
            "text": "A non k-synchronizable execution e is a borderline violation if e = e \u00b7 r, r is a reception and e is k-synchronizable. Note that a system S that is not k-synchronizable always admits at least one borderline violation e \u00b7 r \u2208 asEx(S) with r \u2208 R: indeed, there is at least one execution e \u2208 asEx(S) which contains a unique minimal prefix of the form e \u00b7 r that is not k-synchronizable; moreover since e is k-synchronizable, r cannot be a k-exchange of just one send action, therefore it must be a receive action. In order to find such a borderline violation, Bouajjani et al. introduced an instrumented system S that behaves like S, except that it contains an extra process \u03c0, and such that a non-deterministically chosen message that should have been sent from a process p to a process q may now be sent from p to \u03c0, and later forwarded by \u03c0 to q. In S , each process p has the possibility, instead of sending a message v to q, to deviate this message to \u03c0; if it does so, p continues its execution as if it really had sent it to q. Note also that the message sent to \u03c0 get tagged with the original destination process q. Similarly, for each possible reception, a process has the possibility to receive a given message not from the initial sender but from \u03c0. The process \u03c0 has an initial state from which it can receive any messages from the system. Each reception makes it go into a different state. From this state, it is able to send the message back to the original recipient. Once a message is forwarded, \u03c0 reaches its final state and remains idle. The following example illustrates how the instrumented system works.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8 (Borderline Violation)."
        },
        {
            "text": "Let e 1 , e 2 be two executions of a system S with MSCs respectively msc(e 1 ) and msc(e 2 ). e 1 is not 1synchronizable. It is borderline in S. If we delete the last reception, it becomes indeed 1-synchronizable. msc(e 2 ) is the MSC obtained from the instrumented system S where the message v 1 is first deviated to \u03c0 and then sent back to q from \u03c0. Note that msc(e 2 ) is 1-synchronous. In this case, the instrumented system S in the 1-synchronous semantics \"reveals\" the existence of a borderline violation of S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 5 (A Deviated Message)."
        },
        {
            "text": "msc(e 1 )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 5 (A Deviated Message)."
        },
        {
            "text": "For each execution e \u00b7 r \u2208 asEx(S) that ends with a reception, there exists an execution deviate(e \u00b7 r) \u2208 asEx(S ) where the message exchange associated with the reception r has been deviated to \u03c0; formally, if e \u00b7 r = e 1 \u00b7 s \u00b7 e 2 \u00b7 r with r = rec(p, q, v) and s r, then deviate(e\u00b7r) = e 1 \u00b7send(p, \u03c0, (q, v))\u00b7rec(p, \u03c0, (q, v))\u00b7e 2 \u00b7send(\u03c0, q, (v))\u00b7rec(\u03c0, q, v).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 5 (A Deviated Message)."
        },
        {
            "text": "A k-synchronizable execution e of S is feasible if there is an execution e \u00b7 r \u2208 asEx(S) such that deviate(e \u00b7 r) = e . A feasible execution e = deviate(e \u00b7 r) of S is bad if execution e \u00b7 r is not k-synchronizable in S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 9 (Feasible Execution, Bad Execution)."
        },
        {
            "text": "Let e be an execution such that msc(e ) is as depicted on the right. Clearly, this MSC satisfies causal delivery and could be the execution of some instrumented system S . However, the sequence e\u00b7r such that deviate(e\u00b7r) = e does not satisfy causal delivery, therefore it cannot be an execution of the original system S. In other words, the execution e is not feasible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "msc(e )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "Lemma 2. A system S is not k-synchronizable iff there is a k-synchronizable execution e of S that is feasible and bad.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "As we have already noted, the set of k-synchronous MSCs of S is regular. The decision procedure for k-synchronizability follows from the fact that the set of MSCs that have as linearisation a feasible bad execution as we will see, is regular as well, and that it can be recognised by an (effectively computable) non-deterministic finite state automaton. The decidability of k-synchronizability follows then from Lemma 2 and the decidability of the emptiness problem for non-deterministic finite state automata.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "Recognition of Feasible Executions. We start with the automaton that recognises feasible executions; for this, we revisit the construction we just used for recognising sequences of k-exchanges that satisfy causal delivery.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "In the remainder, we assume an execution e \u2208 asEx(S ) that contains exactly one send of the form send(p, \u03c0, (q, v)) and one reception of the form rec(\u03c0, q, v), this reception being the last action of e . Let (V, { XY \u2212\u2192} X,Y \u2208{R,S} ) be the conflict graph of e . There are two uniquely determined vertices \u03c5 start , \u03c5 stop \u2208 V such that proc R (\u03c5 start ) = \u03c0 and proc S (\u03c5 stop ) = \u03c0 that correspond, respectively, to the first and last message exchanges of the deviation. The conflict graph of e \u00b7 r is then obtained by merging these two nodes. In order to decide whether an execution e is feasible, we want to forbid that a send action send(p , q, v ) that happens causally after \u03c5 start is matched by a receive rec(p , q, v ) that happens causally before the reception \u03c5 stop . As a matter of fact, this boils down to deal with the deviated send action as an unmatched send. So we will consider sets of processes C \u03c0 S and C \u03c0 R similar to the ones used for e,k = = \u21d2 cd , but with the goal of computing which actions happen causally after the send to \u03c0. We also introduce a summary node \u03c8 start and the extra edges following the same principles as in the previous section. Formally, let B : P \u2192 (2 P \u00d7 2 P ), C \u03c0 S , C \u03c0 R \u2286 P and e \u2208 S \u2264k R \u2264k be fixed, and let CG(e, B) = (V , E ) be the constraint graph with summary nodes for unmatched sent messages as defined in the previous section. The local constraint graph CG(e, B, C \u03c0 S , C \u03c0 R ) is defined as the graph (V , E ) where V = V \u222a {\u03c8 start } and E is E augmented with",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "As before, we consider the \"closure\" XY of these edges by the rules of Fig. 3 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 71,
                    "end": 77,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "The transition relation e,k = == \u21d2 feas is defined in Fig. 6 . It relates abstract configurations of the form ( l, B, C, dest \u03c0 ) with C = (C S,\u03c0 , C R,\u03c0 ) and dest \u03c0 \u2208 P\u222a{\u22a5} storing to whom the message deviated to \u03c0 was supposed to be delivered. Thus, the initial abstract configuration is (l 0 , B 0 , (\u2205, \u2205), \u22a5), where \u22a5 means that the processus dest \u03c0 has not been determined yet. It will be set as soon as the send to process \u03c0 is encountered. Lemma 4. Let e be an execution of S . Then e is a k-synchronizable feasible execution iff there are e = e 1 \u00b7 \u00b7 \u00b7 e n \u00b7 send(\u03c0, q, v) \u00b7 rec(\u03c0, q, v) with e 1 , . . . , e n \u2208 S \u2264k R \u2264k , B : P \u2192 2 P , C \u2208 (2 P ) 2 , and a tuple of control states l such that msc(e ) = msc(e ), \u03c0 \u2208 C R,q (with B (q) = (C S,q , C R,q )), and ( l, B) Comparison with [4] . In [4] the authors verify that an execution is feasible with a monitor which reviews the actions of the execution and adds processes that no longer are allowed to send a message to the receiver of \u03c0. Unfortunately, we have here a similar problem that the one mentioned in the previous comparison paragraph. According to their monitor, the following execution e = deviate(e \u00b7 r) is feasible, i.e., is runnable in S and e \u00b7 r is runnable in S.",
            "cite_spans": [
                {
                    "start": 796,
                    "end": 799,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 805,
                    "end": 808,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [
                {
                    "start": 54,
                    "end": 60,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "However, this execution is not feasible because there is a causal dependency between v 1 and v 3 . In [4] this execution would then be considered as feasible and therefore would belong to set sT r k (S ). Yet there is no corresponding execution in asT r(S), the comparison and therefore the k-synchronizability, could be distorted and appear as a false negative.",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 105,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "Recognition of Bad Executions. Finally, we define a non-deterministic finite state automaton that recognizes MSCs of bad executions, i.e., feasible executions e = deviate(e \u00b7 r) such that e \u00b7 r is not k-synchronizable. We come back to the \"non-extended\" conflict graph, without edges of the form",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "Lemma 5. The feasible execution e is bad iff one of the two holds 1. \u03c5 start \u2212\u2192 * RS \u2212\u2192\u2212\u2192 * \u03c5 stop , or 2. the size of the set Post * (\u03c5 start ) \u2229 Pre * (\u03c5 stop ) is greater or equal to k + 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "In order to determine whether a given message exchange v of CG(e ) should be counted as reachable (resp. co-reachable), we will compute at the entry and exit of every k-exchange of e which processes are \"reachable\" or \"co-reachable\".",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 6 (A Non-feasible Execution)."
        },
        {
            "text": "Consider the MSC on the right made of five 1-exchanges. While sending message (s, v 0 ) that corresponds to \u03c5 start , process r becomes \"reachable\": any subsequent message exchange that involves r corresponds to a vertex of the conflict graph that is reachable from \u03c5 start . While sending v 2 , process s becomes \"reachable\", because process r will be reachable when it will receive message v 2 . Similary, q becomes reachable after receiving v 3 because r was reachable when it sent v 3 , and p becomes reachable after receiving v 4 because q was reachable when it sent msc(e)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. (Reachable and Co-reachable Processes)"
        },
        {
            "text": "Co-reachability works similarly, but reasoning backwards on the timelines. For instance, process s stops being \"co-reachable\" while it receives v 0 , process r stops being co-reachable after it receives v 2 , and process p stops being coreachable by sending v 1 . The only message that is sent by a process being both reachable and co-reachable at the instant of the sending is v 2 , therefore it is the only message that will be counted as contributing to the SCC.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. (Reachable and Co-reachable Processes)"
        },
        {
            "text": "More formally, let e be sequence of actions, CG(e) its conflict graph and Lemma 6. Let e be a feasible k-synchronizable execution of S . Then e is a bad execution iff there are e = e 1 \u00b7 \u00b7 \u00b7 e n \u00b7 send(\u03c0, q, v) \u00b7 rec(\u03c0, q, v) with e 1 , . . . , e n \u2208 S \u2264k R \u2264k and msc(e ) = msc(e ), P , Q \u2286 P, sawRS \u2208 {True, False}, cnt \u2208 {0, . . . , k + 2}, such that Comparison with [4] . As for the notion of feasibility, to determine if an execution is bad, in [4] the authors use a monitor that builds a path between the send to process \u03c0 and the send from \u03c0. In addition to the problems related to the wrong characterisation of k-synchronizability, this monitor not only can detect an RS edge when there should be none, but also it can miss them when they exist. In general, the problem arises because the path is constructed by considering only an endpoint at the time.",
            "cite_spans": [
                {
                    "start": 370,
                    "end": 373,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 450,
                    "end": 453,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Example 7. (Reachable and Co-reachable Processes)"
        },
        {
            "text": "We can finally conclude that: Theorem 4. The k-synchronizability of a system S is decidable for k \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. (Reachable and Co-reachable Processes)"
        },
        {
            "text": "In this section, we will apply k-synchronizability to peer-to-peer systems. A peerto-peer system is a composition of communicating automata where each pair of machines exchange messages via two private FIFO buffers, one per direction of communication. Here we only give an insight on what changes with respect to the mailbox setting.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "Causal delivery reveals the order imposed by FIFO buffers. Definition 4 must then be adapted to account for peer-to-peer communication. For instance, two messages that are sent to a same process p by two different processes can be received by p in any order, regardless of any causal dependency between the two sends. Thus, checking causal delivery in peer-to-peer systems is easier than in the mailbox setting, as we do not have to carry information on causal dependencies.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "Within a peer-to-peer architecture, MSCs and conflict graphs are defined as within a mailbox communication. Indeed, they represents dependencies over machines, i.e., the order in which the actions can be done on a given machine, and over the send and the reception of a same message, and they do not depend on the type of communication. The notion of k-exchange remains also unchanged.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "Decidability of Reachability for k-synchronizable Peer-to-Peer Systems. To establish the decidability of reachability for k-synchronizable peer-topeer systems, we define a transition relation",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "for a sequence of action e describing a k-exchange. As for mailbox systems, if a send action is unmatched in the current k-exchange, it will stay orphan forever. Moreover, after a process p sent an orphan message to a process q, p is forbidden to send any matched message to q. Nonetheless, as a consequence of the simpler definition of causal delivery, , we no longer need to work on the conflict graph. Summary nodes and extended edges are not needed and all the necessary information is in function B that solely contains all the forbidden senders for process p.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "The characterisation of a k-synchronizable execution is the same as for mailbox systems as the type of communication is not relevant. We can thus conclude, as within mailbox communication, that reachability is decidable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "Theorem 5. Let S be a k-synchronizable system and l a global control state of S. The problem whether there exists e \u2208 asEx(S) and Buf such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "Decidability of k-synchronizability for Peer-to-Peer Systems. As in mailbox system, the detection of a borderline execution determines whether a system is k-synchronizable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "k-synchronizability for Peer-to-Peer Systems"
        },
        {
            "text": "allows to obtain feasible executions. Differently from the mailbox setting, we need to save not only the recipient dest \u03c0 but also the sender of the delayed message (information stored in variable exp \u03c0 ). The transition rule then checks that there is no message that is violating causal delivery, i.e., there is no message sent by exp \u03c0 to dest \u03c0 after the deviation. are, therefore, the same.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The relation transition"
        },
        {
            "text": "As for mailbox systems, we can, thus, conclude that for a given k, k-synchronizability is decidable. Theorem 6. The k-synchronizability of a system S is decidable for k \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The relation transition"
        },
        {
            "text": "In this paper we have studied k-synchronizability for mailbox and peer-to-peer systems. We have corrected the reachability and decidability proofs given in [4] . The flaws in [4] concern fundamental points and we had to propose a considerably different approach. The extended edges of the conflict graph, and the graph-theoretic characterisation of causal delivery as well as summary nodes, have no equivalent in [4] . Transition relations e,k = == \u21d2 feas and e,k = == \u21d2 bad building on the graph-theoretic characterisations of causal delivery and k-synchronizability, depart considerably from the proposal in [4] .",
            "cite_spans": [
                {
                    "start": 156,
                    "end": 159,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 175,
                    "end": 178,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 413,
                    "end": 416,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 610,
                    "end": 613,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Concluding Remarks and Related works"
        },
        {
            "text": "We conclude by commenting on some other related works. The idea of \"communication layers\" is present in the early works of Elrad and Francez [8] or Chou and Gafni [7] . More recently, Chaouch-Saad et al. [6] verified some consensus algorithms using the Heard-Of Model that proceeds by \"communication-closed rounds\". The concept that an asynchronous system may have an \"equivalent\" synchronous counterpart has also been widely studied. Lipton's reduction [14] reschedules an execution so as to move the receive actions as close as possible from their corresponding send. Reduction recently received an increasing interest for verification purpose, e.g. by Kragl et al. [12] , or Gleissenthal et al. [11] .",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 144,
                    "text": "[8]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 163,
                    "end": 166,
                    "text": "[7]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 204,
                    "end": 207,
                    "text": "[6]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 454,
                    "end": 458,
                    "text": "[14]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 668,
                    "end": 672,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 698,
                    "end": 702,
                    "text": "[11]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Concluding Remarks and Related works"
        },
        {
            "text": "Existentially bounded communication systems have been studied by Genest et al. [10, 15] : a system is existentially k-bounded if any execution can be rescheduled in order to become k-bounded. This approach targets a broader class of systems than k-synchronizability, because it does not require that the execution can be chopped in communication-closed rounds. In the perspective of the current work, an interesting result is the decidability of existential k-boundedness for deadlock-free systems of communicating machines with peer-to-peer channels. Despite the more general definition, these older results are incomparable with the present ones, that deal with systems communicating with mailboxes, and not peer-to-peer channels.",
            "cite_spans": [
                {
                    "start": 79,
                    "end": 83,
                    "text": "[10,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 84,
                    "end": 87,
                    "text": "15]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Concluding Remarks and Related works"
        },
        {
            "text": "Basu and Bultan studied a notion they also called synchronizability, but it differs from the notion studied in the present work; synchronizability and ksynchronizability define incomparable classes of communicating systems. The proofs of the decidability of synchronizability [3, 2] were shown to have flaws by Finkel and Lozes [9] . A question left open in their paper is whether synchronizability is decidable for mailbox communications, as originally claimed by Basu and Bultan. Akroun and Sala\u00fcn defined also a property they called stability [1] and that shares many similarities with the synchronizability notion in [2] . Context-bounded model-checking is yet another approach for the automatic verification of concurrent systems. La Torre et al. studied systems of communicating machines extended with a calling stack, and showed that under some conditions on the interplay between stack actions and communications, contextbounded reachability was decidable [13] . A context-switch is found in an execution each time two consecutive actions are performed by a different participant. Thus, while k-synchronizability limits the number of consecutive sendings, bounded context-switch analysis limits the number of times two consecutive actions are performed by two different processes.",
            "cite_spans": [
                {
                    "start": 276,
                    "end": 279,
                    "text": "[3,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 280,
                    "end": 282,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 328,
                    "end": 331,
                    "text": "[9]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 546,
                    "end": 549,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 621,
                    "end": 624,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 964,
                    "end": 968,
                    "text": "[13]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Concluding Remarks and Related works"
        },
        {
            "text": "As for future work, it would be interesting to explore how both contextboundedness and communication-closed rounds could be composed. Moreover refinements of the definition of k-synchronizability can also be considered. For instance, we conjecture that the current development can be greatly simplified if we forbid linearisation that do not correspond to actual executions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Concluding Remarks and Related works"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Automated verification of automata communicating via FIFO and bag buffers",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Akroun",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Sala\u00fcn",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Formal Methods in System Design",
            "volume": "52",
            "issn": "3",
            "pages": "260--276",
            "other_ids": {
                "DOI": [
                    "10.1007/s10703-017-0285-8"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "On deciding synchronizability for asynchronously communicating systems",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Basu",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bultan",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci",
            "volume": "656",
            "issn": "",
            "pages": "60--75",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Verification, Model Checking, and Abstract Interpretation -13th International Conference",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Basu",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bultan",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ouederni",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Lecture Notes in Computer Science",
            "volume": "7148",
            "issn": "",
            "pages": "56--71",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-27940-9_5"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "On the completeness of verifying message passing programs under bounded asynchrony",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bouajjani",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Enea",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Ji",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Qadeer",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Computer Aided Verification -30th International Conference, CAV 2018, Held as Part of the Federated Logic Conference, FloC",
            "volume": "10982",
            "issn": "",
            "pages": "372--391",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-96142-2_23"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Abstract regular model checking",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bouajjani",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Habermehl",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Vojnar",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Computer Aided Verification, 16th International Conference",
            "volume": "3114",
            "issn": "",
            "pages": "372--386",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-27813-9_29"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "A reduction theorem for the verification of round-based distributed algorithms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chaouch-Saad",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Charron-Bost",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Merz",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Reachability Problems, 3rd International Workshop",
            "volume": "5797",
            "issn": "",
            "pages": "93--106",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-04420-5_10"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Understanding and verifying distributed algorithms using stratified decomposition",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Chou",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Gafni",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Proceedings of the Seventh Annual ACM Symposium on Principles of Distributed Computing",
            "volume": "",
            "issn": "",
            "pages": "44--65",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Decomposition of distributed programs into communication-closed layers",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Elrad",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Francez",
                    "suffix": ""
                }
            ],
            "year": 1982,
            "venue": "Sci. Comput. Program",
            "volume": "2",
            "issn": "3",
            "pages": "155--173",
            "other_ids": {
                "DOI": [
                    "10.1016/0167-6423(83)90013-8"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Synchronizability of communicating finite state machines is not decidable",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Finkel",
                    "suffix": ""
                },
                {
                    "first": "\u00c9",
                    "middle": [],
                    "last": "Lozes",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Chatzigiannakis",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Indyk",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Kuhn",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "44th International Colloquium on Automata, Languages, and Programming",
            "volume": "80",
            "issn": "",
            "pages": "1--122",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.ICALP.2017.122"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "On communicating automata with bounded channels",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Genest",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kuske",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Muscholl",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Fundam. Inform",
            "volume": "80",
            "issn": "1-3",
            "pages": "147--167",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Pretend synchrony: synchronous verification of asynchronous distributed programs",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Von Gleissenthall",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "G"
                    ],
                    "last": "Kici",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bakst",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Stefan",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Jhala",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "PACMPL 3(POPL)",
            "volume": "59",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3290372"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Synchronizing the asynchronous",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Kragl",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Qadeer",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "A"
                    ],
                    "last": "Henzinger",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "29th International Conference on Concurrency Theory, CONCUR 2018",
            "volume": "118",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.CONCUR.2018.21"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Tools and Algorithms for the Construction and Analysis of Systems",
            "authors": [
                {
                    "first": "La",
                    "middle": [],
                    "last": "Torre",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Madhusudan",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Parlato",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "14th International Conference, TACAS 2008, Held as Part of the Joint European Conferences on Theory and Practice of Software",
            "volume": "4963",
            "issn": "",
            "pages": "299--314",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-78800-3_21"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Reduction: A method of proving properties of parallel programs",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "J"
                    ],
                    "last": "Lipton",
                    "suffix": ""
                }
            ],
            "year": 1975,
            "venue": "Commun. ACM",
            "volume": "18",
            "issn": "12",
            "pages": "717--721",
            "other_ids": {
                "DOI": [
                    "10.1145/361227.361234"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Analysis of communicating automata",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Muscholl",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Language and Automata Theory and Applications, 4th International Conference",
            "volume": "6031",
            "issn": "",
            "pages": "50--57",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-13089-2_4"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made. The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "(a) and (b): two MSCs that violate causal delivery. (c) and (d): an MSC and its conflict graph",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "(a) the MSC of Example 1.1. (b) the MSC of Example 1.2. (c) the MSC of Example 2 and (d) its conflict graph.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Deduction rules for extended dependency edges of the conflict graph Example 3.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Definition to p that occurred in some k-exchange before e. E is the set E of edges XY \u2212\u2192 among message exchanges of e, as in Definition 5, augmented with the following set of extra edges that takes into account summary nodes.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "that are due to two sends messages or, respectively, a send and a receive on the same process. Equations(2) and(3)considers connections RR \u2212\u2192 and RS \u2212\u2192 that are due to two received messages or, respectively, a receive and a subsequent send on the same process. Notice how the rules in Fig. 3 would then imply the existence of a connection SS , in particular Equation (3) abstract the existence of an edge SS built because of Rule 4. Equations in (4) abstract edges that would connect the current k-exchange to previous ones. As before those edges in the global conflict graph would correspond to extended edges added because of Rule 4 in Fig. 3. Once we have this enriched local view of the conflict graph, we take its extended version. Let XY denote the edges of the extended conflict graph as defined from rules in Fig. 3 taking into account the new vertices \u03c8 p and their edges.Finally, let S be a system and e,k = = \u21d2 cd be the transition relation given inFig. 4among abstract configurations of the form ( l, B). l is a global control state of S and B : P \u2192 2 P \u00d7 2 P is the function defined above that associates to each process p a pair of sets of processes B(p) = (C S,p , C R,p ). Transition e,k = = \u21d2 cd updates these sets with respect to the current k-exchange e. Causal delivery is verified by checking that for all p \u2208 P, p \u2208 C R,p meaning that there is no cyclic dependency r = {q} CR,r = {s} C S,r = {p, q} C R,r = {s, r}",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "(a) an MSC (b) its associated global conflict graph, (c) the conflict graphs of its k-exchanges as stated in Theorem 2. The initial state is ( l 0 , B 0 ), where B 0 : P \u2192 (2 P \u00d7 2 P ) denotes the function such that B 0 (p) = (\u2205, \u2205) for all p \u2208 P.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "The execution e is not feasible iff there is a vertex v in the conflict graph of e such that \u03c5 startSS v RR \u2212\u2192 \u03c5 stop .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": ", B 0 , (\u2205, \u2205), \u22a5) e1,k = == \u21d2 feas . . . en,k = == \u21d2 feas ( l , B , C , q).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Definition",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": ", Q two sets of processes, Post e (P ) = Post * {v | procs(v) \u2229 P = \u2205} and Pre e (Q) = Pre * {v | procs(v) \u2229 Q = \u2205} are introduced to represent the local view through k-exchanges of Post * (\u03c5 start ) and Pre * (\u03c5 stop ). For instance, for e as in Example 7, we get Post e({\u03c0}) = {(s, v 0 ), v 2 , v 3 , v 4 , v 0 } and Pre e ({\u03c0}) = {v 0 , v 2 , v 1 , (s, v 0 )}.In each k-exchange e i the size of the intersection between Post ei (P ) and Pre ei (Q) will give the local contribution of the current k-exchange to the calculation of the size of the global SCC. In the transition relation e,k = == \u21d2 bad this value is stored in variable cnt. The last ingredient to consider is to recognise if an edge RS belongs to the SCC. To this aim, we use a function lastisRec : P \u2192 {True, False} that for each process stores the information whether the last action in the previous k-exchange was a reception or not. Then depending on the value of this variable and if a node is in the current SCC or not the value of sawRS is set accordingly.The transition relatione,k = == \u21d2 bad defined inFig. 7deals with abstract configurations of the form (P, Q, cnt, sawRS, lastisRec ) where P, Q \u2286 P, sawRS is a boolean value, and cnt is a counter bounded by k + 2. We denote by lastisRec 0 the function where all lastisRec(p) = False for all p \u2208 P.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "{\u03c0}, Q, 0, False, lastisRec 0 ) e1,k = == \u21d2 bad . . . en,k = == \u21d2 bad (P , {\u03c0}, cnt, sawRS, lastisRec)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": ", Q , cnt , sawRS , lastisRec ) Definition least one of the two holds: either sawRS = True, or cnt = k + 2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Finally the recognition of bad execution, works in the same way as for mailbox systems. The characterisation of a bad execution and the definition of",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}