{
    "paper_id": "e6efb473ef4fda97eb9947e17d19481a4bfc93fa",
    "metadata": {
        "title": "A Choreography-Driven Approach to APIs: The OpenDXL Case Study",
        "authors": [
            {
                "first": "Leonardo",
                "middle": [],
                "last": "Frittelli",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "McAfee Cordoba",
                    "location": {
                        "settlement": "C\u00f3rdoba",
                        "country": "Argentina"
                    }
                },
                "email": "leonardofrittelli@mcafee.com"
            },
            {
                "first": "Facundo",
                "middle": [],
                "last": "Maldonado",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "McAfee Cordoba",
                    "location": {
                        "settlement": "C\u00f3rdoba",
                        "country": "Argentina"
                    }
                },
                "email": "facundomaldonado@mcafee.com"
            },
            {
                "first": "Hern\u00e1n",
                "middle": [],
                "last": "Melgratti",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Emilio",
                "middle": [],
                "last": "Tuosto",
                "suffix": "",
                "affiliation": {},
                "email": "emilio.tuosto@gssi.it"
            }
        ]
    },
    "abstract": [
        {
            "text": "We propose a model-driven approach based on formal datadriven choreographies to model message-passing applications. We apply our approach to the threat intelligence exchange (TIE) services provided by McAfee through the OpenDXL industrial platform. We advocate a chain of model transformations that (i) devises a visual presentation of communication protocols, (ii) formalises a global specification from the visual presentation that captures the data flow among services, (iii) enables the automatic derivation of specifications for the single components, and (iv) enables the analysis of software implementations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "We propose a methodology for the modelling and analysis of (part of) OpenDXL, a distributed platform that embraces the principles of the API-economy [10, 17] . In this context applications are services built by composing APIs and made available through the publication of their own APIs. In fact, the APIs of OpenDXL are paramount for enabling the openness of the platform, its growth in terms of services (currently the platform offers hundreds of different services), and its trustworthiness. The overall goal of OpenDXL is to provide a shared platform for the distributed coordination of security-related operations. A key aspect of the platform is to foster public APIs available to stakeholders for the provision or consumption of cyber-security services.",
            "cite_spans": [
                {
                    "start": 149,
                    "end": 153,
                    "text": "[10,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 154,
                    "end": 157,
                    "text": "17]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A well-known issue in API-based development is that APIs interoperability heavily depends on the (quality of) documentation: \"An API is useless unless you document it\" [29] . Proper documentation of APIs is still a problem. The current practice is to provide informal or semi-formal documentation that makes it difficult to validate software obtained by API composition, to establish their properties, and to maintain and evolve applications [2] . The OpenDXL platform is no exception. The APIs of the platform is mostly described in plain English.",
            "cite_spans": [
                {
                    "start": 168,
                    "end": 172,
                    "text": "[29]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 442,
                    "end": 445,
                    "text": "[2]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We advocate a more systematic approach that, turning informal documentation of APIs in precise models, enables the application of formal methods to develop and analysis services. We focus on threat intelligence exchange (TIE) [23] , one of the OpenDXL APIs for the coordination of activities such as assessment of security-related digital documents or reaction to indicators flagging suspicious behaviour or data. The API of TIE is part of OpenDXL and it has been designed to enable the coordination of distributed security-related activities. More precisely, TIE APIs support the management of crucial cyber-security information about assets (digital or not) of medium-size to big organisations.",
            "cite_spans": [
                {
                    "start": 226,
                    "end": 230,
                    "text": "[23]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Components for TIE developed by third-party stakeholders sometimes exhibit unexpected behaviour due to the ambiguity of the documentation of communication protocols. In fact, TIE relies on an event-notification communication infrastructure to cope with the high number of components and the volume of the communication. This asynchronous communication mechanism requires the realisation of a specific communication protocol (an application-level protocol) for the various components of the architecture to properly coordinate with each other. To address these issues, we propose a more rigorous approach to the development and documentation of the APIs. We adopt a recent behavioural type system [5] to give a precise model of some TIE services. Besides the resolution of ambiguities in the API documentation, our model enables some static and run-time verification of TIE services. We will discuss how these models could be used to check that the communication pattern of components is the expected one. Also, we will show how our behavioural types can be used to automatically verify logs of executions that may flag occurrences of unexpected behaviour.",
            "cite_spans": [
                {
                    "start": 696,
                    "end": 699,
                    "text": "[5]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Summary of the Contributions. Our overall contribution is a methodology for the design, rigorous documentation, and analysis message-passing applications. We firstly introduce our methodology and describe the model-transformations it entails. An original aspect of our approach is the combination of two models conceived to tackle different facets of message-passing applications. More precisely we rely on global choreographies (g-choreographies, for short; see e.g., [13, 32] and references therein) to specify the communication pattern of a message-passing system and on klaimographies [5] to capture the data-flow and the execution model of our application domain.",
            "cite_spans": [
                {
                    "start": 469,
                    "end": 473,
                    "text": "[13,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 474,
                    "end": 477,
                    "text": "32]",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 589,
                    "end": 592,
                    "text": "[5]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We aim to show how a model-driven approach can be conducive of a fruitful collaboration between academics and practitioners. We draw some considerations about this in Sect. 6. Our approach consists of the following steps: 2. Transform G into behavioural types formalising the protocol into a behavioural type K representing the global behaviour of the application; for this we use klaimographies (cf. Sect. 2.2). 3. Transform K into specifications of each component of the application; for this we project K on local types (cf. Sect. 4). 4. Transform the local types into state machines from which to derive monitors to check for possible deviations from expected behaviour and verify implementations of components (cf. Sect. 5).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Although, g-choreographies are crucial to settle a common ground between academics and practitioners, they do not capture the data-flow and the execution model of OpenDXL. To cope with this drawback we formalise TIE with klaimographies, a data-driven model of choreographies.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Structure of the Paper. An overview of the TIE and an informal account of our behavioural types system is given in Sect. 2.1 (we refer the reader to [5] for the full details ",
            "cite_spans": [
                {
                    "start": 149,
                    "end": 152,
                    "text": "[5]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We survey the two main ingredients of this paper, OpenDXL and klaimographies. We focus on the part of OpenDXL relevant to our case study and only give an informal account of klaimographies (see [5] for details).",
            "cite_spans": [
                {
                    "start": 194,
                    "end": 197,
                    "text": "[5]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The Open Data Exchange Layer (OpenDXL, https://www.opendxl.com/) is an open-source initiative aiming to support the exchange of timely and accurate cyber-security information in order to foster the dynamic adaptation of interconnected services to security threats. OpenDXL is part of the McAfee Security Innovation Initiative [22] , a consortium of about hundred ICT companies including HP, IBM, and Panasonic. A main goal of OpenDXL is to provide a shared platform to enable the distributed coordination of security-related operations. This goal is supported by the threat intelligence exchange (TIE) reputation APIs [23] designed to enable the coordination of activities involving -the assessment of the security threats of an environment (configuration files, certificates, unsigned or unknown files, etc.); -the prioritisation of analysis steps (focusing on malicious or unknown files); -the customisation of security queries based on reputation-based data (such as product or company names); -the reaction to suspicious indicators.",
            "cite_spans": [
                {
                    "start": 326,
                    "end": 330,
                    "text": "[22]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 618,
                    "end": 622,
                    "text": "[23]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "An Informal Account of OpenDXL"
        },
        {
            "text": "A key aspect of OpenDXL lays in its service-oriented nature. Providers use the APIs to offer various services such as reporting services, firewalls, security analytics, etc. Consumers of these APIs (typically companies or large institutions) can either use existing services, or combine them to develop their own functionalities. The basic communication infrastructure features an event-notification architecture whereby participants subscribe to topics of interests to generate events or query services. Such topics are also used to broadcast security information of general interest. The main components of OpenDXL are clients (C), servers (S), and brokers (B). The latter mediate interactions among clients and servers in order to guarantee service availability. Brokers interact with each other to dynamically assign servers to clients when default servers are unavailable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An Informal Account of OpenDXL"
        },
        {
            "text": "The high-level workflow of the TIE APIs is specified by the sequence diagram in Fig. 1 (borrowed from [23] ). Together with other informal documentation, the diagram guides the implementation of new components or the composition of services available in the platform. For instance, the documentation describing how clients can set the reputation of a file specifies that a client \"must have permission to send messages to the /mcafee/service/tie/reputation/set topic\".",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 106,
                    "text": "[23]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [
                {
                    "start": 80,
                    "end": 86,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "An Informal Account of OpenDXL"
        },
        {
            "text": "Unlike \"standard\" behavioural types, klaimographies model data flows in a communication model not based on point-to-point interactions. Interactions in a klaimography happen through tuple spaces in the style of Linda-like languages [12] . Instead of relying on primitives for sending and receiving messages over a channel, here there are primitives for inserting a tuple on a tuple space, for reading (without consuming) a tuple from a tuple space, or for retrieving a tuple from a tuple space. We call these interactions data-driven, as the coordination is based on (the type of) the exchanged tuples and the roles played by components. In fact, the communication model uses pattern matching to establish when a message from a sender may be accessed by a receiver. Crucially, klaimographies also feature multi-roles, namely roles that may be enacted by an arbitrary number of instances. Let us discuss these points with a simple example:",
            "cite_spans": [
                {
                    "start": 232,
                    "end": 236,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "The klaimography K specifies the communication protocol between (arbitrarily many) clients C and (arbitrarily many) servers S. More precisely, each client makes a request to a server by inserting a tuple consisting of a boolean and an integer at the tuple space , as indicated by the prefix C \u2192 S : (bool \u00b7 int) @ . A server consumes the request and generates a response to be consumed by a client, as specified by S \u2192 C : (int \u00b7 str) @ . Remarkably, K does not prescribe that the particular client and server involved in the first interaction are also the ones involved in the second interaction; K above establishes instead that every client starts by producing a tuple to be consumed by a server and then consumes a tuple generated by a server (also K stipulates that servers behave dually). As a consequence, the participants in K cannot correlate messages in different interactions. This can be achieved by using binders, e.g.,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "The first interaction in K introduces a new name x for the integer value exchanged in the first message. The use of x in the second interaction constraints the instances of S and C to share a tuple whose integer expression matches the integer shared in the first interaction. Consequently, the two messages in the protocol are correlated by the integer values in the two messages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "Tuple spaces may simulate other communication paradigms such as multicast or event-notification. For instance, a tuple space can be thought of as a topic; messages can be produced, read and consumed only by those roles that know such topic. Binders can also be used to ensure the creation of new topics. Consider the klaimography below:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "K is similar to K but for the fact that each client communicates to the server a new tuple space known only to the particular client and server that communicate in the first interaction; the second interaction takes place by producing and consuming messages on such new tuple space.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "Broadcast can be achieved by producing persistent messages, e.g.,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "where S!int \u00b7 str @ r states that servers insert their responses at locality r. The absence of round brackets around the tuple expresses that such tuple is read-only (i.e., they cannot be removed from the tuple space); the absence of a receiver expresses that any role can read the tuple; consequently, the generated tuple can be read by any role \"knowing\" the locality r. Additionally, klaimographies provide operators for sequential composition (\u227a), choices (+) and recursion (\u03bc \u03c1 X.K), illustrated in the following section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data-Driven Global Types"
        },
        {
            "text": "The first problem we had to face in the modelling of the protocol was to find a common ground between academic and industrial partners. This is important in order to have enough confidence that the produced formalisation faithfully represent the protocol. To attain this we gave a first approximation of the protocol as the g-choreography in Fig. 2 which we now describe. A client C and a server S engage in a protocol where C may (repeatedly) either (i) send S meta-data regarding some file x or (ii) request the analysis of a file x. A server S reacts to a request from a client in four possible ways depending on the information S may need to further acquire from the requesting client. In the protocol these alternatives are encoded with a message Res bb (x) where b and b are two boolean flags; the first boolean is set to true when the server needs meta-data related to the file x while b is set to true if more context information about the file is necessary. The client reacts to this request from the sever as appropriate. For instance, if C receives the message Res tt (x) then it has to send both meta-data and context information, while only the latter are sent if Res ft (x) is received. Before iterating back, the server may publish a new report 1 ; this is modelled by the activity K NR which we leave unspecified. This activity consists of a possible emission of a new report about file x that the server S may decide to multi-cast to clients (not just to clients currently engaging with the server).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 342,
                    "end": 348,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "Klaimographies for OpenDXL"
        },
        {
            "text": "We remark that the g-choreography in Fig. 2 represents the interactions between clients and servers and has been introduced as a first step in the formalisation of the protocol to pave the way for its algebraic definition as klaimographies. Firstly, a graphical representation played a central r\u00f4le when validating protocol interactions with industrial partners. Secondly, the graph was used as a blueprint for the formalisation. Hence, we invite the reader to follow such graph as the formal definitions unroll.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 37,
                    "end": 43,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "Klaimographies for OpenDXL"
        },
        {
            "text": "In the OpenDXL platform several clients and servers may interact by exchanging messages. The interaction in TIE is always triggered by a client which, as seen in Sect. 2.1, iteratively decides to either send some metadata on a file or request for the reputation of a specific file. This can be defined as follows",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Klaimographies for OpenDXL"
        },
        {
            "text": "where \u03bc C X.K Body \u227a X is the recursive type to express iterative behaviour; it indicates that role C is the one controlling the iteration. Namely, C decides whether to repeat the execution of the body K Body or to end it. The sequential composition K Body \u227a X is just syntax to express that, after the execution of K Body , the iteration restarts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Klaimographies for OpenDXL"
        },
        {
            "text": "Notation. We write as \"macros\" so that occurrences of the left-hand side of the equation are verbatim replaced for its right-hand side.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Klaimographies for OpenDXL"
        },
        {
            "text": "The body of the iteration in (1), defined as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Klaimographies for OpenDXL"
        },
        {
            "text": "specifies that each iteration consists of a choice between K MD (x, ) and K REQ (x, ) followed by K NR (x):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "-The branch K MD (x, ) accounts for the case in which a client sends new metadata to a server. -The branch K REQ (x, ) describes the interaction for the case in which the client sends a reputation request. -The continuation K NR (x) describes the decision of the server of emitting a reputation report.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "Notation. In accordance with the previous notation, x and above are just meta-identifiers for the same syntactic identifier across equations. Let b be a globally known location representing the public name on which a client sends requests to a server. The branches of the body are defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "In both cases the first interaction takes place on the tuple space b.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "In K MD (x, ), the client simply sends a tuple MD \u00b7 \u03bdx : Dgt \u00b7 \u03bd : loc made of three fields. The first field has sort MD which is a tag for messages carrying metadata. The second field is a named sort \u03bdx : Dgt, where (i) the sort Dgt (after digest) types values that are hash codes of files and (ii) the identifier x is introduced to establish the correlation that will be used in the following interactions. This mechanism enables the tracking of data dependencies among interactions. Finally, the third field is another named sort : loc; basically, the client communicates also the name of a new tuple space, to be used in the subsequent communications. For instance, the continuation type",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "describes the behaviour of a server that decides whether to emit a new report about the received metadata or not. Type K NR (x) consists of a non-deterministic choice between a branch S!Report \u00b7 x : Dgt @ b' and the empty type 0. The former specifies that the server publishes a new report for the file by emitting a (persistent) tuple of type Report \u00b7 x : Dgt on a publicly known 2 tuple space b'.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "Note that the use of x constraints the new report produced by server S to be related to a file digest communicated earlier to S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "The interaction prefixes C \u2192 S : (...) @ are quite different than the prefix S!Report \u00b7 x : Dgt @ . This is a remarkable peculiarity of klaimographies that is quite useful to model TIE. Firstly, the former kind of prefix describes an interaction between two roles: clients are supposed to produce messages of some sort for servers. Instead, the behavioural type S!Report \u00b7 x : Dgt @ only prescribes the expected communication from a single role, the server. This allows any role to access the tuple types generated by this kind of prefixes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "Another important aspect is the other syntactic difference: the messages in round brackets are produced to be consumed, while the ones not surrounded by brackets are persistent and can only be read; moreover, the message can be read by any role able to access the tuple space . For instance, requests of clients are eventually handled by a server, while any role can read, but not remove, reports.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "Let us now return to the comment on the other branch in (2) . In the klaimography K REQ (x, ), a client sends a request for the reputation of a file by sending a message whose tag is of type Req. In that message, the client sends the digest Dgt that identifies the file and, analogously to K MD (x, ), a fresh locality ; the correlation x and the locality are used in the subsequent interactions, which are described by K info (x, ) below. it prescribes the possible responses that the server may send to the client. We start commenting on the last branch. If the server does not require further information, it simply informs the client that the interaction for that request concludes. The remaining branches of K info (x, ) model the cases in which the server requests both the metadata and the file (first branch), just the metadata (second branch) or just the file (third branch). When both metadata and file are requested, then the protocol continues as follows",
            "cite_spans": [
                {
                    "start": 56,
                    "end": 59,
                    "text": "(2)",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "And, when the server asks for either the metadata or the file, then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "which is in accordance with the g-choreography in Sect. 2.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A g-choreography for TIE APIs"
        },
        {
            "text": "As commonplace in choreographic approaches, the description of the expected behaviour of each participant in a protocol can be obtained by projection. In our case, this is an operation that takes a klaimography and a role and generates a description, dubbed local type, of the flow of messages sent and received by that participant. Local types are meant to give an abstract specification of the processes implementing the roles of the klaimography. We write the projection of a klaimography K for the role \u03c1 as K \u03c1 . Note that the projection operation is completely automatic; given a klaimography the behaviour of each component is algorithmically derived. We omit here the formal definition of K \u03c1 , which can be found at [5] , and illustrate its application to K TIE in (1). We consider K TIE C first. The projection operation is defined by induction on the syntax of the klaimography; hence we focus on the constituent parts of K TIE . Consider the branch K MD (x, ), which is defined in (3) as the interaction C \u2192 S : (MD \u00b7 \u03bdx : Dgt \u00b7 \u03bd : loc) @ b. The projection of this interaction on the client role just consists of the behaviour that generates a message of type MD \u00b7 \u03bdx : Dgt \u00b7 \u03bd : loc on the locality b; formally, this is written",
            "cite_spans": [
                {
                    "start": 725,
                    "end": 728,
                    "text": "[5]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "Note (a) the use of the round brackets to represent message consumption, and (b) the projection is oblivious of the intended receiver (the server). In fact, the behavioural type system of klaimographies ensures that if the actual components abide by the klaimographies given in Sect. 3, then only components enacting the role of the server will access those kind of tuples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "The projection for K req (x, ) (and all its constituents) is analogous:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "Observe that the projection for K info is a choice in which C expects (and consumes) one of the four possible messages produced by the server at locality . Finally, the projection of K NR (x) is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "Differently from the projection of interactions in which the client consumes the messages, the first branch of the above projection just reads the message at the locality . Note the difference between (t)? (consumption) and t? (read), which reflects the usage of round bracket discussed in Sect. 3. Projection works homomorphically on choices and sequential composition, hence the projection of K body in (2) we have",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "We now give the projection of K TIE , which is a recursive klaimography. Then,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "The projection of a recursive klaimography is also a recursive local type. However, the projection introduces auxiliary interactions to coordinate the execution of the loop. Since C is the role that coordinates the recursion in K TIE , in the projection C starts its body by communicating its decision to terminate or to continue. Namely, the body of K TIE C has two branches, stop !b communicates the termination of the recursion, while the other starting with \u03bdy : loc !b iterates (and distributes a fresh localities for the next iteration). Note that recursive variables X in the local types are parameterised variables X(b) and X b . In general, a klaimography \u03bc \u03c1 X.K is projected as a recursive local type \u03bcX( x) . L where the formal parameters x stand for the locations used for coordination and are the initial values, in this case, b. The projection for the behaviour of the server is obtained analogously.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Projections"
        },
        {
            "text": "Like data types, behavioural types can be regarded as specifications of the intended behaviour of a system. As such they can check that the components implementing the protocol abide by their specifications. Customarily, approaches to behavioural types focus on static enforcement [9, 15, 16] , i.e., the source code implementing a role is type-checked against its local type and the soundness of the type checking algorithm ensures that well-typed code behaves as prescribed by its type. Also the dynamic enforcement of protocols based on local types has been addressed in the literature [3, 11, 27] . In most cases, monitors dynamically check that the messages exchanged by the components comply with the protocol. Deviations from the expected behaviour are singled out and offending components are blamed. In this work we explore the usage of local types for the off-line monitoring of role implementations. In particular, we use projections to check that the different implementations of the multirole C in TIE follow the protocol. We take advantage of the fact that the communication infrastructure of TIE keeps a log with the communication messages generated by the different roles.",
            "cite_spans": [
                {
                    "start": 281,
                    "end": 284,
                    "text": "[9,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 285,
                    "end": 288,
                    "text": "15,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 289,
                    "end": 292,
                    "text": "16]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 589,
                    "end": 592,
                    "text": "[3,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 593,
                    "end": 596,
                    "text": "11,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 597,
                    "end": 600,
                    "text": "27]",
                    "ref_id": "BIBREF29"
                }
            ],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "In Fig. 3 we show an anonymised (and simplified) version of a few entries of a real log. Each entry corresponds to an interaction between a client and a server and it consists of a record of comma-separated fields which we now describe:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 9,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Types at Work"
        },
        {
            "text": "-the first field is a global timestamp used to order the entries chronologically; -the second field is the locality, which is encoded by a three-digits number; -the third and fourth fields are the identity of the sender and of the receiver respectively (for obvious reasons, the real identities have been obfuscated; Fig. 3 uses symbolic names clientA, server1, etc.); -the remaining fields are the payloads of the message, which varies depending on the type of the message.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 317,
                    "end": 323,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Types at Work"
        },
        {
            "text": "The type of each message is identified by a tag: Req, MD, and File have analogous meaning to the ones used in the specification of the protocol in Sects. 3 and 4. The sorts such as Res tf used in our specification are rendered in the implementation with a payload consisting of three parts: the tag Res and two binary digits; used to encode the subscript (with 1 representing true and 0 representing false); for instance, the subscript tf above is encoded as the pair 1, 0. We use file i to represent the different digests transmitted over the messages. The first entry in the log of Fig. 3 is generated by the interaction",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 584,
                    "end": 590,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Types at Work"
        },
        {
            "text": "where the instance clientA of the role C sends to the instance server1 of S a request for a reputation report about the file file1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "The second entry in the log corresponds to the selection of the branch",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "in K info (x, ) in which the server asks the client for the metadata of the file; the messages in which the client sends the metadata can be seen in the third line @startuml left to right direction [*] --> S0 S0 --> S0: 'MD'@l @Dgt S0 --> S1: 'Req'@l S1 --> S2: ('Res', '1', '1')@l -> @Dgt S1 --> S3: ('Res', '0', '1')@l -> @Dgt S1 --> S4: ('Res', '1', '0')@l -> @Dgt S1 --> S0: ('Res', '0', '0')@l S2 --> S3: 'MD'@l -> @Dgt S3 --> S0: 'File'@f S4 --> S0: 'MD'@l @enduml of the log. Obviously, the interactions among different instances need not to be consecutive, as it is the case for the entries at locality 340 which are on the lines 4, 5 and 7. Observe also that the last entry in Fig. 3 has broadcast as its receiver. This message corresponds to the publication of a reputation report by the server, which is defined in K NR (x) as Report \u00b7 x : Dgt? . We have implemented in Python an off-line monitor that takes a log and a local type in input and checks whether the log faithfully follows behaviour described by the local type. Local types are turned into a textual representation of finite state automata that can be depicted as UML state machines. For instance, the local type K tie C is defined as shown in Fig. 4 , which can be graphically represented as shown in Fig. 5 . These representations are obtained by \"massaging\" the projections defined in Sect. 4. The main difference between the UML representation and the local type (besides the obvious syntactic changes) is that the former does not contain the messages for coordinating the recursion in (4) (i.e., stop and \u03bdy : loc); those have been omitted because not explicitly exchanged by the components. As a consequence, we assume that the client continues the loop if it keeps sending messages and it finishes silently otherwise. Another simplification for the sake of the presentation is the omission of K NR (x) C , essentially because the observable behaviour of the client is unaffected if it reads or not a report. In fact, the log is not informative enough to discriminate on the choice made by the client.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 686,
                    "end": 692,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 1218,
                    "end": 1224,
                    "text": "Fig. 4",
                    "ref_id": null
                },
                {
                    "start": 1276,
                    "end": 1282,
                    "text": "Fig. 5",
                    "ref_id": null
                }
            ],
            "section": "Types at Work"
        },
        {
            "text": "Once such simplifications are in place, (4) can be easily matched with the graphical representation in Fig. 5 . The state S0 represents K TIE C . The self-loop stands for the selection of the branch K MD (x, ) C , i.e., the client sends a message containing metadata, and then restart the loop. The transition from S0 to S1 represents instead the choice of the branch K req (x, ) C , i.e., the client request of a reputation report. The remaining states are in one-to-one correspondence with the following projections defined in the previous section: S1 stands for K info (x, ) C , S2 for K tt (x, ) C , S3 for K ft (x, ) C , and S4 for K tf (x, ) C . All the transitions are decorated with the associated messages sent or received by a client. Note also that S1, S3 and S4 have transitions to the state S0 meaning that execution of the body the is completed and that the body can be restarted.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 103,
                    "end": 109,
                    "text": "Fig. 5",
                    "ref_id": null
                }
            ],
            "section": "Types at Work"
        },
        {
            "text": "With this implementation we have detected a few deviations from the expected behaviour. In particular, some clients exhibit the following violations:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "-files are sent for analysis without a prior request, -requests for further information from the server are not honoured.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "The first violation is detected by the presence of an entry of the log with a message tagged File without a previous message from the server with tag Res tt or Res ft . The second violation is due to the absence of an entry related to a given hash used by the server for asking further information.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "Our implementation can also check other properties. For example, TIE clients should guarantee a so-called \"time-window\" property which requires that \"a request for the analysis of the same file from a client must not happen before a given amount of time elapsed from the previous request from the client for the same file.\"",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "This property (as well as others) can be checked by monitor derived from the local types as done in the examples above.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types at Work"
        },
        {
            "text": "Summary. We reported on a collaboration between industrial and academic partners which applied formal methods to address a key problem affecting APIsbased software. More precisely, the problem that informal specifications of the behaviour of services may lead to errors in message-passing applications. For instance, third-party clients of TIE services exhibit anomalous when interacting with the services developed at McAfee. To overcome this problem, TIE services are engineered with a rather defensive approach to anticipate anomalous interactions. Unintended behaviours are reported to third-parties after a \"post-mortem\" analysis of execution logs. We devised a model-driven approach to model and validate message-passing software. We applied the methodology in the context of the OpenDXL platform, an initiative of a consortium of industries conceived for the development of cyber-security functionalities. The platform provides an API to allow developers to access and combine the functionalities of a service-oriented architecture. In this context we applied the methodology to the threat intelligence exchange (TIE) service provided by McAfee Cordoba for the assessment of security threats, prioritisation of analysis steps, reputation-based data queries.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "Related Work. The use of behavioural types for the specification and analysis of message-passing application is widespread (see [16] for a survey). Semantics of behavioural types (operational or denotational) abstract the behaviour of systems and enables the use of formal methods and tools to check their properties.",
            "cite_spans": [
                {
                    "start": 128,
                    "end": 132,
                    "text": "[16]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "Our proposal hinges on a form of choreographies in the vein of global type systems [15] , which formally capture the design of WSCDL [18] . In fact, the specification of a global view is the starting step of our methodology and the use of a projection operation to (automatically) derive local views is a paramount step in the model-transformation chain described in Sect. 1. The literature offers several variants of choreographic models [4, 6, 8, 14, 30, 32] (to mention but a few). A common treat of those models is that they are grounded on point-to-point communication in traditional settings (such as the use of the actor model [1] or \u03c0-calculus [25, 26, 31] ). A distinguished feature of OpenDXL is that it relies on event-notification mechanisms. This is the main motivation for the adoption of klaimographies [5] . In fact, unlike other choreographic approaches, klaimographies advocate a peculiar interpretation of interactions. More precisely, interactions A\u2212 \u2192B : m are generally interpreted as \"an instance of A and an instance of B exchange message m\". The interpretation of A\u2212 \u2192B : m drastically changes in klaimographies and becomes \"any instance of A generates the message m expected to be handled by any instance of B\". This interpretation is the cornerstone for a faithful modelling of OpenDXL.",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[15]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 133,
                    "end": 137,
                    "text": "[18]",
                    "ref_id": null
                },
                {
                    "start": 439,
                    "end": 442,
                    "text": "[4,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 443,
                    "end": 445,
                    "text": "6,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 446,
                    "end": 448,
                    "text": "8,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 449,
                    "end": 452,
                    "text": "14,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 453,
                    "end": 456,
                    "text": "30,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 457,
                    "end": 460,
                    "text": "32]",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 652,
                    "end": 656,
                    "text": "[25,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 657,
                    "end": 660,
                    "text": "26,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 661,
                    "end": 664,
                    "text": "31]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 818,
                    "end": 821,
                    "text": "[5]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "Lesson Learned. Although we are at an early stage of the collaboration, we can draw some conclusions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "A first point worth remarking is about the effectiveness of our methodology. On the one hand, the academic partners were oblivious of several current practices (such as the continuous defensive patching TIE servers). On the other hand, the industrial partners acquired some notions about behavioural specifications during the participation of a school [24] organised by the academic partners as well as presented the OpenDXL platforms at the school. The methodology was applied immediately after the school and the bulk of modelling and analysis of TIE was concluded in about 3-persons month. In the chain of model transformations of our methodology, steps (1) and (4) were paramount for practitioners to apply this methodology: the use of visual, intuitive, yet formal models enabled a fruitful collaboration among stakeholders. In fact, g-choreographies were key to tune up the model and to identify the main aspects of the intended communication protocol as well as to ease the collaboration between practitioners and academics. Basically, g-choreographies gave a first intuitive presentation capturing the essential interactions of TIE. This has been instrumental for an effectual collaboration. Once the g-choreography expressing the intended behaviour has been identified, the academic partners have devised the klaimographies formalising the expected behaviour. The identification of the corresponding klaimographies allowed us to automatically derive local specifications (step (iii)) and use them as precise blue-prints of components as well as to automatically derive monitors (step (iv)). Remarkably, the transformation from local types to state machines was suggested by our industrial partners who saw it as a more streamlined way of sharing the specifications among practitioners (including those outside McAfee). At this stage we do not have data to measure the impact of the enhanced documentation on the quality of the software produced.",
            "cite_spans": [
                {
                    "start": 352,
                    "end": 356,
                    "text": "[24]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "This experience also highlights the importance of non-deterministic abstractions and of visual tools in practice. We argue that these elements are paramount for collaborations that could be beneficial to both academics and practitioners. In fact, behavioural types (as many formal methods) may not be easy for practitioners to handle. To tackle this issue we opted for models offering a visual and intuitive presentations of the formal models used in the specifications. The specification in terms of g-choreographies and klaimographies was attained in few days of man-power involving academics and practitioners. This hints that our model-driven methodology can significantly reduce the steepness of the learning curve that formal methods often require.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "The problem of informal behavioural specification is ubiquitous in API-based software. The approach we followed aimed at some generality: instead of devising ad-hoc formal methods for the OpenDXL case study, we decided to apply existing frameworks. In fact, both g-choreographies and klaimographies had been developed before and independently of this collaboration. The methodology proposed here assumes only that components communicate through generative coordination mechanisms [12] . As noted by one of the reviewers, \"tuple-semantics are well-suited not only for this use case but for the modern age of IoT, where eventbased middlewares are becoming the norm.\"",
            "cite_spans": [
                {
                    "start": 480,
                    "end": 484,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "A final note on the connection with other formal methods. Behavioural specifications offer also support to \"bottom-up\" engineering (see, e.g., [19, 21] ). This would require to infer the behaviour to analyse from logs and, as noted by another reviewer, one could spare \"to model the whole behaviour [...] and focus on specific components.\" We concur that our methodology can be complemented by such technique (and this is indeed one of the goals within the BehAPI project). Also, one may wonder if the methodology can be combined with model checking. This is indeed the case since our models feature operation semantics amenable to be model checked. A drawback of model checking is that practitioners would find it hard to express the properties to check. Instead the top-down approach allowed them to express such conditions in terms of state machines.",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 147,
                    "text": "[19,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 148,
                    "end": 151,
                    "text": "21]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "Future Work. Global graphs have been key to facilitate the collaboration between academics and industrial partners for the former can use gchoreographies precisely (since they come with a precise semantics) and the latter can use the visual and intuitive presentation of g-choreographies. It is in the scope of future work to use the formal framework of g-choreographies. In fact, we can use g-choreographies to verify liveness properties of the communication protocols, or to generate executable template code to be refined by practitioners. We plan to extend ChorGram [20] , a tool based on g-choreographies, to support the methodology. For instance, projection operations from global to local views are a key feature of our choreographic framework. Here, we have manually given klaimographies and their projections. This can be automatised by algorithmically transforming g-choreographies into klaimographies. Another possibility is to exploit ChorGram to generate code; for instance, ChorGram can map g-choreographies to (executable) Erlang code. These sort of functionalities are highly appealing to industrial stakeholders due (a) to the \"correct-byconstruction\" principle they support and (b) to the fact that each release of TIE services requires the realisation of in-house clients for many different languages and platforms. For instance, OpenDXL needs to develop several version of each component for different execution environments. Also, TIE clients have to be implemented in different programming languages or for operating systems; this could be done by devising each software component by projection from a global view. Having tools that generate template code for implementing the communication protocol of each component would speed up the development process and reduce the time of testing (which would not need to focus on communications which would be correct-by-construction). In order to attain this, it could be useful to \"dress up\" g-choreographies with existing industrial standards that practitioners may find more familiar (and may be more appealing). An interesting candidate for this endeavour is BPMN [28] since its coordination mechanisms are very close to those of g-choreographies. In fact, BPMN is becoming popular in industry and it has recently gained the attention of the scientific community which is proposing formal semantics of its constructs. For instance, the formal semantics in [7] could be conducive of a formal mapping from BPMN to g-choreographies or global types. In this way practitioners may specify global views within a context without spoiling the rigour of our methodology.",
            "cite_spans": [
                {
                    "start": 570,
                    "end": 574,
                    "text": "[20]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 2133,
                    "end": 2137,
                    "text": "[28]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 2425,
                    "end": 2428,
                    "text": "[7]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "For simplicity in this paper we abstracted away from some aspects of TIE. The extension of our approach to the complete protocol is not conceptually complex, but it is scope for future work. This will include the analysis to further properties expected of TIE components and that can be checked from the logs. Following our methodology, we plan to devise monitors for the run-time verification of those properties as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        },
        {
            "text": "A final remark is about other advantages of behavioural types that we can exploit in the future. For instance, one goal is to device tools for checking the compliance of components to the TIE protocol. This can be achieved by typechecking components against their projections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions, Related and Future Work"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": ":50, 649, clientA, server1, MD, file1 2019-03-27T15:59:50, 340, clientC, server1, Req",
            "authors": [],
            "year": 2019,
            "venue": "",
            "volume": "340",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Actors: A Model of Concurrent Computation in Distributed Systems",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Agha",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Testing in the API Economy",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Ariola",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Dunlop",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Top 5 Myths",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Monitoring networks through multiparty session types",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Bocchi",
                    "suffix": ""
                },
                {
                    "first": "T.-C",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Demangeon",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Honda",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Yoshida",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "FMOOD-S/FORTE -2013",
            "volume": "7892",
            "issn": "",
            "pages": "50--65",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-38592-6_5"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Contract compliance and choreography conformance in the presence of message queues",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bravetti",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        ";"
                    ],
                    "last": "Zavattaro",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Ws-Fm",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Data-driven choreographies\u00e0 la Klaim",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bruni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Corradini",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Gadducci",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Melgratti",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Montanari",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Models, Languages, and Tools for Concurrent and Distributed Programming",
            "volume": "11665",
            "issn": "",
            "pages": "170--190",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-21485-2_11"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Choreography and orchestration conformance for system design",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Busi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gorrieri",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Guidi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Lucchi",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Zavattaro",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "COORDINATION 2006",
            "volume": "4038",
            "issn": "",
            "pages": "63--81",
            "other_ids": {
                "DOI": [
                    "10.1007/11767954_5"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Walking through the semantics of exclusive and event-based gateways in BPMN choreographies",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Corradini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Morichetta",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Re",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Tiezzi",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "The Art of Modelling Computational Systems: A Journey from Logic and Concurrency to Security and Privacy",
            "volume": "11760",
            "issn": "",
            "pages": "163--181",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-31175-9_10"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Dynamic choreographies",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Dalla Preda",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gabbrielli",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Giallorenzo",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Lanese",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mauro",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "COORDINATION 2015",
            "volume": "9037",
            "issn": "",
            "pages": "67--82",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-19282-6_5"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Sessions and session types: an overview",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Dezani-Ciancaglini",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "De&apos;liguoro",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "WS-FM 2009",
            "volume": "6194",
            "issn": "",
            "pages": "1--28",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-14458-5_1"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The API Economy -Disruption and the Business of APIs",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Doerrfeld",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Wood",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Anthony",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sandoval",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lauret",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Reversible choreographies via monitoring in Erlang",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Francalanza",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "A"
                    ],
                    "last": "Mezzina",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "DAIS 2018",
            "volume": "10853",
            "issn": "",
            "pages": "75--92",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-93767-0_6"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Generative communication in Linda",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gelernter",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "ACM Trans. Program. Lang. Syst",
            "volume": "7",
            "issn": "1",
            "pages": "80--112",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Realisability of Pomsets via communicating automata",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guanciale",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings 9th Interaction and Concurrency Experience",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Realisability of Pomsets via communicating automata",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guanciale",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "J. Logic Algebraic Methods Program",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Multiparty asynchronous session types",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Honda",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Yoshida",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Carbone",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "J. ACM",
            "volume": "63",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Foundations of session types and behavioural contracts",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "H\u00fcttel",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "ACM Comput. Surv",
            "volume": "49",
            "issn": "1",
            "pages": "1--3",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Synthesising choreographies from local session types",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lange",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "CONCUR 2012",
            "volume": "7454",
            "issn": "",
            "pages": "225--239",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "ChorGram: tool support for choreographic development",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lange",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "From communicating machines to graphical choreographies",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lange",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Yoshida",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "POPL 2015",
            "volume": "",
            "issn": "",
            "pages": "221--232",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Mcafee Security Innovation Alliance",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Mcafee",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Threat intelligence exchange recommended workflow",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Mcafee",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Summer School on Behavioural Approaches for API-Economy with Applications",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "C"
                    ],
                    "last": "Melgratti",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "8--12",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Communicating and Mobile Systems: the \u03c0-Calculus",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Milner",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "A calculus of mobile processes, I and II",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Milner",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Parrow",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Walker",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Inf. Comput",
            "volume": "100",
            "issn": "1",
            "pages": "41--77",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Timed runtime monitoring for multiparty conversations",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Neykova",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Bocchi",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Yoshida",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Formal Aspects Comput",
            "volume": "29",
            "issn": "5",
            "pages": "877--910",
            "other_ids": {
                "DOI": [
                    "10.1007/s00165-017-0420-8"
                ]
            }
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Business Process Model and Notation",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Application Programming Interface",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Orenstein",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Computer World",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Towards the theoretical foundation of choreography",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Qiu",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhao",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cai",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Proceedings of the 16th International Conference on World Wide Web",
            "volume": "",
            "issn": "",
            "pages": "973--982",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "The \u03c0-Calculus: A Theory of Mobile Processes",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sangiorgi",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Walker",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Semantics of global view of choreographies",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tuosto",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guanciale",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "J. Log. Algebraic Methods Program",
            "volume": "95",
            "issn": "",
            "pages": "17--40",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Documenting TIE[23]",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "info (x, ) S \u2192 C : (Res tt \u00b7 x : Dgt) @ . K tt (x, ) + S \u2192 C : (Res tf \u00b7 x : Dgt) @ . K tf (x, ) + S \u2192 C : (Res ft \u00b7 x : Dgt) @ . K ft (x, ) + S \u2192 C : (Res ff \u00b7 x : Dgt) @ This klaimography corresponds to the inner-most choice of the graph in Sect. 2.1;",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "A simplified snippet of a real (anonymised) log",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Kdxl C as UML diagram (textual representation) Kdxl C as UML diagram (graphical representation)",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "). The behavioural types of TIE are reported in Sect. 3; there we clarify that our model falls in the setting of \"top-down\" choreographic approaches. This amounts to say that we first give global specification that formally captures the main aspects of the communication protocol of all TIE from a holistic point of view. Then, in Sect. 4 we discuss how to automatically derive (by projection) the local behaviour of each component of TIE. We consider a few real scenarios in Sect. 5 and draw some conclusions in Sect. 6.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We thank the anonymous reviewers for their many insightful comments and suggestions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgments."
        }
    ]
}