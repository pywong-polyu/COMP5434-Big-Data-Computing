{
    "paper_id": "0abd80d0eb6c7608b0d63c9dd45c5aadb7fa58d8",
    "metadata": {
        "title": "Quantum-effective exact multiple patterns matching algorithms for biological sequences",
        "authors": [
            {
                "first": "Kapil",
                "middle": [],
                "last": "Kumar",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Maulana Azad National Institute of Technology",
                    "location": {
                        "settlement": "Bhopal",
                        "region": "Madhya Pradesh",
                        "country": "India"
                    }
                },
                "email": ""
            },
            {
                "first": "Soni",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Maulana Azad National Institute of Technology",
                    "location": {
                        "settlement": "Bhopal",
                        "region": "Madhya Pradesh",
                        "country": "India"
                    }
                },
                "email": ""
            },
            {
                "first": "Akhtar",
                "middle": [],
                "last": "Rasool",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Maulana Azad National Institute of Technology",
                    "location": {
                        "settlement": "Bhopal",
                        "region": "Madhya Pradesh",
                        "country": "India"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "This article presents efficient quantum solutions for exact multiple pattern matching to process the biological sequences. The classical solution takes \u039f(mN) time for matching m patterns over N sized text database. The quantum search mechanism is a core for pattern matching, as this reduces time complexity and achieves computational speedup. Few quantum methods are available for multiple pattern matching, which executes search oracle for each pattern in successive iterations. Such solutions are likely acceptable because of classical equivalent quantum designs. However, these methods are constrained with the inclusion of multiplicative factor m",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "in their complexities. An optimal quantum design is to execute multiple search oracle in parallel on the quantum processing unit with a single-core that completely removes the multiplicative factor m, however, this method is impractical to design. We have no effective quantum solutions to process multiple patterns at present. Therefore, we propose quantum algorithms using quantum processing unit with C quantum cores working on shared quantum memory. This quantum parallel design would be effective for searching all t exact occurrences of each pattern. To our knowledge, no attempts have been made to design multiple pattern matching algorithms on quantum multicore processor. Thus, some quantum remarkable exact single pattern matching algorithms are enhanced here with their equivalent versions, namely enhanced quantum memory processing based exact algorithm and enhanced quantum-based combined exact algorithm for multiple pattern matching. Our quantum solutions find all t exact occurrences of each pattern inside the biological sequence in O\u00f0\u00f0m=C\u00de ffiffiffiffi N p \u00de and O\u00f0\u00f0m=C\u00de ffiffi t p \u00de time complexities. This article shows the hybrid simulation of quantum algorithms to validate quantum solutions. Our theoretical-experimental results justify the significant improvements that these algorithms outperform over the existing classical solutions and are proven effective in quantum counterparts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "The exact multiple pattern matching problem is to find a bijective mapping for m patterns within the text sequence database. Searching for the multiple string patterns would be more practical while processing large biological sequence databases (Basel, 2006; Neamatollahi, 2020) . The search of multiple nucleotides or amino acid patterns is necessary within the genome, protein and other biological sequences for a significant purpose (Charalampos, Panagiotis & Konstantinos, 2011) . For example, we know that proteogenomics mapping uses proteomics data for DNA or genome annotation. This mapping matches peptide or protein patterns within the proteomics data through the mass spectrometry analysis against the target genome for identifying all locations of genes with coding regions (Choo, 2006; Fredriksson, 2009) . Therefore, this processing demands a compatible and efficient solution to search for multiple patterns belonging to P \u00bc P 1 ; :; P k ; :; P m f gwith P j j \u00bc m. Each pattern P k 1 k m \u00f0 \u00deof independent length M k \u00bc 0 to M k \u00c0 1 \u00bd is searched within the large-sized text sequence T of length N \u00bc 0 to N \u00c0 1 \u00bd . Both M and N belongs to the alphabet set AE such that N ) M, and t number of pattern occurrences is possible to search between index positions 0 and N \u2212 M. Now, specific to biological sequence processing, we usually prefer these m patterns with the same length. Certainly, the set P contains multiple patterns, although, the restricted singleton set P j j \u00bc 1 allows us to search P as a single pattern (Charalampos, Panagiotis & Konstantinos, 2011; Faro & Lecroq, 2013; Zhang et al., 2015; Hendrian et al., 2019; Hakak & Kamsin, 2019) .",
            "cite_spans": [
                {
                    "start": 245,
                    "end": 258,
                    "text": "(Basel, 2006;",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 259,
                    "end": 278,
                    "text": "Neamatollahi, 2020)",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 436,
                    "end": 482,
                    "text": "(Charalampos, Panagiotis & Konstantinos, 2011)",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 785,
                    "end": 797,
                    "text": "(Choo, 2006;",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 798,
                    "end": 816,
                    "text": "Fredriksson, 2009)",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1531,
                    "end": 1577,
                    "text": "(Charalampos, Panagiotis & Konstantinos, 2011;",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1578,
                    "end": 1598,
                    "text": "Faro & Lecroq, 2013;",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1599,
                    "end": 1618,
                    "text": "Zhang et al., 2015;",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 1619,
                    "end": 1641,
                    "text": "Hendrian et al., 2019;",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 1642,
                    "end": 1663,
                    "text": "Hakak & Kamsin, 2019)",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "The biological sequence database contains N sized text with exponential factors of gigabytes, terabytes or more. For single pattern matching, the classical solution scans these databases in directional sequence on the main memory (Sheik, Aggarwal & Anindya Poddar, 2004; Kalsi, Peltola & Tarhio, 2008; Rivals, Salmela & Tarhio, 2011) . The search time is still bound to O(N) or the complete scan of text to find all the t occurrences of P P j j \u00bc 1 \u00f0 \u00de; however, for the exponentially large value of N, the problem is computationally hard. Thus, we clarify that the time of pattern search increases in proportion to the size of text database, so fast searching techniques are expected. A classical method for the multiple pattern matching takes O(mN) time complexity due to repeated scanning of N sized text database for m patterns (Fredriksson, 2009; Charalampos, Panagiotis & Konstantinos, 2011) . In contrast, the quantum search takes O ffiffiffiffi N p \u00c0 \u00c1 time (Nielsen & Chuang, 2010) ; therefore, a quadratic speedup is possible, and such acceleration is expected in quantum pattern matching . Since the existence of problem, solutions have been suggesting through modified algorithms.",
            "cite_spans": [
                {
                    "start": 230,
                    "end": 270,
                    "text": "(Sheik, Aggarwal & Anindya Poddar, 2004;",
                    "ref_id": null
                },
                {
                    "start": 271,
                    "end": 301,
                    "text": "Kalsi, Peltola & Tarhio, 2008;",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 302,
                    "end": 333,
                    "text": "Rivals, Salmela & Tarhio, 2011)",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 832,
                    "end": 851,
                    "text": "(Fredriksson, 2009;",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 852,
                    "end": 897,
                    "text": "Charalampos, Panagiotis & Konstantinos, 2011)",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 966,
                    "end": 990,
                    "text": "(Nielsen & Chuang, 2010)",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "The objective is to suggest effective pattern matching algorithm with better performance than others and to set itself as a benchmark solution. We seek technology-based solutions; therefore, effective quantum-based algorithms are expected for multiple pattern matching. Some quantum-based exact single pattern matching algorithms are enhanced here for their equivalent multiple pattern matching versions (Soni & Rasool, 2021) . Our methods remove existing multiple pattern matching constraints (Soni & Malviya, 2021) and realize the effective quantum-based solutions by scanning the text database in the uniform superposition of quantum memory (QMEM) (Giovannetti, Lloyd & Maccone, 2008; Nielsen & Chuang, 2010) . Therefore, based on the advantage of quantum processing unit (QPU) having C quantum cores 1 c C \u00f0 \u00de (Metodi, 2011; Lin et al., 2013; Fu et al., 2016; Britt, 2017; Brandl, 2017) , we propose our algorithms to match m patterns using the quantum-exact match (QEM) circuit (Sena Oliveira, Benicio Melo de Sousa & Viana Ramos, 2007; Soni & Rasool, 2021) and quantum Grover's search operator (GSO) mechanism (Nielsen & Chuang, 2010; Chakrabarty, Khan & Singh, 2017) .",
            "cite_spans": [
                {
                    "start": 404,
                    "end": 425,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 494,
                    "end": 516,
                    "text": "(Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 651,
                    "end": 687,
                    "text": "(Giovannetti, Lloyd & Maccone, 2008;",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 688,
                    "end": 711,
                    "text": "Nielsen & Chuang, 2010)",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 814,
                    "end": 828,
                    "text": "(Metodi, 2011;",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 829,
                    "end": 846,
                    "text": "Lin et al., 2013;",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 847,
                    "end": 863,
                    "text": "Fu et al., 2016;",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 864,
                    "end": 876,
                    "text": "Britt, 2017;",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 877,
                    "end": 890,
                    "text": "Brandl, 2017)",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 983,
                    "end": 1041,
                    "text": "(Sena Oliveira, Benicio Melo de Sousa & Viana Ramos, 2007;",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 1042,
                    "end": 1062,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1116,
                    "end": 1140,
                    "text": "(Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 1141,
                    "end": 1173,
                    "text": "Chakrabarty, Khan & Singh, 2017)",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "For processing the biological sequence databases, exact matches are always preferred with accurate matching outcomes. The nucleotide and amino acid patterns are used to locate within genome, protein and other biological sequences for different purposes (Jiang, Zhang & Zhang, 2013; Singh, 2015) . The size of DNA or RNA alphabet set is AE j j \u00bc 4, and coded adjacent triplet of nucleotide characters which forms amino acid with the set size AE j j \u00bc 20. The biological sequence databases are excessively large, so multiple string patterns should be effectively processed. Multiple pattern matching aims to identify all locations of m patterns within the sequence databases in a single scan. The searching of DNA pattern within nucleotide sequence helps us to identify, compare and align the sequences as well as to analyze mutations (Faro & Lecroq, 2009; Tahir, Sardaraz & Ikram, 2017; Raja & Srinivasulu Reddy, 2019) . However, different nucleotides can code to similar proteins, so protein databases are searched for similarity checks.",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 281,
                    "text": "(Jiang, Zhang & Zhang, 2013;",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 282,
                    "end": 294,
                    "text": "Singh, 2015)",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 833,
                    "end": 854,
                    "text": "(Faro & Lecroq, 2009;",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 855,
                    "end": 885,
                    "text": "Tahir, Sardaraz & Ikram, 2017;",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 886,
                    "end": 917,
                    "text": "Raja & Srinivasulu Reddy, 2019)",
                    "ref_id": "BIBREF41"
                }
            ],
            "ref_spans": [],
            "section": "Significance of processing biological sequences"
        },
        {
            "text": "An exact multiple pattern matching has more practical applications in computational biology, such as sequence alignments, motif finding, read mapping in gene and genome, substring matching, proteogenomics mapping, overlap detection, codon matching, etc. Thus, the problem is intentionally assumed here to search for the exact occurrences of the patterns (Kalsi, Peltola & Tarhio, 2008; Charalampos, Panagiotis & Konstantinos, 2011; Rivals, Salmela & Tarhio, 2011) . There exists an impact of processing large sequences through the efficient algorithm, hence quantum algorithms are made suitable to process biological sequence applications. We search for multiple patterns set P \u00bc P 1 ; :; P k ; :; P m f gwith implicit consideration of processing singleton pattern set to find all t exact occurrence of single nucleotide patterns in gene and genome databases, or multiple nucleotide patterns to confirm the presence of amino acid within the peptide and protein sequences (Singh, 2015; Hakak & Kamsin, 2019) . Later, in \"proposed algorithmic applications to process biological sequences\", we define several applications of our quantum algorithms which are related to searching multiple patterns within the biological sequence databases. For a more comprehensive understanding to process the biological sequences, review these referenced articles (Sheik, Aggarwal & Anindya Poddar, 2004; Basel, 2006; Choo, 2006; Kalsi, Peltola & Tarhio, 2008; Fredriksson, 2009; Charalampos, Panagiotis & Konstantinos, 2011; Rivals, Salmela & Tarhio, 2011; Faro & Lecroq, 2013; Jiang, Zhang & Zhang, 2013; Singh, 2015; Zhang et al., 2015; Tahir, Sardaraz & Ikram, 2017; Hakak & Kamsin, 2019; Neamatollahi, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021; Raja & Srinivasulu Reddy, 2019) .",
            "cite_spans": [
                {
                    "start": 354,
                    "end": 385,
                    "text": "(Kalsi, Peltola & Tarhio, 2008;",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 386,
                    "end": 431,
                    "text": "Charalampos, Panagiotis & Konstantinos, 2011;",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 432,
                    "end": 463,
                    "text": "Rivals, Salmela & Tarhio, 2011)",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 971,
                    "end": 984,
                    "text": "(Singh, 2015;",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 985,
                    "end": 1006,
                    "text": "Hakak & Kamsin, 2019)",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 1345,
                    "end": 1385,
                    "text": "(Sheik, Aggarwal & Anindya Poddar, 2004;",
                    "ref_id": null
                },
                {
                    "start": 1386,
                    "end": 1398,
                    "text": "Basel, 2006;",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1399,
                    "end": 1410,
                    "text": "Choo, 2006;",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1411,
                    "end": 1441,
                    "text": "Kalsi, Peltola & Tarhio, 2008;",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 1442,
                    "end": 1460,
                    "text": "Fredriksson, 2009;",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1461,
                    "end": 1506,
                    "text": "Charalampos, Panagiotis & Konstantinos, 2011;",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1507,
                    "end": 1538,
                    "text": "Rivals, Salmela & Tarhio, 2011;",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 1539,
                    "end": 1559,
                    "text": "Faro & Lecroq, 2013;",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1560,
                    "end": 1587,
                    "text": "Jiang, Zhang & Zhang, 2013;",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1588,
                    "end": 1600,
                    "text": "Singh, 2015;",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 1601,
                    "end": 1620,
                    "text": "Zhang et al., 2015;",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 1621,
                    "end": 1651,
                    "text": "Tahir, Sardaraz & Ikram, 2017;",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 1652,
                    "end": 1673,
                    "text": "Hakak & Kamsin, 2019;",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 1674,
                    "end": 1693,
                    "text": "Neamatollahi, 2020;",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 1694,
                    "end": 1714,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1715,
                    "end": 1736,
                    "text": "Soni & Malviya, 2021;",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 1737,
                    "end": 1768,
                    "text": "Raja & Srinivasulu Reddy, 2019)",
                    "ref_id": "BIBREF41"
                }
            ],
            "ref_spans": [],
            "section": "Significance of processing biological sequences"
        },
        {
            "text": "The quantum machine can achieve computational speedups because of implicit parallelism. It needs O(1), i.e. constant execution step to realize an exponential number of operations (Nielsen & Chuang, 2010) . We assume a problem of pattern matching as hard when the size of text database N \u00bc 2 n is excessively large as gigabytes (2 30 ), terabytes (2 40 ) or more (Kalsi, Peltola & Tarhio, 2008; Neamatollahi, 2020) . So, instead of classical, the quantum pattern search takes reduced O ffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi N \u00bc 2 n p \u00c0 \u00c1 time (Menon & Chattopadhyay, 2021 ). An existing quantum pattern matching solution achieved speedups over classical complexities (Ramesh & Vinay, 2003; De Jesus, Aborot & Adorna, 2013; Aborot, 2017; Soni & Rasool, 2021) ; however, the benchmark methods are constrained to find a single pattern, and the quantum multiple pattern matching is found ineffective because of executing multiple search oracles in successive iterations and it includes multiplicative factor m (Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 179,
                    "end": 203,
                    "text": "(Nielsen & Chuang, 2010)",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 362,
                    "end": 393,
                    "text": "(Kalsi, Peltola & Tarhio, 2008;",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 394,
                    "end": 413,
                    "text": "Neamatollahi, 2020)",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 551,
                    "end": 579,
                    "text": "(Menon & Chattopadhyay, 2021",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 675,
                    "end": 697,
                    "text": "(Ramesh & Vinay, 2003;",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 698,
                    "end": 730,
                    "text": "De Jesus, Aborot & Adorna, 2013;",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 731,
                    "end": 744,
                    "text": "Aborot, 2017;",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 745,
                    "end": 765,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1014,
                    "end": 1036,
                    "text": "(Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "The optimal quantum design may execute multiple search oracle in parallel on QPU with single-core to remove completely such factor m, however, this is impractical to design. We seek exact solutions of pattern matching with more applicability in computational biology. Thus, the available quantum benchmark algorithms QPBE and QBCE are enhanced here, with the names, enhanced QMEM processing-based exact algorithm (EnQPBEA-MPM) and enhanced quantum-based combined exact algorithm (EnQBCEA-MPM) for multiple pattern matching. The design of algorithms is based on processing effectiveness of QPU having C quantum cores and each core shares the text T on QMEM. So, to find all the t exact occurrences of each pattern, the search time complexities of the proposed algorithms are O m=C \u00f0 \u00de ffiffiffiffi N p \u00c0 \u00c1 and O m=C \u00f0 \u00de ffiffi t p \u00c0 \u00c1 . Our motivation is to search for all exact occurrences of m patterns either by direct use of effective quantum processing framework over original text sequence database T in O ffiffiffiffi N p \u00c0 \u00c1 queries or by transforming approximate filtering outcome into exactness over reduced search space in O ffiffi t p \u00c0 \u00c1 queries. The algorithms are based inherently on Grover's search operator (GSO). We use QMEM to explore the text of size N \u00bc 2 n such that, the entire text search space is accessed in parallel in \u039f(1) time, but memory word access needs O log 2 N \u00c0 \u00c1 steps (Park & Petruccione, 2019; Matteo, 2020; . A new quantum circuit of \u039f(1) time is proposed for exact match between pattern P and substring of T of size M, whereas classical comparison takes \u039f(M) time (Sena Oliveira, Benicio Melo de Sousa & Viana Ramos, 2007; De Jesus, Aborot & Adorna, 2013; Soni & Rasool, 2021) . Thus, we initiate quantum-effective algorithms with a context of exponential increase in biological text size. The proposed work of this article is organized as per Fig. 1 , and we derive our results by giving the proofs of Theorem 1 and Theorem 2 in the proposed methods section. This article presents our main contribution as the effective quantum design of multiple patterns matching algorithms which are proved mathematically along with their simulations. We outline our work below to achieve objectives in a streamlined manner throughout this article:",
            "cite_spans": [
                {
                    "start": 1405,
                    "end": 1431,
                    "text": "(Park & Petruccione, 2019;",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 1432,
                    "end": 1445,
                    "text": "Matteo, 2020;",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 1636,
                    "end": 1662,
                    "text": "Sousa & Viana Ramos, 2007;",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 1663,
                    "end": 1695,
                    "text": "De Jesus, Aborot & Adorna, 2013;",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1696,
                    "end": 1716,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [
                {
                    "start": 1884,
                    "end": 1890,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "We realize the effective quantum processing framework by using QPU with C quantum cores which access quantum processing circuit of equivalent QMEM procedure. It achieves the quantum-based computational and processing speedups. We also proposed, a new constant time, quantum exact match (QEM) circuit which is utilized implicitly under GSO iterations. We justify our proposed quantum algorithms using complexities analysis, and specific quantum proving techniques such as probabilistic, truthness and correctness proofs. The future works of Soni & Rasool (2021) (Soni & Rasool, 2021) . A factor m=C \u00f0 \u00de is proved negligible for a small arbitrary constant value of m and constant value of C as the QPU with C quantum cores utilizing their own set of quantum registers for searching m m=C \u00f0 \u00de is included explicitly in the time complexities for considering m ) C \u00f0 \u00deas the worst case.",
            "cite_spans": [
                {
                    "start": 540,
                    "end": 560,
                    "text": "Soni & Rasool (2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 561,
                    "end": 582,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "The quantum operations of proposed algorithms are proved equivalent to their quantum circuits. These circuits are the actual realization of quantum solutions. Quantum query, time and storage complexities of proposed algorithms justify their effectiveness. Based on several complexity analysis factors, we prove our proposed solutions as efficient to find exact patterns, and these remove the existing multiple pattern matching constraint (Soni & Malviya, 2021) as designs of QEMP and QAMP cannot exclude multiplicative factor m.",
            "cite_spans": [
                {
                    "start": 438,
                    "end": 460,
                    "text": "(Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "Our proposed quantum algorithms are simulated for validation through the quantum exact simulation toolkit (QuEST). Also, we proposed a quantum circuit implementation of QMEM through algebraic normal form (ANF). The intentions are not to analyze the efficiency of the simulation due to classical machine restrictions; therefore, we do the hybrid implementation. We validate our results using QuEST simulation by assuming that t number of search solutions, either unique or multiple solution, are already known. To realize the case in which the value of t is unknown, we use quantum counting (QC) additionally to validate the search results of our proposed EnQPBEA-MPM and EnQBCEA-MPM algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "We suggest several applications of EnQPBEA-MPM and EnQBCEA-MPM for processing biological sequences. Such applicability of these algorithms is specified with respect to significant characteristics and performance restrictions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "The abbreviated names used throughout the text are available in Table A1 (Appendix A). The nomenclature used in this article is a prerequisite for further reading purpose, therefore refer to Table B1 (Appendix B). The individual correctness proofs of algorithms EnQPBEA-MPM and EnQBCEA-MPM are separately included in Appendix C and Appendix D. A correctness proof shows algorithmic trace steps which expands the applied quantum operations.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 64,
                    "end": 72,
                    "text": "Table A1",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 191,
                    "end": 199,
                    "text": "Table B1",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Motivation and contribution of work"
        },
        {
            "text": "In classical findings, earlier exact multiple patterns matching solutions were proposed as the enhanced version of Knuth-Morris-Pratt (KMP) and Boyer-Moore (BM) algorithms. Both these multiple patterns matching solutions are available in \u039f(mM) time for pattern pre-processing, and searching takes \u039f(mN) Soni & Malviya, 2021 (Fredriksson, 2009; Hendrian et al., 2019) . The performance of these algorithms is dependent on AE j j, size of text database T j j \u00bc N, number of patterns |P| = m and each pattern P k with varying length M k \u00bc 0 to M k \u00c0 1 \u00bd . We noted that the multiplicative factor m is somehow included in time complexities of the classical algorithms. Among all the algorithms, AC has significant applications in biological sequence processing. However, AC requires large memory to store the automata, and hence it is constrained to process large patterns set. This algorithm induces competitive results on the small-sized AE j j and P j j \u00bc m with each pattern P k of short length M k (Fredriksson, 2009; Charalampos, Panagiotis & Konstantinos, 2011; Faro & Lecroq, 2013; Zhang et al., 2015; Hendrian et al., 2019; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 303,
                    "end": 323,
                    "text": "Soni & Malviya, 2021",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 324,
                    "end": 343,
                    "text": "(Fredriksson, 2009;",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 344,
                    "end": 366,
                    "text": "Hendrian et al., 2019)",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 999,
                    "end": 1018,
                    "text": "(Fredriksson, 2009;",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1019,
                    "end": 1064,
                    "text": "Charalampos, Panagiotis & Konstantinos, 2011;",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1065,
                    "end": 1085,
                    "text": "Faro & Lecroq, 2013;",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1086,
                    "end": 1105,
                    "text": "Zhang et al., 2015;",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 1106,
                    "end": 1128,
                    "text": "Hendrian et al., 2019;",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 1129,
                    "end": 1150,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "There exist few solutions for quantum pattern matching with the advantage of using amplitude amplification of Grover's search (GSO). This method finds search results over N-sized text in O ffiffiffiffi N p \u00c0 \u00c1 steps with high probability, and it is better than the classical linear search time \u039f(N) (Lanzogorta & Uhlmann, 2008; Zhou et al., 2013; Coles, 2020) . Few single and multiple patterns matching schemes are available in the quantum. Single pattern matching was initiated by Ramesh-Vinay (RV) through the quantum deterministic sampling method; however, the suggested solution needs O ffiffiffiffi ffi M p \u00fe ffiffiffiffi N p \u00c0 \u00c1 time by including the pre-processing and searching (Ramesh & Vinay, 2003; Montanaro, 2017; Menon & Chattopadhyay, 2021 Aborot & Adorna, 2013; Aborot, 2017) .",
            "cite_spans": [
                {
                    "start": 299,
                    "end": 327,
                    "text": "(Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 328,
                    "end": 346,
                    "text": "Zhou et al., 2013;",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 347,
                    "end": 359,
                    "text": "Coles, 2020)",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 687,
                    "end": 709,
                    "text": "(Ramesh & Vinay, 2003;",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 710,
                    "end": 726,
                    "text": "Montanaro, 2017;",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 727,
                    "end": 754,
                    "text": "Menon & Chattopadhyay, 2021",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 755,
                    "end": 777,
                    "text": "Aborot & Adorna, 2013;",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 778,
                    "end": 791,
                    "text": "Aborot, 2017)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "Recent advancements of these algorithms are presented by extending the logic of QEPM or combining the methods of QEPM and QAPM for effective exact matching design. A suggested QMEM processing based exact (QPBE) algorithm is efficient to process large text sequences and this also overcomes the constraint of QEPM method by finding all t exact occurrences of search pattern in O ffiffiffiffiffi Nt p \u00c0 \u00c1 time (Soni & Rasool, 2021) . However, the quantum-based combined exact (QBCE) algorithm replaces approximations of the QAPM method with exact matches. This also reduces implicit quantum circuit depth to explore the text during pattern search with logarithmic factors. The desired search time of all t exact occurrence of search pattern is O ffiffi t p \u00c0 \u00c1 (Soni & Rasool, 2021) . Both these extended solutions are remarkable; however, no attempt has been made yet to design QPBE and QBCE algorithms to process multiple patterns, which are highly expected in biological sequence processing. As well as, the design of QBCE is not available under the specific processing of QMEM (Soni & Rasool, 2021) . For quantum multiple pattern matching, initial solutions were suggested as an extension to QEPM and QAPM methods. Soni & Malviya (2021) suggested multiple pattern algorithms, renamed here as quantum exact multiple pattern (QEMP) algorithm to search for either the single occurrence or all t occurrence of m patterns within time complexities range O m ffiffiffiffi",
            "cite_spans": [
                {
                    "start": 408,
                    "end": 429,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 759,
                    "end": 780,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1079,
                    "end": 1100,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1217,
                    "end": 1238,
                    "text": "Soni & Malviya (2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "Such algorithms search for the equal and unequal sized patterns in successive iterations, and this includes multiplicative factor m in time complexities. Thus, search solution for multiple pattern algorithms is not effective (Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 225,
                    "end": 247,
                    "text": "(Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "We are providing the brief description of algorithms QEPM & QAPM, QPBE & QBCE, and QEMP & QAMP from the next subsection onward. As per the reviewed analysis of algorithms, the qubits estimations and algorithmic complexities analysis are also included separately.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "Quantum exact pattern matching (QEPM) and quantum approximate pattern matching (QAPM) algorithms",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "The QEPM method is based on the design of an oracle that performs parallel matching under the quantum superposition by aligning comparison window between pattern and text substring to search for a leftmost exact occurrence of pattern. In O ffiffiffiffi N p \u00c0 \u00c1 queries, oracle inverts the leftmost index to report pattern match solution with high probability. The algorithm uses GSO and assures O ffiffiffiffi N p log 2 N \u00c0 \u00c1 search time complexity. Table 1 shows that the method is constrained to find a single t \u00bc 1 \u00f0 \u00de occurrence of pattern, and qubits estimation is the same as quantum search algorithm (De Jesus, Aborot & Adorna, 2013) . The algorithm QAPM applies hamming distance (HD) method for approximate text filtering and matching. It cannot find accurate results as HD is an error model and allow replacement at unit cost. A pattern is reported when HD Threshold (precomputed). A QAPM needs more storage as it uses a large number of quantum registers with excessive qubits requirement (Aborot, 2017) ; see Table 1 . However, this searches all occurrences with O ffiffi t p \u00c0 \u00c1 queries. Additional indices may filter using HD, and this increases the size of filtered text, and even HD based verification generates search results with approximation. A filtering needs O tlog 2 N \u00c0 \u00c1 time to find all t filtered indices, then verification matches the t 0 approximate occurrences of pattern through registers comparison, and ffiffi t p calls of GSO, in the O ffiffiffiffi ffi tt 0 p log 2 N \u00c0 \u00c1 and O tlog 2 N \u00c0 \u00c1 time (Aborot, 2017) .",
            "cite_spans": [
                {
                    "start": 618,
                    "end": 640,
                    "text": "Aborot & Adorna, 2013)",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 998,
                    "end": 1012,
                    "text": "(Aborot, 2017)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1528,
                    "end": 1542,
                    "text": "(Aborot, 2017)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [
                {
                    "start": 450,
                    "end": 457,
                    "text": "Table 1",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 1019,
                    "end": 1026,
                    "text": "Table 1",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "RELATED WORK Prior work and the important findings"
        },
        {
            "text": "The recently proposed algorithms, QPBE and QBCE, are efficient to process the large text sequences. These also overcome the constraints of QEPM and QAPM methods (Soni & Rasool, 2021) . The QPBE design is realized efficiently under the superposition of text indices on a quantum memory, and it finds all t exact occurrences of search pattern in O ffiffiffiffiffi Nt p \u00c0 \u00c1 time. However, the QBCE algorithm replaces pattern matching approximations with exact matches. It also reduces implicit quantum circuit depth to explore the text during pattern search with the logarithmic factor. A search time for all t 0 exact occurrences over the reduced text of size t is O ffiffiffiffi ffi tt 0 p \u00c0 \u00c1 . Both these methods were proposed with significant aspects to process the specific biological sequences. A query remains the same as existing methods, rather the ",
            "cite_spans": [
                {
                    "start": 161,
                    "end": 182,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [],
            "section": "QMEM processing based exact (QPBE) and quantum-based combined exact (QBCE) pattern matching algorithms"
        },
        {
            "text": "As we reviewed, the storage complexity of QPBE is same as the existing QEPM algorithm. The QBCE remarkably reduces the storage while comparing with the excessive qubits requirement of pattern verification used in the existing QAPM method. All the required complexity analysis detail of these algorithms are included in Table 2 for quick reference (Soni & Rasool, 2021) .",
            "cite_spans": [
                {
                    "start": 347,
                    "end": 368,
                    "text": "(Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [
                {
                    "start": 319,
                    "end": 326,
                    "text": "Table 2",
                    "ref_id": "TABREF5"
                }
            ],
            "section": "QMEM processing based exact (QPBE) and quantum-based combined exact (QBCE) pattern matching algorithms"
        },
        {
            "text": "Quantum exact multiple pattern (QEMP) and quantum approximate multiple pattern (QAMP) matching algorithms",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QMEM processing based exact (QPBE) and quantum-based combined exact (QBCE) pattern matching algorithms"
        },
        {
            "text": "There are varieties of solutions proposed for the first time on quantum multiple pattern matching. However, the design of such algorithms is based on the execution of search oracle in successive iterations. So for different pattern sizes, it is iteratively called for finding all t occurrence of each pattern P k . Due to this direct possible design, Table 3 shows that a multiplicative factor (m) is included in the complexities of algorithms (Soni & Malviya, 2021) . The authors categorized multiple patterns matching methods as exact and approximate with quantum memory processing based design. Search complexity of suggested QEMP algorithm to find t occurrence of each P k ranges between",
            "cite_spans": [
                {
                    "start": 444,
                    "end": 466,
                    "text": "(Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [
                {
                    "start": 351,
                    "end": 358,
                    "text": "Table 3",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "QMEM processing based exact (QPBE) and quantum-based combined exact (QBCE) pattern matching algorithms"
        },
        {
            "text": "In contrast, the QAMP method uses approximate filtering in O m tlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 time to find t filtered indices for each P k . Further, the iterative search time for each P k to search all t 0 occurrences of reduced text of size t, ranges between O m ffiffiffiffi ffi tt 0 p log 2 N \u00c0 \u00c1 \u00c0 \u00c1 and O m tlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 . Both these methods are not increasing storage complexity because of iterative executions; and reasonably, the multiplicative factor m is included. Still, there exist high qubits requirement in the QAMP algorithm (see Table 3 ). The time of quantum memory O Nlog 2 N \u00c0 \u00c1 is considered explicitly due to no such physical availability. These algorithms were suggested to process biological sequences. For the detailed design and analysis of these methods, refer to Soni & Malviya (2021) . ",
            "cite_spans": [
                {
                    "start": 780,
                    "end": 801,
                    "text": "Soni & Malviya (2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [
                {
                    "start": 535,
                    "end": 542,
                    "text": "Table 3",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "QMEM processing based exact (QPBE) and quantum-based combined exact (QBCE) pattern matching algorithms"
        },
        {
            "text": "Quantum operational framework used in the algorithmic design Quantum algorithms based on superposition can perform exponential operations in parallel. The quantum behavior realizes qubit presence as j0i and j1i at same time. A jwi is a column vector, represents superposition, and hwj is a row vector; usually, Bra-Ket notation wjw h i is inner product. An n qubits quantum register jq i i q i 2 0; 1 f g n \u00f0 \u00despans the tensor product of 2 n dimension as Hilbert space. So, the computational basis is formed as w n j i \u00bc a 0 0 j i\u00fe . . . \u00fea i i j i\u00fe . . . \u00fea 2 n \u00c01 2 n \u00c01 j i to realize superposition under n dimensional vector space with complex probability amplitudes. Quantum registers can entangle with each other. A measurement collapses superposition into classical states jii between j0i to j2 n \u00c0 1i with probability a i j j 2 such that P i2 0;1 f g 2 a i j j 2 \u00bc 1. To visualize such n qubits superposition with the required dimensions, refer to these article for the Bloch sphere model (Choo, 2006; Lanzogorta & Uhlmann, 2008; Nielsen & Chuang, 2010; Coles, 2020; .",
            "cite_spans": [
                {
                    "start": 997,
                    "end": 1009,
                    "text": "(Choo, 2006;",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1010,
                    "end": 1037,
                    "text": "Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 1038,
                    "end": 1061,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 1062,
                    "end": 1074,
                    "text": "Coles, 2020;",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "QUANTUM ALGORITHMIC FRAMEWORK"
        },
        {
            "text": "Qubits remain in a pure state (vectors), but a quantum gate operator transforms n qubits into 2 n \u00c2 2 n sized mixed state (density matrix). The outer product of vectors is obtained as jwihwj because quantum unitary gate U applies certain operations within superposition to transform the quantum state. A U y is a conjugate transpose of U that performs the reverse quantum operation, such that UU y \u00bc I holds. Quantum logic operations such as [H] creates superposition, Pauli matrices X; Y; Z \u00bd obtains any rotation on Bloch sphere, R x h \u00f0 \u00de; R y h \u00f0 \u00de; R z h \u00f0 \u00de \u00c2 \u00c3 applies rotation with angle h as unitary operation. Some required controlled operations are C n NOT or C n X \u00bd which flips the target qubit and C n Z \u00bd flips the phase of target, when n control qubits are set to 1. The unitary operators encode to perform specific operations under quantum superposition. Refer to Table B1 (Appendix B) for symbols and used unitary operators throughout this article, and for more comprehensive understanding of quantum operations, refer to the following articles (Lanzogorta & Uhlmann, 2008; Nielsen & Chuang, 2010; Coles, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 1063,
                    "end": 1091,
                    "text": "(Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 1092,
                    "end": 1115,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 1116,
                    "end": 1128,
                    "text": "Coles, 2020;",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1129,
                    "end": 1149,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1150,
                    "end": 1171,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [
                {
                    "start": 881,
                    "end": 889,
                    "text": "Table B1",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "QUANTUM ALGORITHMIC FRAMEWORK"
        },
        {
            "text": "Our analysis framework for the quantum algorithm is oriented toward quantum-based proof methods. So, we categorized the proofs with their specialized point of interest with their additive use in the quantum algorithmic analysis. We provide the precise description of them as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Methodology and framework used for quantum algorithm analysis"
        },
        {
            "text": "Quantum Complexity Proof: The proposed algorithms are justified by using the following complexities analysis. Query complexity shows the number of superposition based oracle calls. Time complexity states the processing time of quantum gates involved in quantum circuits with logarithmic factors. Circuit complexity defines the composition of the quantum circuit with depth. Storage complexity estimates required qubits with ancilla. Quantum Probabilistic Proof: The proposed algorithms are also proved based on computational theory to identify the quantum complexity class as either the exact quantum polynomial (EQP) with Pr \u00bc 1 or bounded error quantum polynomial (BQP) complexity with Pr = \u2208. The probabilistic proof is used to identify results based on probabilities to be used later in lemmas and theorems. Quantum Truthness Proof: We prove the algorithms mathematically using Lemma proofs to derive primarily partial results, and then used Theorem proofs to justify the computational complexities result based on rigorous logic and reasoning. Quantum Correctness Proof: We proved the proposed algorithms for their correctness on the basis of quantum algorithmic trace steps which expands quantum operations applied under superposition to show quantum state transformations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Methodology and framework used for quantum algorithm analysis"
        },
        {
            "text": "(The above-mentioned proofs are categorized on the basis of the following references Lanzogorta & Uhlmann, 2008; Nielsen & Chuang, 2010; Faro & Lecroq, 2013; Zhou et al., 2015; Broda, 2016; Giri & Korepin, 2017; Grassi, Plasencia & Schrottenloher, 2018; Coles, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 85,
                    "end": 112,
                    "text": "Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 113,
                    "end": 136,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 137,
                    "end": 157,
                    "text": "Faro & Lecroq, 2013;",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 158,
                    "end": 176,
                    "text": "Zhou et al., 2015;",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 177,
                    "end": 189,
                    "text": "Broda, 2016;",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 190,
                    "end": 211,
                    "text": "Giri & Korepin, 2017;",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 212,
                    "end": 253,
                    "text": "Grassi, Plasencia & Schrottenloher, 2018;",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 254,
                    "end": 266,
                    "text": "Coles, 2020;",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 267,
                    "end": 287,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 288,
                    "end": 309,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Methodology and framework used for quantum algorithm analysis"
        },
        {
            "text": "We generalized a framework for the ordered design of algorithms with (1) processing advantage of quantum memory; (2) proposed efficient quantum exact match (QEM) circuit; and (3) Grover's search to generate high probable results. The remarks of framework are specified in Table 4 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 272,
                    "end": 279,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "Quantum effective processing framework for algorithm design"
        },
        {
            "text": "First, for the compatibility of QPU based computation, both text and pattern are required to encode as quantum data. This facilitates the processing of large biological sequences under quantum superposition. So, QMEM of size jT 2 n \u00c2w i QMEM is used to realize superposition with N \u00bc 2 n memory words each with size w qubits. The QMEM needs address register jT i i QA of size log 2 N \u00bc n qubits to refer all text indices jT i i QA in superposition, and data corresponding to entangled addresses is accessed by data register jT i \u00bd i QD of size log 2 AE j j \u00bc w qubits (Giovannetti, Lloyd & Maccone, 2008; Nielsen & Chuang, 2010; Metodi, 2011; Lin et al., 2013; Fu et al., 2016; Britt, 2017) .",
            "cite_spans": [
                {
                    "start": 568,
                    "end": 604,
                    "text": "(Giovannetti, Lloyd & Maccone, 2008;",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 605,
                    "end": 628,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 629,
                    "end": 642,
                    "text": "Metodi, 2011;",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 643,
                    "end": 660,
                    "text": "Lin et al., 2013;",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 661,
                    "end": 677,
                    "text": "Fu et al., 2016;",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 678,
                    "end": 690,
                    "text": "Britt, 2017)",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Processing advantage of quantum memory (QMEM)"
        },
        {
            "text": "The design of QMEM is realized using bucket brigade architecture that enables data access in O log 2 N \u00c0 \u00c1 steps, as among O N \u00bc 2 n \u00f0 \u00dequtrit, O log 2 2 n \u00c0 \u00c1 quantum switch remains active. This design is effective, as classical memory (CRAM) needs all O N \u00bc 2 n \u00f0 \u00deswitches active for word access. So, QMEM gains exponential speedup as 2 n =log 2 2 n \u00c0 \u00c1 over ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Processing advantage of quantum memory (QMEM)"
        },
        {
            "text": "A text is shared on memory, and each c th core QCore c can access it in owned superposition. A QPU with C cores uses their registers set, and such parallelism minimizes processing time as negligible. Figure 2 shows the architecture of QPU with C cores working on shared QMEM with the design of the quantum memory circuit. A QMEM is realized using U QMEM of Eq. (1) in support of Eqs.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 200,
                    "end": 208,
                    "text": "Figure 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Processing advantage of quantum memory (QMEM)"
        },
        {
            "text": "(2)-(4) (Giovannetti, Lloyd & Maccone, 2008; Nielsen & Chuang, 2010; Metodi, 2011; Lin et al., 2013; Fu et al., 2016; Britt, 2017; Brandl, 2017; Park & Petruccione, 2019; Matteo, 2020; .",
            "cite_spans": [
                {
                    "start": 8,
                    "end": 44,
                    "text": "(Giovannetti, Lloyd & Maccone, 2008;",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 45,
                    "end": 68,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 69,
                    "end": 82,
                    "text": "Metodi, 2011;",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 83,
                    "end": 100,
                    "text": "Lin et al., 2013;",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 101,
                    "end": 117,
                    "text": "Fu et al., 2016;",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 118,
                    "end": 130,
                    "text": "Britt, 2017;",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 131,
                    "end": 144,
                    "text": "Brandl, 2017;",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 145,
                    "end": 170,
                    "text": "Park & Petruccione, 2019;",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 171,
                    "end": 184,
                    "text": "Matteo, 2020;",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "Processing advantage of quantum memory (QMEM)"
        },
        {
            "text": "A unitary U QMEM makes the data available in parallel for each jT i i QA index. It prepares the jqutrits N\u00c01 i switches in jwait N\u00c01 i state and realizes the superposition of entire memory. As per target index jT i i QA , the qutrit are transformed from jwaiti to jlefti or jrighti state using U Swap of Eq. (2) under fiduciary qubit jf i that fixes switch state. Among jqutrits N\u00c01 i only the jqutrits log 2 N i remains active during the memory call [14] . We perform the data loading using U Load of Eq. (3). It activates bus qubits to trace a path of active qutrit switches, copies the cell data, and traces back over same qutrit to load copied data into jT i \u00bd i QD , and meanwhile, qutrit are transformed to jwaiti state by reverse unitary U y Swap of Eq. (4) (Giovannetti, Lloyd & Maccone, 2008; Nielsen & Chuang, 2010) . A QMEM needs O log 2 N \u00c0 \u00c1 steps; and a memory call enables the bus qubits equal to the word size to access data in parallel, so for w \u00bc M \u00c2 log 2 AE j j qubits, the log 2 N switch remains active until the word transfer is not completed. Therefore, with word transfer, the QMEM needs O M \u00c2 log 2 N \u00c0 \u00c1 steps with the negligible factor M (Nielsen & Chuang, 2010; Soni & Rasool, 2021; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 451,
                    "end": 455,
                    "text": "[14]",
                    "ref_id": null
                },
                {
                    "start": 765,
                    "end": 801,
                    "text": "(Giovannetti, Lloyd & Maccone, 2008;",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 802,
                    "end": 825,
                    "text": "Nielsen & Chuang, 2010)",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 1165,
                    "end": 1189,
                    "text": "(Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 1190,
                    "end": 1210,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1211,
                    "end": 1232,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Processing advantage of quantum memory (QMEM)"
        },
        {
            "text": "Second, we propose quantum-exact match (QEM) circuit through unitary U Comp to perform parallel match between pattern jP 0 to M\u00c01 \u00bd i DR and retrieved substring in register jT w \u00bd i QD of size w \u00bc M \u00c2 log 2 AE j j qubits. We seek an exact match on behalf of each index jT i i QA in superposition on QMEM. This circuit compares the qubits of size log 2 AE j j for each symbol contained in jPi DR . So, for M length pattern, all log 2 AE j j sized qubits are analyzed in O 1 \u00f0 \u00de time. We specified the QEM operation in Eq. (5), and relevant circuit is shown in Fig. 3 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 559,
                    "end": 565,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Proposed efficient quantum exact match (QEM) circuit"
        },
        {
            "text": "The comparison between jP 0 to M\u00c01 \u00bd i DR and jT \u00bdi to i\u00feM\u00c01 i QD is performed by unitary U Comp in an explored superposition of QMEM with text indices jT i i QA . So, entire w \u00bc M \u00c2 log 2 AE j j qubits sized substring is compared in parallel with constant time. This circuit is designed with 3 \u00c2 M \u00c2 log 2 AE j j \u00bc C 2 NOT gates which are arranged at level zero (for M sized text substring and pattern, and M additional ancilla). At level one, we used M \u00bc C log 2 AE j j\u00fe1 NOT gates to check for equality as either 0 j i \u00bc\u00bc 0 j i or 1 j i \u00bc\u00bc 1 j i between aligned qubits of size log 2 AE j j for each character of P. Last level is designed with single C M\u00fe1 NOT gate that flips a target qubit jq Comp i to indicate the quantum-based ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QEM Operation"
        },
        {
            "text": "Third, Grover's method is optimal to search for pattern in O ffiffiffiffi N p \u00c0 \u00c1 steps over N size text. It uses amplitude amplification that repeats for p=4 ffiffiffiffi N p times, each iteration applies reflection operations for transforming target index to high amplified amplitude under superposition state, and thus to obtain high probable search results (Nielsen & Chuang, 2010; Chakrabarty, Khan & Singh, 2017) . So, O ffiffiffiffi N p \u00c0 \u00c1 steps assure to eventually result in the desired state with significantly large amplitude. A method is shown in Fig. 4 and it's next to next figure. No more iterations than ffiffiffiffi N p is recommended, as this succeeds with a solution on the sine function principle. It gradually increases as per the increase in function argument, but later this starts decreasing. However, this search mechanism is the only way to achieve a quadratic speedup (Lanzogorta & Uhlmann, 2008; Zhou et al., 2013; Coles, 2020) .",
            "cite_spans": [
                {
                    "start": 361,
                    "end": 385,
                    "text": "(Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 386,
                    "end": 418,
                    "text": "Chakrabarty, Khan & Singh, 2017)",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 896,
                    "end": 924,
                    "text": "(Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 925,
                    "end": 943,
                    "text": "Zhou et al., 2013;",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 944,
                    "end": 956,
                    "text": "Coles, 2020)",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 560,
                    "end": 566,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "The GSO operation is defined as Eq. (6) with sub-unitary specified in Eqs. (7) and (8).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "\u00c1 marks the target index location of the pattern when U Comp of Eq. (5) is succeeded for the exact match through Boolean oracle. Further, phase inversion is applied by phase oracle using U Mark jT i i QA jqi of Eq. (7) to reflect the target index amplitude as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": ", inverts all amplitudes around the mean, such that the amplitude of solution increases and the others decrease. In actual, this method amplifies the search index amplitude in each iteration (Lanzogorta & Uhlmann, 2008; Zhou et al., 2013; Broda, 2016; Giri & Korepin, 2017; Figgatt et al., 2017; Coles, 2020) . The GSO operational description is provided in correctness proof of proposed algorithms. GSO Opeartion",
            "cite_spans": [
                {
                    "start": 191,
                    "end": 219,
                    "text": "(Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 220,
                    "end": 238,
                    "text": "Zhou et al., 2013;",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 239,
                    "end": 251,
                    "text": "Broda, 2016;",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 252,
                    "end": 273,
                    "text": "Giri & Korepin, 2017;",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 274,
                    "end": 295,
                    "text": "Figgatt et al., 2017;",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 296,
                    "end": 308,
                    "text": "Coles, 2020)",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "A GSO works under superposition state jw n i by making an angle p=2 \u00c0 h \u00f0 \u00deand transforms the solution state by applying each time 2h rotations. So, for r rotations,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "For geometric proof, refer (Nielsen & Chuang, 2010; Broda, 2016; Chakrabarty, Khan & Singh, 2017; Coles, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 27,
                    "end": 51,
                    "text": "(Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 52,
                    "end": 64,
                    "text": "Broda, 2016;",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 65,
                    "end": 97,
                    "text": "Chakrabarty, Khan & Singh, 2017;",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 98,
                    "end": 110,
                    "text": "Coles, 2020;",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 111,
                    "end": 131,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 132,
                    "end": 153,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "As reviewed, analysis of quantum effective processing framework is specified in with respect to negligible multiplicative factor log 2 N \u00c0 \u00c1 (Brassard et al., 2002; Lomont, 2003; Ablayev et al., 2020) . If it is known that the t \u00bc 0 (no solution), then GSO returns a random element uniformly in O ffiffiffiffi iterations are needed to obtain high probable search solution. We prefer the quantum search to find the few pattern occurrences. The consideration of t \u00bc N is found rare for a biological text, and hence this can be ignored (Nielsen & Chuang, 2010; Broda, 2016; Chakrabarty, Khan & Singh, 2017; Soni & Rasool, 2021; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 164,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 165,
                    "end": 178,
                    "text": "Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 179,
                    "end": 200,
                    "text": "Ablayev et al., 2020)",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 533,
                    "end": 557,
                    "text": "(Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 558,
                    "end": 570,
                    "text": "Broda, 2016;",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 571,
                    "end": 603,
                    "text": "Chakrabarty, Khan & Singh, 2017;",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 604,
                    "end": 624,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 625,
                    "end": 646,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "To our knowledge, the quantum search assumes that the number of search solutions t (either unique or multiple solution) are already known. Therefore, number of GSO iterations can be determined in advance and after p=4 ffiffiffiffiffiffiffiffi N=t p iterations the search results are found with certainty and high probability. However, the GSO can overshoot if the t number of search solutions are unknown/not known in advance. In that case, with the unknown number of GSO iterations, the probability of success would be vanishingly small (Boyer et al., 1998; Brassard et al., 2002; Lomont, 2003; Younes, 2008; Song, 2017; Ablayev et al., 2020) .",
            "cite_spans": [
                {
                    "start": 538,
                    "end": 558,
                    "text": "(Boyer et al., 1998;",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 559,
                    "end": 581,
                    "text": "Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 582,
                    "end": 595,
                    "text": "Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 596,
                    "end": 609,
                    "text": "Younes, 2008;",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 610,
                    "end": 621,
                    "text": "Song, 2017;",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 622,
                    "end": 643,
                    "text": "Ablayev et al., 2020)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "To deal with the unknown number of search solutions, one of the methods was proposed by Boyer et al. (1998) and restated in Younes (2008); Song (2017) and Ablayev et al. (2020) as the modified Grover's search that runs GSO several times in successive iterations. The modified algorithm of Boyer et al. (1998) repeats GSO by taking the value of t in an exponential increase. On j th repetition, p=4 ffiffiffiffiffiffiffiffiffiffi N=2 j p iterations are performed. The repetitions are here summing to O ffiffiffiffi N p \u00c0 \u00c1 times. Either of these iterations may find the search results with a sufficient high probability. In each of these repetition, the GSO operations are still bounded by p=4 ffiffiffiffi N p \u00c0 \u00c1 iterations. It is equivalent to O N \u00f0 \u00de time classical complexity, so not used in practical implementation (Boyer et al., 1998) .",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 107,
                    "text": "Boyer et al. (1998)",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 139,
                    "end": 150,
                    "text": "Song (2017)",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 155,
                    "end": 176,
                    "text": "Ablayev et al. (2020)",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 289,
                    "end": 308,
                    "text": "Boyer et al. (1998)",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 821,
                    "end": 841,
                    "text": "(Boyer et al., 1998)",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "Quantum counting (QC) is an alternative approach that can satisfactorily handle the problem of unknown number of search solutions (Brassard et al., 2002; Lomont, 2003; Song, 2017) . A QC is quantum amplitude estimation (QAE) method that can estimate t number of search solutions either based on approximation or based on exactness. It helps to decide the required number of GSO iterations. The QAE technique is defined in Brassard et al. (2002) and Fang Song (2017) , and it is used for estimating",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 153,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 154,
                    "end": 167,
                    "text": "Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 168,
                    "end": 179,
                    "text": "Song, 2017)",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 422,
                    "end": 444,
                    "text": "Brassard et al. (2002)",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 454,
                    "end": 465,
                    "text": "Song (2017)",
                    "ref_id": "BIBREF47"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "n o as the possible count to find the number of search solutions. These authors (Boyer et al., 1998; Brassard et al., 2002; Lomont, 2003) suggested to run quantum counting algorithm initially, and then to proceed with actual number of GSO iterations. Quantum counting results can be obtained with quadratic speedup in",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 100,
                    "text": "(Boyer et al., 1998;",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 101,
                    "end": 123,
                    "text": "Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 124,
                    "end": 137,
                    "text": "Lomont, 2003)",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "Therefore, we observed it as an efficient method when the number of search solutions are unknown, and hence it prevents overshooting of Grover's. Later, in theoretical results and complexity analysis section, we analyze the exact and approximate quantum counting methods, and these are implemented to simulate our algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "A circuit of QMEM needs C n\u00fe1 NOT to mark jT i i QA address, and to store",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "This memory is exponentially faster than the CRAM circuit. However, its access depends on the depth of the bifurcation tree i.e. O log 2 N \u00c0 \u00c1 time. Quantum search works with QMEM by applying H n jT i i QA and XH jqi \u00f0 \u00de and then U Comp checks for exact match followed by amplification. On a successful match, qubit jqi is flipped by C n\u00fe1 NOT gate, then U Mark flips the phase of index jT i i QA by C n Z gate. Diffusion performs the amplification through the set of quantum operators H n X n f g C n Z H n X n f g f g . At the last, perform measurement at index jT i i QA . In addition, we included qubits requirement for QMEM and GSO. Quantum gates and the circuit requirement of the framework is shown in Table 4 . However, our remark states that quantum search over text T of size N takes n \u00fe 2Mlog 2 AE j j \u00fe 1 qubits (Lanzogorta & Uhlmann, 2008; Nielsen & Chuang, 2010; Zhou et al., 2013; Broda, 2016; Chakrabarty, Khan & Singh, 2017; Giri & Korepin, 2017; Figgatt et al., 2017; Coles, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021) . Further, n is replaced by tq qubits for the search which is performed over the reduced size filtered text. A QMEM is efficiently simulated using algebraic normal form (ANF) for the hybrid realization of quantum operations (Bogdanova et al., 2018; Malviya & Tiwari, 2020; Hao et al., 2020; Malviya & Tiwari, 2021) .",
            "cite_spans": [
                {
                    "start": 824,
                    "end": 852,
                    "text": "(Lanzogorta & Uhlmann, 2008;",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 853,
                    "end": 876,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 877,
                    "end": 895,
                    "text": "Zhou et al., 2013;",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 896,
                    "end": 908,
                    "text": "Broda, 2016;",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 909,
                    "end": 941,
                    "text": "Chakrabarty, Khan & Singh, 2017;",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 942,
                    "end": 963,
                    "text": "Giri & Korepin, 2017;",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 964,
                    "end": 985,
                    "text": "Figgatt et al., 2017;",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 986,
                    "end": 998,
                    "text": "Coles, 2020;",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 999,
                    "end": 1019,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1020,
                    "end": 1041,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 1266,
                    "end": 1290,
                    "text": "(Bogdanova et al., 2018;",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1291,
                    "end": 1314,
                    "text": "Malviya & Tiwari, 2020;",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 1315,
                    "end": 1332,
                    "text": "Hao et al., 2020;",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 1333,
                    "end": 1356,
                    "text": "Malviya & Tiwari, 2021)",
                    "ref_id": "BIBREF33"
                }
            ],
            "ref_spans": [
                {
                    "start": 709,
                    "end": 716,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "Grover's search operator (GSO) to generate high probable results"
        },
        {
            "text": "This section includes proposed EnQPBEA & EnQBCEA algorithms. Both these designs use the effective quantum processing framework. Algorithms can process multiple patterns string of set P \u00bc P 1 ; :; P k ; :; P m f gwith each pattern P k of length M k 1 k m \u00f0 \u00de , using the shared text T of size N explored on QMEM to search all exact match occurrence of individual pattern P k 2 P through c th core QCore c of QPU having C quantum cores. Our algorithms are enhancement of improved QPBE & QBCE methods for processing multiple patterns with an aim to remove the multiplicative factor m in complexities. The proposed solutions are remarkable and efficient on comparing with existing QEMP & QAMP multiple pattern methods. We modify the design of algorithms by running multiple search oracles in parallel. A QPU runs C cores to search for m=C pattern in parallel, and each quantum core uses its own set of registers. So a multiplicative constant m=C \u00f0 \u00de with a small arbitrary constant value of m and constant value of C is found negligible. However, for comparatively large value of m ) C, a factor m=C cannot be ignored in the complexities analysis. Hence, we initially clarify that for few pattern occurrences, the storage and time both are implicitly saved in enhanced designs of algorithms. We justify our proposed methods by giving the proof of the resulting Theorems 1 and 2. Later, we show the efficient and effective hybrid simulation of these quantum algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "Proposed method 1: enhanced QMEM processing based exact algorithm for multiple pattern matching (EnQPBEA-MPM) This method searches for each pattern P k 2 P in parallel using QPU with C cores accessing text T on shared QMEM, such that search time of all t k occurrence of P k overlaps. QEM circuit is applied under superposition of text on QMEM by each QCore c . Search results are instantly possible and would be effective for the biological sequencing because of no other processing overhead except the search time. Existing QPBE is enhanced efficiently by executing search oracles in parallel with the negligible time factor, and the existing iterative pattern search overhead of QEMP is also removed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "A pattern P k 2 P is individually processed on c th core QCore c where 1 c C \u00f0 \u00de , so m=C patterns are searching in parallel within the text T of size N shared on QMEM. Each pattern P k is assumed with individual size w \u00bc M k \u00c3 log 2 AE j j qubits, and it is stored in jP 0 to M k \u00c01 \u00bd i DRk as in separate data register. The text T realized on jT 2 n \u00c2w i QMEM is accessed in a superposition of addresses by QCore c through address register jT i i QAk i 2 0; 1 f g n \u00f0 \u00de . All the text substrings, each of length M k \u00c3 log 2 AE j j are loaded in entangled register jT w \u00bd i QDk by applying QMEM transformation. A unitary U Load makes sure such data load in a coherent superposition of text addresses. Once these substrings are available in parallel, EnQPBEA applies the GSO operator, separately on QCore c to ensure an exact match of each P k with QEM circuit realized using U kComp . The Boolean oracle circuit succeeds by flipping target qubit of Fig. 3 to report exactness. When c th core QCore c identifies exact match in superposition, the amplification operator U Diff U Mark \u00f0 \u00deis then applied to increase the probability amplitude of identified indices jT i i QAk . The GSO operator repeats for O ffiffiffiffi N p \u00c0 \u00c1 time and then QCore c applies the measurement to obtain search index jT i i QAk with high probability.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 950,
                    "end": 956,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "The quantum state gets collapsed after each measurement, so its repetition ensures to report all t k index locations of P k 2 P which are identified by c th quantum core QCore c . Each pattern occurrence is verified by same core as jT \u00bdi to i\u00feM k \u00c01 i QDk \u00bc\u00bc jP 0 to M k \u00c01 \u00bd i DRk . The pattern matching method of EnQPBEA-MPM is illustrated in Fig. 4 . However, the steps are listed in the proposed algorithm, and the equivalent quantum circuit executing search oracles in parallel is shown in Fig. 5 . In reference to Table 4 discussion, we state, that each core realizes O ffiffiffiffiffiffiffiffiffi ffi N=t k p iterations of GSO in parallel, and therefore, results in all desired pattern occurrence t k on behalf of pattern P k . However, we require Proposed Algorithm 1: EnQPBEA-MPM.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 345,
                    "end": 351,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 495,
                    "end": 501,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 520,
                    "end": 527,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "Data : Text T stored on jT 2 n \u00c2w i QMEM which is accessed by quantum registers jT n i QA1 ; . . . ; jT n i QAm",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "j j to store search pattern P k 2 P \u00bc P 1 ; :; P k ; :; P m f g , and set of ancillary qubit designated to number of patterns jqi Q1 ; . . . ; jqi Qm n o",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "Result : Outputs all t k exact occurrence 1 t k N \u00f0 \u00deof each pattern P k 2 P in parallel using c th quantum core QCore c accessing T on shared QMEM, as index",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "Prepare registers as jzeroes n i in jT n i QAk ,jzeroes w \u00bd i in jT w \u00bd i QDk , j1i in jqi Qk and jP 0 to M k \u00c01 \u00bd i DRk",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THE PROPOSED METHODS"
        },
        {
            "text": "For each pattern P k 2 P to be processed separately on c th quantum core QCore c",
            "cite_spans": [],
            "ref_spans": [],
            "section": "3:"
        },
        {
            "text": "Initialize quantum state in registers as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4:"
        },
        {
            "text": "For all jT i i QAk in their separate uniform quantum superposition state jw n i k",
            "cite_spans": [],
            "ref_spans": [],
            "section": "5:"
        },
        {
            "text": "Load data at jT i \u00bd i QDk as per entangled jT i i QAk by applying QMEM Transformation as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "6:"
        },
        {
            "text": "Repeat GSO for O \u00c0 ffiffiffiffiffiffiffiffiffi ffi N=t k p \u00c1 times in uniform superposition jw n i k , with QEM Operation which is implicitly applied through U kComp for exact matching of M k \u00c2 log 2 AE j j qubits size as -",
            "cite_spans": [],
            "ref_spans": [],
            "section": "8:"
        },
        {
            "text": ":",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9"
        },
        {
            "text": "End of GSO Repeat",
            "cite_spans": [],
            "ref_spans": [],
            "section": "10:"
        },
        {
            "text": "Measure the final state to get the desired index jT i i QAk as high probable solution",
            "cite_spans": [],
            "ref_spans": [],
            "section": "11:"
        },
        {
            "text": "Verify pattern P k at jT i i QAk on c th core QCore c as jT \u00bdi to i\u00feM k \u00c01 i QDk \u00bc\u00bc jP 0 to M k \u00c01 \u00bd i DRk",
            "cite_spans": [],
            "ref_spans": [],
            "section": "12:"
        },
        {
            "text": "End of Inner For",
            "cite_spans": [],
            "ref_spans": [],
            "section": "13:"
        },
        {
            "text": "End of Outer For",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "\u00dequeries to report all t k marked occurrences, and hence the pattern matching time is bounded to O ffiffiffiffiffiffiffi Nt k p log 2 N \u00c0 \u00c1 with negligible logarithmic factor. We clarify that EnQPBEA repeats GSO operation in parallel for t k times on each core QCore c to search all t k indexes. So, we consider t \u00bc t k \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00deas based on longest core processing to find maximum pattern occurrences. Therefore, the search complexity of parallel executions of EnQPBEA using QPU with C cores is O m=C",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "In support of complexities, a correctness proof of EnQPBEA-MPM with quantum operations is specified in Appendix C. For mathematical proof, we define certain Lemma 1 as partial required proof, and based on that, we conclude the computational complexity and achieved speedup through the resulting proof of Theorem 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Lemma 1: A QPU having C quantum cores 1 c C \u00f0 \u00decan access the text T of size N on shared QMEM. It loads all text substring equal to pattern length P k as M k \u00c3 log 2 AE j j qubits in superposition by using QCore c in parallel. Time needed for such parallel loading operations ranges between O m=C",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Proof (Lemma 1): About earlier discussions of effective processing framework and Table 4 , we use to prove this lemma. The jT 2 n \u00c2w i QMEM as shared among C cores of QPU, makes sure that all jT i i QAk addresses are available in parallel on each QCore c & QMEM transformation loads M k \u00c3 log 2 AE j j qubits in entangled register jT w \u00bd i QDk . The entire memory access is available in constant time on each individual core, however, by considering M as M \u00bc max M 1 ; :; M k ; :; M m \u00f0 \u00de the memory circuit needs O Mlog 2 N \u00c0 \u00c1 steps. So, the parallel time of QMEM access using QPU with C quantum cores is O m=C \u00f0 \u00de Mlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 . As we know, that the quantum state is collapsed after each measurement, so to report all t k index of P k identified by c th quantum coreQCore c , we need this access several times. By assuming t \u00bc t k \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00deat any QCore c for QMEM transformation, and at worst, if number of identified patterns are t \u00bc N then each time, all parallel substring load will take O m=C \u00f0 \u00de MNlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 time. We discussed earlier, that both these factors M and m=C \u00f0 \u00de are negligible due to parallel load and parallel processing by achieving exponential speedup.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 81,
                    "end": 88,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "14:"
        },
        {
            "text": "Theorem 1: Given text database T of size N and the multiple patterns set P \u00bc P 1 ; :; P k ; :; P m f gwith each pattern P k of length M k 1 k m \u00f0 \u00de . Algorithm EnQPBEA-MPM uses QPU having C quantum cores 1 c C \u00f0 \u00deto access the text T on shared QMEM. A c th core is used to search for the all t k exact occurrence of a pattern P k indexed at jT i i QAk , that is jT \u00bdi to i\u00feM k \u00c01 i QDk \u00bc\u00bc jP 0 to M k \u00c01 \u00bd i DRk . Based on longest core processing to find pattern occurrences t \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00de , the search time complexity",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "for the worst case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Proof (Theorem 1): This proof relies on Lemma 1 and other statements which are justified earlier. Proof of Lemma 1 states that, for t \u00bc 1 or t few (t few denotes few pattern occurrences (t few ( N)) and t \u00bc N, all substring load transformation is possible in O log 2 N \u00c0 \u00c1 and O Nlog 2 N \u00c0 \u00c1 time. Now EnQPBEA-MPM algorithm realizes such parallelism using QPU with C quantum cores and each core access text T on shared QMEM. For each pattern P k 2 P of length M k 1 k m \u00f0 \u00de , this algorithm identifies the target indices based on the QEM circuit under superposition of N sized text. Further, the simultaneous iterations of GSO finds all t k solutions of P k using c th quantum core",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Indeed, quantum state is collapsed while measured, so, EnQPBEA repeats GSO followed by measurement on QCore c to report all t k occurrence of",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "\u00dequeries. Now, based on longest core processing, consider t \u00bc t k \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00de . So, using QPU with C cores and for t \u00bc 1 or t few (t few denotes few pattern occurrences (t few ( N)), the best case time complexity of EnQPBEA-MPM is O m=C \u00f0 \u00de ffiffiffiffiffi Nt p log 2 N \u00c0 \u00c1 \u00c0 \u00c1 and this finds all patterns in parallel. However, when t \u00bc N (all are search solutions), the worstcase time complexity is O m=C \u00f0 \u00de Nlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 . A multiplicative factor log 2 N \u00c0 \u00c1 is considered negligible with n qubits, surprisingly small, to expand the original search space. However, this factor cannot be ignored when the number of qubits n is usually large to expand the original text space (Lomont, 2003) . And the multiplicative constant m=C \u00f0 \u00dewith a small arbitrary constant value of m and constant value of C is found negligible. However, for the comparatively large value of m ) C, a factor m=C cannot be ignored in time complexities. Therefore, quantum search is preferred effectively for finding few occurrences. Instead, for biological text, t \u00bc N is rare and hence ignored while stating the generalized complexity. We know that algorithm design is based on GSO, so, results are obtained with at least probability as Pr EnQPBEA running at QCore c measures jT i i QAk h in each iteration ! t k =N.",
            "cite_spans": [
                {
                    "start": 700,
                    "end": 714,
                    "text": "(Lomont, 2003)",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Proposed method 2: enhanced quantum-based combined exact algorithm for multiple pattern matching EnQBCEA-MPM",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "The algorithm EnQBCEA-MPM is an enhanced version of the existing benchmark method QBCE. So, we formalize this multiple pattern algorithm with the possible speedup. The pattern matching method is illustrated in Fig. 6 . Each pattern P k 2 P is individually processed using QPU with C cores; however, the c th core QCore c 1 c C \u00f0 \u00deprocesses the text T of size N over shared QMEM for m=C \u00f0 \u00depatterns either for filtering or searching. In this method, each core QCore c transforms the original N sized text into reduced search space t k (corresponding to P k ), so-called filtered indices, and then performs exact searching of all t k 0 occurrence of each P k in overlapping of time evolution. To transform the text into reduced search space, we use an existing method of quantum-approximate filtering (QAF). This method is based on the hamming distance (HD) to check for the possible errors between pattern and text substring (to filter index) and ensures its correctness when the hamming distance HD \u00f0 \u00de threshold (pre-computed). Such filtering outcomes are based on approximations, thus, we verify the filtered indices for a pattern match using the exactness. An additional time of QAF filtering is included in the complexity of this algorithm; however, this allows searching of patterns in an optimized way by achieving speedup. Our EnQBCEA design executes exact search oracles in parallel with the negligible time factor, and this also removes the existing iterative overhead (text filtering and pattern searching) of the QAMP algorithm. We expect the pattern matching results as effective for the biological sequencing because of overlapped quick search time to find the exact matches over the filtered text indices.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 210,
                    "end": 216,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "14:"
        },
        {
            "text": "Initially, we redefine QAF (Aborot, 2017) to execute for each QCore c while accessing text T on shared QMEM for text filtering. The procedure QAF is redesigned here by using QMEM transformation. This prepares the pattern in register jPi DR and the start locations of distinct symbols of the pattern are store in array SL M \u00bd . Now, initializes QMEM registers jT n i QA and jT w \u00bd i QD in the zero state along with auxiliary register jT n\u00fe1 i AX measured for the filtered index as possible start locations of the pattern. The superposition of text created in jT i i QA and jT n\u00fe1 i AX is made entangled with addresses. Under memory superposition of jT i i QA , QAF marks the distinct symbols of the pattern at jT i j i AX by unitary U SLoc . And then, the possible start location of the patterns are marked as jT i \u00c0 T i j i AX by U PLoc . A Hamming distance (HD) is applied at jT i \u00c0 T i j i AX to check for threshold, further, Hadamard is applied at jT i i QA to merge probability amplitudes of entangled indices of jT i \u00c0 T i j i AX . Finally, measure auxiliary register jT i \u00c0 T i j i AX to identify filtered indices jT i i which are then stored in the referenced location array LA . . . \u00bd . As measurement destroys quantum state, so in each call at c th quantum core QCore c on behalf of P k 2 P, the QAF needs its execution several times to filter all t k indices location and then to store within the location array LA k t k \u00bd . Algorithm EnQBCEA-MPM needs following preparation such aseach pattern P k 2 P is assumed with individual size w \u00bc M k \u00c3 log 2 AE j j qubits, and it is stored in jP 0 to M k \u00c01 \u00bd i DRk as in separate data register. At first, procedure QAF jT n i QAk ; jP k i DRk ; LA k is called for each pattern P k on each core to store the filtering results at individual location array LA k t k \u00bd . Each LA k . . . \u00bd contained with t k N filtered text indices; therefore, the algorithm needs location register jT tq i QLk each of size log 2 t k \u00bc tq qubits to access LA k t k \u00bd by using c th core QCore c . Procedure: QAF jT n i QA ; jPi DR ; LA . . . \u00bd .",
            "cite_spans": [
                {
                    "start": 27,
                    "end": 41,
                    "text": "(Aborot, 2017)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Input : Text address register jT n i QA , auxiliary register of same size with additional qubit jT n\u00fe1 i AX , the implicit data register jP 0 to M\u00c01 \u00bd i DR , SL M \u00bd classical array that keeps distinct symbol location within pattern as ji j i, access to location array LA . . . \u00bd to classically store filtered text indices.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Output : Stores all filtered text indices as possible start of pattern in location array LA . . . ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "For each jT i i QA remains in uniform quantum superposition state jw n i do",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14:"
        },
        {
            "text": "Mark distinct symbol of pattern by unitary U SLoc as jT ij i AX corresponding to jT i i QA",
            "cite_spans": [],
            "ref_spans": [],
            "section": "8:"
        },
        {
            "text": "Mark possible start location of pattern by U PLoc as jT i \u00c0 T ij i AX on behalf of jT i i QA",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9:"
        },
        {
            "text": "Apply HD at jT i \u00c0 T ij i AX to check for distance between text and pattern, such that, HD threshold",
            "cite_spans": [],
            "ref_spans": [],
            "section": "10:"
        },
        {
            "text": "Apply Hadamard at jT i i QA to merge amplitudes of entangled indices of jT i \u00c0 T ij i AX",
            "cite_spans": [],
            "ref_spans": [],
            "section": "11:"
        },
        {
            "text": "Measure the auxiliary register jT i \u00c0 T ij i AX and store the identified index as jT i i in LA . . . \u00bd",
            "cite_spans": [],
            "ref_spans": [],
            "section": "12:"
        },
        {
            "text": "The algorithm EnQBCEA proceeds to search for each pattern by running all cores in parallel. An equivalent quantum circuit executing search oracles in parallel is shown in Fig. 7 . So, each core QCore c explores filtered indices of LA k t k \u00bd in superposition over QMEM. We expect that the reduced search space of size t k ( N is small than that of original text T of size N. Algorithm prepares registers in jzeroi states, and initializes superposition of filtered indices for each LA k t k \u00bd as jw tq i k by using jT i i QLk i 2 0; 1 f g tq \u00c0 \u00c1 of QCore c . Now, for each jT i i QLk under the quantum superposition jw tq i k we apply U kGetL to obtain n \u00c0 qubits original filtered index as jT i \u00bd i QLk \u00bc iLk i.e. i \u00bd th memory content of Result : Outputs all t k 0 exact occurrence 1 t k 0 t k \u00f0 \u00deof each pattern P k 2 P in parallel, using c th quantum core QCore c accessing filtered location array LA k t k \u00bd which is explored on QMEM, as searched index jT iLk i QAk s.t. jT \u00bdiLk to iLk \u00fe M k \u00c01 i QDk \u00bc\u00bc jP 0 to Mk\u00c01 \u00bd i DRk 1: Procedure EnQBCEA-MPM 2:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 171,
                    "end": 177,
                    "text": "Fig. 7",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "14: End Procedure"
        },
        {
            "text": "For each pattern P k 2 P to be processed separately on c th quantum core QCore c",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14: End Procedure"
        },
        {
            "text": "Call QAF jT n i QAk ; jP k i DRk ; LA k ;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "3:"
        },
        {
            "text": "End of For",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4:"
        },
        {
            "text": "Prepare registers as jzeroes tq i in jT tq i QLk , jzeroes n i in jT n i QAk , jzeroes w \u00bd i in jT w \u00bd i QDk , j1i in jqi Qk and jP 0 to M k \u00c01 \u00bd i DRk",
            "cite_spans": [],
            "ref_spans": [],
            "section": "5:"
        },
        {
            "text": "For each pattern P k 2 P to be processed separately on c th quantum core QCore c",
            "cite_spans": [],
            "ref_spans": [],
            "section": "6:"
        },
        {
            "text": "Initialize quantum state for accessing LA k t k \u00bd in register as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "7:"
        },
        {
            "text": "For all jT i i QLk in their separate uniform quantum superposition state jw tq i k",
            "cite_spans": [],
            "ref_spans": [],
            "section": "8:"
        },
        {
            "text": "Apply the unitary U kGetL to get n-qubits actual index as jT i \u00bd i QLk \u00bc iLk i.e. the memory content of LA k t k \u00bd through jT i i QLk , and then store k th address in corresponding register jT iLk i QAk 10:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9:"
        },
        {
            "text": "Load data at jT \u00bdiLk i QDk as per addresses jT iLk i QAk by applying QMEM Transformation as 12:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "11:"
        },
        {
            "text": "Repeat GSO for O ffiffiffiffiffiffiffiffiffiffi t k =t k 0 p times in uniform superposition jw tq i k , with QEM Operation which is implicitly applied through U kComp for exact matching of M k \u00c2 log 2 AE j j qubits size as -",
            "cite_spans": [],
            "ref_spans": [],
            "section": "13:"
        },
        {
            "text": ": LA k t k \u00bd through jT i i QLk . This transformation helps address register jT iLk i QAk to access actual indices, so the search can perform over original text. Now, the original text is available in QMEM superposition and shared among all quantum cores. Therefore, text T realized on jT 2 n \u00c2w i QMEM is accessed in a superposition of addresses by QCore c by address register jT iLk i QAk iLk 2 0; 1 f g n \u00f0 \u00de . All the text substrings, each of length M k \u00c3 log 2 AE j j are loaded in entangled register jT \u00bdiLk i QDk by applying QMEM transformation. A unitary U Load makes sure such loading is in a coherent superposition of text addresses. Once substrings are available in parallel, EnQBCEA applies GSO, by QCore c to find an exact match of each P k with QEM circuit realized using the unitary operator U kComp .The processing of GSO is the same as per earlier discussion of EnQPBEA and Table 4 . Instead, each core realizes O ffiffiffiffiffiffiffiffiffiffi t k =t k 0 p iterations of GSO in parallel, however, after O ffiffiffi ffi t k p \u00f0 \u00de repetition QCore c applies measurement to obtain index jT iLk i QAk with high probability. As measurement collapses quantum state, so, each QCore c requires O ffiffiffiffiffiffiffi ffi t k t k 0 p \u00f0 \u00dequeries to report all t k 0 t k marked occurrences of P k in T. In addition, EnQBCEA-MPM allows c th core QCore c to verify pattern match at jT iLk i QAk as jT \u00bdiLk to iLk\u00feM k \u00c01 i QDk \u00bc\u00bc jP 0 to M k \u00c01 \u00bd i DRk . A correctness proof of EnQBCEA-MPM is included in Appendix D and complexity is proved in Theorem 2.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 891,
                    "end": 898,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "14"
        },
        {
            "text": "Lemma 2: A QPU having C quantum cores 1 c C \u00f0 \u00decan access the text T of size N on shared QMEM. A c th core filters t k indices jT i i QAk in parallel to identify the possible start locations of pattern P and to store such original filtered indices in LA k t k \u00bd . Time needed for executing quantum approximate filtering (QAF) in parallel is O m=C \u00f0 \u00de tlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 . Proof (Lemma 2): In support of the earlier discussions and using the reference to Aborot (2017) and Soni & Rasool (2021) , we used to prove this lemma. Procedure QAF is executed in parallel for each pattern P k 2 P on c th quantum core QCore c sharing the QMEM. Quantum circuit included in Aborot (2017) and Soni & Rasool (2021) will runs separately on QCore c and performs equivalent quantum operations as U SLoc , U PLoc , HD followed by the Hadamard on jT i i QAk to merge probability amplitudes of entangled indices of jT i \u00c0 T i j i AX . Now auxiliary register measures filtered indices jT i i to store in LA . . .",
            "cite_spans": [
                {
                    "start": 470,
                    "end": 490,
                    "text": "Soni & Rasool (2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 678,
                    "end": 698,
                    "text": "Soni & Rasool (2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "\u00bd . All such operations are bounded by O log 2 N \u00c0 \u00c1 time. However, measurement destroys quantum state, so in each call at c th quantum core QCore c on behalf of P k 2 P, the QAF needs its repeated executions to filter all t k indices and to store them in location array LA k t k \u00bd . Therefore, based on longest core processing to filter maximum pattern locations, we assume t \u00bc t k \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00deat any QCore c . The time required for such filtering in parallel is O m=C \u00f0 \u00de tlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 . The multiplicative factors can be ignored due to parallel processingquantum circuit operations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "Theorem 2: Given text database T of size N and the multiple pattern set P \u00bc P 1 ; :; P k ; :; P m f gwith each pattern P k of length M k 1 k m \u00f0 \u00de . Algorithm EnQBCEA-MPM uses QPU having C quantum cores 1 c C \u00f0 \u00deto access the text T on shared QMEM. The c th core runs QAF to store all t k filtered indices of a pattern P k in LA k t k \u00bd . The indices of LA k t k \u00bd are used by c th core to search for all t k 0 exact occurrence of patterns indexed at jT iLk i QAk , that is jT \u00bdiLk to iLk\u00feM k \u00c01 i QDk \u00bc\u00bc jP 0 to M k \u00c01 \u00bd i DRk . Based on maximum filtered indices t \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00dein LA k t \u00bd and longest core processing to find pattern occurrences t 0 \u00bc max t 1 0 ; :; t k 0 ; :; t m 0 \u00f0 \u00de , the search time complexity of EnQBCEA-MPM algorithm is O m=C \u00f0 \u00de ffiffiffiffi ffi tt 0 p log 2 t \u00c0 \u00c1 \u00c0 \u00c1 in the best case and O m=C \u00f0 \u00de tlog 2 t \u00c0 \u00c1 \u00c0 \u00c1 for the worst case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "Proof (Theorem 2): The proof of this theorem is based on Lemma 2 and other statements which are justified earlier. Our algorithm EnQBCEA-MPM performs a search on filtering outcomes that are stored in parallel by executing the QAF on separate quantum cores. It is assured that EnQBCEA performs the search on reduced size text database T, each of size t k . Thus, this increases the success probability for identifying the search results. Lemma 2 states, that to store all t k filtered indices in LA k t k \u00bd we need O m=C \u00f0 \u00de tlog 2 N \u00c0 \u00c1 \u00c0 \u00c1 time. Each core QCore c 2 QPU utilizes the processing advantage of QMEM in both filtering and searching. Algorithm EnQBCEA-MPM accesses LA k t k \u00bd on each QCore c to obtain the original filtered text indices by applying unitary U kGetL . It takes O 1 \u00f0 \u00de time for realizing such transformation under the superposition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "The original text is available in QMEM superposition and shared among all quantum cores. Thus, each QCore c applies QMEM transformation to load all substrings in parallel, such that, each pattern P k 2 P of length M k 1 k m \u00f0 \u00deverifies for exactness over filtered index approximations. Now, based on the QEM circuit applied under the superposition of t k sized text T, the indices are identified for an exact match. Further, parallel iterations of GSO finds all t k 0 t k 0 t k \u00f0 \u00desolutions of P k using c th core QCore c in O m=C \u00f0 \u00de ffiffiffiffiffiffiffiffiffiffi t k =t k 0 p queries. Indeed, the quantum state collapsed while measured; therefore, EnQBCEA repeats GSO operation followed by measurement, on each quantum core QCore c to report all t k 0 exact occurrences of the pattern P k in resulting O m=C \u00f0 \u00de ffiffiffiffiffiffiffi ffi t k t k 0 p \u00f0 \u00de \u00f0",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "\u00dequeries and thus O m=C \u00f0 \u00de ffiffiffiffiffiffiffi ffi t k t k 0 p log 2 t k \u00c0 \u00c1 \u00c0 \u00c1 time. To conclude the complexity, we are considering the maximum reduced size of any filtered location array LA k t k \u00bd as t \u00bc t k \u00bc max t 1 ; :; t k ; :; t m \u00f0 \u00de , and the longest core processing to find maximum pattern occurrences t 0 \u00bc t k 0 \u00bc max t 1 0 ; :; t k 0 ; :; t m 0 \u00f0 \u00de . So, using QPU with C cores and for t0 \u00bc 1 or t few (t few denotes few pattern occurrences (t few ( t)), the best case time complexity of EnQBCEA-MPM is O m=C \u00f0 \u00de ffiffiffiffi ffi tt 0 p log 2 t \u00c0 \u00c1 \u00c0 \u00c1 and this finds all patterns in parallel. However, when t 0 \u00bc t the worst-case complexity is still bounded to O m=C \u00f0 \u00de tlog 2 t \u00c0 \u00c1 \u00c0 \u00c1 . A multiplicative factor log 2 t \u00c0 \u00c1 is considered negligible as due to less qubits tq ( n \u00f0 \u00deneeded to expand the reduced search space. However, this factor cannot be ignored when the number of qubits tq is sufficiently large to expand the filtered space (Lomont, 2003; Soni & Rasool, 2021) . And the multiplicative constant m=C \u00f0 \u00de with a small arbitrary constant value of m and constant value of C is found negligible. However, for the comparatively large value of m ) C, a factor m=C cannot be ignored in time complexities. Therefore, quantum search is preferred effectively for few occurrences. Instead, for biological text, t 0 \u00bc t is rare and hence ignored while stating a generalized complexity. We also suggest that algorithm design based on the functionality of GSO, enhances the results with probability",
            "cite_spans": [
                {
                    "start": 964,
                    "end": 978,
                    "text": "(Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 979,
                    "end": 999,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "Pr EnQBCEA running at QCore c measuresjT iLk i QAk in each iteration",
            "cite_spans": [],
            "ref_spans": [],
            "section": "14"
        },
        {
            "text": "The presented algorithms EnQPBEA-MPM and EnQBCEA-MPM are hereby observed with summarized facts of several complexities analysis. This section incorporates the design methods by mainly focusing on actual qubits requirement. For dealing with number of unknown search solutions, the analysis of quantum counting algorithms is included. An idea to simulate QMEM is also discussed here with the realization of quantum effective processing framework.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "THEORETICAL RESULTS AND COMPLEXITIES ANALYSIS"
        },
        {
            "text": "We summarize our proven results to compare with the related work. The significant findings were noted herein dedicated tables to emphasize our analytical interpretation. In this section, we present the concluded complexities of our algorithms using Tables 5 and 6 is referred for discussing the design methods with qubits requirement and success probability.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 249,
                    "end": 263,
                    "text": "Tables 5 and 6",
                    "ref_id": "TABREF13"
                }
            ],
            "section": "Summarized complexities analysis and mathematical proved results"
        },
        {
            "text": "Analysis of proposed algorithms based on several quantum complexities:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Summarized complexities analysis and mathematical proved results"
        },
        {
            "text": "The resulting complexities of algorithms have been proved earlier and summarized in We enhanced the QPBE and QBCE for multiple patterns under quantum architectural and implicit operational parallelism. Based on complexity analysis, our solutions are proved efficient to find an exact match while comparing with existing multiple pattern methods QEMP and QAMP as the factor m cannot be excluded from their complexities. Our algorithm designs execute exact search oracles in parallel using individual quantum core. The processing time for few pattern occurrences (t few ( N) is negligible, and we need less qubits to expand the filtered search space. A QPU runs C cores to search for m=C pattern in parallel, and each quantum core uses its own set of register. So multiplicative constant m=C \u00f0 \u00de with a small arbitrary constant value of m and constant value of C is found negligible. But, for comparatively large value of m ) C, factor m=C cannot be ignored in time complexities. We included the storage complexity of our algorithms to estimate the qubits requirement. This complexity is based on the asymptotic estimation of qubits by excluding constants. Later, in Table 6 , we specify actual qubits requirement with coefficients to check simulation feasibility of algorithms, as classical machine configuration is restricted to simulate large qubits. Quantum algorithms and their quantum circuits are proved equivalent for implementations. Therefore, the quantum query, time and storage complexities of ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1165,
                    "end": 1172,
                    "text": "Table 6",
                    "ref_id": "TABREF15"
                }
            ],
            "section": "Summarized complexities analysis and mathematical proved results"
        },
        {
            "text": "proposed algorithms justify their effectiveness. All the requisite and relevant discussions on behalf of Table 5 have been discussed earlier as per the contextual need.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 105,
                    "end": 112,
                    "text": "Table 5",
                    "ref_id": "TABREF13"
                }
            ],
            "section": "Summarized complexities analysis and mathematical proved results"
        },
        {
            "text": "Design methods used for quantum multiple pattern matching algorithms: Table 6 shows framework and design of algorithms. Used quantum registers are mentioned to check for proportional simulation feasibility of actual qubits requirement. Search success probability on any QCore c , proved in theorems, is based on original and filtered text sizes.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 70,
                    "end": 77,
                    "text": "Table 6",
                    "ref_id": "TABREF15"
                }
            ],
            "section": "Summarized complexities analysis and mathematical proved results"
        },
        {
            "text": "The quantum results may contain error while measured; therefore, GSO operation is used to amplify the probability amplitudes. Thus, we obtain the search results with a high probability. Therefore, we categorize our algorithms in BQP complexity class. The qubits are implicitly analyzed based on the quantum register requirement. For QPU with C cores based parallel processing, this m=C \u00f0 \u00de factor is there; however, these cores use their own set of quantum registers, so the factor is negligible, and time is reduced in parallelism. Classical machine configuration is restricted to simulate large qubits and affects simulation. Therefore, algorithms are implemented using hybrid simulation, such that each core can use the sufficient qubits with no excessive increase in qubits requirement of a quantum system. To save qubits requirement, EnQPBEA and EnQBCEA are simulated by using ANF based quantum operations, dedicated use of ancillary qubits, and utilizing QuEST specific unitary for efficient realization. The hybrid simulation results are noted later in the tables included in \"Simulation Results and Discussion\" section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Summarized complexities analysis and mathematical proved results"
        },
        {
            "text": "Quantum counting (QC) is a quantum amplitude estimation method to handle the case of GSO overshooting as t number of search solutions are unknown in advance, so it leads to the unknown number of GSO iterations (Brassard et al., 2002; Nielsen & Chuang, 2010; Song, 2017) . These authors (Boyer et al., 1998; Brassard et al., 2002; Lomont, 2003; Younes, 2008) suggested running the quantum counting algorithm initially and then proceeding with the actual number of GSO iterations. We obtained an accurate t value by implementing Exact-QC and the estimated t value through Approx.-QC methods. We provide the complexities analysis of both these cases in the subsection, and the resulting complexities are specified in Table 7 .",
            "cite_spans": [
                {
                    "start": 210,
                    "end": 233,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 234,
                    "end": 257,
                    "text": "Nielsen & Chuang, 2010;",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 258,
                    "end": 269,
                    "text": "Song, 2017)",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 286,
                    "end": 306,
                    "text": "(Boyer et al., 1998;",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 307,
                    "end": 329,
                    "text": "Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 330,
                    "end": 343,
                    "text": "Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 344,
                    "end": 357,
                    "text": "Younes, 2008)",
                    "ref_id": "BIBREF53"
                }
            ],
            "ref_spans": [
                {
                    "start": 714,
                    "end": 721,
                    "text": "Table 7",
                    "ref_id": "TABREF18"
                }
            ],
            "section": "Exact and approximate quantum counting complexity analysis"
        },
        {
            "text": "Analysis of approximate and exact quantum counting (QC) algorithms: (Boyer et al., 1998; Brassard et al., 2002; Lomont, 2003; Younes, 2008 (Brassard et al., 2002; Soni & Rasool, 2021) . In Table 7 , we have shown the complexities by including m=C \u00f0 \u00defactor because the quantum counting is needed to run on individual quantum core for each pattern separately. To measure the accurate value of t through Exact-QC we used to take the register with the precision qubits }r} % log 2 N \u00bc n \u00c0 \u00c1 qubits for EnQPBEA and }r} % log 2 t \u00bc tq \u00c0 \u00c1 qubits for EnQBCEA algorithm. Similarly, to measure the approximation of the value of t through Approx.-QC we need a register with precision qubits }r} , log 2 N qubits for EnQPBEA and }r} , log 2 t qubits for EnQBCEA algorithm (Brassard et al., 2002; Song, 2017; Soni & Rasool, 2021) . The storage complexity showing qubits estimation for Approx.-QC and Exact-QC is also shown additionally in the presented Table 7 . There are two cases to obtain the resulting complexities of combining the QC and GSO as it is further used in our simulation of EnQPBE algorithm -(1) Run Approx.-QC followed by the GSO to find all t occurrences of the pattern, so",
            "cite_spans": [
                {
                    "start": 68,
                    "end": 88,
                    "text": "(Boyer et al., 1998;",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 89,
                    "end": 111,
                    "text": "Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 112,
                    "end": 125,
                    "text": "Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 126,
                    "end": 138,
                    "text": "Younes, 2008",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 139,
                    "end": 162,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 163,
                    "end": 183,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 762,
                    "end": 785,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 786,
                    "end": 797,
                    "text": "Song, 2017;",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 798,
                    "end": 818,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [
                {
                    "start": 189,
                    "end": 196,
                    "text": "Table 7",
                    "ref_id": "TABREF18"
                },
                {
                    "start": 942,
                    "end": 949,
                    "text": "Table 7",
                    "ref_id": "TABREF18"
                }
            ],
            "section": "Exact and approximate quantum counting complexity analysis"
        },
        {
            "text": "(2) Run Exact-QC followed by GSO to find all t occurrences of the pattern, therefore ffiffiffiffiffi",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Exact and approximate quantum counting complexity analysis"
        },
        {
            "text": "time. Therefore, the complexity is still bounded by O ffiffiffiffiffi Nt p \u00c0 \u00c1 time (Brassard et al., 2002; Lomont, 2003; Song, 2017) . Similarly for these cases, the complexity of EnQBCEA algorithm remains O ffiffiffiffi ffi tt 0 p \u00c0 \u00c1 time as it works on t filtered indices to find t 0 pattern occurrences (Brassard et al., 2002; Soni & Rasool, 2021) . We may expect accurate number of GSO iterations when the exact value of t is obtained through Exact-QC but the deviations in t values are possible through Approx.-QC algorithm, and hence the quantum search results need to be compromised with more errors.",
            "cite_spans": [
                {
                    "start": 84,
                    "end": 107,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 108,
                    "end": 121,
                    "text": "Lomont, 2003;",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 122,
                    "end": 133,
                    "text": "Song, 2017)",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 308,
                    "end": 331,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 332,
                    "end": 352,
                    "text": "Soni & Rasool, 2021)",
                    "ref_id": "BIBREF51"
                }
            ],
            "ref_spans": [],
            "section": "Exact and approximate quantum counting complexity analysis"
        },
        {
            "text": "To simulate our algorithms with the effective quantum processing framework, we propose the design of an algebraic normal form (ANF) circuit for realizing QMEM. Thus, this supports the hybrid simulation (Bogdanova et al., 2018; Hao et al., 2020) . We can implement and perform most of the quantum operations directly by utilizing the ",
            "cite_spans": [
                {
                    "start": 202,
                    "end": 226,
                    "text": "(Bogdanova et al., 2018;",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 227,
                    "end": 244,
                    "text": "Hao et al., 2020)",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Design and analysis of algebraic normal form to realize QMEM"
        },
        {
            "text": "advantage of ANF that are equivalent to unitary circuits, such as U Load (QMEM transformation), U Comp (QEM operation), and needful quantum adder operation (QAF filtering); hence, this saves the qubits requirement (Malviya & Tiwari, 2020; Malviya & Tiwari, 2021) . The other requisite circuits and GSO operations needed for our proposed algorithms will be implemented using combination of ANF and the specific quantum unitary operations available in the QuEST library (defined in next section, used for simulation purpose). For comprehensive understanding of the ANF based QMEM realization refer to Malviya & Tiwari (2020) ; Soni & Rasool (2021) ; Soni & Malviya (2021) and Malviya & Tiwari (2021) . We proposed a quantum circuit in Fig. 8 showing implicit operational method about the memory processing mentioned in Fig. 2 . A design of QMEM transformation is proposed here for a main unitary U Load by using ANF. This will be later used in the next section to simulate QMEM. So, for considered jT 2 n \u00c2w i QMEM , the quantum circuit of Fig. 8 creates a superposition of N \u00bc 2 n text addresses by applying H n gates on n qubits address register jT i i QA . These n qubits are used in ANF as n variables to form 2 n possible binary strings, usually called Boolean terms. In Fig. 8 , the n \u00bc 4 variables are taken as jT 0 T 1 T 2 T 3 i, where T 0 j i \u00bc 2 3 j i and T 3 j i \u00bc 2 0 j i are the most significant and least significant qubit positions. Therefore, the total 2 4 \u00bc 16 possible terms 0 j i . . . ; 7 j i; . . . F j i f g forms uniform superposition of binary strings 0000 j i. . . ; 0111 j i; . . . 1111 j i f g . Further, ANF creates the data superposition, by realizing all the substring data load operation in parallel, each of size M \u00c2 log 2 AE j j in entangled data register jT i \u00bd i QD for each jT i i QA . So, for such realization, M \u00c2 log 2 AE j j Boolean functions are computed in parallel, each can have at most O 2 n \u00f0 \u00de Boolean terms. These terms are computed with the logical \"AND\" followed by \"XOR\" operations. The computation of all possible terms, results output of associated Boolean function. A circuit is shown in Fig. 8 (about Fig. 2 ) considers pattern of length M \u00bc 4. Therefore, total 4 \u00c2 2 Boolean functions (Bogdanova et al., 2018; Malviya & Tiwari, 2020) .",
            "cite_spans": [
                {
                    "start": 214,
                    "end": 238,
                    "text": "(Malviya & Tiwari, 2020;",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 239,
                    "end": 262,
                    "text": "Malviya & Tiwari, 2021)",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 599,
                    "end": 622,
                    "text": "Malviya & Tiwari (2020)",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 625,
                    "end": 645,
                    "text": "Soni & Rasool (2021)",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 648,
                    "end": 669,
                    "text": "Soni & Malviya (2021)",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 674,
                    "end": 697,
                    "text": "Malviya & Tiwari (2021)",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 2239,
                    "end": 2263,
                    "text": "(Bogdanova et al., 2018;",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 2264,
                    "end": 2287,
                    "text": "Malviya & Tiwari, 2020)",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [
                {
                    "start": 733,
                    "end": 739,
                    "text": "Fig. 8",
                    "ref_id": "FIGREF8"
                },
                {
                    "start": 817,
                    "end": 823,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1038,
                    "end": 1044,
                    "text": "Fig. 8",
                    "ref_id": "FIGREF8"
                },
                {
                    "start": 1274,
                    "end": 1280,
                    "text": "Fig. 8",
                    "ref_id": "FIGREF8"
                },
                {
                    "start": 2140,
                    "end": 2160,
                    "text": "Fig. 8 (about Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Design and analysis of algebraic normal form to realize QMEM"
        },
        {
            "text": "Each function f xy with x = [0 to M \u2212 1] = {0, 1, 2, 3} and y = [0 to log 2 |\u03a3|] = {0, 1} is computed using variables associated with each term. To load all substring of size M \u00c2 log 2 AE j j in jT i \u00bd i QD for each text address jT i i QA in superposition, the binary string equivalent to index position jT i i is taken as input, and by applying their instances, these Boolean functions are then computed to generate the desired substring within superposition. For example, the loading of text substring indexed at jT 4 i QA , uses binary string j0100i QA to load the desired output string in data register j00011011i QD (see Fig. 2 ). This realization facilitates the qubits consuming operation in parallel, and thus, it simulates the quantum algorithms with the minimum qubits requirement (Malviya & Tiwari, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021; Malviya & Tiwari, 2021) . The design specifications used for quantum effective processing of algorithms are specified in Table 8 along with interpretation. Later, we will use these designs to simulate our proposed quantum algorithms using the QuEST simulation.",
            "cite_spans": [
                {
                    "start": 791,
                    "end": 815,
                    "text": "(Malviya & Tiwari, 2020;",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 816,
                    "end": 836,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 837,
                    "end": 858,
                    "text": "Soni & Malviya, 2021;",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 859,
                    "end": 882,
                    "text": "Malviya & Tiwari, 2021)",
                    "ref_id": "BIBREF33"
                }
            ],
            "ref_spans": [
                {
                    "start": 626,
                    "end": 632,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 980,
                    "end": 987,
                    "text": "Table 8",
                    "ref_id": "TABREF19"
                }
            ],
            "section": "Design and analysis of algebraic normal form to realize QMEM"
        },
        {
            "text": "Design specifications used for quantum effective processing framework: Table 8 specifies the proposed designs of quantum effective processing framework. It is used in reference with Table 4 to know the quantum gates required for circuit, processing time and qubits needed to realize a circuits. The ANF circuit is realized as equivalent unitary U Load (Eq. 3) for QMEM transformation. A circuit implementation needs quantum gates set ANF based circuit (Fig. 8 )",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 71,
                    "end": 78,
                    "text": "Table 8",
                    "ref_id": "TABREF19"
                },
                {
                    "start": 182,
                    "end": 189,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                },
                {
                    "start": 452,
                    "end": 459,
                    "text": "(Fig. 8",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Design and analysis of algebraic normal form to realize QMEM"
        },
        {
            "text": "H tq ; C tq NOT; X tq f g with tq n \u00f0 \u00de. Such circuit can be simulated later with varying length, as per needed size of QMEM to realize. The time complexity of ANF based QMEM depends on the circuit depth constructed over tq input variables tq n. It realizes M \u00c2 log 2 AE j j Boolean function in parallel, each consist of at most 2 tq terms. So, with maximum circuit depth, this circuit will take the exponential complexity O 2 tq \u00f0 \u00de as tq n under the simulation. We conclude that the physical QMEM processing is remarkable with O 1 \u00f0 \u00de time; however, it is exponentially slow in classical. The O 1 \u00f0 \u00de time QEM % U Comp (Eq. 5) design can be simulated efficiently with M \u00c2 log 2 AE j j qubits as all substrings, each of M \u00c2 log 2 AE j j length, can realize in superposition using ANF. The GSO can be realized as per Table 4 . A unitary U Mark (Eq. 7) marks index with the phase inversion through C tq\u00c01 NOT \u00f0 \u00degate, this flips a target index by inverting ancilla. Further, amplification circuit is used with the set of gates H tq ; X tq f g C tq\u00c01 Z; X tq ; H tq f g f g (Broda, 2016; Figgatt et al., 2017; Coles, 2020) . A circuit depth of GSO is O ffiffiffiffiffi ffi 2 tq p \u00c0 \u00c1 , so this depends on text size, as for t sized filtered or N sized original text with t N.",
            "cite_spans": [
                {
                    "start": 1072,
                    "end": 1085,
                    "text": "(Broda, 2016;",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1086,
                    "end": 1107,
                    "text": "Figgatt et al., 2017;",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1108,
                    "end": 1120,
                    "text": "Coles, 2020)",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 817,
                    "end": 824,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "Design and analysis of algebraic normal form to realize QMEM"
        },
        {
            "text": "Our proposed algorithms are validated using hybrid (classical and quantum) simulation for the effective realization of equivalent quantum circuits. Therefore, we implemented the algorithms by utilizing the advantage of a C-Library based, flexible simulator with a multi-platform support, called the Quantum Exact Simulation Toolkit (QuEST) (Jones & Benjamin, 2018) . We do not intend to analyze the simulation efficiency because of quantum operational restrictions on the classical machine. For a detailed study of QuEST simulation, refer to the published articles (Jones & Benjamin, 2018; Malviya & Tiwari, 2020; Malviya & Tiwari, 2021; Soni & Rasool, 2021; Soni & Malviya, 2021) .",
            "cite_spans": [
                {
                    "start": 340,
                    "end": 364,
                    "text": "(Jones & Benjamin, 2018)",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 565,
                    "end": 589,
                    "text": "(Jones & Benjamin, 2018;",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 590,
                    "end": 613,
                    "text": "Malviya & Tiwari, 2020;",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 614,
                    "end": 637,
                    "text": "Malviya & Tiwari, 2021;",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 638,
                    "end": 658,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 659,
                    "end": 680,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "SIMULATION AND EXPERIMENTAL DETAIL"
        },
        {
            "text": "Quantum computations are highly complex, and their efficient simulation on the classical machine is not expected rather than the quantum machine. We performed the simulation to analyze the feasibility of quantum algorithm computations. A quantum machine with a significant amount of qubits still does not exist to realize quantum algorithms. Therefore, we used the QuEST library for the efficient and high-performance simulation of quantum circuits as a substitute for the quantum computer. This simulator is ideal, open-source and available with competent hybrid features such as multithreaded, distributed, and GPU accelerated to use classical hardware for the efficient simulation of quantum circuits. The QuEST simulator proved for the excellent scaling on multicore architectures. Hybrid features of this simulator realized in parallel execution support of OpenMP and MPI. We expect no compromise on simulating the quantum computations even realization is more accurate on a single node, shared memory and distributed systems. A QuES simulation prepares basic and multi-controlled quantum gates as either pure state (vectors) or mixed state (density matrix) under the presence of decoherence (Jones & Benjamin, 2018) . This simulation is effective as it performs the quantum operations in the absence of quantum noise.",
            "cite_spans": [
                {
                    "start": 1197,
                    "end": 1221,
                    "text": "(Jones & Benjamin, 2018)",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "QuEST specific simulation features and environment setting"
        },
        {
            "text": "In their article, Jones & Benjamin (2018) , presented the performance comparison of QuEST with the other simulators, and they justified that QuEST is effective because it speeds up simultaneous quantum operations by data parallelism with SIMD execution support. The GPU acceleration is possible through NVIDIA's CUDA to attain operational speedup and to facilitate parallelism in quantum specific scientific codes. This maintains exponential operations 2 n \u00f0 \u00de as the pure quantum state over n-qubits quantum register represented as complex floating-point numbers with default double precision. The quantum multicore realization is the implicit phenomenon that is implemented through the QuEST simulator in the separate quantum execution environment. However, such realization is based on parallel execution of the task in the multithreaded environment over the multiple cores of the CPU (Jones & Benjamin, 2018) . Conclusively, we used the QuEST for high-performance simulation of quantum circuits and effective implementation equivalent to quantum algorithms.",
            "cite_spans": [
                {
                    "start": 18,
                    "end": 41,
                    "text": "Jones & Benjamin (2018)",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 888,
                    "end": 912,
                    "text": "(Jones & Benjamin, 2018)",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "QuEST specific simulation features and environment setting"
        },
        {
            "text": "We perform the experiments by implementing our quantum algorithms locally on one node with the machine configuration as \"Intel i7-7700HQ\" processor (having four cores and eight threads) running at 2.80 GHz (having 2400 MHz clock frequency) and 8GB classical RAM (CRAM). We set the QuEST execution environment for either a single or multiple (three) quantum system, each of them contains a separate register with a set of qubits in a pure state to show simulation of our quantum algorithms on single and multicore architecture. The simulation features such as OpenMP is enabled, GPU acceleration is disabled and default double-precision size of 8 bytes is used for reading probability amplitudes; however, the hybrid simulation would be effective.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific simulation features and environment setting"
        },
        {
            "text": "For the simulation purpose, we used the gene sequence database of \"Severe Acute Respiratory Syndrome Corona-Virus 2 SARS-CoV-2\" for humans. A detailed dataset description and QuEST specific simulation codes are specified within subsection of Additional Information and Declarations entitled \"Data and Simulation Codes Availability\".",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Description and encoding of biological dataset and patterns"
        },
        {
            "text": "An idea of implementation is to assign each symbol of the alphabet set AE with the binary string of length log 2 AE j j qubits, and then to transform text database and pattern into binary encoded form. The nucleotide/gene/genome sequence database is preferred for validating our algorithms, so each DNA character of AE \u00bc A; T; C; G f gis assigned with the log 2 4 \u00bc 2 length binary string as AE \u00bc 00; 01; 10; 11 f g (Faro & Lecroq, 2009; Soni & Rasool, 2021; Soni & Malviya, 2021) . In contrast, the peptide sequences/protein databases with amino acid symbols set AE j j \u00bc 20 are ignored here to avoid simulation specific restricted processing of long length binary strings log 2 AE j j \u00bc 5 qubits, as this increases qubits requirement.",
            "cite_spans": [
                {
                    "start": 416,
                    "end": 437,
                    "text": "(Faro & Lecroq, 2009;",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 438,
                    "end": 458,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 459,
                    "end": 480,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Description and encoding of biological dataset and patterns"
        },
        {
            "text": "The subsets of gene sequence \u00f0SARS \u00c0 CoV \u00c0 2\u00de is intentionally prepared, as per feasibility of simulation with the text file sizes of 128; 256; 512 f gcharacters. A QPU with the ANF circuit with varying length and as per needed size of QMEM to realize. However, based on ANF the QuEST simulation of QMEM is observed exponentially slow. The most important point to remember is justified here, that the ANF-based QMEM circuit allows several quantum operations with no increase in qubits requirement. In experimental results, we may observe some deviations and exceptions (if identified) due to implicit random increase in depth of Boolean functions as they are used to simulate QMEM. Further, we use this to perform other requisite quantum operations on the same ANF circuit. We used two implementations of Boolean oracle circuit for QEM % U Comp (Eq. 5). First, using log 2 AE j j sized ancilla qubits to store matching results of each index. Next, we use QuEST specific complex-matrix unitary to find a match and to negate the index for marking. Similarly, the simulation of GSO is realized as per Tables 4 and 8, however, QuEST specific multi-controlled qubit unitary is used to implement the phase inversion.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Description and encoding of biological dataset and patterns"
        },
        {
            "text": "The QuEST simulator realizes exponential operations effectively by optimizing simulation performance on the classical machine. This simulator provides the log file of quantum assembly instructions (QASM) which help us to record the operations executed on quantum registers by quantum gates and to report execution time of specific quantum circuit during simulation (Jones & Benjamin, 2018; Malviya & Tiwari, 2020; Malviya & Tiwari, 2021; Soni & Malviya, 2021) . A CRAM is allocated on demand, so its workspace area may contain several blocks of memory and may be available in compressed form. So, in addition, we used process explorer to measure the maximum workspace requirement of CRAM during the execution of a simulated algorithm.",
            "cite_spans": [
                {
                    "start": 365,
                    "end": 389,
                    "text": "(Jones & Benjamin, 2018;",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 390,
                    "end": 413,
                    "text": "Malviya & Tiwari, 2020;",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 414,
                    "end": 437,
                    "text": "Malviya & Tiwari, 2021;",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 438,
                    "end": 459,
                    "text": "Soni & Malviya, 2021)",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Description and encoding of biological dataset and patterns"
        },
        {
            "text": "This section includes QuEST simulation with observation to map our theoreticalexperimental results of algorithms. The results are categorized separately for equal and unequal sized patterns. We noted the results in the tables as per the analysis cases m C \u00f0 \u00de and m . C \u00f0 \u00defor different text file sizes. A recorded execution log is mentioned in Tables 9 and 10. To prevent the overshooting problem of GSO we implemented exact and approximate quantum counting (QC) algorithms that can find the required number of GSO iterations. So, the observed results of QC and further error analysis are included from Tables 11-13 (for equal sized pattern) and from Tables 14-16 (for unequal sized pattern). The average search time with the memory requirement of the algorithm under QuEST simulation is noted in Tables 17 and 18. Analysis of the experimental log observed during QuEST simulation:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 798,
                    "end": 815,
                    "text": "Tables 17 and 18.",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "For our algorithms EnQPBEA-MPM and EnQBCEA-MPM, Tables 9 and 10 are used to categorize the results between separate text file sizes 128; 256; 512 f gand analysis cases m C \u00f0",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00deand m . C \u00f0 \u00deare formed for equalunequal sized multiple pattern set P \u00bc P 1 ; P 2 ; P 3 ; P 4 ; P 5 ; P 6 f g of lengths 3; 3; 3; 3; 3; 3 f gand 2; 2; 3; 3; 4; 4 f g . A QPU with quantum cores C \u00bc C 1 ; C 2 ; C 3 f gis considered for the separate execution of desired pattern search.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00de to search for single pattern P of length 3 f g on C j j \u00bc 1 i.e. single core to show the simulation of existing QPBE and QBCE algorithms. In this case, other cores are remaining idle. The case of",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00de is considered for searching the desired pattern on individual quantum core. We noted the performance of our algorithms for the case",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00de to realize their executions for large number of patterns (exactly doubled) on constant number of quantum cores. For these cases, we utilized QuEST specific log file that contains a record of standard QASM instructions. The log record for EnQPBEA and EnQBCEA algorithms are identified for searching, but in case of the EnQBCEA algorithm, the filtering log is additionally recorded. It keeps number of quantum gates needed during the simulation of the quantum algorithm or its equal quantum circuit. A universal quantum gates set H; X; R z ; C tq\u00c01 Z; C tq X f g is noted in QASM log. We used to represent C tq\u00c01 Z and C tq X as CZ and CX to save the text space in tables. The number of coded qubits is observed additionally during a simulation of algorithm within test log. In reference to Table 6 , we simulated the EnQPBEA algorithm using workspace qubits. Instead of actual qubits n \u00fe 2 \u00c2 Mlog 2 AE j j \u00c0 \u00c1 \u00fe 1 \u00c0 \u00c1 , the n \u00fe Mlog 2 AE j j \u00fe 2 \u00fe 2 \u00c0 \u00c1 qubits used in the implementation. Here, all text substrings of size Mlog 2 AE j j are realized using ANF, and log 2 AE j j \u00bc 2 workspace qubits store the parallel matching result of each index in superposition. Other two qubits are used as ancillary to support GSO operation. Our findings on qubits, for both the equal and unequal sized patterns, are observed the same as expectations. The simulation of EnQBCEA algorithm is efficiently coded with 2n \u00fe tq \u00f0 \u00dequbits instead of the actual 2n \u00fe 2 \u00c2 Mlog 2 AE j j \u00c0 \u00c1 \u00fe tq \u00fe 1 \u00c0 \u00c1 qubits mentioned in Table 6 . We took 2n qubits for QAF filtering, and tq qubits to search on filtered indices. All substring of size Mlog 2 AE j j are realized using ANF and the pattern is loaded classically. For GSO operation, QuEST unitary complex-matrix is used to find a match and to negate the index for marking. The qubits are observed as the same as expectations for both equal and unequal sized patterns. We wished to show the implementation using QPU with C quantum cores; thus, the QuEST execution environment was initialized as either a single or multiple (three) quantum system containing a separate register set. We coded hybrid simulation to intentionally save qubits, such that, qubits requirement on any core should not exceed the limits of a classical machine. Especially for searching, the qubits needed by EnQPBEA is comparatively more than the EnQBCEA because of search is performed with original indices rather than filtered. A QAF takes 2n qubits to filter t indices, so, log 2 t \u00bc tq search qubits may vary as per t value. The expansion of different text search space with reduced indices enhances search mechanism, but this would happen, when a value of t is found as too low as likely the value of log 2 N \u00bc n.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 791,
                    "end": 798,
                    "text": "Table 6",
                    "ref_id": "TABREF15"
                },
                {
                    "start": 1504,
                    "end": 1511,
                    "text": "Table 6",
                    "ref_id": "TABREF15"
                }
            ],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "The qubits needed for the searching increases in accordance with the size of the biological text sequence and in direct proportion to the varying length patterns. This phenomenon can be observed in the tables by analysing noted qubits for both equalunequal sized patterns and text size. A QuEST simulation of algorithms on quantum multicore architecture shows that quantum registers are separately allocated with a set of qubits in the pure state. We observed the quantum logic gates as implicitly realized under the QuEST simulation of algorithms. For EnQPBEA with equalunequal sized patterns running on any QCore c . The quantum gates are close proximate values to the gate observed during a single pattern search on a single quantum core. In same context, the number of quantum gates, noted on each QCore c for EnQBCEA, are approximately doubled than single core. Due to small-sized equal or unequal pattern lengths, the observed number of gates for both the algorithms are analysed in close proximity. However, there is a proportional increase in the gates as with the increase in text file sizes and for the varying length patterns. There exist, huge difference between the gates observation of EnQPBEA and EnQBCEA because the gates observed for EnQBCEA are combined for both filtering and searching. The size of filtered text eventually increases or decreases multiplicity of quantum gates during simulation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "In general, we observed that the simulation takes more quantum gates due to the realization of ANF and other requisite quantum operations. We distributed uniform workload on all cores under the multiple (three) quantum system containing a separate register set. Table 9 shows a case of m . C \u00f0 \u00defor that the overlapping pattern P 2 \u00bc TTT executed on core C 2 takes very less number of gates as due to the reduced depth of ANF circuit. However, we noted proportional increase in the gate counts as per the length and occurrences of search pattern. There is no increase in gate requirements because most of the quantum operations are coded under ANF and this actually saves the specific requirements of quantum gates.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 262,
                    "end": 269,
                    "text": "Table 9",
                    "ref_id": "TABREF20"
                }
            ],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "To considering all file sizes, we observed the same growth in the gate counts of R z and C tq X with a gradual increase. A controlled phase flip gate C tq\u00c01 Z is used to perform the phase inversion on the occurrence identification of pattern over the index. A subset of H; X f g gates are used as per necessity to realize QMEM or diffusion operator of GSO. Any exception other than that are always expected because of the quantum operations are applied over the random increase in depth of Boolean function which is realized in ANF such that tq n. P \u00bc P 1 ; P 2 ; P 3 ; P 4 ; P 5 ; P 6 f g of lengths 3; 3; 3; 3; 3; 3 f gand 2; 2; 3; 3; 4; 4 f g . A QPU with quantum cores C \u00bc C 1 ; C 2 ; C 3 f gis considered for the separate execution of desired pattern search. We noted the results of equal sized pattern from Tables 11-13 and unequal sized pattern from Tables 14-16. In reference to the earlier discussions on Grover's quantum search, initially we implemented our algorithms by assuming that the t number of search solutions (either unique or multiple solution) are already known, and therefore, the GSO iterations were also coded in advance. The case of GSO overshooting is considered as t number of search solutions are unknown. However, it leads to the unknown number of GSO iterations and hence the probability of success would be vanishingly small. So, we handle this by implementing QC algorithm. To analyze our results, we implemented quantum counting (QC) (Brassard et al., 2002; Nielsen & Chuang, 2010) to estimate the t number of search solutions in advance. We obtained accurate value of t by Exact-QC and estimated value of t through Approx.-QC methods. We know that QC is an amplitude estimation method, therefore, additional quantum register is used with required precision qubits to store the exact or bifurcates the measurement result out of 100 iterations), and hence it is equivalently considered as 1,000 iterations. We define some requisite parameters which are evaluated for the error analysis purpose, out of 1,000 iterations, such as - (1) In each of the 10 repeated executions, we coded 100 iterations for sufficient be valuations. If the number of iterations were selected too small % 25 iterations, then there would have been the chance of getting the No: of IMP in our evaluations. However, because of the sufficient iterations, we have not reported this case for any search pattern. Therefore, we assure that the likely indices are at least identified during the search phase of both EnQPBEA & EnQBCEA algorithms. We also justify the fact, that the increase in number of iterations also increases the accuracy of measuring all the likely indices. And it also reduces the possibility of pattern that may be incorrectly missed. Similarly, on taking too large number of iterations % 1;000 iterations, a possibility of getting No: of IMP will be removed completely, but the algorithm performance becomes worse than the classical equivalent algorithm. noted for entire execution as the memory is shared among all cores. We used to realize",
            "cite_spans": [
                {
                    "start": 1468,
                    "end": 1491,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1492,
                    "end": 1515,
                    "text": "Nielsen & Chuang, 2010)",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00de for the performance evaluation with large no. of patterns (exactly doubled), and these patterns are executed on the constant number of quantum cores. A Avg: ET was observed using C-Library based clock\u00f0\u00de function call. It returns several clock ticks since the initiation of QuEST program execution. However, the clock ticks are dependent on processor architecture. So to note a time in seconds, we divide the clock ticks by CLOCKS_PER_SEC. This observation is noted through the test log. A CRAM workspace is observed explicitly by using process explorer to measure the maximum peak of the classical memory throughout the execution of the QuEST program. Our experiments for the pattern searching was repeated 20 times in a sequence to note their Avg: ET in seconds. The measured time includes the time of quantum superposition realized using ANF to simulate quantum operations in parallel. Both EnQPBEA and EnQBCEA are found exact for searching the pattern on target indices original or filtered text. The results tested on the dataset within QuEST simulations are here validated. Algorithms identify all pattern occurrences with high probability and in less time of execution. However, the search results of EnQBCEA are found optimal due to the search is performed on filtered space of size t rather than the original space of size N. Even on a single core, these results are optimized because of the same pattern is searched over the filtered text. The algorithms' performance observed in proportional increase with Avg: ET of searching, concerning the increase in text file sizes. We have stated earlier that our intentions are not to analyze the simulation efficiency due to performance restrictions on the classical machine. However, we ensure that for our text file sizes and patterns the time needed by a real quantum machine will be negligible. Average times noted for algorithms are specified explicitly for each core; but, due to parallel realization on the quantum multicore concept, we consider a maximum time taken by any core among C-QCore. Due to small-sized equal or unequal pattern lengths, the Avg: ET observed for both these algorithms are analyzed in close proximity. However, all the occurrences of each pattern are reported either within the original or filtered text sequence (see tables). For a case of m . C \u00f0 \u00dewe distributed uniform workload on all the quantum cores under the multiple (three) quantum system containing a separate register set. Tables 17 and  18 shows proportional increase in the Avg: ET values as per the increase in file sizes. And in the same case, Avg: ET of the EnQBCEA algorithm is found optimal than the EnQPBEA algorithm. The search time is dependent on the size of the text sequence and the number of occurrences to report for each pattern; therefore, we consider slight deviations. For all file sizes, and the equal or unequal sized patterns, we noted the Avg: ET on individual cores. Here, the time is deviating in accordance with the size and frequency of pattern occurrences within the text sequence. Some exceptions are considered here because of implicit random increase in depth of Boolean functions used in ANF based hybrid simulation. Recall, such an implementation aspect gives us privilege to save the number of qubits required for a simulation of algorithms. We restate that algorithmic performance on simulation may affect due to the scaling factors associated with qubits; thus, this also increases the workspace requirement of CRAM and processing time with an exponential increase. Memory requirement is also a crucial cum critical factor that may limit the execution of QuEST specific simulated program. So, we prepared a very small-sized data processing requirement of text and pattern and observed the utilization of the CRAM workspace (in KiB) throughout the execution of QuEST program. In reference to Avg: ET, we noted workspace utilization of CRAM. Therefore, the specified workspace in Tables 17 and 18 shows the average of repetitive experiments that were performed 20 times. A CRAM consumption is observed separately with respect to single pattern on single core. We noted the combined workspace for the cases m \u00bc C \u00f0",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 2471,
                    "end": 2488,
                    "text": "Tables 17 and  18",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 3962,
                    "end": 3978,
                    "text": "Tables 17 and 18",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00deand m . C \u00f0 \u00deto search for multiple string patterns, each one runs on separate quantum core. This is observed throughout the execution of algorithms that, the CRAM consumption of a single core is less on comparing with multiple quantum cores sharing. We expect this under QuEST simulation because the execution environment was set to a single quantum system with assigned registers to realize a single quantum core. For EnQPBEA and EnQBCEA, and m \u00bc C \u00f0 \u00decase, the execution environment of QuEST was set to multiple quantum systems with their separate registers of needed qubits to realize multiple quantum cores as a simulation of physical quantum multicore machine. So, cross-comparison assures that CRAM workspace is usually more. Similarly, for m . C \u00f0 \u00de case, we are observing the expected increase in CRAM workspace as each quantum system can simulate the individual quantum core to execute EnQPBEA and EnQBCEA algorithms twice to complete the execution. A CRAM workspace will gradually increase with respect to the text file sizes. Thus, this proportional phenomenon may restrict the classical simulation of quantum behaviour for processing the large sequence databases, usually of at least exponential in size. As well as, to process a large number of multiple string pattern m on the small number of available quantum cores C, there would be an eventual increase in the size of CRAM utilization. For all the cases m , C",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "\u00deour Tables 17 and 18 shows the proportional increase in the CRAM workspace values as per the increase in file sizes. And for same cases, CRAM workspace of the EnQBCEA algorithm is found optimal than the EnQPBEA algorithm. Since we observed that the CRAM utilization of EnQBCEA for their equalunequal sized patterns are found in the close proximate regions. However, there exists much more difference in the CRAM consumptions of EnQPBEA due to the reported pattern occurrences over the original text and implicit random increase in depth of Boolean functions used in ANF. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 5,
                    "end": 21,
                    "text": "Tables 17 and 18",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "QuEST specific algorithmic simulation results with observation"
        },
        {
            "text": "* Performs multiple patterns search on filtered text in effectively as its design utilizes the multiple cores to search for P k on shared QMEM. * All exact occurrence of each P k are found through QCore c of QPU having C cores in O m=C \u00f0 \u00de ffiffi t p \u00c0 \u00c1 . * Exact matching is preferred over large text that may contain frequent pattern occurrence, thus, significant to process a biological sequence. * Search mechanism is effective as because of finding patterns over the reduced size text, instead original. * This algorithm is remarkable over all classical and especially existing quantum multi-pattern methods. * Each core assures to report pattern match with Pr QCore c \u00f0 \u00de!t k 0 =t k over individual filtered text indices. * The probability of search results at k th core QCore c will depend on relativeness of individual filtered indices to the occurrences of pattern present in filtered text for each P k . * Bothe filtering and search time is still dependent on c th core QCore c , so, core running for unequal sized pattern with more filtering outcome and frequent search occurrence may degrades algorithm performance. * Due to algorithmic filtering, the qubits requirement increases with m=C \u00f0 \u00de, thus, restricts simulation. * Performance on each QCore c is affected with unequal length pattern and its formation over large AE j j. * O 2 tq \u00f0 \u00de tq n ANF circuit depth slows down simulation, and thus, it affects individual QCore c output. Our observations on QuEST specific simulation mainly involves the critical factor of qubits requirement for simulating quantum algorithm. It may cause exhaustive use of CRAM, and the classical CPU computation time is also increased with the at least exponential factor to process the circuit depth of quantum algorithms. However, we implemented quantum algorithms with hybrid simulation by effectively utilizing QuEST performance with several optimizations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "EnQBCEA-MPM"
        },
        {
            "text": "This section defines several applications of our proposed quantum algorithms related to search multiple patterns within the biological sequence databases. Table 19 specifies the applicability of proposed algorithms with respect to significant characteristics and performance restrictions.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 155,
                    "end": 163,
                    "text": "Table 19",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Proposed algorithmic applications to process biological sequences"
        },
        {
            "text": "In Table 19 , we summarize the significant characteristics and performance restrictions of the presented algorithms. We highlighted main points with respect to the contextual interpretation of biological text sequences and their standardized databases.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 11,
                    "text": "Table 19",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Proposed algorithmic applications to process biological sequences"
        },
        {
            "text": "To have more understanding of the algorithms, we direct the reader to specific applications (Sheik, Aggarwal & Anindya Poddar, 2004; Basel, 2006; Choo, 2006; Kalsi, Peltola & Tarhio, 2008; Fredriksson, 2009; Charalampos, Panagiotis & Konstantinos, 2011; Rivals, Salmela & Tarhio, 2011; Faro & Lecroq, 2013; Jiang, Zhang & Zhang, 2013; Singh, 2015; Zhang et al., 2015; Tahir, Sardaraz & Ikram, 2017; Hakak & Kamsin, 2019; Neamatollahi, 2020; Soni & Rasool, 2021; Soni & Malviya, 2021; Raja & Srinivasulu Reddy, 2019) . These articles are related to process biological sequences and their databases. In general, we say that the presented algorithms to process biological sequences, are influenced by three parameters such as alphabet size, pattern length and the size of the text. These parameters may affect the performance of the algorithmic simulation. However, their realization of quantum machines would be effective in specific biological applications. The probability of search results is based on the relativity between pattern occurrences and the size of the text database (original or filtered). Therefore, the search results are obtained in the best time with at least half probability, and for more frequent pattern occurrences, the results are obtained in the worst time with very high probability. In multiple pattern processing, there exist some variations in the performance of algorithm. It is because of processing equal or unequal size patterns. The simulation over a very large-sized biological sequence database is not feasible for simulation because of higher qubits requirement; therefore, a subset of the database is searched for a pattern as per the feasibility. There is no such restriction on real quantum machines as they can realize effective processing.",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 132,
                    "text": "(Sheik, Aggarwal & Anindya Poddar, 2004;",
                    "ref_id": null
                },
                {
                    "start": 133,
                    "end": 145,
                    "text": "Basel, 2006;",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 146,
                    "end": 157,
                    "text": "Choo, 2006;",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 158,
                    "end": 188,
                    "text": "Kalsi, Peltola & Tarhio, 2008;",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 189,
                    "end": 207,
                    "text": "Fredriksson, 2009;",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 208,
                    "end": 253,
                    "text": "Charalampos, Panagiotis & Konstantinos, 2011;",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 254,
                    "end": 285,
                    "text": "Rivals, Salmela & Tarhio, 2011;",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 286,
                    "end": 306,
                    "text": "Faro & Lecroq, 2013;",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 307,
                    "end": 334,
                    "text": "Jiang, Zhang & Zhang, 2013;",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 335,
                    "end": 347,
                    "text": "Singh, 2015;",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 348,
                    "end": 367,
                    "text": "Zhang et al., 2015;",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 368,
                    "end": 398,
                    "text": "Tahir, Sardaraz & Ikram, 2017;",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 399,
                    "end": 420,
                    "text": "Hakak & Kamsin, 2019;",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 421,
                    "end": 440,
                    "text": "Neamatollahi, 2020;",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 441,
                    "end": 461,
                    "text": "Soni & Rasool, 2021;",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 462,
                    "end": 483,
                    "text": "Soni & Malviya, 2021;",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 484,
                    "end": 515,
                    "text": "Raja & Srinivasulu Reddy, 2019)",
                    "ref_id": "BIBREF41"
                }
            ],
            "ref_spans": [],
            "section": "Proposed algorithmic applications to process biological sequences"
        },
        {
            "text": "In this work, we enhanced the existing quantum pattern matching methods QPBE and QBCE to search multiple patterns in parallel by using QPU with C cores accessing text on",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CONCLUSION AND FUTURE WORK"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Quantum algorithms for string processing",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ablayev",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ablayev",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Khadiev",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Salihova",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Vasiliev",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Quantum approximate string matching for large alphabets",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Aborot",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Theory & Practice of Computation",
            "volume": "1",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1142/10334"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Biological sequences and the exact string matching problem",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Basel",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Introduction to Computational Biology",
            "volume": "",
            "issn": "",
            "pages": "43--63",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Representation of Boolean function in terms of quantum computations",
            "authors": [
                {
                    "first": "Y",
                    "middle": [
                        "I"
                    ],
                    "last": "Bogdanova",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [
                        "A"
                    ],
                    "last": "Bogdanova",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "V"
                    ],
                    "last": "Fastovets",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "F"
                    ],
                    "last": "Lukichev",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Tight bounds on quantum searching",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Boyer",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Brassard",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Hoyer",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tapp",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Fortschritte der Physik",
            "volume": "46",
            "issn": "4-5",
            "pages": "493--505",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "A quantum von Neumann architecture for large scale quantum computing",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "F"
                    ],
                    "last": "Brandl",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Quantum amplitude amplification and estimation",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Brassard",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Hoyer",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mosca",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tapp",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Contemporary Mathematics",
            "volume": "305",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1090/conm/305/05215"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "High performance computing with quantum processing units",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Britt",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Journal on Emerging Technologies in Computing System",
            "volume": "13",
            "issn": "39",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3007651"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Quantum search of a real unstructured database",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Broda",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "European Physics Journal Plus",
            "volume": "131",
            "issn": "38",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1140/epjp/i2016-16038-2"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Dynamic Grover search: application in recommendation system & optimization problems",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Chakrabarty",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Khan",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Singh",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Quantum Information Processing",
            "volume": "16",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s11128-017-1600-4"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Parallel processing of multiple pattern matching algorithms for biological sequences: methods and performance results",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Charalampos",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Panagiotis",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Konstantinos",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Bioinformatics-Computational Biology and Modeling. Intech",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.5772/18488"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Quantum computing: Grover's search algorithm and its applications in bioinformatics",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "W"
                    ],
                    "last": "Choo",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "COSMOS World Scientific",
            "volume": "2",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1142/S0219607706000171"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Quantum algorithm implementations for beginners",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "J"
                    ],
                    "last": "Coles",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Solving the exact pattern matching problem constrained to single occurrence of pattern P in string S Using Grover's quantum search algorithm",
            "authors": [
                {
                    "first": "Bka",
                    "middle": [],
                    "last": "De Jesus",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Aborot",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "N"
                    ],
                    "last": "Adorna",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theory & Practice of Computation, Proceedings in Information & Communications Technology Springer",
            "volume": "7",
            "issn": "",
            "pages": "124--142",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "An efficient matching algorithm for encoded DNA sequences and binary strings",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Faro",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Lecroq",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "LNCS Springer",
            "volume": "5577",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-02441-2"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "The exact online string matching problem: a review of the most recent results",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Faro",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Lecroq",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ACM Computing Surveys",
            "volume": "45",
            "issn": "2",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/2431211.2431212"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Complete 3-qubit Grover search on a programmable quantum computer",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Figgatt",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Maslov",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Landsman",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [
                        "M"
                    ],
                    "last": "Linke",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Debnath",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Monroe",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Nature Communications",
            "volume": "8",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1038/s41467-017-01904-7"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Succinct backward-DAWG-matching",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Fredriksson",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ACM Journal of Experimental Algorithmics",
            "volume": "13",
            "issn": "8",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/1412228.1455263"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "A heterogeneous quantum computer architecture",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Fu",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Riesebos",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Lao",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "G"
                    ],
                    "last": "Almudever",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Sebastiano",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Versluis",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Charbon",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Bertels",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the ACM CF -16 International Conferences on Computing Frontiers",
            "volume": "",
            "issn": "",
            "pages": "323--330",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Quantum random access memory",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Giovannetti",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lloyd",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Maccone",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Physics Review Letters",
            "volume": "100",
            "issn": "16",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.100.160501"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "A review on quantum search algorithms",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "R"
                    ],
                    "last": "Giri",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "E"
                    ],
                    "last": "Korepin",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Quantum Information Processing",
            "volume": "16",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s11128-017-1768-7"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Quantum algorithms for the k-xor problem",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Grassi",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "N"
                    ],
                    "last": "Plasencia",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Schrottenloher",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Advances in Cryptology -ASIACRYPT",
            "volume": "",
            "issn": "",
            "pages": "527--559",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Exact string matching algorithms-survey, issues, and future research directions",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "I"
                    ],
                    "last": "Hakak",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kamsin",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Access",
            "volume": "7",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1109/ACCESS.2019.2914071"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Quantum algorithms for learning the algebraic normal form of quadratic Boolean functions",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Hao",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Xia",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Quantum Information Processing",
            "volume": "19",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s11128-020-02778-3"
                ]
            }
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Permuted pattern matching algorithms on multi-track strings",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hendrian",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Ueki",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Narisawa",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Yoshinaka",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shinohara",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Algorithms MDPI Journal",
            "volume": "12",
            "issn": "4",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.3390/a12040073"
                ]
            }
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Basics of bioinformatics, lecture notes of the graduate summer school on bioinformatics of China",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "Q"
                    ],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "QuEST and high performance simulation of quantum computers",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jones",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Benjamin",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Science Reports",
            "volume": "9",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1038/s41598-019-47174-9"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Comparison of exact string matching algorithms for biological sequences",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Kalsi",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Peltola",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tarhio",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "CCIS Springer",
            "volume": "13",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-70600-7"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Quantum computer science",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lanzogorta",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Uhlmann",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Synthesis Lectures on Quantum Computing",
            "volume": "1",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.2200/S00159ED1V01Y200810QMC002"
                ]
            }
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Accelerating pattern matching using a novel parallel algorithm on GPUs",
            "authors": [
                {
                    "first": "C-H",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "C-H",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "L-S",
                    "middle": [],
                    "last": "Chien",
                    "suffix": ""
                },
                {
                    "first": "S-C",
                    "middle": [],
                    "last": "Chang",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IEEE Transaction on Computers",
            "volume": "62",
            "issn": "10",
            "pages": "1906--1916",
            "other_ids": {
                "DOI": [
                    "10.1109/TC.2012.254"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Robust string matching in O(\u221aN +M) quantum queries",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lomont",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Linear approximation of a vectorial Boolean function using quantum computing",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "K"
                    ],
                    "last": "Malviya",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Tiwari",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Europhysics Letters",
            "volume": "132",
            "issn": "4",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1209/0295-5075/132/40001"
                ]
            }
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Quantum algorithm to identify division property of a multiset",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "K"
                    ],
                    "last": "Malviya",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Tiwari",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Arabian Journal of Science and Engineering",
            "volume": "46",
            "issn": "9",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s13369-021-05665-w"
                ]
            }
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Fault tolerant resource estimation of quantum random access memories",
            "authors": [
                {
                    "first": "O",
                    "middle": [
                        "D"
                    ],
                    "last": "Matteo",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "IEEE Transaction on Quantum Engineering",
            "volume": "1",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1109/TQE.2020.2965803"
                ]
            }
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Quantum pattern matching oracle construction",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Menon",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Chattopadhyay",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Pramana -Journal of Physics",
            "volume": "95",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s12043-020-02062-0"
                ]
            }
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Quantum computing for computer architects",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "S"
                    ],
                    "last": "Metodi",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Quantum pattern matching fast on average",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Montanaro",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Springer Journal Algorithmica",
            "volume": "77",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-015-0060-4"
                ]
            }
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Simple and efficient pattern matching algorithms for biological sequences",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Neamatollahi",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "IEEE Access",
            "volume": "8",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1109/ACCESS.2020.2969038"
                ]
            }
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Quantum computation and quantum information",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Nielsen",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [
                        "L"
                    ],
                    "last": "Chuang",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Circuit-based quantum random access memory for classical data. Quantum Physics",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "K"
                    ],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Petruccione",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Scientific Reports",
            "volume": "9",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1038/s41598-019-40439-3"
                ]
            }
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "Maximum exact matches for high throughput genome subsequence assembly",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Raja",
                    "suffix": ""
                },
                {
                    "first": "Srinivasulu",
                    "middle": [],
                    "last": "Reddy",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IETE Journal of Research",
            "volume": "3",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1080/03772063.2019.1603085"
                ]
            }
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "String matching in O(\u221an+ \u221am) quantum time",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Ramesh",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Vinay",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Journal of Discrete Algorithms",
            "volume": "1",
            "issn": "2",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/S1570-8667(03)00010-8"
                ]
            }
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "Exact search algorithms for biological sequences",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Rivals",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Salmela",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tarhio",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Algorithms in Computational Molecular Biology -Techniques",
            "volume": "",
            "issn": "",
            "pages": "91--111",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "Quantum bit string comparator -circuits and applications",
            "authors": [
                {
                    "first": "Sena",
                    "middle": [],
                    "last": "Oliveira",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": "Benicio",
                    "middle": [],
                    "last": "Melo De Sousa",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": "Viana",
                    "middle": [],
                    "last": "Ramos",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "IEEE International Telecommunications Symposium",
            "volume": "7",
            "issn": "",
            "pages": "17--26",
            "other_ids": {
                "DOI": [
                    "10.1109/ITS.2006.4433341"
                ]
            }
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "A fast pattern matching algorithm",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "S"
                    ],
                    "last": "Sheik",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "K"
                    ],
                    "last": "Aggarwal",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Journal of Chemical Information and Computer Science",
            "volume": "44",
            "issn": "4",
            "pages": "1251--1256",
            "other_ids": {
                "DOI": [
                    "10.1021/ci030463z"
                ]
            }
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Fundamentals of bioinformatics and computational biology",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "B"
                    ],
                    "last": "Singh",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "6",
            "issn": "",
            "pages": "1--345",
            "other_ids": {}
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "Early days following Grover's quantum search algorithm",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Song",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "Classical equivalent quantum based efficient data preprocessing algorithm",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Soni",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Khare",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "K"
                    ],
                    "last": "Soni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rasool",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "IEEE International Conference on Computing, Communication and Networking Technologies (ICCCNT)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF49": {
            "ref_id": "b49",
            "title": "Design and analysis of pattern matching algorithms based on QuRAM processing",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "K"
                    ],
                    "last": "Soni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "K"
                    ],
                    "last": "Malviya",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Arabian Journal for Science and Engineering",
            "volume": "46",
            "issn": "4",
            "pages": "3829--3851",
            "other_ids": {
                "DOI": [
                    "10.1007/s13369-020-05310-y"
                ]
            }
        },
        "BIBREF50": {
            "ref_id": "b50",
            "title": "Pattern matching: a quantum oriented approach",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "K"
                    ],
                    "last": "Soni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rasool",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Procedia Computer Science",
            "volume": "167",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/j.procs.2020.03.230"
                ]
            }
        },
        "BIBREF51": {
            "ref_id": "b51",
            "title": "Quantum-based exact pattern matching algorithms for biological sequences",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "K"
                    ],
                    "last": "Soni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rasool",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "ETRI Journal",
            "volume": "46",
            "issn": "3",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.4218/etrij.2019-0589"
                ]
            }
        },
        "BIBREF52": {
            "ref_id": "b52",
            "title": "EPMA: efficient pattern matching algorithm for DNA sequences",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Tahir",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sardaraz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "A"
                    ],
                    "last": "Ikram",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Expert Systems with Applications",
            "volume": "80",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/j.eswa.2017.03.026"
                ]
            }
        },
        "BIBREF53": {
            "ref_id": "b53",
            "title": "Strength and weakness in Grover's quantum search algorithm",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Younes",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF54": {
            "ref_id": "b54",
            "title": "An efficient parallel algorithm for exact multi-pattern matching. Security and Communication Networks",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Tian",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Fan",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "8",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1002/sec.1115"
                ]
            }
        },
        "BIBREF55": {
            "ref_id": "b55",
            "title": "Quantum differential cryptanalysis. Quantum Information Processing",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lu",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sun",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "14",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s11128-015-0983-3"
                ]
            }
        },
        "BIBREF56": {
            "ref_id": "b56",
            "title": "Quantum pattern search with closed match",
            "authors": [
                {
                    "first": "R-G",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "C-Y",
                    "middle": [],
                    "last": "Shen",
                    "suffix": ""
                },
                {
                    "first": "Xiao T-R",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "Y-C",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "International Journal of Theoretical Physics",
            "volume": "52",
            "issn": "11",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s10773-013-1710-4"
                ]
            }
        },
        "BIBREF57": {
            "ref_id": "b57",
            "title": "Biological databases for human research",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Zou",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ma",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Genomics Proteomics Bioinformatics",
            "volume": "13",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/j.gpb.2015.01.006"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Organization of quantum-based effective multiple pattern matching algorithms. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-1",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Quantum circuit equivalent to the quantum memory (QMEM) processing. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-2",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Quantum circuit for exact pattern match as (QEM) working with QMEM processing. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-3 exact match. So, the depth of quantum circuit is O 1 \u00f0 \u00de. The qubits requirement of the proposed circuit is 3 \u00c2 M \u00c2 log 2 AE j j \u00c0 \u00c1 + M + 1 and we estimate asymptotic complexity with O M \u00c2 log 2 AE j j \u00c0 \u00c1 . Thus, this quantum-exact match (QEM) circuit is efficient.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Quantum-based illustration of the EnQPBEA-MPM algorithm. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-4",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Quantum circuit equivalent to search mechanism of EnQPBEA-MPM algorithm. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-5",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Quantum-based illustration of the EnQBCEA-MPM algorithm. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-6",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Begin Prepare P in jP 0 to M\u00c01 \u00bd i DR , and store ji j i in SL M \u00bd as preprocessed start locations of distinct symbol of jPi DR 3: Prepare registers as jzeroes n i in jT n i QA ,jzeroes w \u00bd i in jT w \u00bd i QD , jzeroes n\u00fe1 i in jT n\u00fe1 i AX 4: Initialize State as jw n i in jT i i QA , jsame w \u00bd i in jT w \u00bd i QD & entangle the register jT n\u00fe1 i AX 5: Load data at jT i \u00bd i QD as per entangled jT i i QA by applying QMEM Transformation as 6:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Quantum circuit equivalent to searching logic of the EnQBCEA-MPM algorithm. Full-size \ue90d DOI: 10.7717/peerj-cs.957/fig-7",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Quantum algebraic normal form (ANF) circuit used to realize QMEM processing. Full-size \ue90d DOI: 10.7717/peerj-cs.computed in parallel as shown in Eqs. (9)-(16)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Quantum counting (QC) results and error analysis during QuEST simulation:For our algorithms EnQPBEA-MPM and EnQBCEA-MPM, we categorize the results in tables between separate text file sizes 128; 256; 512 f gand the analysis cases m C \u00f0 \u00de and m . C \u00f0 \u00deformed for equalunequal sized multiple pattern set",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "are presented here as enhanced solutions. Our proposed algorithms EnQPBEA-MPM and EnQBCEA-MPM are proved to search for all t exact occurrence of m patterns with effective time O m=C For a single pattern search, the proposed algorithms EnQPBEA-MPM and EnQBCEA-MPM can simulate the QMEM processing based enhanced designs of QPBE & QBCE algorithms",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "). Based on these proposals, other existing algorithms are categorized for multiple pattern matching. There exist several multiple patterns matching methods, few are highlighted with their complexities. Aho-Corasick (AC) is the automata based prefix algorithm that works on KMP logic in O m \u00fe N \u00f0 \u00detime complexity. Commentz-Walter (CW) as a suffix algorithm, extending BM with possible variants, takes \u039f(m(NM)) time in worst case. Multiple Pattern Backward DAWG (BDM) and Backward Set Oracle Matching (BSOM) are the factor or substring search-based algorithms which run in \u00deand verification through the AC algorithm. Wu-Manber (WM) is hashing based algorithm works for a large number of patterns search in O N M=w where w is number of bits in word size. Shift-OR (SO), Shift-AND (SA), and Backward Non-Deterministic DAWG (BNDM) Matching methods perform bits operation through intrinsic parallelism to realize solutions for multiple patterns matching in",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "QAPM finds approximate pattern match, and QEPM is constrained to search single pattern occurrence (De Jesus,",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "Analysis of algorithmic complexities QEPM and QAPM algorithms with qubits estimation.",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "Analysis of algorithmic complexities QPBE and QBCE algorithms with qubits estimation.",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "Analysis of algorithmic complexities QEMP and QAMP algorithms with qubits estimation.",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Analysis of quantum memory processing, quantum exact match, and quantum search operation.",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "with depth 2 i.e. O 1 \u00f0 \u00de (Sena Oliveira, Benicio Melo de Sousa & Viana Ramos, 2007; De Jesus,Aborot & Adorna, 2013;Soni & Rasool, 2021;Soni & Malviya, 2021).",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "The QMEM makes searching outcomes available in parallel with O 1 \u00f0 \u00de step. The unitary U Comp of O 1 \u00f0 \u00de time is used in GSO as implicit operation and it is simulated on QMEM design. The GSO can find number of pattern occurrences t \u00bc t",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "same as the classical. For t \u00bc 1 case, GSO can obtain the result with high probability after",
            "latex": null,
            "type": "table"
        },
        "TABREF11": {
            "text": "Data : Text T stored on jT 2 n \u00c2w i QMEM which is accessed by quantum registers jT n i QA1 ; . . . ; jT n i QAm DR1 ; . . . ; jP 0 to Mm\u00c01 each P k , location registers to access filtered indices for each pattern as jT tq i QL1 ; . . . ; jT tq i QLm t k \u00bc tq qubits, & set of ancillary qubits designated to no. of pattern jqi Q1 ; . . . ; jqi Qm",
            "latex": null,
            "type": "table"
        },
        "TABREF12": {
            "text": "Measure the final state to get the desired index jT iLk i QAk as high probable solution18:Verify pattern P k at jT iLk i QAk on c th core QCore c as jT \u00bdiLk to iLk\u00feM k \u00c01 i QDk \u00bc\u00bc jP 0 to M k \u00c01",
            "latex": null,
            "type": "table"
        },
        "TABREF13": {
            "text": "In reference to Tables 1-3, we discuss comparative factors of our work. each core of QPU sharing QMEM does parallel match by U kComp , and hence this makes our solutions",
            "latex": null,
            "type": "table"
        },
        "TABREF14": {
            "text": "Summarized quantum complexities of the proposed algorithms.",
            "latex": null,
            "type": "table"
        },
        "TABREF15": {
            "text": "Framework and design of proposed algorithms with qubits requirement and success probability.",
            "latex": null,
            "type": "table"
        },
        "TABREF17": {
            "text": "). Similarly the EnQBCEA algorithm, working on t filtered indices to find t 0 pattern occurrences, needs O",
            "latex": null,
            "type": "table"
        },
        "TABREF18": {
            "text": "Analysis of QC algorithm used to find approximate or exact value of t as number of search solutions.",
            "latex": null,
            "type": "table"
        },
        "TABREF19": {
            "text": "Simulation detail to realize the design of quantum effective processing framework.",
            "latex": null,
            "type": "table"
        },
        "TABREF20": {
            "text": "Observed outcomes of experimental log during QuEST simulation for equal sized patterns.",
            "latex": null,
            "type": "table"
        },
        "TABREF21": {
            "text": "Observed outcomes of experimental log during QuEST simulation for unequal sized patterns.",
            "latex": null,
            "type": "table"
        },
        "TABREF22": {
            "text": "Observed results of QC with error analysis in QuEST simulation for N = 128 & equal sized patterns.",
            "latex": null,
            "type": "table"
        },
        "TABREF23": {
            "text": "Observed results of QC with error analysis in QuEST simulation for N = 256 and equal sized patterns.",
            "latex": null,
            "type": "table"
        },
        "TABREF24": {
            "text": "Observed results of QC with error analysis in QuEST simulation for N = 512 and equal sized patterns.",
            "latex": null,
            "type": "table"
        },
        "TABREF25": {
            "text": "Observed results of QC with error analysis in QuEST simulation for N = 128 and unequal sized patterns. Text file size: 128 Actual patterns Filtered indices Error analysis (Exact-QC) Error analysis (Approx. -QC)",
            "latex": null,
            "type": "table"
        },
        "TABREF26": {
            "text": "No. of Correctly Identified Patterns (CIP): No. of times the pattern identified correctly at the measured index; (2) No. of Incorrectly Identified Patterns (IIP): No. of times the pattern does not found at measured index; (3) No. of Incorrectly Missed Patterns (IMP): No. of times any of the correct pattern index could not be measured; and (4) Error % : No: of IIP= No: of CIP \u00fe No: of IIP",
            "latex": null,
            "type": "table"
        },
        "TABREF27": {
            "text": "Observed results of QC with error analysis in QuEST simulation for N = 512 and unequal sized patterns.",
            "latex": null,
            "type": "table"
        },
        "TABREF28": {
            "text": "The quantum counting Exact-QC and Approx.-QC are executed 10 times and majority result is considered as correct count of t i.e. either accurate value of t or estimated value of t. The obtained value of t of Exact-QC are found accurate as per actual number of pattern occurrences. As expected, we analyzed the deviations in values of t obtained after executing Approx.-QC algorithm. Therefore, to measure EnQPBEA and EnQBCEA search results, Error % of Approx.-QC case would be comparatively more than the Exact-QC case. For the case m \u00bc 1\u00f0\u00de, C \u00bc 3 \u00f0 \u00de \u00f0\u00de , we show the simulation of existing QPBE and QBCE algorithms. So, a single pattern P of length 3 f g is searched on a single core with the values of t obtained from Exact-QC and Approx.-QC. In this case, other cores are remaining idle. For the case of m \u00bc 3 Exact-QC and Approx.-QC algorithms on individual quantum cores. After obtaining the separate values of t, the algorithms EnQPBEA and EnQBCEA execute for",
            "latex": null,
            "type": "table"
        },
        "TABREF29": {
            "text": "Experimental realization of algorithms through QuEST specific simulation for equal sized pattern. desired number of search iterations. Evaluating parameters No: of CIP & No: of IIP are also evaluated separately on each core. Throughout our experimentation, including exceptional cases, we measured our search results with high probability and with relative Error % value. We performed the repeated execution of Exact-QC and Approx.-QC for some patterns of equal size TAA; TAG; TGA f g and unequal size TA; TAG; TGAC f g on individual quantum core to analyze m C \u00f0 \u00deand m . C \u00f0 \u00decases. So our analysis confirms to obtain the desired values of t on different cores, based on majority, and thus the number of GSO iterations also remains same. However for these cases, based on the evaluating parameters No: of CIP and No: of IIP, the resulting outcomes of EnQPBEA and EnQBCEA algorithms were measured with either the similarity or with slight variations. Practically, based on values of t for Exact-QC and Approx.-QC we coded p=4 ffiffiffiffiffiffiffiffi N=t p number of GSO iterations in the searching phase of EnQPBEA and EnQBCEA algorithms. There exist some deviations in the estimated value of t through Approx.-QC algorithm. So based on this t value, if p=4 ffiffiffiffiffiffiffiffi N=t piterations (rounded off to the nearest integer) remains same as by taking the t value through Exact-QC method, then we identify the same GSO iterations experimentally in both cases. However, the evaluating",
            "latex": null,
            "type": "table"
        },
        "TABREF30": {
            "text": "Experimental realization of algorithms through QuEST specific simulation for unequal sized pattern.",
            "latex": null,
            "type": "table"
        },
        "TABREF31": {
            "text": "Applications specific detail of proposed algorithm to process biological sequences. * Suitable for processing multiple patterns in an effective manner as its design utilizes multiple cores to search for P k on shared QMEM. * This performs exact search, thus it is more practicable for processing biological sequences efficiently. * All exact occurrence of each P k are found through QCore c of QPU having C cores in Suitable to search for long length patterns either formed over AE j j \u00bc 4 (DNA) or AE j j \u00bc 20 (Amino Acid), as match takes O 1 \u00f0 \u00de on QMEM. * Exponential sized text sequence is effectively search for each pattern, irrespective of text size & frequent pattern occurrence with speedup. * Sets benchmark to find multiple pattern using multicore parallelism on text withPr QCore c \u00f0 \u00de!t k =N. High probable search results may be affected on each QCore c while processing exponentially large size text with few P k occurrences. * For large alphabet set AE such as AE j j \u00bc 20 (Amino Acid), the qubits requirement is excessively high, as of now, it is restricted, however, no limitation on quantum machine. * Search time is still dependent on c th core QCore c , so, core running for the unequal sized pattern with expected more frequent occurrence, degrades algorithm performance.* The average probability of search result, with N sized text & t marked index, are proportionally increased with successive measurements. * A O 2 n \u00f0 \u00de depth ANF circuit slows down the simulation, and thus, this affects individual QCore c output. * DNA/RNA text is searched with a long length pattern. Equal and unequal pattern length is preferred on genome sequence. A sequence database for such examples are GenBank, DDBJ, EMBL. * Search for multiple amino acid pattern in protein database with prefer able moderate length patterns. This reduces the searching overhead. Example of some database are the GenBank, DDBJ, EMBL, GenPept, PROSITE, Swiss-Prot.",
            "latex": null,
            "type": "table"
        },
        "TABREF32": {
            "text": "* Multiple codon can code for same amino acid with either single or the multi locations within sequence. * DNA/RNA/Peptide & Protein sequences are preferably search with the small length pattern for simulation and no restrictions on quantum machine. * The biological text sequence database as can search for multi pattern. In example GenBank, Nucleotide database, PROSITE, GenPept, Swiss-Prot, DDBJ, EMBL. DNA/RNA/Genome/ Protein sequencing. * Preferable approach for method of multiple sequence alignment. * Motif finding, open reading frame search and codons matching with using a similarity detection/checking. * Apply over specific nucleotide or peptide sequences to deal with the local alignment. * Apply to a sequence alignment (global) on genome or protein. * Applicable on gene mapping and the exact substring matching.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "The authors are thankful to the domain researchers for sharing their ideas to extend over upcoming quantum technology. We are also thankful to the reviewers as their valuable suggestions improved the quality of the article.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ACKNOWLEDGEMENTS"
        },
        {
            "text": "C \u00bc 3 cores is used to realize a case m C \u00f0 \u00defor single pattern P j j \u00bc 1 and multiple patterns set P j j \u00bc 3. In case of single pattern, other cores will remain idle. A possible case of m . C \u00f0 \u00deis shown by taking multiple patterns set P j j \u00bc 6. For m \u00bc C \u00f0 \u00decase, we take each pattern as of equal size by considering \"open reading frame searchpatterns\" used in the codon process, thus, the pattern of length 3; 3; 3 f gcharacters is taken as TAA; TAG; TGA f g to identify stop codon. And for m . C \u00f0 \u00decase, the 3 length patterns TAA; TTT; TAG; TAC; TGA; TGC f g are searched using a multicore environment. Next, we take unequal sized patterns TA; TAG; TGAC f g to realize m \u00bc C \u00f0 \u00decase by considering the DNA regular expression based \"motif patterns\" of length 2; 3; 4 f g characters. For m . C \u00f0 \u00decase, we take the pattern of length 2; 2; 3; 3; 4; 4 f gcharacters as TA; TC; TAG; TTC; TGAC; TTCA f g . The restricted singleton set P j j \u00bc 1 is used to search single pattern ATG f g (start codon of frame) for existing algorithms. Text and pattern are encoded in binaries, but we specify our results with character file sizes. For each QCore c , we take the pattern of M k \u00c2 log 2 AE j j qubits, and sequence text of size N \u00bc 2 n indices with word length log 2 AE j j qubits. Exact pattern match is performed by exploring text on QMEM (realized by ANF), and by applying QEM circuit for comparing M \u00c2 log 2 AE j j qubits in parallel.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "annex"
        },
        {
            "text": "Our proposed algorithms EnQPBEA-MPM and EnQBCEA-MPM were simulated using the QuEST simulator. The experimental results observed during QuEST specific simulation are discussed here in the initial section. In the next section, we suggest some applications related to biological sequence processing for our proposed algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SIMULATION RESULTS AND DISCUSSION"
        },
        {
            "text": "The qubits estimation of a quantum algorithm (or equivalent quantum circuit) shows simulation possibility; however, actual qubits requirement with multiplicative constants decides, whether it is feasible or not. Thus, the performance of QuEST simulation depends on the scaling of multiplicative factors with respect to the data (qubits) processing requirement of quantum circuits. An excessive qubits requirement also limit an underlying configuration of a classical machine. This increases the CRAM workspace and classical CPU processing time with exponential increase. In general, a complete human genome sequence can be excessively large as of 2 30 \u00f0 \u00de nucleotide characters with approximately 3 \u00c2 10 9 \u00f0 \u00debase pairs which are contained in 23 chromosomes, each contains gene sequence of at least 2 15 \u00f0 \u00de DNA=RNA characters (Faro & Lecroq, 2013; Neamatollahi, 2020; Zou et al., 2015) . So, for a simulation of n qubits system, QuEST realizes 2 n variables (each need 8 bytes of double precision) in O 2 n \u00f0 \u00de classical processing time. Therefore, CRAM and a classical CPU processing time proportionally increase as with qubits requirement. For this reason, we prepared the subsets of gene sequence (SARS-CoV-2) with text file sizes of 128; 256; 512 f gcharacters by analyzing the feasible QuEST based hybrid simulation of QPU with C quantum cores accessing text T of size N on shared QMEM.ANF is actually implemented to simulate the QMEM behaviour and for the other requisite operations. Therefore, in reference to the interpretation of approximate value of t as count. In Exact-QC, we measure the accurate value of t using the register with a precision size % log 2 N qubits, and we need the register with precision size , log 2 N qubits to measure the approximate value of t through Approx.-QC (Brassard et al., 2002; Nielsen & Chuang, 2010) . So, we coded required qubits in additional register, respectively. After executing Exact-QC and Approx.-QC algorithms, values of t are obtained. And then the algorithm EnQPBEA executes p=4 ffiffiffiffiffiffiffiffi N=t p and EnQBCEA executes p=4 ffiffiffiffiffiffiffi t=t 0 p no. of GSO iterations to obtain relative search results. We include the error analysis with the exact value of t Exact-QC and with the approximate value of t (Approx.-QC) in Tables 11-16 . For evaluating the accuracy of search results, we include error analysis with Exact-QC and Approx.-QC cases. So for each pattern, after obtaining the value of t from Exact-QC and Approx.-QC, we repeat EnQPBEA and EnQBCEA algorithms 10 times separately on the individual quantum core. Each repetition completes 100 iterations of algorithms, and after each iteration, we perform the measurement on each core to obtain the search result. Instead of taking the average of 10 times, we have noted the results from Tables 11-16 by taking a summation of 10 repeated executions (each (2) With the reduced search space of size t there exist a possibility of actual pattern occurrences t 0 ffi t=2 (approximately equal to half). In this case, GSO iterations used in EnQBCEA algorithms will realize the problem of balanced function i.e. the pattern occurrence may be checked on the random selection of index from filtered indices. Therefore, the probability of measuring the search result would remain approximately uniform, and it actually generates less accurate results. And in the same exceptional cases, the Error % can also be observed as more. Based on evaluation parameters No: of CIP and No: of IIP the search results of EnQBCEA are obtained well than the EnQPBEA algorithm because of the searching is performed on the filtered indices (reduced search space) rather than the entire available search space which is used by the EnQPBEA algorithm. However, on processing overlapped pattern P 2 \u00bc TTT f gfor m . C \u00f0 \u00decase, we noted the worst outcome of quantum approximate filtering (QAF). Tables 11-13 are showing the improvement in the obtained results. Therefore, in the hypothetical assumption, we may expect the search results of EnQBCEA algorithm with less Error % than the search results of EnQPBEA algorithm.",
            "cite_spans": [
                {
                    "start": 827,
                    "end": 848,
                    "text": "(Faro & Lecroq, 2013;",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 849,
                    "end": 868,
                    "text": "Neamatollahi, 2020;",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 869,
                    "end": 886,
                    "text": "Zou et al., 2015)",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 1799,
                    "end": 1822,
                    "text": "(Brassard et al., 2002;",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1823,
                    "end": 1846,
                    "text": "Nielsen & Chuang, 2010)",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [
                {
                    "start": 2298,
                    "end": 2310,
                    "text": "Tables 11-16",
                    "ref_id": null
                }
            ],
            "section": "Simulation detail and analysis with algorithms evaluation criteria"
        },
        {
            "text": "For our algorithms EnQPBEA-MPM and EnQBCEA-MPM, Tables 17 and 18 are used to categorize the results between separate text file sizes 128; 256; 512 f gand analysis cases m C \u00f0 \u00deand m . C \u00f0 \u00deformed for the equalunequal sized multiple pattern set P \u00bc P 1 ; P 2 ; P 3 ; P 4 ; P 5 ; P 6 f g of lengths 3; 3; 3; 3; 3; 3 f gand 2; 2; 3; 3; 4; 4 f g . A QPU with quantum cores C \u00bc C 1 ; C 2 ; C 3 f gis considered for the separate execution of desired pattern search. Tables 17 and 18 Tables 11-16 . We evaluated these parameters for the existing QPBE and QBCE algorithms. So, a single pattern P of length {3} is executed on single core to simulate the case m \u00bc 1\u00de . In this case, other cores are remaining idle. The case m \u00bc 3\u00de is considered for searching a desired pattern on individual quantum core. So, Avg: ET is separately noted, but the CRAM workspace is shared QMEM. The search time to find all occurrences of the individual patterns overlapped implicitly. Based on several complexity analysis factors, our proposed quantum algorithms EnQPBEA-MPM and EnQBCEA-MPM are proved efficient to find exact patterns while comparing with existing multiple pattern methods such as QEMP and QAMP as their quantum design cannot exclude multiplicative factor m. A design of presented algorithms uses architectural parallelism, but with a multiplicative constant m=C. This factor can be negligible for small arbitrary constant value of m and constant value of C. However, for comparatively large value of m ) C, a factor m=C cannot be ignored in the time complexities. Similarly, due to an implicit operational parallelism, the logarithmic factor is found negligible when the original or filtered search space remains too small to expand in superposition. However, this logarithmic factor cannot be ignored with large number of qubits. Indeed, our proposed algorithms are preferred effectively for finding the few pattern occurrences. Therefore, to process the exponentially large size biological text sequences, our O m=C\u00c1 time quantum solutions are efficient, and they outperform over existing classical as well as quantum solutions by achieving speedups. The algorithms are justified, based on mathematical proves, as equivalent to quantum circuits. To obtain the accurate search results, quantum counting is explicitly added to the functionality of proposed algorithms. We suggested specific applications of these algorithms related to biological sequence processing.The quantum algorithms are validated through restricted simulation performance. We used Exact-QC to measure exact value of t and to validate the accurate search results. However, we analyzed the deviations and less accurate search results by combining Approx.-QC and GSO operator. The possible cases m C \u00f0 \u00deand m . C \u00f0 \u00dewere used in our experimentation to observe the variations in search results. Indeed, our intentions were not to analyze the simulation efficiency; therefore, as per the feasibility, we presented the hybrid simulation to realize quantum operations of the algorithm on the classical machine. However, we seek their efficient execution on the real quantum machine to observe the high-performance computation aspects. Further, the proposed work can be extended possibly either to replace filtering approximations of EnQBCEA with exactness or to modify this using other error metric methods to increase accuracy. The open problems would be the realizations of multiple oracles in parallel on a single quantum core, such that the multiplicative factors can be completely removed, and the design of search method through phase matching as replacement of amplitude amplification.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 460,
                    "end": 476,
                    "text": "Tables 17 and 18",
                    "ref_id": null
                },
                {
                    "start": 477,
                    "end": 489,
                    "text": "Tables 11-16",
                    "ref_id": null
                }
            ],
            "section": "Analysis of experimental results obtained during QuEST simulation:"
        },
        {
            "text": "The authors received no funding for this work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ADDITIONAL INFORMATION AND DECLARATIONS Funding"
        },
        {
            "text": "The authors declare that they have no competing interests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Competing Interests"
        },
        {
            "text": "Kapil Kumar Soni conceived and designed the experiments, performed the experiments, analyzed the data, performed the computation work, prepared figures and/or tables, authored or reviewed drafts of the paper, quantum algorithm design & analysis, and writing of complexity proofs, and approved the final draft. Akhtar Rasool analyzed the data, authored or reviewed drafts of the paper, and approved the final draft.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Author Contributions"
        },
        {
            "text": "The following information was supplied regarding data availability:The sequences are available at Genbank: MW687138. The QuEST Simulation Codes are available at GitHub: https://github.com/profkapilsoni/EnQPBEA-and-EnQBCEA-Algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Availability"
        },
        {
            "text": "Supplemental information for this article can be found online at http://dx.doi.org/10.7717/ peerj-cs.957#supplemental-information.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Supplemental Information"
        }
    ]
}