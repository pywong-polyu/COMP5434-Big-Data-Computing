{
    "paper_id": "b627862512a66f85bca765635969fc96d72662e2",
    "metadata": {
        "title": "On CDCL-Based Proof Systems with the Ordered Decision Strategy",
        "authors": [
            {
                "first": "Nathan",
                "middle": [],
                "last": "Mull",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Chicago",
                    "location": {
                        "settlement": "Chicago",
                        "country": "USA"
                    }
                },
                "email": "nmull@cs.uchicago.edu"
            },
            {
                "first": "Shuo",
                "middle": [],
                "last": "Pang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Chicago",
                    "location": {
                        "settlement": "Chicago",
                        "country": "USA"
                    }
                },
                "email": "spang@math.uchicago.edu"
            },
            {
                "first": "Alexander",
                "middle": [],
                "last": "Razborov",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Chicago",
                    "location": {
                        "settlement": "Chicago",
                        "country": "USA"
                    }
                },
                "email": "razborov@cs.uchicago.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "We prove that CDCL SAT-solvers with the ordered decision strategy and the DECISION learning scheme are equivalent to ordered resolution. We also prove that, by replacing this learning scheme with its opposite, which learns the first possible non-conflict clause, they become equivalent to general resolution. In both results, we allow nondeterminism in the solver's ability to perform unit propagation, conflict analysis, and restarts in a way that is similar to previous works in the literature. To aid the presentation of our results, and possibly future research, we define a model and language for CDCL-based proof systems -particularly those with nonstandard features -that allow for succinct and precise theorem statements.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Since their conception, SAT-solvers have become significantly more efficient, but they have also become significantly more complex. Consequently, there has been increasing interest in understanding their theoretical limitations and strengths. Much of the recent literature has focused on the relationship between CDCL SAT-solvers 1 and the resolution proof system. Beame et al. [5] were the first to study this relationship and many followed suit (see [3, 6, 7, 11, [13] [14] [15] [17] [18] [19] [20] among others). In particular, Pipatsrisawat and Darwiche [18] show that, under a few assumptions, CDCL with the nondeterministic decision strategy (i.e., when the solver has to choose a variable to assign, it chooses both the variable and its assigned value nondeterministically) polynomially simulates resolution. An obvious question arises from this result: how much does the theoretical efficiency of CDCL depend on nondeterminism in the decision strategy? Along these lines, Atserias et al. [3] (concurrently with [18] ) show that CDCL with the random decision strategy (i.e., both the variable and assigned value are chosen uniformly at random) simulates bounded-width resolution, under essentially the same assumptions as those in [18] . More recently, Vinyals [20] has shown that CDCL with the VSIDS decision strategy -among other common dynamic decision strategies -does not simulate general resolution. We attempt to make progress on this question by studying a simple decision strategy that we call the ordered decision strategy. This strategy is identical to the one studied by Beame et al. [4] in the context of DPLL without clause learning. It is defined naturally: when the solver has to choose a variable to assign, it chooses the smallest unassigned variable according to some fixed order and chooses its assigned value nondeterministically. If unit propagation is used, the solver may assign variables out of order; a unit clause does not necessarily correspond to the smallest unassigned variable. This possibility of \"cutting the line\" is precisely what makes the situation more subtle and nontrivial. Thus, our motivating question is the following:",
            "cite_spans": [
                {
                    "start": 378,
                    "end": 381,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 452,
                    "end": 455,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 456,
                    "end": 458,
                    "text": "6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 459,
                    "end": 461,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 462,
                    "end": 465,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 466,
                    "end": 470,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 471,
                    "end": 475,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 476,
                    "end": 480,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 481,
                    "end": 485,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 486,
                    "end": 490,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 491,
                    "end": 495,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 496,
                    "end": 500,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 558,
                    "end": 562,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 996,
                    "end": 999,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1019,
                    "end": 1023,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1238,
                    "end": 1242,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1268,
                    "end": 1272,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1603,
                    "end": 1606,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Is there a family of contradictory CNFs {\u03c4 n } \u221e n=1 that possess polynomial size resolution refutations but require superpolynomial time for CDCL using the ordered decision strategy?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We also note in passing that this question may be motivated as a way of understanding the strength of static decision strategies such as MINCE [1] and FORCE [2] .",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 146,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 157,
                    "end": 160,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our Contributions. A proof system that captures any class of CDCL solvers should be no stronger than general resolution, and if it captures solvers with the ordered decision strategy, it should be reasonably expected to be at least as strong as ordered resolution with respect to the same order. Our main results show that, depending on the learning scheme employed, both of these extremes are attained. More specifically, we prove 1. CDCL with the ordered decision strategy and a learning scheme we call DECISION-L is equivalent to ordered resolution (Theorem 1). In particular, it does not simulate general resolution. 2. CDCL with the ordered decision strategy and a learning scheme we call FIRST-L is equivalent to general resolution (Theorem 2).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As the name suggests, DECISION-L is the same as the so-called DECI-SION learning scheme. 2 FIRST-L is a learning scheme designed to directly simulate particular resolution steps in the presence of certain forms of nondeterminism, and is similar to FirstNewCut [5] . In the full version of this paper [16] , we also prove linear width lower bounds which, combined with the second result, create a sharp contrast with the size-width relationship for general resolution proved by Ben-Sasson and Wigderson [8] .",
            "cite_spans": [
                {
                    "start": 260,
                    "end": 263,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 300,
                    "end": 304,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 502,
                    "end": 505,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "In these two results, the CDCL solver may arbitrarily choose the conflict/unit clause if there are several, may elect not to do conflict analysis/unit propagations at all, and may restart at any time. This substantial amount of nondeterminism allows us to identify two proof systems that are, more or less straightforwardly, equivalent to the corresponding CDCL variant. Determining the exact power of these systems constitutes our main technical contribution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "There are a couple points of interpretation to emphasize here. First, the implicit separation between CDCL solvers and general resolution in the first result applies to actual SAT-solver implementations, albeit with heuristics that are not usually used in practice, and could, in principle, be demonstrated by experiment. In contrast, the second result does not say anything substantial about actual SAT-solver implementations. But we also note that this is not unprecedented. The correspondence between proof systems and algorithms considered here is very similar to the correspondence between regWRTI and a variant of CDCL with similar features called DLL-LEARN, both introduced by Buss et al. [11] ; nonstandard sources of nondeterminism manifest themselves naturally when translating CDCL into a proof system. Both lower and upper bounds on these systems are valuable; even if upper bounds do not apply directly to practice, they demonstrate, often nontrivially, what convenient features of simple proof systems must be dropped to potentially prove separations.",
            "cite_spans": [
                {
                    "start": 696,
                    "end": 700,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "Finally, in order to aid the above work -and, perhaps, even facilitate further research in the area -we present a model and language for studying CDCL-based proof systems. This model is not meant to be novel, and is heavily influenced by previous work [3, 13, 17] . However, the primary goal of our model is to highlight possible nonstandard sources of nondeterminism in variants of CDCL, as opposed to creating a model completely faithful to applications. Our second result (Theorem 2) can be written in this language as:",
            "cite_spans": [
                {
                    "start": 252,
                    "end": 255,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 256,
                    "end": 259,
                    "text": "13,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 260,
                    "end": 263,
                    "text": "17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "For any order \u03c0, CDCL(FIRST-L, \u03c0-D) is polynomially equivalent to general resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "Due to space limitations, not all proofs are provided and there may be excluded details or remarks that, though not essential, are useful in understanding possible subtleties in the constructions and arguments. After presenting the preliminary material in Sect. 2, we give an nearly complete account of our first result mentioned above in Sect. 3, and reflect very briefly on our second result in Sect. 4. We refer the reader to the full version of this paper [16] for complete proofs and extended discussion.",
            "cite_spans": [
                {
                    "start": 460,
                    "end": 464,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "Throughout the paper, we assume that the set of propositional variables is fixed as V def = {x 1 , . . . , x n }. A literal is either a propositional variable or its negation. We will sometimes use the abbreviation x 0 forx and x 1 for x (so that the Boolean assignment x = a satisfies the literal x a ). A clause is a set of literals, thought of as their disjunction, in which no variable appears together with its negation. For a clause C, let Var(C) denote the set of variables appearing in C. A CNF is a set of clauses thought of as their conjunction. For a CNF \u03c4 , let Var(\u03c4 ) denote the set of variables appearing in \u03c4 , i.e., the union of Var(C) for all C \u2208 \u03c4 . We denote the empty clause by 0. The width of a clause is the number of literals in it. The resolution proof system is a Hilbert-style proof system whose lines are clauses and that has only one resolution rule",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We will sometimes denote the result of resolving C \u2228x a i and D \u2228x 1\u2212a",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "). The size of a resolution proof \u03a0, denoted as |\u03a0|, is the number of lines in it. For a CNF \u03c4 and a clause C, let S R (\u03c4 C) denote the minimal possible size of a resolution proof of the clause C from clauses in \u03c4 (\u221e if C is not implied by \u03c4 ). Likewise, let w(\u03c4 C) denote the minimal possible width of such a proof, defined as the maximal width of a clause in it. For a proof \u03a0 that derives C from \u03c4 , the clauses in \u03c4 that appear in \u03a0 are called axioms, and if C = 0 then \u03a0 is called a refutation. Let Var(\u03a0) denote the set of variables appearing in \u03a0, i.e., the union of Var(C) for C appearing in \u03a0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Note that the weakening rule",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "is not included by default. In the full system of resolution it is admissible in the sense that S R (\u03c4 0) does not change if we allow it. But this will not be the case for some of the CDCL-based fragments we will be considering below. Despite this, it is often convenient in analysis to consider intermediate systems that do allow the weakening rule. We make it clear when we do this by adding the annotation '+ weakening' to the system.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Our results depend on the careful analysis of the structure of resolution proofs. It will, for example, be useful for us to maintain structural properties of the proof while changing the underlying clauses and derivations. Definition 1. For a resolution + weakening proof \u03a0, its resolution graph, G(\u03a0), is an acyclic directed graph representing \u03a0 in the natural way: each clause in \u03a0 has a distinguished node, and for each node there are incoming edges from the nodes corresponding to the clauses from which it is derived. The set of nodes of G(\u03a0) is denoted by V (\u03a0), and the clause at v \u2208 V (\u03a0) is denoted by c \u03a0 (v). 3 In the following collection of definitions, let \u03a0 be an arbitrary resolution + weakening proof and let S be an arbitrary subset of V (\u03a0). A vertex u is above a vertex v in G(\u03a0), written u > v, if there is a directed path from v to u. We also say v is below u. Moreover, v is a parent of u if (v, u) is an edge in G(\u03a0). S is independent if any two of its nodes are incomparable. The maximal and minimal nodes of S are max \u03a0 S def = {v \u2208 S | \u2200u \u2208 S (\u00ac(v < u))} and min \u03a0 S def = {v \u2208 S | \u2200u \u2208 S (\u00ac(v > u))}, respectively. The upward closure and",
            "cite_spans": [
                {
                    "start": 620,
                    "end": 621,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Resolution Graphs."
        },
        {
            "text": "if it contains either both parents or neither parent of each of its nodes. S is pathcomplete if it contains all nodes along any path in G(\u03a0) whose endpoints are in S. A resolution graph is connected if | max \u03a0 V (\u03a0)| = 1, i.e., it has a unique sink. These definitions behave naturally, as demonstrated by the following useful proposition, which is easily verified.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Resolution Graphs."
        },
        {
            "text": ", let Var k \u03c0 denote the k smallest variables according to \u03c0. A clause C is k-small with respect to \u03c0 if Var(C) \u2286 Var k \u03c0 . The proof system \u03c0-ordered resolution is the subsystem of resolution defined by imposing the following restriction on the resolution rule (1):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 1. Let S \u2286 V (\u03a0) be a nonempty set of nodes that is both parentcomplete and path-complete. Then the induced subgraph of"
        },
        {
            "text": "In the literature this system is usually defined differently, namely in a top-down manner (see, e.g., [10] ). It is easy to see, however, that our version is equivalent.",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 106,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Proposition 1. Let S \u2286 V (\u03a0) be a nonempty set of nodes that is both parentcomplete and path-complete. Then the induced subgraph of"
        },
        {
            "text": "Our approach to modeling CDCL is, in a sense, the opposite of what currently exists in the literature. Rather than attempting to model CDCL solver implementations as closely as possible and allowing nondeterminism in various features, we rigorously describe a basic model that is very liberal and nondeterministic and intends to approximate the union of most conceivable features of CDCL solvers. Then models of actual interest will be defined by their deviations from the basic model. Due to space limitations, we present our model rather tersely (see the full version of this paper [16] for further details).",
            "cite_spans": [
                {
                    "start": 584,
                    "end": 588,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "CDCL-Based Proof Systems."
        },
        {
            "text": "A few more definitions are in order before proceeding. A unit clause is a clause consisting of a single literal. An assignment is an expression of the form x i = a where 1 \u2264 i \u2264 n and a \u2208 {0, 1}. A restriction \u03c1 is a set of assignments in which all variables are pairwise distinct. Let Var(\u03c1) denote the set of all variables appearing in \u03c1. Restrictions naturally act on clauses, CNFs, and resolution proofs; we denote the result of this action by C| \u03c1 , \u03c4 | \u03c1 , and \u03a0| \u03c1 , respectively. An annotated assignment is an expression of the form x i * = a where 1 \u2264 i \u2264 n, a \u2208 {0, 1}, and * \u2208 {d, u}. See Definition 3 below for details about these annotations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CDCL-Based Proof Systems."
        },
        {
            "text": "The underlying structure of our model is a labeled transition system whose states represent data maintained by a CDCL solver during runtime and whose labeled transitions are possible actions taken by a solver during runtime. We first define explicitly what constitutes a state. We now describe the core of our (or, for that matter, any other) model, that is, transition rules between states. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CDCL-Based Proof Systems."
        },
        {
            "text": "-U (S) consists of all those assignments x i u = a for which \u03c4 | t contains the unit clause x a i ; the transition function is given by the same formula (2) but with a different annotation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "(3)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": ". By reverse induction on k = r + 1, . . . , 1 we define the set C k (S) that, intuitively, is the set of clauses that can be learned by backtracking up to the prefix t[\u2264 k]. We let",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "4 Restarts will be treated as a part of the learning scheme.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "be the set of all conflict clauses. For 1 \u2264 k \u2264 r, we do the following: if the kth assignment of t is of the form",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "= a k , and we build up C k (S) by processing every clause D \u2208 C k+1 (S) as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "\u2022",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "To make sure that this definition is sound, we have to guarantee that C and D are actually resolvable (that is, they do not contain any other conflicting variables but x i k ). For that we need the following observation, easily proved by reverse induction on k, simultaneously with the definition:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "Finally, we let",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "This completes the description of the basic model. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "where A k \u2208 Actions(S k ). In other words, a partial run is a labeled path in \u0393 n . A successful run is a partial run from (\u03c4, \u039b) to a terminal state. A CDCL solver is a partial function 6 \u03bc on S o n such that \u03bc(S) \u2208 Actions(S) whenever \u03bc(S) is defined. The above remarks imply that when we repeatedly apply a CDCL solver \u03bc starting at any initial state (\u03c4, \u039b), it will always result in a finite sequence like (5) , with T being a terminal state (successful run) or such that \u03bc(T ) is undefined (failure).",
            "cite_spans": [
                {
                    "start": 410,
                    "end": 413,
                    "text": "(5)",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "Theoretical analysis usually deals with classes (i.e., sets) of individual solvers rather than with individual implementations. We define such classes by prioritizing and restricting various actions. , where x i is the smallest variable with respect to \u03c0 that does not appear in t. Note that this amendment does not have any effect on U (S), and our main technical contributions can be phrased as answering under which circumstances this \"loophole\" can circumvent the severe restriction placed on the set D(S). NEVER-R In the definition (4), we require that t * is the longest prefix of t satisfying C| t * = 0 (in which case C| t * is necessarily a unit clause). As described, this amendment does not model nonchronological backtracking or require that the last assignment in the trail is a decision. However, this version is easier to state and it is not difficult to modify it to have the aforementioned properties. WIDTH-w, where w is an integer In the definition (4), we keep in C(S) \\ C only clauses of width \u2264 w. Note that this amendment still allows us to use wide clauses as intermediate results within a single clauses learning step.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "Thus, our preferred way to specify local classes of solvers and the corresponding proof systems is by listing one or more amendments, with the convention that their effect is cumulative: an action is removed from Actions(S) if and only if it should be removed according to at least one of the amendments present. More formally, Definition 6. For a finite set A 1 , . . . , A r of polynomial-time computable 7 amendments, we let CDCL (A 1 , . . . , A r ) be the (possibly incomplete) proof system whose proofs are those successful runs in which none of the actions A i is affected by any of the amendments A 1 , . . . , A r .",
            "cite_spans": [
                {
                    "start": 407,
                    "end": 408,
                    "text": "7",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 433,
                    "end": 453,
                    "text": "(A 1 , . . . , A r )",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "Using this language, the main result from [18] can be very roughly summarized as Finally, we would like to mention the currently open question about the exact strength of CDCL without restarts. This is one of the most interesting open questions in the area and has been considered heavily in the literature (see [6, 9, 11, 12, 15, 19] among others). It may be abstracted as",
            "cite_spans": [
                {
                    "start": 42,
                    "end": 46,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 312,
                    "end": 315,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 316,
                    "end": 318,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 319,
                    "end": 322,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 323,
                    "end": 326,
                    "text": "12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 327,
                    "end": 330,
                    "text": "15,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 331,
                    "end": 334,
                    "text": "19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Definition 2. A trail is an ordered list of annotated assignments in which all variables are pairwise distinct. A trail acts on clauses, CNFs, and proofs just in the same way as does the restriction obtained from it by disregarding the order and the annotations on assignments. For a trail t and an annotated assignment"
        },
        {
            "text": "For both open questions mentioned above, we have taken the liberty of removing those amendments that do not appear immediately relevant.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Does CDCL(ALWAYS-C, ALWAYS-U, NEVER-R) (or at least CDCL(NEVER-R)) simulate general resolution?"
        },
        {
            "text": "At this point, since we discuss our main results in the introduction, we formulate them here more or less matter-of-factly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Does CDCL(ALWAYS-C, ALWAYS-U, NEVER-R) (or at least CDCL(NEVER-R)) simulate general resolution?"
        },
        {
            "text": "For any fixed order \u03c0 on the variables, the system CDCL (DECISION-L, \u03c0-D) is polynomially equivalent to \u03c0-ordered resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1."
        },
        {
            "text": "For any fixed order \u03c0 on the variables, the system CDCL (FIRST-L, \u03c0-D) is polynomially equivalent to general resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2."
        },
        {
            "text": "The proof of Theorem 1 is divided into two parts: we prove that each system is equivalent to an intermediate system we call \u03c0-half-ordered resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CDCL(DECISION-L, \u03c0-D) = p \u03c0-Ordered Resolution"
        },
        {
            "text": "Recall that, for the system \u03c0-ordered resolution, the variable that is resolved on must be \u03c0-maximal in each antecedent. In \u03c0-half-ordered resolution, this is required of at least one of the antecedents. That is, \u03c0-half-ordered resolution is the subsystem of resolution defined by imposing the restriction (\u2200l \u2208 C (\u03c0(l) < \u03c0(x i ))) \u2228 (\u2200l \u2208 D (\u03c0(l) < \u03c0(x i ))) on the resolution rule (1). Clearly, \u03c0-half-ordered resolution simulates \u03c0-ordered resolution but, somewhat surprisingly, it doesn't have any additional power over it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CDCL(DECISION-L, \u03c0-D) = p \u03c0-Ordered Resolution"
        },
        {
            "text": "For any fixed order \u03c0 on the variables, \u03c0-ordered resolution is polynomially equivalent to \u03c0-half-ordered resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "We prove Theorem 3 by applying a sequence of transformations to a \u03c0-halfordered refutation that, with the aid of the following definition, can be shown to make it incrementally closer to a \u03c0-ordered resolution refutation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "The \u03c0-ordered refutations are then precisely those that are \u03c0-ordered up to n \u2212 1. Now in order for these transformations not to blow up the size of the refutation, we need to carefully keep track of its structure throughout the process. As such, the proof of Theorem 3 depends heavily on resolution graphs and related definitions introduced in Sect. 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 7. A resolution refutation is \u03c0-ordered up to k if it satisfies the property that if any two clauses are resolved on a variable x i \u2208 Var k \u03c0 , then all resolution steps above it are on variables in Var"
        },
        {
            "text": "Proof. Let \u03a0 be a \u03c0-half-ordered resolution refutation of \u03c4 . Without loss of generality, assume \u03c0 = id; otherwise, rename variables. We will construct by induction on k (satisfying 0 \u2264 k \u2264 n \u2212 1) a \u03c0-half-ordered resolution refutation \u03a0 k of \u03c4 which is ordered up to k. For the base case, let \u03a0 0 def = \u03a0. Suppose now \u03a0 k has been constructed. Without loss of generality, assume that \u03a0 k is connected; otherwise, take the subrefutation below any occurrence of 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 7. A resolution refutation is \u03c0-ordered up to k if it satisfies the property that if any two clauses are resolved on a variable x i \u2208 Var k \u03c0 , then all resolution steps above it are on variables in Var"
        },
        {
            "text": "Consider the set of nodes whose clauses are k-small. Note that this set is parent-complete. We claim that it is also upward-closed and, hence, pathcomplete. Indeed, let u be a parent of v and assume that c \u03a0 k (u) is k-small. Then, since we disallow weakenings, c \u03a0 k (v) is obtained by resolving on a variable x i \u2208 Var k \u03c0 . Since \u03a0 k is ordered up to k, it follows that Var(c \u03a0 k (v)) \u2286 Var i\u22121 \u03c0 \u2286 Var k \u03c0 ; otherwise, some variable in c \u03a0 k (v) would have remained unresolved on a path connecting v to the sink (here we use the fact that \u03a0 k is connected). Hence c \u03a0 k (v) is also k-small.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 7. A resolution refutation is \u03c0-ordered up to k if it satisfies the property that if any two clauses are resolved on a variable x i \u2208 Var k \u03c0 , then all resolution steps above it are on variables in Var"
        },
        {
            "text": "Furthermore, L k splits \u03a0 k into two parts, i.e.,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Let D denote the subproof on dcl \u03a0 k (L k ) and let U denote the subrefutation on ucl \u03a0 k (L k ). Note that D is comprised of all nodes in \u03a0 that are labeled by a clause that is not k-small or belong to L k , and U is comprised of all nodes labeled by a k-small clause. In particular, all axioms are in D, all resolutions in U are on the variables in Var k \u03c0 , and, since \u03a0 k is ordered up to k, all resolutions in D are on the variables not in Var k \u03c0 . Define",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "We will eliminate all resolutions on x k+1 in D by the following process, during which the set of nodes stays the same, while edges and clause-labeling function possibly change. More precisely, we update D in s rounds, defining a sequence of \u03c0-half-ordered resolution + weakening proofs Claim. In the following properties, let u and v be arbitrary vertices in V (D).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "a. If v is not above u in D, then the same is true in",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "and, moreover, this clause is obtained in D i\u22121 with the same resolution as in D; d. D i\u22121 is a \u03c0-half-ordered resolution + weakening proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Let us construct D i from D i\u22121 . By property (c) and the fact that M is independent, the resolution step at w i is unchanged from D to D i\u22121 . Let w and w denote the parents of w i in D and let c D (w ) = B \u2228x k+1 and c D (w ) = C \u2228x k+1 . Since \u03a0 k is \u03c0-half-ordered, either B or C is k-small. Assume without loss of generality that B is k-small.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Recall that there is no resolution in D on variables in Var k \u03c0 . Thus, for all v \u2208 A i , it follows that B is a subclause of c D (v), and by property (b), we have the following crucial property:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "By property (a), A i remains upward closed in D i\u22121 . Accordingly, as the first step, for any v \u2208 A i we set c i (v):=c i\u22121 (v) and we leave its incoming edges unchanged.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Next, we update vertices v \u2208 A i in an arbitrary D-topological order maintaining the property that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "First we set c i (w i ):=c i\u22121 (w i ) \u2228 x k+1 and replace the incoming edges by a weakening edge from w . This is possible since c i\u22121 (w i ) = c D (w i ) by property (c) and, hence, does not contain x k+1 by virtue of being in M .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "For v \u2208 A i \\ {w i }, we proceed as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "1. If x k+1 \u2208 c i\u22121 (v), keep the clause but replace incoming edges with a weakening edge (w , v). This is well-defined by (8) . Also, since w < w < v in D, we maintain property (a).",
            "cite_spans": [
                {
                    "start": 123,
                    "end": 126,
                    "text": "(8)",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "-and replace incoming edges by a weakening edge (u, v).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "In other words, we append the literal x k+1 to c i (v) if and only if this was previously done for c i (u).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": ") that is, like in the previous item, we append x k+1 if and only if it was previously done for either c i (v) or c i (w). Since > k + 1, this step remains \u03c0-half-ordered.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "This completes our description of D i . It is straightforward to verify that D s is a \u03c0-half-ordered resolution + weakening proof without resolutions on x k+1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "To finally construct \u03a0 k+1 , we reconnect D s to U along L k and then remove any weakenings introduced in D s . This may require adding new nodes, as it may be the case that c s (v) = c D (v) for some v \u2208 L k . But, in this case, it is straightforward to verify, using (8) , that there is a vertex w \u2208 dcl D (M ) \\ {M } such that c D (v) = Res(c s (w), c s (v)) on x k+1 , and this resolution is half-ordered. In fact, w can be taken to be a parent in D of some nodes in M . Thus, when necessary we add to D s a new node\u1e7d labeled by Res(c s (w), c s (v)) and add the edges (v,\u1e7d) and (w,\u1e7d).",
            "cite_spans": [
                {
                    "start": 269,
                    "end": 272,
                    "text": "(8)",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Denote by \u03a0 k+1 the result of connecting D s and U along the vertices in L k and this newly added collection of vertices. Since neither D s nor U contain resolutions on x k+1 except for those in the derivations of the clauses just added to D s , it follows that \u03a0 k+1 is a \u03c0-half-ordered resolution + weakening refutation that is ordered up to k + 1. Let \u03a0 k+1 be obtained by contracting all weakenings.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "It only remains to analyze its size (note that a priori it can be doubled at every step, which is unacceptable). Since",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "we only have to control |L k |. For that we will keep track of the invariant |dcl \u03a0 k (L k )|; more precisely, we claim that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Let us prove this by constructing an injection from dcl \u03a0 k+1 (L k+1 ) to dcl \u03a0 k (L k ); we will utilize the notation from above. First note that the resolution + weakening refutation \u03a0 k+1 and its weakening-free contraction \u03a0 k+1 can be related as follows. For every node",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "which is minimal among those contracting to v. If v is an axiom node of \u03a0 k+1 then so is v * in\u03a0 k+1 . Otherwise, if u and w are the two parents of v, and if u and w are the corresponding parents of v * (v * may not be obtained by weakening due to the minimality assumption), then c \u03a0 k+1 (u * ) is a subclause of c \u03a0 k+1 (u ) and c \u03a0 k+1 (w * ) is a subclause of c \u03a0 k+1 (w ). We claim that (v \u2192 v * ) | dcl\u03a0 k+1 (L k+1 ) (which is injective by definition) is the desired injection. We have to check that its image is contained in dcl \u03a0 k (L k ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Fix v \u2208 dcl \u03a0 k+1 (L k+1 ). Then by definition of L k , either v is an axiom or both its parents are not (k + 1)-small. By the above mentioned facts about the contraction \u03a0 k+1 \u2192 \u03a0 k+1 , this property is inherited by v * . In particular, v * \u2208 {w | w \u2208 L k } as all nodes in this set have at least one (k + 1)-small parent due to half-orderedness. Finally, since the corresponding clauses in D and D s differ only in the variable x k+1 , v * cannot be in U , for the same reason (recall that all axioms are in D).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "Having thus proved (10), we conclude by the obvious induction that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "At last, we must show the equivalence holds for the corresponding CDCL system. We provide a sketch of the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "By Proposition 1, this set defines a subrefutation of the clauses labeling the independent set"
        },
        {
            "text": "For any fixed order \u03c0 on the variables, CDCL(\u03c0-D, DECISION-L) is polynomially equivalent to \u03c0-half-ordered resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "Proof. As above, assume \u03c0 = id. The fact that CDCL(\u03c0-D, DECISION-L) polynomially simulates \u03c0-half ordered resolution is almost trivial. A \u03c0-half-ordered resolution step deriving Res(C \u2228 x i , D \u2228 x i ) can be directly simulated by constructing a trail t that falsifies C \u2228 D and contains a single unit propagation on x i . This is possible since C or D is i-small. Then C \u2228 D can be easily learned using t.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "The other direction is just slightly more involved. It suffices to show that for a learning step (\u03c4, t)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "=\u21d2 (\u03c4 \u222a{D}, t * ), there is a short \u03c0-half-ordered resolution proof of D from \u03c4 . Any learned clause can be thought of naturally as the result of a sequence of resolutions; there are clauses C 1 , . . . , C k+1 in \u03c4 and variables x i1 , . . . , x i k assigned by unit propagation in t from which we can inductively define",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "where C j and C j+1 are resolvable on x ij and D = C 1 . These resolutions may not all be \u03c0-half-ordered, but they can be reordered and duplicated to derive the same clause while maintaining \u03c0-half-orderedness. Formally, we define by double induction a different collection of derivable clause: for \u03b3 and j in [k + 1] satisfying j < \u03b3, C \u03b3,\u03b3 def = C \u03b3 and C \u03b3,j def = Res(C j,1 , C \u03b3,j+1 ) C j,1 and C \u03b3,j+1 are resolvable on x ij C \u03b3,j+1 otherwise.",
            "cite_spans": [
                {
                    "start": 313,
                    "end": 317,
                    "text": "+ 1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "Because of \u03c0-D, the only literals appearing in C j that are potentially larger than x ij (with respect to \u03c0) are the other variables assigned by unit propagation in t and resolved on in the derivation of C 1 . One can show that the clause C j,1 is the result of \"washing out\" these other literals so that x ij appears maximally. Since all resolutions on are clauses of this form, they are all \u03c0-half-ordered. And for the learning scheme DECISION-L, the learned clause C 1 contains only decision variables in t, so this reorganizing of resolutions does not affect the final derived clause; it can be verified that C k+1,1 = C 1 = D. In total, this derivation of C k+1,1 (and, hence, D) is \u03c0-half ordered and has at most n 2 resolutions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "This result is by far the most technical. It would have been impossible to give a satisfying treatment in the space available, but in the interest of providing some idea of its formal aspects, we briefly discuss our approach. As in the previous section, the proof is divided into two parts: we prove that each system is equivalent to an intermediate system we call \u03c0-trail resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CDCL(FIRST-L, \u03c0-D) = p General Resolution"
        },
        {
            "text": "Fix an order \u03c0 on the variables. The proof system \u03c0-trail resolution is defined as follows. Its lines are either clauses or trails, where the empty trail is an axiom. It has the following rules of inference:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8."
        },
        {
            "text": ", (Decision rule) where x i is the \u03c0-smallest index such that x i does not appear in t and a \u2208 {0, 1} is arbitrary; (Learning rule) where (C \u2228 D)| t = 0, (x i * = a) \u2208 t and all other variables of C appear before x i in t.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 2,
                    "end": 17,
                    "text": "(Decision rule)",
                    "ref_id": null
                },
                {
                    "start": 116,
                    "end": 131,
                    "text": "(Learning rule)",
                    "ref_id": null
                }
            ],
            "section": "Definition 8."
        },
        {
            "text": "Without the unit propagation rule, this is just \u03c0-half-ordered resolution, modulo additional traffic in trails. It follows almost directly from its definition that \u03c0-trail resolution is polynomially equivalent to CDCL(FIRST-L, \u03c0-D) (and even CDCL(\u03c0-D)). Our main technical contribution is proving the following.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8."
        },
        {
            "text": "For any fixed order \u03c0 on the variables, \u03c0-trail resolution polynomially simulates general resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5."
        },
        {
            "text": "The key observation is that, due to the unit propagation rule, \u03c0-trail resolution becomes significantly more powerful when the underlying formula has many unit clauses. Thus, we design the simulation algorithm to output a derivation of all unit clauses appearing in the given refutation \u03a0 and then recursively apply it to gain access to more unit clauses throughout the procedure. At first glance, it might seem reasonable to recursively apply the simulation algorithm to various restrictions of \u03a0, but restriction as an operation has two flaws with regards to our objectives. First, the results of different restrictions on proofs often overlap; for example, when viewing restriction as an operation on resolution graphs, the graphs of \u03a0| xi=0 and \u03a0| xi=1 will likely share vertices from G(\u03a0). This leads to an exponential blow-up in the size of the output if one is not careful. Second, restrictions may collapse parts of the \u03a0; for example, if \u03c1 falsifies an axiom of \u03a0, then \u03a0| \u03c1 is the trivial refutation and it is impossible to extract anything from it by recursively applying our simulation algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5."
        },
        {
            "text": "To make this approach feasible, we introduce a new operator, which may be of independent interest, called variable deletion; it is an analogue of restriction for sets of variables as opposed to sets of variable assignments. This operator has the property that it always yields a nontrivial refutation (for proper subsets of variables), and its size and structure are highly regulated by the size and structure of the input refutation. This allows for a surgery-like process; we simulate small local pieces of the refutation and then stitch them together into a new global refutation. For complete details, see the full version of this paper [16] .",
            "cite_spans": [
                {
                    "start": 641,
                    "end": 645,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 5."
        },
        {
            "text": "Our work continues the line of research aimed at better understanding theoretical limitations of CDCL solvers. We have focused on the impact of decision strategies, and we have considered the simple strategy that always chooses the first available variable under a fixed ordering. We have shown that, somewhat surprisingly, the power of this model heavily depends on the learning scheme employed and may vary from ordered resolution to general resolution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "In practice, the fact that CDCL(DECISION-L, \u03c0-D, ALWAYS-C, ALWAYS-U) is not as powerful as resolution supports the observation that CDCL solvers with the ordered decision strategy are often less efficient than those with more powerful decision strategies like VSIDS. But, although DECISION-L is an asserting learning strategy, most solvers use more efficient asserting strategies like 1-UIP. A natural open question then is what can be proved if DECISION-L is replaced with some other amendment modeling a different, possibly more practical asserting learning scheme? Furthermore, what is the exact strength of CDCL(\u03c0-D, ALWAYS-C, ALWAYS-U)?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "MINCE: a static global variable-ordering for SAT and BDD",
            "authors": [
                {
                    "first": "F",
                    "middle": [
                        "A"
                    ],
                    "last": "Aloul",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [
                        "L"
                    ],
                    "last": "Markov",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Sakallah",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "International Workshop on Logic and Synthesis",
            "volume": "",
            "issn": "",
            "pages": "1167--1172",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "FORCE: a fast & easy-to-implement variable-ordering heuristic",
            "authors": [
                {
                    "first": "F",
                    "middle": [
                        "A"
                    ],
                    "last": "Aloul",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [
                        "L"
                    ],
                    "last": "Markov",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Sakallah",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Proceedings of the 13th ACM Great Lakes Symposium on VLSI",
            "volume": "",
            "issn": "",
            "pages": "116--119",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Clause-learning algorithms with many restarts and bounded-width resolution",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Atserias",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "K"
                    ],
                    "last": "Fichte",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Thurley",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "J. Artif. Intell. Res",
            "volume": "40",
            "issn": "",
            "pages": "353--373",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The efficiency of resolution and Davis-Putnam procedures",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Beame",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Karp",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Pitassi",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Saks",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "SIAM J. Comput",
            "volume": "31",
            "issn": "4",
            "pages": "1048--1075",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Towards understanding and harnessing the potential of clause learning",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Beame",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kautz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sabharwal",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "J. Artif. Intell. Res",
            "volume": "22",
            "issn": "",
            "pages": "319--351",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Non-restarting SAT solvers with simple preprocessing can efficiently simulate resolution",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Beame",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sabharwal",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence",
            "volume": "",
            "issn": "",
            "pages": "2608--2615",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Lower bounds for width-restricted clause learning on small width formulas",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ben-Sasson",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Johannsen",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "SAT 2010",
            "volume": "6175",
            "issn": "",
            "pages": "16--29",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-14186-7_4"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Short proofs are narrow -resolution made simple",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ben-Sasson",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wigderson",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "J. ACM",
            "volume": "48",
            "issn": "2",
            "pages": "149--169",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Improved separations of regular resolution from clause learning proof systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Bonet",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Buss",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Johannsen",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "J. Artif. Intell. Res",
            "volume": "49",
            "issn": "",
            "pages": "669--703",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "On the relative complexity of resolution refinements and cutting planes proof systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Bonet",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "L"
                    ],
                    "last": "Esteban",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Galesi",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Johannsen",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "SIAM J. Comput",
            "volume": "30",
            "issn": "5",
            "pages": "1462--1484",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Resolution trees with lemmas: resolution refinements that characterize DLL-algorithms with clause learning",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Buss",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hoffmann",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Johannsen",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Logical Methods Comput. Sci",
            "volume": "4",
            "issn": "4",
            "pages": "1--28",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Small stone in pool",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Buss",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "A"
                    ],
                    "last": "Ko Lodziejczyk",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Logical Methods Comput. Sci",
            "volume": "10",
            "issn": "2",
            "pages": "1--22",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Trade-offs between time and memory in a tighter model of CDCL SAT solvers",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Elffers",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Johannsen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lauria",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Magnard",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Nordstr\u00f6m",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vinyals",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "SAT 2016",
            "volume": "9710",
            "issn": "",
            "pages": "160--176",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Clause learning can effectively p-simulate general propositional resolution",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Hertel",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bacchus",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Pitassi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Van Gelder",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence",
            "volume": "",
            "issn": "",
            "pages": "283--290",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Towards a complexitytheoretic understanding of restarts in SAT solvers",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Fleming",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vinyals",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Pitassi",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Ganesh",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Theory and Applications of Satisfiability Testing -SAT 2020",
            "volume": "12178",
            "issn": "",
            "pages": "233--249",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "On CDCL-based proof systems with the ordered decision strategy",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Mull",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Razborov",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1909.04135"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Solving SAT and SAT modulo theories: from an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T )",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Nieuwenhuis",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Oliveras",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Tinelli",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. ACM",
            "volume": "53",
            "issn": "6",
            "pages": "937--977",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "On the power of clause-learning SAT solvers as resolution engines",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Pipatsrisawat",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Darwiche",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Artif. Intell",
            "volume": "175",
            "issn": "2",
            "pages": "512--525",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Pool resolution and its relation to regular resolution and DPLL with clause learning",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Van Gelder",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "LPAR 2005",
            "volume": "3835",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/11591191_40"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Hard examples for common variable decision heuristics",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vinyals",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 34th AAAI Conference on Artificial Intelligence",
            "volume": "2020",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "or \u03c4 contains 0. All other states are nonterminal. We let S n denote the set of all states (recall that n is reserved for the number of variables), and let S o n \u2286 S n be the set of all nonterminal states.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "For a (nonterminal) state S = (\u03c4, t) \u2208 S o n , we define the finite set Actions(S) and the function Transition S : Actions(S) \u2212\u2192 S n ; the fact Transition S (A) = S will be usually abbreviated to S A =\u21d2 S . Those are described as follows: Actions(S) def = D(S) . \u222a U (S) . \u222a L(S), where the letters D, U, L have the obvious meaning 4 . -D(S) consists of all annotated assignments x i d = a such that x i does not appear in t and a \u2208 {0, 1}. We naturally let",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "The transition graph \u0393 n is the directed graph on S n defined by erasing the information about actions; thus (S, S ) \u2208 E(\u0393 n ) if and only if S \u2208 im(Transition S ). It is easy to see (by double induction on (|\u03c4 |, n \u2212 |t|)) that \u0393 n is acyclic. Moreover, both the set {(S, A) | A \u2208 Actions(S) } and the function (S, A) \u2192 Transition S (A) are polynomial-time 5 computable. These observations motivate the following definition.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Given a CNF \u03c4 , a partial run on \u03c4 from the state S to the state T is a sequence",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "A local class of CDCL solvers is described by a collection of subsets AllowedActions(S) \u2286 Actions(S) where S \u2208 S o n . It consists of all those solvers \u03bc for which \u03bc(S) \u2208 AllowedActions(S), whenever \u03bc(S) is defined.We will describe local classes of solvers in terms of amendments prescribing what actions should be removed from the set Actions(S) to form AllowedActions(S). The examples presented below illustrate how familiar restrictions look in this language. Throughout their description, we fix a nonterminal state S = (\u03c4, t).ALWAYS-C If \u03c4 | t contains the empty clause, then D(S) and U (S) are removed from Actions(S). In other words, this amendment requires the solver to perform conflict analysis if it can do so.ALWAYS-U If \u03c4 | t contains a unit clause, then D(S) is removed from Actions(S).This amendment insists on unit propagation, but leaves to nondeterminism the choice of the unit to propagate if there are several choices. Note that as defined, ALWAYS-U is a lower priority amendment than ALWAYS-C: if both a conflict and a unit clause are present, the solver must do conflict analysis. DECISION-L In the definition (4), we shrink C(S) \\ \u03c4 to C 1 (S) \\ \u03c4 . FIRST-L In the definition (4), we shrink C(S)\\\u03c4 to those clauses that are obtained by resolving a conflict clause with one other clause in \u03c4 . Such clauses are the first learnable clauses encountered in the process from Definition 3. \u03c0-D, where \u03c0 \u2208 S n is an order on the variables We keep in D(S) only the two assignments x",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "CDCL(DECISION-L, ALWAYS-C, ALWAYS-U) is polynomially equivalent to general resolution. The open question asked in [3, Section 2.3.4] can be reasonably interpreted as whether CDCL(ALWAYS-C, ALWAYS-U, WIDTH-w) is as powerful as width-w resolution, perhaps with some gap between the two width constraints. Our width lower bound mentioned in the introduction can be cast in this language as For any fixed order \u03c0 on the variables and every > 0 there exist contradictory CNFs \u03c4 n with w(\u03c4 n 0) \u2264 O(1) not provable in CDCL (\u03c0-D, WIDTH-(1 \u2212 )n).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "D 2 , . . . , D s . Initially D 0 def = D. Fix now an index i. Let c i\u22121 denote the clause-labeling c Di\u22121 . To define the transformation of D i\u22121 to D i , we need the following structural properties of D i\u22121 , which are easily verified by induction simultaneously with the definition.",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}