{
    "paper_id": "c33d8ed8ba340f913b53864957cd39fa482eee6a",
    "metadata": {
        "title": "Online Sorting and Translational Packing of Convex Polygons",
        "authors": [
            {
                "first": "Anders",
                "middle": [],
                "last": "Aamand",
                "suffix": "",
                "affiliation": {},
                "email": "aamand@mit.edu"
            },
            {
                "first": "Mikkel",
                "middle": [],
                "last": "Abrahamsen",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Copenhagen",
                    "location": {}
                },
                "email": ""
            },
            {
                "first": "Lorenzo",
                "middle": [],
                "last": "Beretta",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Copenhagen",
                    "location": {}
                },
                "email": "beretta@di.ku.dk"
            },
            {
                "first": "Linda",
                "middle": [],
                "last": "Kleist",
                "suffix": "",
                "affiliation": {},
                "email": "kleist@ibr.cs.tu-bs.de"
            }
        ]
    },
    "abstract": [
        {
            "text": "We investigate various online packing problems in which convex polygons arrive one by one and have to be placed irrevocably into a container before the next piece is revealed; the pieces must not be rotated, but only translated. The aim is to minimize the used space depending on the specific problem at hand, e.g., the strip length in strip packing, the number of bins in bin packing, etc.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "We draw interesting connections to the following online sorting problem Online-Sorting[\u03b3, n]: We receive a stream of real numbers s1, . . . , sn, si \u2208 [0, 1], one by one. Each real must be placed in an array A with \u03b3n initially empty cells without knowing the subsequent reals. The goal is to minimize the sum of differences of consecutive reals in A. The offline optimum is to place the reals in sorted order so the cost is at most 1. We show that for any \u2206-competitive online algorithm of Online-Sorting[\u03b3, n], it holds that \u03b3\u2206 \u2208 \u2126(log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "We use this lower bound to answer several fundamental questions about packing. Specifically, we prove the non-existence of competitive algorithms for various online translational packing problems of convex polygons, among them strip packing, bin packing and perimeter packing. These results remain true even if the diameter of all pieces is bounded by any small constant \u03b4 > 0, and even in the asymptotic case, i.e., for arbitrarily large values of OPT. This also implies that there exists no online algorithm that can pack all streams of pieces of diameter and total area at most \u03b4 into the unit square, i.e., the critical packing density is 0. These results are in contrast to the case when the pieces are restricted to rectangles, for which competitive algorithms are known. Likewise, the offline versions of packing convex polygons have constant factor approximation algorithms. These offline algorithms sort the convex polygons by the slope of their spine segment so that they form a fan-like pattern. In essence, our result shows that the impossibility of solving the online sorting problem implies the non-existence of a competitive algorithm, as it prevents arranging the pieces in a fan-like pattern.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "On the positive side, we present an algorithm with competitive ratio O(n 0.59 ) for online translational strip packing of convex polygons. This beats the trivial n-competitive algorithm that places each new piece as far into the strip as possible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "For Online-Sorting[1, n], i.e., if A has n cells, we show that any online algorithm has a competitive ratio in \u2126( \u221a n), and describe an algorithm with competitive ratio O( \u221a n). This can be seen as an asymptotically tight analysis of an online variant of the traveling salesperson problem on the real line. In the case of Online-Sorting[C, n] for any constant C > 1, we present an O(2 O( \u221a log n log log n) )-competitive algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Packing problems are omnipresent in our daily lives and likewise appear in many large-scale industries. For instance, two-dimensional versions of packing arise when a given set of pieces have to be cut out from a large piece of material such that waste is minimized. This is relevant in clothing production where pieces are cut out from a strip of fabric, and similarly in leather, glass, wood, and sheet metal cutting. In these settings, it is often important that the inherent structure of the host material (grain of fabric, patterns, etc.) is respected, i.e., the pieces should not be arbitrarily rotated, but merely translated. In some applications, the objects appear in an online fashion, i.e., the pieces appear one after the other, and each of them must be placed before the next one is known. This is in contrast to offline problems, where all the pieces are known in advance. Problems related to packing were some of the first for which online algorithms were described and analyzed. Indeed, the first use of the terms \"online\" and \"offline\" in the context of approximation algorithms was in the early 1970s and used for algorithms for bin-packing problems [20] . Most existing research on packing, and all research on online translational packing that we are aware of, is concerned with axis-parallel rectangular pieces.",
            "cite_spans": [
                {
                    "start": 1168,
                    "end": 1172,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we study online translational packing of convex polygons. The pieces arrive one by one and have to be placed irrevocably into a horizontal strip (or into bins, a square, the plane) before the next piece is revealed, and only translations of the pieces are allowed. The aim is to minimize the used space depending on the specific problem at hand, e.g., the used length of the strip, the number of bins, etc.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To develop lower bounds for these packing problems, we introduce the problem Online-Sorting[\u03b3, n] which we believe to be of independent interest. In this problem, we have an empty array A with \u03b3n cells, \u03b3 \u2265 1, and receive a stream of real numbers s 1 , . . . , s n , s i \u2208 [0, 1]. Each real has to be placed into an empty cell of A before the next real is known. The goal is to minimize the sum of differences of consecutive reals in A. The offline optimum is obtained by placing the reals in sorted order in some n cells of A. We show that Online-Sorting does not allow for constant factor competitive online algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Theorem 1. Suppose that \u03b3, \u2206 \u2265 1 are such that Online-Sorting[\u03b3, n] admits a \u2206-competitive algorithm, then \u03b3\u2206 = \u2126(log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We then use this insight to show that various packing problems do not allow for constant factor asymptotically competitive online algorithms. In Strip-Packing, we have a horizontal strip of height 1 which is bounded to the left by a vertical segment and unbounded to the right. The goal is to place the pieces so that we use a part of the strip of minimum length. In Bin-Packing, the pieces have to be placed in unit squares, and the goal is to use a minimum number of these squares. In Perimeter-Packing, we can place the pieces anywhere in the plane, and the goal is to minimize the perimeter of their convex hull. In Square-Packing[\u03b4], we receive a stream of pieces with diameter at most \u03b4 and total area at most \u03b4, and the goal is to place them in a unit square. For more background on each of these packing problems and their relation to previous work, we refer to Section 1.2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Theorem 2. The following holds, where n is the number of pieces:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "(a) Strip-Packing does not allow for a competitive online algorithm, even if all pieces have diameter at most \u03b4 for any constant \u03b4 > 0. In particular, the competitive ratio of any algorithm is \u2126( log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "(b) Bin-Packing does not allow for a competitive online algorithm, even if all pieces have diameter at most \u03b4 for any constant \u03b4 > 0. In particular, the competitive ratio of any algorithm is \u2126( log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "(c) Perimeter-Packing does not allow for a competitive online algorithm, even if all pieces have diameter at most \u03b4 for any constant \u03b4 > 0. In particular, the competitive ratio of any algorithm is \u2126( 4 log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "(d) Square-Packing[\u03b4] does not allow for an online algorithm for any \u03b4 \u2208 (0, 1]. In particular, for any algorithm and infinitely many n, there exists a stream of n pieces of total area O( log log n/ log n) that the algorithm cannot pack in the unit square.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Here, (a) and (b) even hold in the asymptotic sense, i.e., if we restrict ourselves to instances with offline optimal cost at least C, for any constant C > 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "On the positive side, we present online algorithms for both online sorting and strip packing. For Online-Sorting[\u03b3, n], we distinguish two scenarios: the case without any extra space, i.e., \u03b3 = 1, and the case \u03b3 = 1 + \u03b5 a constant \u03b5 > 0. In the case \u03b3 = 1, we can provide an asymptotically tight analysis. Theorem 3. There exists an online algorithm for Online-Sorting [1, n] with competitive ratio at most 18 \u221a n. Every online algorithm of Online-Sorting [1, n] has competitive ratio at least n/2.",
            "cite_spans": [
                {
                    "start": 369,
                    "end": 375,
                    "text": "[1, n]",
                    "ref_id": null
                },
                {
                    "start": 456,
                    "end": 462,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As we describe in Section 1.3, this can be seen as an asymptotically tight analysis of an online version of the travelling salesperson problem (TSP) on the real line. Indeed, we can imagine that we must visit n cities on [0, 1] at time steps 1, . . . , n. The position of each city is revealed to us in an online fashion and we immediately have to decide the time step where we visit this city. In addition to packing and TSP, we believe that the online sorting problem can be useful when studying other online problems as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In contrast to Theorem 3, when the available space is a constant factor larger than n, there exists an algorithm with competitive ration n o (1) . We note that there is an exponential gap between the lower and upper bounds in Theorem 1 and Theorem 4. It is an interesting open problem to close this gap, say for Online-Sorting [2, n] .",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 144,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 327,
                    "end": 333,
                    "text": "[2, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "There is a trivial n-competitive algorithm Strip-Packing that places each of the n pieces as deep into the strip as possible. Improving upon this turns out to be quite challenging. We present an online algorithm with competitive ratio O(n log 3\u22121 log n) = O(n 0.59 ), where log x denotes the base-2 logarithm of x. Another interesting open problem is to improve upon this. Is it for example possible to obtain an n o(1)competitive algorithm for Strip-Packing as we have for Online-Sorting[1 + \u03b5, n]? Because the sorting problem is much simpler than the packing problem, the lower bound from Theorem 1 implies a lower bound for Strip-Packing, but the algorithm behind Theorem 4 does not lead to any packing algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our results in Theorem 2 are in contrast to translational offline packing of convex polygons for which constant factor approximations exist. In a recent paper, Alt, de Berg, and Knauer [5, 6] gave a constantfactor approximation algorithm for offline translational packing of convex polygons so as to minimize the area of their bounding box. The algorithm works by first grouping the pieces into exponentially increasing height classes and then sorting the pieces in each height class by the slopes of their spine segments; see Figure 1 . The spine segment of a piece is the line segment from the bottommost to the topmost corner. Placing the pieces in rows in this sorted order (so that each row appears as a fan-like pattern) yields a compact packing with constant density. We show that similar procedures yield constant factor approximations for the offline version of strip packing, bin packing, square packing and perimeter packing. (d) Offline-Square-Packing [1/10] , in particular, every set of convex polygons of diameter and total area at most 1/10 can be packed into the unit square.",
            "cite_spans": [
                {
                    "start": 185,
                    "end": 188,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 189,
                    "end": 191,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 964,
                    "end": 970,
                    "text": "[1/10]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 527,
                    "end": 535,
                    "text": "Figure 1",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "The necessity of sorting pieces by slope"
        },
        {
            "text": "The contrast between Theorem 2 and Theorem 6 shows that sorting the pieces by the slope of their spine segments is essential for obtaining an efficient packing. In particular, we use the lower bound from Theorem 1 to create an adaptive stream of pieces that will force any packing algorithm to use excessive space. In the reduction, the numbers to be sorted in the online sorting problem correspond to the slopes of the spine segments in the packing problems, and the impossibility of placing the numbers in nearly sorted order implies that the packing algorithm is forced to produce an arrangement that is far from an optimal fan-like pattern.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The necessity of sorting pieces by slope"
        },
        {
            "text": "The literature on online packing problems is vast. See the surveys of Christensen, Khan, Pokutta, and Tetali [13] , Epstein and van Stee [17] , van Stee [41, 42] , and Csirik and Woeginger [15] for an overview. Below we survey the most important results for each of the types of packing problems mentioned in Theorem 2. Let us highlight that when the pieces are restricted to axis-parallel rectangles, there are online algorithms with constant competitive ratios solving all the problems of Theorem 2.",
            "cite_spans": [
                {
                    "start": 109,
                    "end": 113,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 137,
                    "end": 141,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 153,
                    "end": 157,
                    "text": "[41,",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 158,
                    "end": 161,
                    "text": "42]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 189,
                    "end": 193,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Strip packing. In strip packing, we have a horizontal strip of height 1 bounded by a vertical segment to the left but unbounded to the right. The goal is to place the pieces in the strip so as to minimize the length of the part of the strip that has been used. Milenkovich [34] and Milenkovich and Daniels [35] described exact algorithms for offline strip packing where the pieces are simple or convex polygons.",
            "cite_spans": [
                {
                    "start": 273,
                    "end": 277,
                    "text": "[34]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 306,
                    "end": 310,
                    "text": "[35]",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Baker and Schwarz [9] described the first algorithms for online strip packing of rectangular pieces. The FFS (First Fit Shelf) algorithm has a competitive ratio of 6.99 under the assumption that the height of each rectangle is at most 1. Ye, Han, and Zang [43] improved the algorithm and obtained a competitive ratio of 7 /2 + \u221a 10 \u2248 6.6623 without the restriction on rectangle heights. Restricting the attention to large instances, FFS has an asymptotic competitive ratio that can be made arbitrarily close to 1.7. Csirik and Woeginger [16] described an improved algorithm with an asymptotic competitive ratio arbitrarily close to h \u221e \u2248 1.69103. This was later improved to 1.58889 by Han, Iwama, Ye, and Zhang [24] . In contrast, we show that when the pieces are convex polygons, then no competitive algorithm exists (Theorem 2 (a)).",
            "cite_spans": [
                {
                    "start": 18,
                    "end": 21,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 256,
                    "end": 260,
                    "text": "[43]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 537,
                    "end": 541,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 711,
                    "end": 715,
                    "text": "[24]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Bin packing. In bin packing, we have an unbounded supply of identical containers, and the goal is to pack the pieces into as few containers as possible. As mentioned, online bin packing problems have been studied since the early 1970s [20] . Many papers have been devoted to the study of online translational bin packing axis-parallel rectangular pieces into unit square bins. In long sequences of papers, the upper bound on the asymptotic competitive ratio for this problem has been decreased from 3.25 to 2.5545 and the lower bound has been increased from 1.6 to 1.907 [23] . In this paper, we show that when packing convex polygons instead of axis-parallel rectangles, there is no competitive algorithm (Theorem 2 (b)).",
            "cite_spans": [
                {
                    "start": 235,
                    "end": 239,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 571,
                    "end": 575,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Perimeter packing. In some packing problems, the \"container\" has no predefined boundaries (contrary to the cases of strip and bin packing and the study of critical densities), but the pieces can be placed anywhere in the plane and the container is dynamically updated as the bounding box or the convex hull of the pieces. The goal is then to minimize the size of the container. In 2D versions of this problem, natural measures of size are the area or the perimeter of the container. Many papers have been written about offline versions of these problems [2, 4, 5, 8, 14, 18, 29, 30, 31, 33, 34, 35, 37, 40] .",
            "cite_spans": [
                {
                    "start": 554,
                    "end": 557,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 558,
                    "end": 560,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 561,
                    "end": 563,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 564,
                    "end": 566,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 567,
                    "end": 570,
                    "text": "14,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 571,
                    "end": 574,
                    "text": "18,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 575,
                    "end": 578,
                    "text": "29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 579,
                    "end": 582,
                    "text": "30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 583,
                    "end": 586,
                    "text": "31,",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 587,
                    "end": 590,
                    "text": "33,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 591,
                    "end": 594,
                    "text": "34,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 595,
                    "end": 598,
                    "text": "35,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 599,
                    "end": 602,
                    "text": "37,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 603,
                    "end": 606,
                    "text": "40]",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Online versions have received relatively little attention. Fekete and Hoffmann [19] studied online packing axis-parallel squares so as to minimize the area of their bounding square, and gave an 8-competitive algorithm for the problem. Abrahamsen and Beretta [1] gave a 6-competitive algorithm for the same problem and studied the more general case where the pieces are axis-parallel rectangles and we want to minimize the bounding box, with or without rotations by 90 \u2022 allowed. They gave a 3.98-competitive algorithm for minimizing the perimeter and showed that there exists no competitive algorithm for minimizing the area, when the pieces can be arbitrary rectangles.",
            "cite_spans": [
                {
                    "start": 79,
                    "end": 83,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 258,
                    "end": 261,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "If the pieces are convex polygons that can be arbitrarily rotated, then the minimum perimeter problem can be reduced to the case of packing axis-parallel rectangles by first rotating each piece so that a diameter of the piece is horizontal. Then the density of the piece in its axis-parallel bounding box is at least 1/2, and the algorithm for rectangles can be applied to the bounding box. An interesting question that remained open was therefore whether there is a competitive algorithm for minimizing the perimeter when the pieces are convex polygons that can not be rotated. We answer this question in the negative (Theorem 2 (c)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Critical densities and square packing. The study of critical densities dates back at least to the 1930s. In the famous Scottisch Book [32] , Auerbach, Banach, Mazur and Ulam gave the following theorem (slightly rephrased) and corollary without a proof.",
            "cite_spans": [
                {
                    "start": 134,
                    "end": 138,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Theorem (Potato Sack Theorem, [32] ). If {K n } \u221e n=1 is a sequence of convex bodies in R 3 , each of diameter \u2264 \u03b4 and the sum of their volumes is \u2264 V , then there exists a cube with sidelength s = f (\u03b4, V ) such that all the given bodies can disjointly be placed into it when rotations are allowed.",
            "cite_spans": [
                {
                    "start": 30,
                    "end": 34,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Corollary. One kilogram of potatoes can be put into a finite sack.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "A simple proof of the theorem, generalized to an arbitrary dimension, was given by Kosi\u0144ski [27] . It was asked in [32] to determine the function f (\u03b4, V ), which, in modern terms, means to determine the critical density. That is, to find the largest value of V such that a sequence of convex bodies of diameters at most \u03b4 and total volume V can always be placed in the unit cube. This theorem has sprouted a lot of interest in determining critical densities in various settings. For instance, Moon and Moser [36] proved that any sequence of d-dimensional cubes of total volume 1/2 d\u22121 can be packed into the unit cube. As two cubes with sidelengths 1/2 + \u03b5, for any \u03b5 > 0, cannot be packed in the unit cube, this shows that the critical density of packing cubes into a unit cube is 1/2 d\u22121 for any d \u2265 1. Alt, Cheong, Park, and Scharf [7] showed that there exist n 2D unit disks embedded in 3D (with different normal vectors) such that whenever they are placed in a non-overlapping way, their bounding box has volume \u2126( \u221a n). It follows that when rotations are not allowed, the critical density of packing convex bodies of bounded diameter into a cube is 0, or, in other words, that one kilogram of potatoes cannot always be put into a finite sack by translation. In contrast to this, the critical density of packing convex polygons of bounded diameter into the unit square by translation is positive when the diameter is sufficiently small, as we prove in Theorem 6 (d).",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 96,
                    "text": "[27]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 115,
                    "end": 119,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 509,
                    "end": 513,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 836,
                    "end": 839,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "The study of critical densities likewise makes sense when the pieces appear in an online fashion. A lower bound on the critical density of online packing squares into the unit square has been improved in a sequence of papers [11, 19, 25, 26] from 5/16 [26] to 2/5 [11] . Interestingly, Januszewski and Lassak [26] proved that in dimension d \u2265 5, the critical density of online packing cubes into the unit cube is 1/2 d\u22121 , just as in the offline case.",
            "cite_spans": [
                {
                    "start": 225,
                    "end": 229,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 230,
                    "end": 233,
                    "text": "19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 234,
                    "end": 237,
                    "text": "25,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 238,
                    "end": 241,
                    "text": "26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 252,
                    "end": 256,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 264,
                    "end": 268,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 309,
                    "end": 313,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Lassak and Zhang [28] proved that the Potato Sack Theorem also holds for any dimension d \u2265 1 when the convex bodies appear online, if rotations are allowed. In order to achieve this, each convex body of volume V is rotated so that it has an axis-parallel bounding box of volume at most d! \u00b7 V . The problem is therefore reduced to online packing axis-parallel boxes. In simplified terms, it is then proved that for some constant \u03b4 = \u03b4(d) > 0, any sequence of axis-parallel boxes of diameter and total area at most \u03b4 can be packed online in the d-dimensional unit hypercube. Determining whether the critical density of translational and online packing convex 2D polygons is positive remained an interesting question: On one hand, this packing problem is harder than the 2D offline version which has positive critical density (Theorem 6 (d)), and on the other hand, it is easier than the 3D online version which has 0 critical density (since also the 3D offline version has 0 critical density [7] ). In this paper, we prove that the 2D online version also has critical density 0 (Theorem 2 (d)).",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 21,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 991,
                    "end": 994,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Relation to previous work on packing"
        },
        {
            "text": "Theorem 3 can be seen as an asymptotically tight analysis of the traveling salesperson problem (TSP) on the real line, following the online-list paradigm: We want to visit n cities in the unit interval [0, 1] over the course of n days, one city per day. The positions of the cities are revealed sequentially to us in an online fashion, and for each city, we have to immediately decide which day to visit that city. Our goal is to minimize the total distance travelled. In fact, we could equally well imagine that we had \u03b3n days for our tour which corresponds to Online-Sorting[\u03b3, n].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Online sorting, TSP and scheduling"
        },
        {
            "text": "The usually studied version of online TSP follows the online-time paradigm. Here, a server starts at point 0 at time 0 and moves with at most unit speed. Each request \u03c3 i = (t i , r i ) is revealed at some time t i and should be visited by the server at time r i or later. We want to minimize the time before the server has visited all requests \u03c3 1 , . . . , \u03c3 n . This problem has been intensely studied [10] . The distinction between these two paradigms is common in the area of scheduling, but the online-list variant of TSP has apparently not received any attention so far.",
            "cite_spans": [
                {
                    "start": 405,
                    "end": 409,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Online sorting, TSP and scheduling"
        },
        {
            "text": "Fiat and Woeginger [21] studied a scheduling problem following the online-list paradigm that seems particularly related to online sorting: The goal is to minimize the average job completion time in a system with n jobs and a single machine. In every step, a single new job arrives and must be scheduled to its time slot immediately and irrevocably and without knowledge of the jobs that arrive in later steps. The offline optimum is to schedule the jobs according to their processing times in sorted order. It was shown that no algorithm can be log n-competitive, but that there is a O(log 1+\u03b5 n)-competitive algorithm for all \u03b5 > 0. For surveys on (online) scheduling, see [3, 12, 22, 38, 39 ].",
            "cite_spans": [
                {
                    "start": 19,
                    "end": 23,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 674,
                    "end": 677,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 678,
                    "end": 681,
                    "text": "12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 682,
                    "end": 685,
                    "text": "22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 686,
                    "end": 689,
                    "text": "38,",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 690,
                    "end": 692,
                    "text": "39",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Online sorting, TSP and scheduling"
        },
        {
            "text": "In Section 2, we introduce our terminology and notation. In Section 3, we describe the connection between the problems of online sorting and online strip packing. In Section 4, we analyze the online sorting problem and prove Theorems 1, 3 and 4. In Section 5, we study online packing problems and present proofs for Theorems 2 and 5. Finally, in Section 6, we consider the offline versions of the packing problems and prove Theorem 6. See Figure 2 for an overview of the reductions we make.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 439,
                    "end": 447,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Structure of the paper"
        },
        {
            "text": "Strip-Packing",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Online-Sorting[C, n]"
        },
        {
            "text": "Perimeter-Packing Figure 2 : An overview of our reductions. Note that an arrow from problem A to problem B means that an algorithm for B implies an algorithm for A. Here, \u00d8 \u2264 \u03b4 means that the diameter of each piece is at most an arbitrary constant \u03b4 > 0.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 18,
                    "end": 26,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "Online-Sorting[C, n]"
        },
        {
            "text": "In the online problems studied in this paper, the input is a stream \u03c3 1 , . . . , \u03c3 n of objects, and we need to handle each object \u03c3 i before we know the next ones \u03c3 i+1 , . . . , \u03c3 n . Here, objects are either real numbers from the unit interval [0, 1], in which case we call them reals, or they are convex polygons, in which case we call them pieces. The problems will be defined in more detail in Section 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Terminology"
        },
        {
            "text": "Let us now revisit the standard terminology of competitive analysis for an online algorithm A of a minimization problem P. For any instance I of P, let OPT(I) denote the cost of the offline optimum solution and A(I) denote the cost of the solution that A produces on input I. Let f be a function from the set of instances to the real numbers (the functions f we consider will in fact only depend on n, the number of pieces in I). We say that A has (absolute) competitive ratio f (I) if for all instances I it holds that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Terminology"
        },
        {
            "text": "If A has competitive ratio f (I) \u2264 c for some constant c, then we say that A is competitive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Terminology"
        },
        {
            "text": "Similarly, we say that A has asymptotic competitive ratio f (I) if there exists \u03b2 > 0 such that for all instances I it holds that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Terminology"
        },
        {
            "text": "For a point p \u2208 R 2 , we denote by x(p) and y(p) the x-and y-coordinates of p, respectively. For a compact set of points S \u2282 R 2 , we define the diameter of S as max p,q\u2208S |p \u2212 q|. We furthermore define the width and height of S as width(S) := max",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Terminology"
        },
        {
            "text": "If S is a polygon, we denote the area of S as area(S). A parallelogram P is horizontal if P has a pair of horizontal edges. The horizontal edges of P are then called the base edges. The shear of a horizontal parallelogram P is x(t) \u2212 x(b), where t and b are the top and bottom endpoints of a non-horizontal edge of P , respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Terminology"
        },
        {
            "text": "In (translational) Strip-Packing, we have a horizontal strip S of height 1 which is bounded to the left by a vertical segment and unbounded to the right; see Figure 3 . We have to pack a stream of convex polygonal pieces appearing online. We must place each piece before we know the next. Specifically, each piece must be placed in S by a translation such that it is interior disjoint from all previously placed pieces. The occupied part of S is the part from the left end of S to the vertical line through the rightmost corner of a piece placed in S. The width or the cost of a packing is the width of the part of S that is occupied, i.e., the horizontal distance from the left end of S to the rightmost corner of a piece placed in S. In the problem Online-Sorting[\u03b3, n], we are given an array A with \u03b3n cells. Each arriving real is contained in the unit interval [0, 1]. After all n reals have been placed, define r := (r 1 , . . . , r n ) to be the numbers according to their left-to-right order in A. Furthermore, define the sentinel values r 0 := 0 and r n+1 := 1. Then the cost is given by",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 158,
                    "end": 166,
                    "text": "Figure 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "The offline optimum is achieved when the reals are in sorted order and is then exactly 1. Figure 2 gives an overview of reductions we make. Arguably, the crucial reduction is that from Online-Sorting to Strip-Packing, as described by the following lemma. Proof. Suppose that we have a C-competitive algorithm A 1 for Strip-Packing. Let s 1 , . . . , s n , s i \u2208 [0, 1], be a stream of reals that we wish to sort online in an array A of size 2Cn. For each real s i , we construct a parallelogram P i with height 1, base edges of length 1/n, and shear s i . We then present A 1 with P i and observe where the bottom left corner of P i is placed in the strip. Let x i be the x-coordinate of this corner (suppose that the line x = 0 forms the left boundary of the strip). We then place s i in the cell of index nx i in the array A, and denote the resulting algorithm A 2 . Since the base segments of the parallelograms have length 1/n, this will not cause any collisions in A.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 90,
                    "end": 98,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "By sorting the pieces P 1 , . . . , P n in order of increasing shear and placing them in this order in the strip, we obtain a packing of width at most 2, so A 1 will place all pieces within a prefix of size 2C \u00d7 1 of the strip. Hence, A 2 will place each real in A. Let r := (r 1 , r 2 , . . . , r n ) be the numbers in the resulting left-to-right order in A produced by A 2 , and let P i be the parallelogram corresponding to r i . We have the following contributions to the width of the resulting packing; see also Figure 4 .",
            "cite_spans": [
                {
                    "start": 517,
                    "end": 525,
                    "text": "Figure 4",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "\u2022 Between the vertical left boundary of the strip and the top edge of P 1 , there is a gap of length at least",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "\u2022 If r i \u2264 r i+1 , then there is a gap between the top edges of P i and P i+1 of length at least |r i+1 \u2212 r i |.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "\u2022 If r i > r i+1 , then there is a gap of length at least |r i+1 \u2212 r i | between the bottom edges of P i and P i+1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "\u2022 The bottom base edges of the pieces have total length 1 \u2265 |r n+1 \u2212 r n |.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "The sum of all these gaps is at least cost(r), and as half of the sum appear as distances along the top or the bottom edge bounding the strip, we get that the width of the produced packing is at least cost(r)/2. Now, since A 1 is C-competitive, we get that cost(r)/2 \u2264 2C, and hence cost(r) \u2264 4C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The connection between online sorting and packing"
        },
        {
            "text": "In this section, we present upper and lower bounds for the online sorting problem. As a warm up, we consider in Section 4.1 the case where we have no extra space, i.e., we are given n reals in [0, 1] in an online fashion to be inserted into an array of length n. We prove Theorem 3, which gives an asymptotically tight analysis of the optimal competitive ratio in this case. In Section 4.2, we proceed to prove Theorem 1, thereby obtaining a general lower bound on the competitive ratio for Online-Sorting[\u03b3, n]. Finally, in Section 4.3, we give an upper bound on the competitive ratio of Online-Sorting[\u03b3, n] for \u03b3 > 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Online sorting"
        },
        {
            "text": "For online sorting n numbers in an array A of size n, we can prove asymptotically tight bounds on the optimal competitive ratio. 1 We restate Theorem 3 below.",
            "cite_spans": [
                {
                    "start": 129,
                    "end": 130,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Theorem 3. There exists an online algorithm for Online-Sorting [1, n] with competitive ratio at most 18 \u221a n. Every online algorithm of Online-Sorting [1, n] has competitive ratio at least n/2.",
            "cite_spans": [
                {
                    "start": 63,
                    "end": 69,
                    "text": "[1, n]",
                    "ref_id": null
                },
                {
                    "start": 150,
                    "end": 156,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Proof. We start out by proving the lower bound. Let N := \u221a 2n . Consider a fixed but arbitrary online algorithm A. We are taking the role of the adversary and present reals of the form k /N with k = 0, 1, . . . , N . Clearly, if all reals are placed in an increasing fashion, the resulting cost is 1. This is the value A has to compete against.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "For a partially filled array, a real is expensive if it does not appear in a cell with an empty adjacent cell. Our strategy is as follows. While there exists one, we present an expensive real. If we are able to present n expensive reals, then any two consecutive entries are distinct and differ by at least 1 /N. Consequently, the cost is at least n+1 N \u2265 n/2. On the other hand, if we reach a point where no real of the form k /N is expensive, we present 0's until all entries are filled. Then, any real of the form k /N will appear next to a 0 in the array, so the total cost is at least N k=0 k /N = (N + 1)/2 > n/2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Next we describe an algorithm A for Online-Sorting [1, n] with competitive ratio at most 18 \u221a n. Define and partition the array A into N 2 subarrays of contiguous cells, A 1 , . . . , A N2 , each of size either n/N 2 or n/N 2 . Whenever A receives a real x \u2208 J i , it checks whether there exists a j such that A j is not full and already contains a number from J i . If so, A places x in the leftmost empty cell of A j . Otherwise, A checks if there exists a j such that A j is empty. If so, A places x in the leftmost cell of such an A j . Finally, if neither of the two above cases occur, then A recurses on the subarray formed by the union of the empty cells of A.",
            "cite_spans": [
                {
                    "start": 51,
                    "end": 57,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Ignoring the sentinel values r 0 := 0 and r n+1 := 1, we prove by induction on n that the total cost never exceeds",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "This clearly holds for n \u2264 \u03b1 2 , as then T (n) \u2265 n which is a trivial upper bound on the total cost. So let n > \u03b1 2 and assume inductively that the result holds for arrays of length n < n. Let B \u2282 {1, . . . , n} denote the set of indices i such that A[i] is full when the algorithm recurses for the first time. At this point, at most N 1 \u2212 1 of the N 2 := 2N 1 subarrays A 1 , . . . , A N2 can be not completely filled, and each subarray must contain at least one real. In particular, |B| \u2265 n/2. Let",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "The total cost incurred by the algorithm is then T 1 + T 2 . By the induction hypothesis, T 1 \u2264 T (|B c |) \u2264 T ( n/2 ). Furthermore, we can upper bound T 2 as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Here the first term comes from consecutive entries internal to a subarray that are both filled before the algorithm recurses for the first time (these have pairwise distance at most 1/N 1 ). ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "It is easy to check that including the sentinel values, the total cost incurred by the algorithm never exceeds 18 \u221a n. This completes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "We remark that the constant 18 in Theorem 3 can be significantly reduced by optimizing over N 1 and N 2 and using less crude bounds. We have abstained from doing so in order to obtain a simple exposition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Having dealt with the case where we have no extra space, we turn to the setting where the array has length \u03b3n for some \u03b3 > 1. This is the setting which is important for our reductions to the online packing problems. In the following two sections, we prove lower and upper bounds, respectively, on how good online sorting algorithms can perform in this case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tight analysis of Online-Sorting[1, n]"
        },
        {
            "text": "Let us restate our lower bound for the competitive ratio of any algorithm for Online-Sorting[\u03b3, n], \u03b3 \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Theorem 1. Suppose that \u03b3, \u2206 \u2265 1 are such that Online-Sorting[\u03b3, n] admits a \u2206-competitive algorithm, then \u03b3\u2206 = \u2126(log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Before delving into the proof, we first describe the high level idea on how to generate an adversarial stream that incurs a high cost for any given algorithm. Assume for simplicity that \u03b3 is a constant, e.g., \u03b3 = 2 and that we want to prove a lower bound of \u2206 on the total cost for some \u2206 = (log n) \u0398(1) . We will start by presenting the algorithm with reals coming from a set S of the form S = {i/n 0 | 0 \u2264 i \u2264 n 0 } for some n 0 \u2264 n. At any point, we consider the set of maximal intervals of empty cells of the array, call them I 1 , . . . , I . For each real x \u2208 S, we define the home H(x) as the union of all such intervals I j such that placing x in I j incurs no extra cost, i.e., the first non-empty cell to the left or right of I j contains the real x. (In fact, we will be a little more generous in the actual proof and allow for some small extra cost). If |H(x)| < n \u2206n0 for some x \u2208 S, we simply present the algorithm with copies of x until one is placed outside H(x) and thus has distance at least 1/n 0 to its neighbours. This will essentially contribute a total cost of 1/n 0 to the objective function, i.e., an average cost of \u2206/n per presented copy of x. Note that this is the correct average cost for a lower bound of \u2206. However, it may well be the case that no such x \u2208 S exists (the average size of H(x) for x \u2208 S is \u2248 \u03b3n/n 0 which is much larger). In this case, we coarsen the set S to a set S \u2282 S consisting of every s'th element of S for some s = polylog n and only present the algorithm with reals from S from this point on. Now for most x \u2208 S, it holds that H(x) = O(n/n 0 ) and that the distance from x to any real in S is \u2126(s/n 0 ). Intuitively, this means that filling up H(x) with elements from S has a high cost of s/n \u2206/n per presented real. We prove that this implies that we can point to a 'deserted space' consisting of \u2126(n/\u2206) empty cells, in which the algorithm can only place a negligible number of reals without incurring a large total cost of \u2206. Now we continue the process starting with S . In each coarsening step, we specify a 'deserted space' of size \u2126(n/\u2206) and we can importantly enforce that these spaces be disjoint. As the array has 2n cells in total, this coarsening can happen at most O(\u2206) times. To ensure that we can in fact perform this coarsening \u2126(\u2206) times, we must ensure that s \u2206 n, which in turn implies that \u2206 = O(log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Proof of Theorem 1. Let A denote any online algorithm for Online-Sorting[\u03b3, n]. We may assume that n is sufficiently large and that \u03b3 \u2264 log n/ log log n. We will present the algorithm with an (adaptive) stream that incurs a cost of \u2126 (log n/\u03b3 log log n). Let C \u2208 [3, 4] be minimal such that s := log C n is an integer and define \u03b4 := log n 16C\u03b3 log log n . For i \u2208 N, we define",
            "cite_spans": [
                {
                    "start": 263,
                    "end": 266,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 267,
                    "end": 269,
                    "text": "4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "We also let i * \u2208 N be maximal with s i * \u2264 n. In other words, we define i * := log n/C log log n . Our adversarial stream will consist of several phases, where in phase i \u2265 1, we present A with reals coming from the set S i . By the end of each phase, we will mark a certain set of currently empty cells of the array. Suppose that we are at time t and in some phase i. For an empty cell p \u2208 R t , we define N t (p) \u2282 [m] to be the set consisting of the first non-empty cell to the left and to the right of p. Thus |N t (p)| \u2264 2. Furthermore, for x \u2208 S i , we define the home of x at time t to be the set",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "By construction, a cell of A can be contained in at most two homes. We say that the home of x is small at time t if |H t (x)| < s i \u03b4 . In this case, we say that x is expensive at time t. The adversarial stream is constructed in the phases (were we stop as soon as the array contains n reals). Note that s i * +2 /\u03b4 \u2265 sn/\u03b4 > \u03b3n, so in phase i * + 2, the real 0 is always expensive and the process will therefore eventually stop.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "We prove three lemmas below which combine to give our desired result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "If the algorithm does not terminate in phase i, then |D i | \u2265 n 8\u03b4 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Proof. We consider the situation in the end of a phase i where the algorithm has not terminated. Since for each x \u2208 S i \\ W i , we have H t (x) > 4\u03b3s i and a cell can lie in at most two homes, it follows that |S i \\ W i | \u2264 2\u00b7 \u03b3n 4\u03b3s i \u2264 |S i |/2, and so |W i | \u2265 |S i |/2. Now S i+1 can be obtained from S i by including every s'th elements from S i in increasing order starting with 0. If we define D i := x \u2208 S i | \u2200z \u2208 S i+1 it holds that |z \u2212 x| \u2265 s i+1 12n , it then follows that |D i | \u2265 3 4 |S i |. Here we used the assumption that i \u2264 i * \u2212 2 which implies that that S i consists of sufficiently many reals (at least s 2 ) for the bound to hold. It follows that |D i | = |W i \u2229D i | \u2265 |S i |/4. Again using that each cell is contained in at most two homes, we have that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Lemma 9. Let \u03b1 > 0 and assume that the algorithm does not terminate in phase i. If at least 56\u03b1n\u03b3/s reals from S i+1 are placed in D i , then the total cost is at least \u03b1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Proof. Write D i = J as a disjoint union of maximal intervals of empty cells in D i . For each , we have that |J | \u2264 4\u03b3s i . If at least 56\u03b1n\u03b3/s reals are placed in D i , it follows that at least 14\u03b1n/s i+1 of the intervals receive at least one real from S i+1 . For such an interval J , we have by the definition of a home, that one of the (up to two) non-empty cells immediately to the left and right of J contains a real x of distance at most s i 2n to an element of D i . However, any x \u2208 S i+1 placed in J has distance at least s i+1 12n to any element of",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "14n , assuming that n and hence s are sufficiently large. Since the J are disjoint, it easily follows that the total cost is at least s i+1 14n \u00b7 14\u03b1n s i+1 = \u03b1. Lemma 10. If A assigns n 0 reals to unmarked cells, during phases 1, . . . , i * , then the total cost is at least \u03b4n0 4n \u2212 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Proof. Write a i for the number of reals that the algorithm assigns to unmarked cells during phase i, so that i\u2264i * a i = n 0 . Let b i := ai s i /\u03b4 and c i := b i . We make the following claim.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "Claim. The total cost is at least i\u2264i * c i \u00b7 s i 2n . Proof of Claim. Note that during the while-loop of our algorithm, the assumption that the home of x is small implies that it must happen at least c i times during phase i that a real from S i is placed outside its home. When an real x gets placed in a cell p \u2208 R t \\ H t (x) outside its home, the reals stored in the cells in N t (p) have distance at least s i 2n to x. We say that an interval of cells [p 1 ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "We say that an i-jump [p 1 , p 2 ] and a j-jump [p 1 , p 2 ] are disjoint if (p 1 , p 2 ) \u2229 (p 1 , p 2 ) = \u2205. We will show that we can find a collection J of such jumps such that (1) the jumps in J are pairwise disjoint and (2) we can make a partition J = i\u22651 J (i) such that J (i) contains at least c i i-jumps. The claim then follows immediately by the triangle inequality.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "To show the existence of such a collection J , suppose we at step t in some phase i are given a collection of (\u2264 i)-jumps J t and a partition J t = j\u2264i J",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "consists of j-jumps. Suppose further that we place a real x in a cell p \u2208 R t \\ H t (x) at step t. Since x was placed outside of its home, any of the (up to two) intervals with one endpoint at p and the other at a cell of N t (p) will form an i-jump. Now if p is not contained in a jump of J t , we can easily extend to a collection J t+1 = j\u2264i J (j) t+1 which still satisfies (1) and where J (i) t+1 contains one further i-jump. We simply add the i-jump between p and either of its neighbours in N t (p). Suppose on the other hand that p is contained in a j-jump [q 1 , q 2 ] of J (j) t for some j \u2264 i. In this case, we in particular have that |N t (p)| = 2 and we write N t (p) = {p 1 , p 2 } where p 1 < p 2 . Then [p 1 , p] and [p, p 2 ] are both i-jumps and in particular j-jumps for j \u2264 i. We then replace [q 1 , q 2 ] with [p 1 , p] in J j t+1 and include [p, p 2 ] in J i t+1 to obtain a collection J t+1 = j\u2264i J (j) t+1 having the same number of j-jumps for j < i but one extra i jump compared to J t . The existence of the collection J follows immediately from these observations. Now assuming that n is sufficiently large, we have that b i \u2265 \u03b4ai 2s i . Moreover, using the definition of i * , it is easy to check that i\u2264i * s i \u2264 2n. Combining this with the claim, we can lower bound the total cost by",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "We now combine the two lemmas to prove a lower bound on the cost incurred by the algorithm on our adversarial stream. Recall that C = 3 and \u03b4 = log n 16C\u03b3 log log n . Suppose for contradiction that the algorithm has not terminated by the end of phase i * \u2212 2. Using Lemma 8 and the fact that the sets (D j ) j\u2264i * \u22122 are disjoint, we obtain that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "assuming that n is sufficiently large. This is a contradiction as there are only \u03b3n cells in A. Thus, the algorithm must terminate during some phase i 0 \u2264 i * \u2212 2. Now the algorithm must either place at least n/2 reals in marked cells or n/2 reals in unmarked cells. In the former case, there must be a phase i in which n 2i * reals a placed in D i , and hence it follows from Lemma 9 that the total cost is \u2126( s i * \u03b3 ) = \u2126(log n). In the latter case, it follows from Lemma 10 that the total cost is at least \u03b4 8 \u2212 1 = \u2126 log n \u03b3 log log n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bound for the general case of Online-Sorting"
        },
        {
            "text": "In this section, we design an algorithm that shows the following theorem. First, we prove a slightly more general lemma, and then we instantiate it with the right set of parameters to obtain Theorem 4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Lemma 11. Let \u03b4 \u2208 (0, 1/2) and [\u03b1, \u03b1 + \u03b2) \u2286 [0, 1]. Then, for any k \u2265 1 with k \u2264 1/(2\u03b4) + 1 there exists an algorithm that solves Online-Sorting [1 + 2k\u03b4, n] over any stream of reals r 1 , . . . , r n \u2208 [\u03b1, \u03b1 + \u03b2) achieving a cost of \u03b2 \u00b7 n 1/(k+1) \u03b4 \u2212O(k+1) .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Proof. We prove the statement by induction on k. The base case of k = 1 follows directly from Theorem 3: in fact, it is sufficient to apply the mapping x \u2192 \u03b1 + \u03b2x to the reals in our stream and notice that the resulting cost also shrinks by a factor \u03b2. We call this version of the algorithm OnlineSorter 1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "For the induction step, we define the algorithm OnlineSorter k using OnlineSorter k\u22121 as a subroutine. Let b := n 1/(k+1) , n := \u03b4n k/(k+1) and w := (1 + 2(k \u2212 1)\u03b4) \u00b7 n . For i \u2265 1, we define the box ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "is not full, we place x into B p(i) using OnlineSorter k\u22121 . Otherwise, we assign a new active box and set p(i) := max j\u2208[b] p(j) + 1, update A and R accordingly, and then place x into B p(i) using OnlineSorter k\u22121 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "By the inductive hypothesis, OnlineSorter k\u22121 can place n reals into an array of size w. Hence, to prove correctness we only have to ensure that the set of used boxes are contained in the array, i.e., that R \u2264 (1 + 2k\u03b4)n. We show that the total number of empty cells in [1, R] is at most 2k\u03b4n and therefore there must be n full cells in [ ",
            "cite_spans": [
                {
                    "start": 270,
                    "end": 276,
                    "text": "[1, R]",
                    "ref_id": null
                },
                {
                    "start": 337,
                    "end": 338,
                    "text": "[",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Moreover, |F | \u2264 n /n and therefore i\u2208F E(B i ) \u2264 n n \u00b7 2(k \u2212 1)\u03b4 \u00b7 n = 2(k \u2212 1)\u03b4n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "If i \u2208 E, we use the trivial bound E(B i ) \u2264 w, moreover j \u2208 E implies B j \u2208 A, hence |E| \u2264 b. This yields",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Putting everything together, we obtain",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "where the last inequality holds because 2(k \u2212 1)\u03b4 \u2264 1 by assumption on k.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "We are left to bound the total cost for which we likewise use induction. By cost (k) (r 1 , . . . , r n ), we denote the cost incurred by algorithm OnlineSorter k when facing the stream of reals r 1 , . . . , r n . We prove that there exists C > 0 such that cost (k) (r 1 , . . . , r n ) \u2264 \u03b2 \u00b7 n 1/(k+1) \u03b4 \u2212C\u00b7(k+1) for any stream of reals r 1 , . . . , r n with r i \u2208 [\u03b1, \u03b1 + \u03b2). For k = 1, we already explained above how Theorem 3 implies that OnlineSorter 1 places a stream r 1 , . . . , r n \u2208 [\u03b1, \u03b1 + \u03b2) with a cost of cost (1) (r 1 , . . . , r n ) = 18\u03b2 \u221a n, and we can choose C accordingly. Now suppose k > 1, and let {B 1 , . . . , B } be the set of full or active boxes. We have \u2264 R/w \u2264 (1 + 2k\u03b4)n/w \u2264 3n 1/(k+1) \u03b4 \u22121 . We can think of our algorithm as partitioning the stream r 1 , . . . , r n into substreams according to the box in which each real is placed. For i \u2208 [ ], denote the substream of length L i placed in B i with y i 1 , . . . , y i Li so that we have {r 1 , . . . , r n } = i=1 {y i 1 , . . . , y i Li }. Moreover, L i \u2264 n for each i \u2208 [ ]. Define \u03b1 := (i\u22121)\u00b7\u03b2n \u22121/(k+1) and \u03b2 := \u03b2n \u22121/(k+1) , then for each j \u2208 [L i ] it holds \u03b1 \u2264 y i j < \u03b1 +\u03b2 . By the induction hypothesis, the cost induced by the recursive call of OnlineSorter k\u22121 on box B i is bounded by",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Now we are ready to estimate the total cost of OnlineSorter k as the sum of costs generated inside a box B i or between any two consecutive boxes:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "where the last inequality holds if we choose C large enough.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Finally, we can prove Theorem 4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "Proof of Theorem 4. We apply Lemma 11 choosing \u03b1 := 0, \u03b2 := 1, k := log n/ log log n and \u03b4 := \u03b5/(2k). ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Upper bound for the general case of Online-Sorting"
        },
        {
            "text": "In this section, we consider various online packing problems. In Section 5.1, we show that Strip-Packing does not allow for a competitive online algorithm. In fact, the argument generalizes to the other important online packing problems Square-Packing, Perimeter-Packing and Bin-Packing. This holds even when all pieces have diameter less than an arbitrarily small constant \u03b4 > 0. In Section 5.2, we present an online algorithm for convex strip packing. A naive greedy algorithm for this problem places each new piece as deep into the strip as possible, and this algorithm is n-competitive, where n is the number of pieces. Our algorithm is O(n 0.59 )-competitive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Online packing"
        },
        {
            "text": "Theorem 1 and Lemma 7 yield the following corollary.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Corollary 12. Strip-Packing does not allow for a competitive online algorithm, even when the diameter of each piece is at most 2. Specifically, for every online algorithm A, there exists a stream of n parallelograms of diameter at most 2 such that A produces a packing of width \u2126( log n/ log log n), while the optimal offline packing has width at most 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Proof. Suppose that Strip-Packing has a C-competitive algorithm A. By Lemma 7, we get a 4Ccompetitive algorithm A 2 for Online-Sorting[2C, n]. Theorem 1 implies that 8C 2 = \u2126(log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "In particular, C = \u2126( log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Specifically, the proof of Theorem 1 yields a stream of n reals where A 2 incurs a cost of \u2126( log n/ log log n). By the proof of Lemma 7, this translates to a stream of n parallelograms that can be packed in a strip of width 2, while A 1 produces a packing of width \u2126( log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "We even get a non-constant asymptotic lower bound.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Corollary 13. For any algorithm A for Strip-Packing, a lower bound on the asymptotic competitive ratio of A is \u2126( log n/ log log n), where n is the number of pieces, even when restricted to pieces of diameter less than 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Proof. Assume for contradiction that A has asymptotic competitive ratio g(n) = o( log n/ log log n). Let P(A) be the stream described in Corollary 12, where A produces a packing of width \u2126( log n/ log log n), while the optimal packing has width at most 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "There exists a function f such that: (i) f (n) \u00b7 g(n) \u2264 log n/ log log n, (ii) f (n) \u2264 n 2 , (iii) f (n) = \u03c9(1), and (iv) f is non-decreasing. If we append f (n) unit squares to the stream P(A), we obtain a stream Q(A) of n := n + f (n) \u2264 2n pieces. Taking Q(A) as input, A produces a packing of width \u2126( log n/ log log n) while the optimum is \u0398( f (n)). This implies that A has a competitive ratio of \u2126 log n/ log log n f (n)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "= \u03c9 \u221a log n / log log n f (n ) on instances having arbitrary large (at least f (n)) optimal offline cost, contradiction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "The insights of Corollaries 12 and 13 imply negative answers also for various other online packing problems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Theorem 2. The following holds, where n is the number of pieces:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(a) Strip-Packing does not allow for a competitive online algorithm, even if all pieces have diameter at most \u03b4 for any constant \u03b4 > 0. In particular, the competitive ratio of any algorithm is \u2126( log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(b) Bin-Packing does not allow for a competitive online algorithm, even if all pieces have diameter at most \u03b4 for any constant \u03b4 > 0. In particular, the competitive ratio of any algorithm is \u2126( log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(c) Perimeter-Packing does not allow for a competitive online algorithm, even if all pieces have diameter at most \u03b4 for any constant \u03b4 > 0. In particular, the competitive ratio of any algorithm is \u2126( 4 log n/ log log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(d) Square-Packing[\u03b4] does not allow for an online algorithm for any \u03b4 \u2208 (0, 1]. In particular, for any algorithm and infinitely many n, there exists a stream of n pieces of total area O( log log n/ log n) that the algorithm cannot pack in the unit square.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Here, (a) and (b) even hold in the asymptotic sense, i.e., if we restrict ourselves to instances with offline optimal cost at least C, for any constant C > 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "Proof. For each of the four packing problems, we consider an arbitrary algorithm A * , where A * packs pieces into a container S * . Here, S * may be a strip, a set of bins etc., depending on the problem at hand. The main idea in all the proofs is to cover S * by (rotated) substrips of a strip S of height 1/c for a (large) constant c, so that we get a correspondence between points in S * and S. By feeding A * with a stream of parallelograms and observing where they are placed in S * , we get an online algorithm A for packing (slightly modified) parallelograms into S. We can then by Corollary 13 choose a stream that forces A to produce a packing much larger than the optimal one, which implies that A * has likewise produced a bad packing. This gives a lower bound on the competitive ratio of A * . For a horizontal parallelogram P , a 2-extended copy is a parallelogram obtained by taking two copies of P and identifying the bottom base segment of one with the top segment of the other copy. We now prove each statement in the theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(a) Suppose that A * is an algorithm for Strip-Packing restricted to pieces of diameter at most \u03b4 > 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "The algorithm A * packs pieces into a strip S * of height 1. We define c := 4/\u03b4 . Recall that S is a strip of height 1/c. We cut S into substrips S 1 , S 2 , . . ., each of which is a rectangles of size 1 \u00d7 1/c. We rotate these by 90 \u2022 and use them to cover the strip S * . Let S * i be the part of S * corresponding to S i , so that the rectangles S * 1 , S * 2 , . . . appear in this order from left to right in S * ; see Figure 5 . We now define an algorithm A for strip packing horizontal parallelograms of height 1/c and diameter at most 2/c into S as follows. Let P be a piece to be packed in S, and let P * be the piece obtained from rotating the 2-extended copy of P by 90 \u2022 . Then P * has diameter at most 4/c = \u03b4. We now feed P * to A * . We observe where A * places P * in S * . Since P * has width 2/c, it intersects both the left and right vertical edge of a substrip S * i . Then, in particular, P := P * \u2229 S * i is congruent to P . We now place P in the substrip S i as specified by the placement of P in S * i . As A * does not place pieces in S * so that they overlap, this approach will produce a valid packing in S.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 424,
                    "end": 432,
                    "text": "Figure 5",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "By Corollary 13, there exists for arbitrarily large n and \u03b1 a stream I of n pieces of total area \u03b1 where OPT(I) = O(\u03b1) whereas A(I) = \u2126( log n/ log log n). Let I * be the stream of 2-extended pieces which we feed to A * . We then have OPT(I * ) = O(\u03b1), as we can just sort the pieces I * by the slope of their spine segments and place them in one long row in S * , which will form a packing of cost at most OPT(I) + 2/c = O(\u03b1). Since A(I) \u2264 c \u00b7 A * (I * ), we also have A * (I * ) = \u2126( log n/ log log n). The statement then follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(b) The proof is almost identical to that of (a), so we only describe the parts that are different. Suppose that A * is an algorithm for Bin-Packing restricted to pieces of diameter at most \u03b4 > 0. Here, A * packs pieces into unit square bins B 1 , B 2 , . . ..",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "We again partition S into substrips and cover the boxes B 1 , B 2 , . . . with these, as shown in Figure 6 . We then get a strip packing algorithm A in S in a similar way as in (a), and obtain a lower bound on the asymptotic competitive ratio of A * in a similar way.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 98,
                    "end": 106,
                    "text": "Figure 6",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(c) Suppose there exists a C-competitive online algorithm A * for Perimeter-Packing. We prove that this implies the existence of an algorithm for Square-Packing[1/160C 2 ], and it follows from (d) that Figure 6 : The figure shows the correspondence between the bins B1, B2, . . . and S. C = \u2126( 4 log n/ log log n). By Theorem 6 (c), every set of convex polygons of diameter at most 1/10 and total area at most 1/10 can be packed in a 1 \u00d7 1 square. Scaling by 1/4C, we get that convex polygons of diameter at most 1/40C and total area at most 1/160C 2 can be packed in a 1/4C \u00d7 1/4Csquare. In particular, the same holds if we bound the diameters to be at most 1/160C 2 . Hence, such a set of polygons can be packed in a box of perimeter 1/C. It follows that A * will produce a packing with a convex hull of perimeter at most 1. Therefore, the packing will be contained in the disk of radius 1/2 centered at any corner of the first piece P 1 , and in particular in the unit square centered at this corner. In other words, we have defined an algorithm for the problem Square-Packing[1/160C 2 ], and the claim follows.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 202,
                    "end": 210,
                    "text": "Figure 6",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "(d) Consider an online algorithm A * for packing a stream of pieces of diameter at most \u03b4 \u2208 (0, 1] into the unit square. For arbitrarily large values of n, we prove that there exists a stream of pieces of diameter at most \u03b4 and total area O( log log n/ log n) that A * cannot pack into the unit square. Let d > 0 be a lower bound on the multiplicative constant hidden in the first \u2126-symbol of Corollary 13. We use the same setup as in (b), just with a single box B, which is covered by the c := 4 d 2 log n log log n first substrips of S. By Corollary 13, there exists a stream P 1 , . . . , P n of pieces such that A produces a packing of width 4 d 2 log n/ log log n, so that A * cannot fit the stream of 2-extended pieces in B. We may without loss of generality assume that n is sufficiently large that 4/c \u2264 \u03b4, so that the 2-extended pieces have diameter at most \u03b4. The pieces have total area O(1/c 2 ) = O( log log n/ log n), and the statement follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower bounds -no competitive algorithms"
        },
        {
            "text": "You are asked to suggest an algorithm for online translational strip packing of convex pieces. What is the first approach that comes to your mind? It may very well be the following greedy algorithm: For each piece P i that appears, place P i as far left into the (horizontal) strip as possible. This algorithm is n-competitive: Indeed, it will occupy no more than n \u00b7 max i width(P i ) of the strip, and the optimum must occupy at least max i width(P i ). This bound is unfortunately also essentially tight: Consider a sequence of very skinny pieces of height 1 and width 1, but with slopes alternating between 1 and \u22121. The algorithm will produce a packing of width n, while the optimum has width slightly more than 2 (depending on the actual fatness of the pieces).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A better-than-naive algorithm for strip packing"
        },
        {
            "text": "We found it surprisingly difficult to develop an algorithm provably better than the naive algorithm, but in the following, we will describe an O(n log 3\u22121 log n)-competitive algorithm (note that log 3 \u2212 1 < 0.59). We denote the algorithm OnlinePacker.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A better-than-naive algorithm for strip packing"
        },
        {
            "text": "We first describe the algorithm and carry out the analysis when all the pieces are parallelograms of a restricted type and then show, in multiple steps, how the method generalizes to arbitrary convex pieces. By rescaling, we may without loss of generality assume that the first piece presented to the algorithm has width 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A better-than-naive algorithm for strip packing"
        },
        {
            "text": "In the following we describe and analyze the algorithm OnlinePacker for online translational strip packing under the assumption that all pieces P are horizontal parallelograms where height(P ) = 1 and width(P ) \u2264 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We define an infinite family of box types as follows. The box types can be represented by an infinite ternary box type tree; see Figure 7 . The empty vector [ ] denotes the basic box type, which is simply a rectangle of size 2 \u00d7 1. Each box type will be defined as a horizontal parallelogram of height 1. Proof. We prove the lemma by induction on d. The claim clearly holds for d = 0, because the basic box type is a rectangle of size 2 \u00d7 1 and s has height 1 and width at most 1. Suppose that for some dimension d \u2265 0, there is a box type T that satisfies the lemma. We then partition the bottom and top edges of T , as described in the definition of the box types. We choose x d+1 \u2208 {\u22121, 0, +1} such that t x d+1 contains the upper endpoint of s. Then T \u2295 [x d+1 ] is a (d + 1)-dimensional box type that satisfies the claim.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 129,
                    "end": 137,
                    "text": "Figure 7",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Lemma 15. For every horizontal parallelogram P where height(P ) = 1 and width(P ) \u2264 1, there exists a box type T such that P can be packed into T and area(T ) \u2264 6 area(P ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Proof. Let be the length of the horizontal segments of P . Choose d \u2265 0 as large as possible such that 3 \u2212d \u2265 ; this is possible because \u2264 1. Let s be a segment of height 1 parallel to the non-horizontal edges of P and consider the d-dimensional box type that contains s as described in Lemma 14. If the top endpoint of s is in the right half of the top edge of T , then we place P to the left of s, i.e., with the right edge of P coincident with s. Otherwise, we place P to the right of s. Since the horizontal segments of T have length 2 \u00b7 3 \u2212d \u2265 2 , it follows that T can contain P . Moreover, by maximality of d, the base edges have length less than 6 , so it follows that area(T ) \u2264 6 area(P ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "If a piece P can be packed into a box type T and area(T ) \u2264 6 area(P ), as in the lemma, then we say that T matches P . We say that a box type T is suitable for a piece P if T is an ancestor in the box type tree of a box type that matches P . In particular, P can be packed in a box B of a suitable type, but the area of B may be much more than 6 area(P ). We consider a type T to be an ancestor of itself.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Our algorithm will allocate space of the strip for boxes of the various box types. Each box of type T contains either:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "\u2022 a piece P that T matches, or",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "\u2022 one, two, or three boxes of types that are children of T in the box type tree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We now explain the behavior of our algorithm OnlinePacker when a new piece P arrives; see Figure 8 . Suppose first that there exists a box B 1 that satisfies the following properties. Figure 8 : An evolving packing produced by the algorithm. In each case, the green piece has just been placed. In the third step, there was no box suitable for the piece which also had room for it, so we allocated a new basic box.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 90,
                    "end": 98,
                    "text": "Figure 8",
                    "ref_id": null
                },
                {
                    "start": 184,
                    "end": 192,
                    "text": "Figure 8",
                    "ref_id": null
                }
            ],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "\u2022 The type T 1 of B 1 is suitable for P , i.e., T 1 is an ancestor of a type T k that matches P in the box type tree. Here, T 1 , . . . , T k be the path from T 1 to T k in the box type tree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "\u2022 The box B 1 has room for one more box of type T 2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "If more than one such box exist, we choose B 1 as small as possible, i.e., with maximum dimension. If B 1 exists, we do the following for each i = 1, . . . , k \u2212 1: We allocate in B i an empty box B i+1 of type T i+1 which is placed in B i as far left as possible. At last, we place P in the box B k . Thus, each of the new boxes B 2 , . . . , B k\u22121 will contain a single box, and B k will contain P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "If such a box B 1 does not exist, we allocate a new box of the basic type and place it as far left in the strip as possible (that is, without overlapping with any already allocated box). We then define it to be our box B 1 and do as explained above; allocating a chain of nested boxes until we get to a type that matches P and place P there.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We say that a d-dimensional box is near-empty if there is exactly one (d + 1)-dimensional box allocated in it. A crucial property of OnlinePacker is that it does not produce an excessive number of near-empty boxes, as described in the following lemma. Lemma 16. There can be at most two near-empty boxes of each type in a packing produced by OnlinePacker.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Proof. Suppose that there are two near-empty boxes B 1 and B 2 of type T , where B 1 was created first. Let P be the piece that caused B 2 to be allocated. We first see that one of the two boxes, say B 1 , must contain a box B 1 of type T \u2295 [\u22121] and the other, B 2 , must contain a box B 2 of type T \u2295 [+1]: If B 1 and B 2 had the same type or one of them had type T \u2295 [+0], then they could be packed in the same box of type T ; see Figure 9 . Hence, P could have been placed in B 1 instead of allocating the new box B 2 , contradicting that we allocate new boxes in a smallest possible existing box.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 433,
                    "end": 441,
                    "text": "Figure 9",
                    "ref_id": "FIGREF14"
                }
            ],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "But since B 1 has type T \u2295 [\u22121] and B 2 has type T \u2295 [+1], it follows that the next box of type T \u2295 [x], for x \u2208 {\u22121, 0, +1}, can be placed in B 1 or B 2 . Therefore, the algorithm will never allocate a third near-empty box of type T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We will now analyze the density under the assumption that there are no near-empty boxes. We shall then reduce the general case to this restricted case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Lemma 17. Suppose that OnlinePacker has produced a packing of n horizontal parallelograms of height 1 and width at most 1, where there are no near-empty boxes. Then the density of the pieces in the occupied part of the strip is at least \u2126(n 1\u2212log 3 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Proof. We prove that when there are no near-empty boxes, then the density in each basic box is at least n 1\u2212log 3 , and the lemma follows. So consider a basic box B and let n B be the number of pieces packed in B. The box B and the boxes allocated in it can be represented as a rooted tree T 1 . Here, the root is B and the children of a d-dimensional box are the (d + 1)-dimensional boxes that it contains, and each leaf is a box that contains a piece. Since there are no near-empty boxes, each internal node in T 1 has two or three children. To get a lower bound on the density in B, we construct a sequence of trees T 1 , T 2 , . . . , T k , where each tree corresponds to a packing in a basic box. The density of these packings decreases, and we will see in the end that the density in T k is at least \u2126(n 1\u2212log 3 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "The final tree T k is balanced in the sense that all leaves are contained in two neighbouring levels d and d + 1. If a tree T i is not balanced, we construct T i+1 in the following way. Let d be the maximum dimension of a box in T i . We can find two or three leaves of dimension d u that have the same parent u. If there are three, we remove one of them and the unique piece it contains from the packing, which decreases the density, and then proceed as in the case where there are two, as described in the following. Let u 1 , u 2 be the two leaves. Suppose that there is also a leaf v at level d v \u2264 d u \u2212 2. Recall that a d-dimensional box has area 2 \u00b7 3 \u2212d . Thus, the area of pieces in the boxes u 1 , u 2 , v combined is at least",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We now make a replacement argument: We \"move\" the leafs u 1 , u 2 , so that they become children of v instead of u, and argue that this only decreases the density. So, we construct a tree T i+1 that is similar to T i , except u is now a leaf and v has two children v 1 , v 2 . For this to be a conceivable packing, we must remove the pieces that were before in u 1 , u 2 , v and place new pieces in u, v 1 , v 2 . We place pieces in u, v 1 , v 2 that fills the boxes with density 1/6. These new pieces have total area",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "It is now straightforward to verify that since d v + 2 \u2264 d u , we have A \u2264 A. Hence, the density in T i+1 is smaller than the density in T i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "In the end, we obtain the packing represented by a balanced tree T k , where all leaves are d-or (d + 1)dimensional for some value d \u2265 0. We then have d \u2264 log n B + 1. Therefore, each piece has area at least 2 \u00b7 3 \u2212 log n B \u22121 /6 = \u2126(3 \u2212 log n ), and the total area of the pieces is \u2126(3 \u2212 log n B \u00b7 n B ) = \u2126(n 1\u2212log 3 B ) = \u2126(n 1\u2212log 3 ), which is also a lower bound on the density.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We now prove that when the total area of pieces is at least 1, then the density of an arbitrary packing produced by the algorithm, i.e., where there may also be near-empty boxes, is not much smaller.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Lemma 18. Suppose that OnlinePacker has packed n horizontal parallelograms of height 1 and width at most 1. If the total area of the pieces is at least 1, the resulting packing has density \u2126(n 1\u2212log 3 / log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Proof. Let A be the area of the strip used by the algorithm, and let \u03a3 be the total area of the pieces. We show that by replacing some boxes and pieces, so that the total area of pieces increases by at most F = O(log n), we obtain a packing with m pieces, where m \u2264 n, and no near-empty boxes. We then get from Lemma 17 that the resulting packing has density",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Using that \u03a3 \u2265 1, it then follows that the original density is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "= \u2126(n 1\u2212log 3 / log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Consider a maximal near-empty box B 1 , i.e., a near-empty box that is not contained in a larger nearempty box. We remove all boxes contained in B 1 and the pieces they contain and instead place a single piece in B 1 that completely fills B 1 . This operation cannot increase the number of pieces, because there was at least one piece contained in B 1 before.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Let d be maximum such that there are at least 2 d near-empty d-dimensional boxes. We first observe that d \u2264 log n: Each of the near-empty d-dimensional boxes contains a distinct piece. We therefore have 2 d \u2264 n, so that d \u2264 log n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "Let F \u2264d be the total area of pieces that we add to eliminate maximal near-empty boxes of dimension at most d and let F >d be the remaining ones, so that F = F \u2264d + F >d .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "In order to bound F \u2264d , we note that there are 3 i types of i-dimensional boxes, each of which has area O(3 \u2212i ). For each maximal near-empty i-dimensional box, we add a piece of area O(3 \u2212i ). As there are at most two near-empty boxes of each type by Lemma 16, we add boxes of total area O(",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "By similar arguments, we get",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "so we conclude that F = O(log n), which finishes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of height 1 and width \u2264 1"
        },
        {
            "text": "We now describe an extension of OnlinePacker in order to handle horizontal parallelograms of arbitrary height (at most 1) and bounded extended width, to be defined shortly. Here, we partition the pieces into height classes, so that a piece P belongs to class h if 2 \u2212h\u22121 < height(P ) \u2264 2 \u2212h . For height class h, the base type is a rectangle of size 2 \u00d7 2 \u2212h , and in the strip we allocate boxes of this size in which to pack pieces from the height class. We define an infinite ternary box type tree for each height class, exactly as when all the pieces have height 1. When a piece P arrives, we determine the height class h of P . We extend the non-horizontal segments of P until we obtain a horizontal parallelogram of height exactly 2 \u2212h , and we denote the resulting piece P so that P \u2282 P . We then define the extended width of P as extwidth(P ) := width(P ). Note that since 2 \u2212h\u22121 < height(P ), we have height(P ) < 2 height(P ) and extwidth(P ) = width(P ) < 2 width(P ). We then pack P (including P ) into a minimum suitable box that has already been allocated, if possible, and otherwise allocate a new basic box.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": "We stack the basic boxes of different height classes if possible. When a new basic box of height class h is created, we stack it on the leftmost pile of basic boxes that has room for it. This choice implies that there can be at most one stack of basic boxes that is less than half full.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": "Lemma 19. Suppose that OnlinePacker has packed n horizontal parallelograms of width at most 1/2 and total area more than 2. The resulting packing has density \u2126(n 1\u2212log 3 / log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": "Proof. Let U be the union of the base boxes (across all height classes), and let A be the area of the part of the strip occupied by the packing. Since the total area of pieces is more than 2, we also have area(U ) \u2265 2. Suppose first it holds that the density in U is at least \u2126(n 1\u2212log 3 / log n). We have that area(A) \u2264 2 area(U )+2, since there is at most one stack of base boxes of height less than 1/2 in the packing. Since 2 < U , we then also have area(A) < 3 area(U ). We can therefore also conclude that the density of the occupied part of the strip is \u2126(n 1\u2212log 3 / log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": "We now prove the density bound in U . Let \u03a3 be the total area of the pieces. For each height class h for which there are some pieces, we feed the algorithm with a rectangle of size 1 \u00d7 2 \u2212h . Let F be the total area of these pieces, and we have F < \u221e h=0 2 \u2212h = 2. We therefore have 2\u03a3 \u2265 \u03a3 + F . Let U be the union of the base boxes in this expanded packing. We then have that the original density is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": ".",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": "Since the area of pieces in each non-empty height class h is at least 2 \u2212h , we can now apply Lemma 18 (by scaling the y-coordinates by a factor of 2, we obtain a packing of parallelograms of height 1). Let n h be the number of pieces in height class h. We get that the density in the base boxes of height 2 \u2212h is \u2126(n 1\u2212log 3 h / log n h ) = \u2126(n 1\u2212log 3 / log n), so this is a bound on the density in all of U . Hence we have \u03a3 area U = \u2126(n 1\u2212log 3 / log n), and this concludes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for horizontal parallelograms of extended width \u2264 1"
        },
        {
            "text": "We now describe an extension of OnlinePacker that handles horizontal parallelograms of arbitrary height and arbitrary width. We partition the parallelograms into width classes. Pieces of width class i are packed in base boxes of width 2 i . Consider a parallelogram P . If extwidth(P ) \u2264 1, then the width class of P is i = 1. Otherwise, P belongs to the width class i such that 2 i\u22121 < 2 extwidth(P ) \u2264 2 i . We handle each width class independently, so that pieces from each class are packed in stacks as described in Section 5.2.2. In particular, each width class i is subdivided into height classes, and we allocate in the strip rectangles of size 2 i \u00d7 1, where we can place a stack of base boxes of sizes 2 i \u00d7 2 \u2212h , for various values of h \u2265 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all horizontal parallelograms"
        },
        {
            "text": "When a new piece P arrives, we determine its width class w and height class h. Then, we pack it into a rectangle of size 2 w \u00d7 1, in a base box of size 2 w \u00d7 2 \u2212h that has room for it. If no rectangle of that size has room for P , a new rectangle of size 2 w \u00d7 1 is created and placed as far left in the strip as possible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all horizontal parallelograms"
        },
        {
            "text": "Lemma 20. The competitive ratio of OnlinePacker when applied to n horizontal parallelograms of arbitrary width is O(n log 3\u22121 log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all horizontal parallelograms"
        },
        {
            "text": "Proof. After OnlinePacker has packed the n parallelograms, we denote the cost of the produced solution as ALG and the optimal offline solution as OPT. We then feed the algorithm with four rectangles of size 2 i\u22122 \u00d7 1 for each width class i for which there are some pieces. We denote the cost of the resulting packing as ALG + and the cost of the optimal offline solution as OPT + . Suppose that the largest width class is class k. We now claim that some piece P has extended width more than 2 k\u22122 . If k > 1 this holds for any piece in width class k, and if k = 1, it follows since we assume that the first piece presented to the algorithm has width 1. We then have OPT \u2265 width(P ) > extwidth(P )/2 > 2 k\u22123 . Since the added pieces are rectangles of height 1, the optimal packing is similar to the optimal packing for the original instance with the extra pieces added in the end. We therefore have",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all horizontal parallelograms"
        },
        {
            "text": "Let n i and \u03a3 i be the number and total area of the pieces in width class i, respectively. Note that \u03a3 i > 2 i , so that we can apply Lemma 19 to each width class (under proper scaling). The bound on the competitive ratio becomes",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all horizontal parallelograms"
        },
        {
            "text": "17n log 3\u22121 log n \u00b7 \u03a3 \u03a3 = O(n log 3\u22121 log n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all horizontal parallelograms"
        },
        {
            "text": "We now describe the extension of OnlinePacker to handle arbitrary convex pieces; see Figure 10 . When a new piece P arrives, we find a horizontal parallelogram P such that P \u2282 P , area(P ) \u2264 2 area(P ) and width(P ) \u2264 2 width(P ); then we apply OnlinePacker to the parallelogram P (with P inside). We define P as follows. Let b and t be the lower and upper horizontal tangent to P , respectively, and let c b \u2208 P \u2229 b and c t \u2208 P \u2229 t . Let l and r be the left and right tangent to P parallel to the segment c b c t , respectively. We then define P to be the horizontal parallelogram enclosed by the lines b , t l , r .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 85,
                    "end": 94,
                    "text": "Figure 10",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "It is straightforward to check that area(P ) \u2264 2 area(P ), because P is convex. Now we prove that width(P ) \u2264 2 width(P ). Define L to be the length of the horizontal edges of P and note that width(P ) = width(c b c t ) + L. On the other hand, width(P ) \u2265 max{width(c b c t ), L}, and this proves the claim.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "In the proof of Lemma 20 we only bound OPT using the width of the widest piece and the total area \u03a3. With respect to both width and area, the value for an arbitrary convex pieces P is at least 1/2 of that of the containing parallelogram P . Therefore, the bound on the competitive ratio carries over up to constant factors when the algorithm is applied to the parallelograms P , as stated in the following. Proof. Alt, de Berg, and Knauer [5, 6] presented an algorithm that packs any set P of convex polygons (with n vertices in total, using O(n log n) time) into an axis-aligned rectangular container B such that area(B) \u2264 23.78 \u00b7 opt, where opt is the minimum area of any axis-aligned rectangular container for P. As an intermediate step, they obtain a collection of rectangular mini-containers that together contain all objects of P. Let w max and h max denote the maximum width and height among all objects of P, respectively. For some fixed constants c > 0, \u03b1 \u2208 (0, 1), each mini-container has width (c + 1)w max and a height h i where h i := \u03b1 i h max for some appropriate i. The total area A C of all mini-containers can be bounded by",
            "cite_spans": [
                {
                    "start": 439,
                    "end": 442,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 443,
                    "end": 445,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "In order to prove (a), (b), (c), and (d), we repeatedly make use of the mini-containers and this equation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "We first consider strip packing and prove (a). When packing a set of convex polygons P into a horizontal strip of height 1, the minimal width opt-w is at least max{w max , area(P)}. Therefore,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "We group the mini-containers greedily into stacks of height at most 1, which we place in the strip. Note that all but possibly one stack have a height of at least 1 /2; otherwise two of these should have been put together. Therefore, the number of stacks is at most 2A C (c+1)wmax + 1. Together with \u03b1 := 0.545 and c := 2.2, this translates into a width of 2A C + (c + 1)w max \u2264 2 \u00b7 (1 + 1 /c) \u00b7 2 \u03b1 + c + 2 /\u03b1 1 \u2212 \u03b1 + c + 1 \u00b7 opt-w < 32.7 \u00b7 opt-w.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "We now turn our attention to (d), and our findings will later be used to prove (b). Let S denote the unit square in which we want to pack a given set P of convex polygons, each of diameter at most \u03b4. We choose \u03b1 := 1/2 and choose the width of the mini-containers to be 1, i.e., (c + 1)w max = 1. 2 We stack all mini-containers on top of each other. Suppose that the total height of the mini-containers exceeds 1. We prove that the total area of pieces is then more than the constant \u03c1 := (1 \u2212 5\u03b4)(1 \u2212 2\u03b4)/4. For \u03b4 := 1/10, we get \u03c1 := 1/10, and the claim in the theorem follows.",
            "cite_spans": [
                {
                    "start": 296,
                    "end": 297,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "We call a mini-container full if the bounding box of all contained pieces has width more than 1 \u2212 \u03b4; otherwise there is room for a further piece. A mini-container that is not full is called near-empty. We can pack the pieces such that in each height class, there is at most one near-empty mini-container. Therefore, the total height of near-empty mini-containers is at most i h i = h max i \u03b1 i \u2264 \u03b4/(1 \u2212 \u03b1) = 2\u03b4. Since the mini-containers (full and near-empty) have a total height of more than 1, the full mini-containers in S have a total height of more than 1 \u2212 2\u03b4, and a total area of more than 1 \u2212 2\u03b4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "Let B be the bounding box of a full mini-container of height h i (and area h i ) and denote the set of contained polygons by P . By [5, 6] , we obtain (1 \u2212 \u03b4)h i \u2264 area(B) \u2264 2/\u03b1 \u00b7 area(P ) + h i w max \u2264 4 area(P ) + h i \u03b4 .",
            "cite_spans": [
                {
                    "start": 132,
                    "end": 135,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 136,
                    "end": 138,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "Consequently, area(P ) \u2265 (1 \u2212 5\u03b4)h i /4 and thus the density in any full mini-container is at least (1 \u2212 5\u03b4)/4. As the total area of the full mini-containers in S is more than 1 \u2212 2\u03b4, the total area packed into S is more than \u03c1 := (1 \u2212 5\u03b4)(1 \u2212 2\u03b4)/4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "We use the described algorithm for square packing to prove statement (b). By the above strategy, if area(P) \u2264 1/\u03c1, where \u03c1 := (1 \u2212 5\u03b4)(1 \u2212 2\u03b4)/4, then the algorithm will use only one bin, so the packing achieves the optimum in this case. We may therefore assume area(P) > 1/\u03c1. We can guarantee a density of at least \u03c1 in all but one bin. Consequently, the number of bins is at most area(P)/\u03c1 + 1. Clearly, the number of bins in the optimal solution is at least area(P). Therefore, the approximation ratio is at most area(P)/\u03c1 + 1 area(P) \u2264 1/\u03c1 + \u03c1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "Using \u03b4 := 1/10 yields the ratio 10.1 as stated in the theorem. We finally prove (c). In order to obtain a bounding box with small perimeter, we consider the minicontainers in a greedy fashion (from largest to smallest height) and pack them on top of each other into stacks of height at most H := \u221a A C + h max and width (c + 1)w max . Clearly the height of each stack except possibly the last one is at least \u221a A C . Consequently, the number of stacks is at most \u221a A C (c+1)wmax + 1. Hence, we obtain a bounding box with perimeter of at most 4 \u221a A C + 2h max + 2(c + 1)w max . Because the optimal perimeter opt-p is at least max{2w max + 2h max , 4 area(P)}, we have h max w max \u2264 opt-p 2 /8 and area(P) \u2264 opt-p 2 /16. We then get from Equation (1) that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "Finally, choosing \u03b1 := 0.5 and c := 1.06, we obtain 4 A C + 2h max + 2(c + 1)w max \u2264 4 (1 + 1 /c) \u00b7 2 \u03b1 \u00b7 1 16 + c + 2 /\u03b1 1 \u2212 \u03b1 \u00b7 1 8 + 1 + c \u00b7 opt-p < 8.9 \u00b7 opt-p.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        },
        {
            "text": "This completes the proof. 2 In fact, we can choose \u03b1 depending on \u03b4 to get a denser packing. It turns out that \u03b1 := 1 \u2212 \u221a 3\u03b4 3 \u22124\u03b4 2 +\u03b4 1\u2212\u03b4 is the optimal value, but we stick to \u03b1 := 1/2 to keep the analysis simpler.",
            "cite_spans": [
                {
                    "start": 26,
                    "end": 27,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Algorithm for all convex pieces"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Online Packing to Minimize Area or Perimeter",
            "authors": [
                {
                    "first": "Mikkel",
                    "middle": [],
                    "last": "Abrahamsen",
                    "suffix": ""
                },
                {
                    "first": "Lorenzo",
                    "middle": [],
                    "last": "Beretta",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "37th International Symposium on Computational Geometry",
            "volume": "6",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.SoCG.2021.6"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Aligning two convex figures to minimize area or perimeter",
            "authors": [
                {
                    "first": "Otfried",
                    "middle": [],
                    "last": "Hee-Kap Ahn",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Cheong",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Algorithmica 62",
            "volume": "1",
            "issn": "",
            "pages": "464--479",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-010-9466-1"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Online scheduling",
            "authors": [
                {
                    "first": "Susanne",
                    "middle": [],
                    "last": "Albers",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Introduction to scheduling",
            "volume": "",
            "issn": "",
            "pages": "71--98",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Computational Aspects of Packing Problems",
            "authors": [
                {
                    "first": "Helmut",
                    "middle": [],
                    "last": "Alt",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Bulletin of the EATCS",
            "volume": "118",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Approximating minimum-area rectangular and convex containers for packing convex polygons",
            "authors": [
                {
                    "first": "Helmut",
                    "middle": [],
                    "last": "Alt",
                    "suffix": ""
                },
                {
                    "first": "Christian",
                    "middle": [],
                    "last": "Mark De Berg",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Knauer",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "JoCG 8.1 (2017)",
            "volume": "",
            "issn": "",
            "pages": "1--10",
            "other_ids": {
                "DOI": [
                    "10.20382/jocg.v8i1a1"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Corrigendum to: Approximating minimum-area rectangular and convex containers for packing convex polygons",
            "authors": [
                {
                    "first": "Helmut",
                    "middle": [],
                    "last": "Alt",
                    "suffix": ""
                },
                {
                    "first": "Christian",
                    "middle": [],
                    "last": "Mark De Berg",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Knauer",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "JoCG 11.1 (2020)",
            "volume": "",
            "issn": "",
            "pages": "653--655",
            "other_ids": {
                "DOI": [
                    "10.20382/jocg.v11i1a26"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Packing 2D Disks into a 3D Container",
            "authors": [
                {
                    "first": "Helmut",
                    "middle": [],
                    "last": "Alt",
                    "suffix": ""
                },
                {
                    "first": "Otfried",
                    "middle": [],
                    "last": "Cheong",
                    "suffix": ""
                },
                {
                    "first": "Ji-Won",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "Nadja",
                    "middle": [],
                    "last": "Scharf",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "International Workshop on Algorithms and Computation (WALCOM 2019",
            "volume": "",
            "issn": "",
            "pages": "369--380",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-10564-8_29"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Packing Convex Polygons into Rectangular Boxes",
            "authors": [
                {
                    "first": "Helmut",
                    "middle": [],
                    "last": "Alt",
                    "suffix": ""
                },
                {
                    "first": "Ferran",
                    "middle": [],
                    "last": "Hurtado",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "18th Japanese Conference on Discrete and Computational Geometry",
            "volume": "",
            "issn": "",
            "pages": "67--80",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Shelf algorithms for two-dimensional packing problems",
            "authors": [
                {
                    "first": "Brenda",
                    "middle": [
                        "S"
                    ],
                    "last": "Baker",
                    "suffix": ""
                },
                {
                    "first": "Jerald",
                    "middle": [
                        "S"
                    ],
                    "last": "Schwarz",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "SIAM Journal on Computing",
            "volume": "12",
            "issn": "3",
            "pages": "508--525",
            "other_ids": {
                "DOI": [
                    "10.1137/0212033"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Tight Bounds for Online TSP on the Line",
            "authors": [
                {
                    "first": "Antje",
                    "middle": [],
                    "last": "Bjelde",
                    "suffix": ""
                },
                {
                    "first": "Jan",
                    "middle": [],
                    "last": "Hackfeld",
                    "suffix": ""
                },
                {
                    "first": "Yann",
                    "middle": [],
                    "last": "Disser",
                    "suffix": ""
                },
                {
                    "first": "Christoph",
                    "middle": [],
                    "last": "Hansknecht",
                    "suffix": ""
                },
                {
                    "first": "Maarten",
                    "middle": [],
                    "last": "Lipmann",
                    "suffix": ""
                },
                {
                    "first": "Julie",
                    "middle": [],
                    "last": "Mei\u00dfner",
                    "suffix": ""
                },
                {
                    "first": "Miriam",
                    "middle": [],
                    "last": "Schl\u00f6ter",
                    "suffix": ""
                },
                {
                    "first": "Kevin",
                    "middle": [],
                    "last": "Schewior",
                    "suffix": ""
                },
                {
                    "first": "Leen",
                    "middle": [],
                    "last": "Stougie",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "ACM Transactions on Algorithms",
            "volume": "17",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3422362"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Improved Bound for Online Square-into-Square Packing",
            "authors": [
                {
                    "first": "Brian",
                    "middle": [],
                    "last": "Brubach",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Approximation and Online Algorithms -12th International Workshop (WAOA",
            "volume": "",
            "issn": "",
            "pages": "47--58",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-18263-6_5"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A Review of Machine Scheduling: Complexity, Algorithms and Approximability",
            "authors": [
                {
                    "first": "Bo",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "Chris",
                    "middle": [
                        "N"
                    ],
                    "last": "Potts",
                    "suffix": ""
                },
                {
                    "first": "Gerhard",
                    "middle": [
                        "J"
                    ],
                    "last": "Woeginger",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Handbook of Combinatorial Optimization: Volume1-3. Ed. by Ding-Zhu Du and Panos M. Pardalos",
            "volume": "",
            "issn": "",
            "pages": "1493--1641",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-4613-0303-9_25"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Approximation and online algorithms for multidimensional bin packing: A survey",
            "authors": [
                {
                    "first": "Henrik",
                    "middle": [
                        "I"
                    ],
                    "last": "Christensen",
                    "suffix": ""
                },
                {
                    "first": "Arindam",
                    "middle": [],
                    "last": "Khan",
                    "suffix": ""
                },
                {
                    "first": "Sebastian",
                    "middle": [],
                    "last": "Pokutta",
                    "suffix": ""
                },
                {
                    "first": "Prasad",
                    "middle": [],
                    "last": "Tetali",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Computer Science Review",
            "volume": "24",
            "issn": "",
            "pages": "1574--0137",
            "other_ids": {
                "DOI": [
                    "10.1016/j.cosrev.2016.12.001"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Efficient packings of unit squares in a large square",
            "authors": [
                {
                    "first": "Fan",
                    "middle": [],
                    "last": "Chung",
                    "suffix": ""
                },
                {
                    "first": "Ron",
                    "middle": [],
                    "last": "Graham",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Discrete & Computational Geometry",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "On-line packing and covering problems",
            "authors": [
                {
                    "first": "J\u00e1nos",
                    "middle": [],
                    "last": "Csirik",
                    "suffix": ""
                },
                {
                    "first": "Gerhard",
                    "middle": [
                        "J"
                    ],
                    "last": "Woeginger",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Online Algorithms: The State of the Art",
            "volume": "",
            "issn": "",
            "pages": "147--177",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0029568"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Shelf Algorithms for On-Line Strip Packing",
            "authors": [
                {
                    "first": "J\u00e1nos",
                    "middle": [],
                    "last": "Csirik",
                    "suffix": ""
                },
                {
                    "first": "Gerhard",
                    "middle": [
                        "J"
                    ],
                    "last": "Woeginger",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Information Processing Letters",
            "volume": "63",
            "issn": "",
            "pages": "171--175",
            "other_ids": {
                "DOI": [
                    "10.1016/S0020-0190(97)00120-8"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Multidimensional packing problems",
            "authors": [
                {
                    "first": "Leah",
                    "middle": [],
                    "last": "Epstein",
                    "suffix": ""
                },
                {
                    "first": "Rob",
                    "middle": [],
                    "last": "Van Stee",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Handbook of Approximation Algorithms and Metaheuristics",
            "volume": "",
            "issn": "",
            "pages": "553--570",
            "other_ids": {
                "DOI": [
                    "10.1201/9781351236423-31"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "On packing squares with equal squares",
            "authors": [
                {
                    "first": "Paul",
                    "middle": [],
                    "last": "Erd\u0151s",
                    "suffix": ""
                },
                {
                    "first": "Ron",
                    "middle": [],
                    "last": "Graham",
                    "suffix": ""
                }
            ],
            "year": 1975,
            "venue": "Journal of Combinatorial Theory, Series A",
            "volume": "19",
            "issn": "1",
            "pages": "119--123",
            "other_ids": {
                "DOI": [
                    "10.1016/0097-3165(75)90099-0"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Online Square-into-Square Packing",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "S\u00e1ndor",
                    "suffix": ""
                },
                {
                    "first": "Hella-Franziska",
                    "middle": [],
                    "last": "Fekete",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Hoffmann",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "867--901",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-016-0114-2"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Competitive analysis of algorithms",
            "authors": [
                {
                    "first": "Amos",
                    "middle": [],
                    "last": "Fiat",
                    "suffix": ""
                },
                {
                    "first": "Gerhard",
                    "middle": [
                        "J"
                    ],
                    "last": "Woeginger",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Online Algorithms: The State of the Art",
            "volume": "",
            "issn": "",
            "pages": "1--12",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0029562"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "On-line scheduling on a single machine: Minimizing the total completion time",
            "authors": [
                {
                    "first": "Amos",
                    "middle": [],
                    "last": "Fiat",
                    "suffix": ""
                },
                {
                    "first": "Gerhard",
                    "middle": [
                        "J"
                    ],
                    "last": "Woeginger",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Acta Informatica",
            "volume": "36",
            "issn": "",
            "pages": "287--293",
            "other_ids": {
                "DOI": [
                    "10.1007/s002360050162"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Optimization and Approximation in Deterministic Sequencing and Scheduling: a Survey",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "L"
                    ],
                    "last": "Graham",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "L"
                    ],
                    "last": "Lawler",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "K"
                    ],
                    "last": "Lenstra",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "H G"
                    ],
                    "last": "Rinnooy Kan",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Discrete Optimization II",
            "volume": "5",
            "issn": "",
            "pages": "287--326",
            "other_ids": {
                "DOI": [
                    "10.1016/S0167-5060(08)70356-X"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "A new upper bound 2.5545 on 2D Online Bin Packing",
            "authors": [
                {
                    "first": "Xin",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [
                        "L"
                    ],
                    "last": "Francis",
                    "suffix": ""
                },
                {
                    "first": "Hing-Fung",
                    "middle": [],
                    "last": "Chin",
                    "suffix": ""
                },
                {
                    "first": "Guochuan",
                    "middle": [],
                    "last": "Ting",
                    "suffix": ""
                },
                {
                    "first": "Yong",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "ACM Transactions on Algorithms",
            "volume": "7",
            "issn": "4",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/2000807.2000818"
                ]
            }
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Strip Packing vs. Bin Packing",
            "authors": [
                {
                    "first": "Xin",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                },
                {
                    "first": "Kazuo",
                    "middle": [],
                    "last": "Iwama",
                    "suffix": ""
                },
                {
                    "first": "Deshi",
                    "middle": [],
                    "last": "Ye",
                    "suffix": ""
                },
                {
                    "first": "Guochuan",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Algorithmic Aspects in Information and Management",
            "volume": "",
            "issn": "",
            "pages": "358--367",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-72870-2_34"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Online removable square packing",
            "authors": [
                {
                    "first": "Xin",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                },
                {
                    "first": "Kazuo",
                    "middle": [],
                    "last": "Iwama",
                    "suffix": ""
                },
                {
                    "first": "Guochuan",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Theory of Computing Systems",
            "volume": "43",
            "issn": "",
            "pages": "38--55",
            "other_ids": {
                "DOI": [
                    "10.1007/s00224-007-9039-0"
                ]
            }
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "On-line packing sequences of cubes in the unit cube",
            "authors": [
                {
                    "first": "Janusz",
                    "middle": [],
                    "last": "Januszewski",
                    "suffix": ""
                },
                {
                    "first": "Marek",
                    "middle": [],
                    "last": "Lassak",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Geometriae Dedicata",
            "volume": "67",
            "issn": "",
            "pages": "285--293",
            "other_ids": {
                "DOI": [
                    "10.1023/A:1004953109743"
                ]
            }
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "A proof of an Auerbach-Banach-Mazur-Ulam theorem on convex bodies",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kosi\u0144ski",
                    "suffix": ""
                }
            ],
            "year": 1957,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "216--218",
            "other_ids": {
                "DOI": [
                    "10.4064/cm-4-2-216-218"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "An on-line potato-sack theorem",
            "authors": [
                {
                    "first": "Marek",
                    "middle": [],
                    "last": "Lassak",
                    "suffix": ""
                },
                {
                    "first": "Jixian",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Discrete & Computational Geometry",
            "volume": "6",
            "issn": "",
            "pages": "1--7",
            "other_ids": {
                "DOI": [
                    "10.1007/BF02574670"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Determining in Linear Time the Minimum Area Convex Hull of Two Polygons",
            "authors": [
                {
                    "first": "Hyun-Chan",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "Tony",
                    "middle": [
                        "C"
                    ],
                    "last": "Woo",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "IIE Transactions",
            "volume": "20",
            "issn": "",
            "pages": "338--345",
            "other_ids": {
                "DOI": [
                    "10.1080/07408178808966189"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Dense packings of congruent circles in rectangles with a variable aspect ratio",
            "authors": [
                {
                    "first": "Boris",
                    "middle": [
                        "D"
                    ],
                    "last": "Lubachevsky",
                    "suffix": ""
                },
                {
                    "first": "Ronald",
                    "middle": [
                        "L"
                    ],
                    "last": "Graham",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Discrete and Computational Geometry: The Goodman-Pollack Festschrift",
            "volume": "",
            "issn": "",
            "pages": "633--650",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-55566-4_28"
                ]
            }
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Minimum perimeter rectangles that enclose congruent non-overlapping circles",
            "authors": [
                {
                    "first": "Boris",
                    "middle": [
                        "D"
                    ],
                    "last": "Lubachevsky",
                    "suffix": ""
                },
                {
                    "first": "Ronald",
                    "middle": [
                        "L"
                    ],
                    "last": "Graham",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Discrete Mathematics",
            "volume": "309",
            "issn": "",
            "pages": "1947--1962",
            "other_ids": {
                "DOI": [
                    "10.1016/j.disc.2008.03.017"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "The Scottish Book: Mathematics from the Scottish Caf\u00e9, with Selected Problems from the New Scottish Book",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": "Daniel",
                    "middle": [],
                    "last": "Mauldin",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-22897-6"
                ]
            }
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Rotational polygon containment and minimum enclosure using only robust 2D constructions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Victor",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Milenkovic",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Computational Geometry",
            "volume": "13",
            "issn": "",
            "pages": "6--7",
            "other_ids": {
                "DOI": [
                    "10.1016/S0925-7721(99)00006-1"
                ]
            }
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Translational polygon containment and minimal enclosure using linear programming based restriction",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Victor",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Milenkovic",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Proceedings of the twenty-eighth annual ACM symposium on Theory of Computing (STOC",
            "volume": "",
            "issn": "",
            "pages": "109--118",
            "other_ids": {
                "DOI": [
                    "10.1145/237814.237840"
                ]
            }
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Translational polygon containment and minimal enclosure using mathematical programming",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Victor",
                    "suffix": ""
                },
                {
                    "first": "Karen",
                    "middle": [],
                    "last": "Milenkovic",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Daniels",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "International Transactions in Operational Research",
            "volume": "6",
            "issn": "",
            "pages": "525--554",
            "other_ids": {
                "DOI": [
                    "10.1111/j.1475-3995.1999.tb00171.x"
                ]
            }
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Some packing and covering theorems",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "W"
                    ],
                    "last": "Moon",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Moser",
                    "suffix": ""
                }
            ],
            "year": 1967,
            "venue": "Colloquium Mathematicum",
            "volume": "17",
            "issn": "1",
            "pages": "103--110",
            "other_ids": {
                "DOI": [
                    "10.4064/cm-17-1-103-110"
                ]
            }
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Bundling three convex polygons to minimize area or perimeter",
            "authors": [
                {
                    "first": "Dongwoo",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "Sang",
                    "middle": [
                        "Won"
                    ],
                    "last": "Bae",
                    "suffix": ""
                },
                {
                    "first": "Helmut",
                    "middle": [],
                    "last": "Alt",
                    "suffix": ""
                },
                {
                    "first": "Hee-Kap",
                    "middle": [],
                    "last": "Ahn",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Computational Geometry",
            "volume": "51",
            "issn": "",
            "pages": "925--7721",
            "other_ids": {
                "DOI": [
                    "10.1016/j.comgeo.2015.10.003"
                ]
            }
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Online scheduling",
            "authors": [
                {
                    "first": "Kirk",
                    "middle": [],
                    "last": "Pruhs",
                    "suffix": ""
                },
                {
                    "first": "Ji\u0159\u00ed",
                    "middle": [],
                    "last": "Sgall",
                    "suffix": ""
                },
                {
                    "first": "Eric",
                    "middle": [],
                    "last": "Torng",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Handbook of Scheduling: Algorithms, Models, and Performance Analysis",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "On-line scheduling",
            "authors": [
                {
                    "first": "Ji\u0159\u00ed",
                    "middle": [],
                    "last": "Sgall",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Online Algorithms: The State of the Art",
            "volume": "",
            "issn": "",
            "pages": "196--231",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0029570"
                ]
            }
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "High density packings of equal circles in rectangles with variable aspect ratio",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Specht",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Computers & Operations Research",
            "volume": "40",
            "issn": "",
            "pages": "58--69",
            "other_ids": {
                "DOI": [
                    "10.1016/j.cor.2012.05.011"
                ]
            }
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "SIGACT news online algorithms column 20: the power of harmony",
            "authors": [
                {
                    "first": "Rob",
                    "middle": [],
                    "last": "Van Stee",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "SIGACT News",
            "volume": "43",
            "issn": "",
            "pages": "127--136",
            "other_ids": {
                "DOI": [
                    "10.1145/2261417.2261440"
                ]
            }
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "SIGACT News Online Algorithms Column 26: Bin packing in multiple dimensions",
            "authors": [
                {
                    "first": "Rob",
                    "middle": [],
                    "last": "Van Stee",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "SIGACT News",
            "volume": "46",
            "issn": "",
            "pages": "105--112",
            "other_ids": {
                "DOI": [
                    "10.1145/2789149.2789167"
                ]
            }
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "A note on online strip packing",
            "authors": [
                {
                    "first": "Deshi",
                    "middle": [],
                    "last": "Ye",
                    "suffix": ""
                },
                {
                    "first": "Xin",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                },
                {
                    "first": "Guochuan",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "In: Journal of Combinatorial Optimization",
            "volume": "17",
            "issn": "",
            "pages": "417--423",
            "other_ids": {
                "DOI": [
                    "10.1007/s10878-007-9125-x"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "For any \u03b5 > 0, there exists an algorithm for Online-Sorting[1 + \u03b5, n] with competitive ratio 2 O( \u221a log n log log n) .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "There exists an algorithm for Strip-Packing with competitive ratio O(n log 3\u22121 log n), where n is the number of pieces.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "A fan-like packing of pieces of nearly equal height. The pieces are sorted according to the slope of their spine segments (dashed).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "There are polynomial-time offline algorithms for the following packing problems: (a) Offline-Strip-Packing, 32.7-approximation algorithm. (b) Offline-Bin-Packing, 10.1-approximation algorithm if the diameter of all pieces is bounded by 1/10. (c) Offline-Perimeter-Packing, 8.9-approximation algorithm.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Strip packing and online sorting.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "If there exists a C-competitive algorithm for Strip-Packing, then there exists a 4C-competitive algorithm for Online-Sorting[2C, n].",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Two strip packings of the same set of parallelograms. Left: The packing we use as an upper bound for the optimum (which is in fact the optimum). Right: An arbitrary packing with the gaps and segments that we count shown as segments outside the strip.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "N 1 := \u221a n and partition [0, 1] into N 1 intervals, J 1 , . . . , J N1 , each of length 1 /N1. Further define N 2 := 2N 1 1 We thank Shyam Narayanan for improving our initial O( \u221a n log n) upper bound to the asymptotically tight O( \u221a n).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Present A with any real from S 1 . Proceed to phase 1. Phase i \u2265 1: While there exists an expensive real x \u2208 S i (at some time t): -Present A with copies of x until one is placed in a cell of R t \\ H t (x). -Leave the set of marked cells unchanged. If no expensive real exists at the current time t: -Define the set of well-sized reals at phase i as W i := x \u2208 S i s i \u03b4 \u2264 |H t (x)| \u2264 4\u03b3s i . -Define the set of deserted reals at phase i as D i := x \u2208 W i \u2200y \u2208 S i+1 it holds that |y\u2212x| \u2265 s i+1 12n . -Define the deserted space at phase i as D i := x\u2208Di H i (x). -Mark all the cells in D i (so that M t := M t\u22121 \u222a D i ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "For any \u03b5 > 0, there exists an algorithm for Online-Sorting[1 + \u03b5, n] with competitive ratio 2 O( \u221a log n log log n) .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "We define the pointer vector p :[b] \u2212\u2192 N and initialize p(i) = i for each i \u2208 [b]. We define the set of active boxes A := {B p(i) | i \u2208 [b]} and let R := max i\u2208[b] p(i) \u00b7 w denote the rightmost cell index in any active box. We say B p(i) is full if it contains n reals. Given a real x \u2208",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "It uses (1 + 2k\u03b4)n \u2264 (1 + \u03b5)n memory cells and yields a cost of n 1/(k+1) \u00b7 \u03b4 \u2212O(k+1) = 2 O(log n/k+k log(2k/\u03b5)) = 2 O( \u221a log n log log n) .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "The figure shows the correspondence between the strips S * and S.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "A box type is represented by a vector [x 1 , . . . , x d ] \u2208 {\u22121, 0, +1} d . Given a d-dimensional box type T := [x 1 , . . . , x d ] \u2208 {\u22121, 0, +1} d , we The top three layers of the box type tree.define (d + 1)-dimensional box types T \u2295 [x d+1 ] = [x 1 , . . . , x d , x d+1 ] for x d+1 \u2208 {\u22121, 0, +1},as follows. Let b and t be the bottom and top edges of T . We partition b and t into three equally long segments b \u22121 , b 0 , b +1 and t \u22121 , t 0 , t +1 , respectively, in order from left to right. For x d+1 \u2208 {\u22121, 0, +1}, we then define T \u2295 [x d+1 ] to be the parallelogram spanned by the segments b 0 and t x d+1 . It follows that a box of type [x 1 , . . . , x d ] has base edges of length 2 \u00b7 3 \u2212d and the other pair of parallel edges have width 2 d i=1 xi /3 i . Lemma 14. For every d \u2265 0 and every line segment s of height 1 and width at most 1, there exists a d-dimensional box type T that can contain s when the lower endpoint of s is placed at the midpoint of the bottom segment of T .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF14": {
            "text": "For any type T it holds that a box of type T can contain two boxes B1, B2 of types that are children of T if B1 and B2 have the same type or one of them has type T \u2295 [0]. Here, it is shown for the base type T := [ ].",
            "latex": null,
            "type": "figure"
        },
        "FIGREF15": {
            "text": "There exists an algorithm for Strip-Packing with competitive ratio O(n log 3\u22121 log n), where n is the number of pieces. The horizontal parallelogram P has area at most twice that of the piece P .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF16": {
            "text": "Constant-factor approximations for offline packingIn this section we show how to obtain offline approximation algorithms for the packing problems of Theorem 2.Theorem 6. There are polynomial-time offline algorithms for the following packing problems: (a) Offline-Strip-Packing, 32.7-approximation algorithm. (b) Offline-Bin-Packing, 10.1-approximation algorithm if the diameter of all pieces is bounded by 1/10.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF17": {
            "text": "Offline-Perimeter-Packing, 8.9-approximation algorithm. (d) Offline-Square-Packing[1/10], in particular, every set of convex polygons of diameter and total area at most 1/10 can be packed into the unit square.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "The second term comes from consecutive entries A[i], A[i + 1] where A[i] is in some subarray A j and A[i + 1] is in the next A j+1 , or A[i] is full when the algorithm recurses for the first time and A[i + 1] becomes full in the recursion (in which case we simply bound |A[i] \u2212 A[i + 1]| \u2264 1). The total cost is therefore upper bounded by",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "The marked cells will represent parts of the array where A can only place a limited number of reals without incurring a high cost. Identifying the array with [m], at any given point in time t, i.e., after t reals in [0, 1] have been presented to A, we let F t \u2282 [m] denote the full cells, M t \u2282 [m] denote the marked cells, and R t := [m] \\ (F t \u222a M t ) denote the remaining cells. We remark that F t and M t need not be disjoint -even though a cell can only get marked when it's empty, A might insert a real in that cell at a later point in time.",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "1, (1 + 2k\u03b4)n]. Let {B 1 , . . . , B } be the set of boxes we used (either full or active), so that [1, R] = i=1 B i . We partition [ ] into F and E so that F := {i \u2208 [ ] | B i is full} and E := [ ] \\ F . Denote with E(B i ) the number of empty cells in box",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We thank Shyam Narayanan for improving the upper bound algorithm in Theorem 3 to the asymptotically tight upper bound of O( \u221a n). We highly appreciate the BARC espresso machine, the comfy couches in the Creative Room, and the cucumbers. We also thank Linda's travel grant, Denmark for opening the borders in the right moment after a COVID-19 lockdown, and the lenient train officer who trusted the great authority of Mikkel's letter of invitation, allowing for travelling to Copenhagen and making this work possible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgements"
        }
    ]
}