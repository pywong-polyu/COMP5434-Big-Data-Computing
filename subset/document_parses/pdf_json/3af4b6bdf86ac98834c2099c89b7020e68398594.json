{
    "paper_id": "3af4b6bdf86ac98834c2099c89b7020e68398594",
    "metadata": {
        "title": "A Generalized Formal Semantic Framework for Smart Contracts",
        "authors": [
            {
                "first": "Jiao",
                "middle": [],
                "last": "Jiao",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Nanyang Technological University",
                    "location": {
                        "country": "Singapore"
                    }
                },
                "email": ""
            },
            {
                "first": "Shang-Wei",
                "middle": [],
                "last": "Lin",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Nanyang Technological University",
                    "location": {
                        "country": "Singapore"
                    }
                },
                "email": "shang-wei.lin@ntu.edu.sg"
            },
            {
                "first": "Jun",
                "middle": [],
                "last": "Sun",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Singapore Management University",
                    "location": {
                        "country": "Singapore"
                    }
                },
                "email": "junsun@smu.edu.sg"
            }
        ]
    },
    "abstract": [
        {
            "text": "Smart contracts can be regarded as one of the most popular blockchain-based applications. The decentralized nature of the blockchain introduces vulnerabilities absent in other programs. Furthermore, it is very difficult, if not impossible, to patch a smart contract after it has been deployed. Therefore, smart contracts must be formally verified before they are deployed on the blockchain to avoid attacks exploiting these vulnerabilities. There is a recent surge of interest in analyzing and verifying smart contracts. While most of the existing works either focus on EVM bytecode or translate Solidity contracts into programs in intermediate languages for analysis and verification, we believe that a direct executable formal semantics of the high-level programming language of smart contracts is necessary to guarantee the validity of the verification. In this work, we propose a generalized formal semantic framework based on a general semantic model of smart contracts. Furthermore, this framework can directly handle smart contracts written in different high-level programming languages through semantic extensions and facilitates the formal verification of security properties with the generated semantics.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Blockchain [17] technologies have been studied extensively recently. Smart contracts [16] can be regarded as one of the most popular blockchain-based applications. Due to the very nature of the blockchain, credible and traceable transactions are allowed through smart contracts without relying on an external trusted authority to achieve consensus. However, the unique features of the blockchain introduce vulnerabilities [10] absent in other programs.",
            "cite_spans": [
                {
                    "start": 11,
                    "end": 15,
                    "text": "[17]",
                    "ref_id": null
                },
                {
                    "start": 85,
                    "end": 89,
                    "text": "[16]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 422,
                    "end": 426,
                    "text": "[10]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Smart contracts must be verified for multiple reasons. Firstly, due to the decentralized nature of the blockchain, smart contracts are different from programs written in other programming languages (e.g., C/Java). For instance, the storage of each contract instance is at a permanent address on the blockchain. In this way, each instance is a particular execution context and context switches are possible through external calls. Particularly, in Solidity, delegatecall executes programs in the context of the caller rather than the recipient, making it possible to modify the state of the caller. Programmers must be aware of the execution context of each statement to guarantee the programming correctness. Therefore, programming smart contracts is error-prone without a proper understanding of the underlying semantic model. Secondly, a smart contract can be deployed on the blockchain by any user in the network. Vulnerabilities in deployed contracts can be exploited to launch attacks that lead to huge financial loss. Verifying smart contracts against such vulnerabilities is crucial for protecting digital assets. One famous attack on smart contracts is the DAO attack [41] in which the attacker exploited the reentrancy vulnerability and managed to take 60 million dollars under his control. Thirdly, it is very difficult, if not impossible, to patch a smart contract once it is deployed due to the very nature of the blockchain.",
            "cite_spans": [
                {
                    "start": 1176,
                    "end": 1180,
                    "text": "[41]",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Related Works. There is a surge of interest in analyzing and verifying smart contracts [32, 12, 24, 28, 26, 9, 25, 31, 21, 44, 20, 22, 38, 36, 4, 34, 43, 19, 30, 35, 29, 23, 46, 14] . Some of the existing works focus on EVM [2, 47] (Ethereum Virtual Machine) . For instance, a symbolic execution engine called Oyente is proposed in [32] to analyze Solidity smart contracts by translating them into EVM bytecode. In addition, a complete formal executable semantics of EVM [24] is developed in the K-framework to facilitate the formal verification of smart contracts at bytecode level. A set of test oracles is defined in [26, 45] to detect security vulnerabilities on EVM bytecode. In [21] , a semantic framework is proposed to analyze smart contracts at EVM level. Securify [44] translates EVM bytecode into a stackless representation in static-single assignment form for analyzing smart contracts. In other works, Solidity smart contracts are translated into programs in intermediate languages for analysis and verification. Specifically speaking, Solidity programs are formalized with an abstract language and then translated into LLVM bitcode in Zeus [28] . Similarly, Boogie is used to verify smart contracts as an intermediate language in the proposed verifiers in [31, 23] . In addition, the formalization in F* [12] is an intermediate-level language for the equivalence checking of Solidity programs and EVM bytecode. In [22] , a simple imperative object-based programming language, called SMAC, is used to facilitate the online detection of Effectively Callback Free (ECF) objects in smart contracts. To conclude, most of the existing approaches either focus on EVM bytecode, or translate Solidity smart contracts into programs in intermediate languages that are suitable for verifying smart contracts or detecting potential issues in associated verifiers or checkers. Furthermore, none of the existing works can directly handle smart contracts written in different high-level programming languages without translating them into EVM bytecode or intermediate languages.",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 91,
                    "text": "[32,",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 92,
                    "end": 95,
                    "text": "12,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 96,
                    "end": 99,
                    "text": "24,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 100,
                    "end": 103,
                    "text": "28,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 104,
                    "end": 107,
                    "text": "26,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 108,
                    "end": 110,
                    "text": "9,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 111,
                    "end": 114,
                    "text": "25,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 115,
                    "end": 118,
                    "text": "31,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 119,
                    "end": 122,
                    "text": "21,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 123,
                    "end": 126,
                    "text": "44,",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 127,
                    "end": 130,
                    "text": "20,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 131,
                    "end": 134,
                    "text": "22,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 135,
                    "end": 138,
                    "text": "38,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 139,
                    "end": 142,
                    "text": "36,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 143,
                    "end": 145,
                    "text": "4,",
                    "ref_id": null
                },
                {
                    "start": 146,
                    "end": 149,
                    "text": "34,",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 150,
                    "end": 153,
                    "text": "43,",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 154,
                    "end": 157,
                    "text": "19,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 158,
                    "end": 161,
                    "text": "30,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 162,
                    "end": 165,
                    "text": "35,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 166,
                    "end": 169,
                    "text": "29,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 170,
                    "end": 173,
                    "text": "23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 174,
                    "end": 177,
                    "text": "46,",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 178,
                    "end": 181,
                    "text": "14]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 224,
                    "end": 227,
                    "text": "[2,",
                    "ref_id": null
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "47]",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 232,
                    "end": 258,
                    "text": "(Ethereum Virtual Machine)",
                    "ref_id": null
                },
                {
                    "start": 332,
                    "end": 336,
                    "text": "[32]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 471,
                    "end": 475,
                    "text": "[24]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 620,
                    "end": 624,
                    "text": "[26,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 625,
                    "end": 628,
                    "text": "45]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 684,
                    "end": 688,
                    "text": "[21]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 774,
                    "end": 778,
                    "text": "[44]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 1154,
                    "end": 1158,
                    "text": "[28]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1270,
                    "end": 1274,
                    "text": "[31,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 1275,
                    "end": 1278,
                    "text": "23]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1318,
                    "end": 1322,
                    "text": "[12]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1428,
                    "end": 1432,
                    "text": "[22]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A direct executable formal semantics of the high-level smart contract programming language is a must for both understanding and verifying smart contracts. Firstly, programmers write and reason about smart contracts at the level of source code without the semantics of which they are required to understand how Solidity programs are compiled into EVM bytecode in order to understand these contracts, which is far from trivial. In addition, there may be semantic gaps between high-level smart contract programming languages and low-level bytecode. Therefore, both high-level [27, 48, 49, 15, 11] and low-level [24, 21] semantics definitions are necessary to conduct equivalence checking to guarantee that security properties are preserved at both levels and reason about compiler bugs. Secondly, even though smart contracts can be transformed into programs in intermediate languages to be analyzed and verified in existing model checkers and verifiers, the equivalence checking of the high-level smart contract programming language and the intermediate language considered is crucial to the validity of the verification. For instance, most of the false positives reported in Zeus [28] are caused by the semantic inconsistency of the abstract language and Solidity.",
            "cite_spans": [
                {
                    "start": 573,
                    "end": 577,
                    "text": "[27,",
                    "ref_id": null
                },
                {
                    "start": 578,
                    "end": 581,
                    "text": "48,",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 582,
                    "end": 585,
                    "text": "49,",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 586,
                    "end": 589,
                    "text": "15,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 590,
                    "end": 593,
                    "text": "11]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 608,
                    "end": 612,
                    "text": "[24,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 613,
                    "end": 616,
                    "text": "21]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1178,
                    "end": 1182,
                    "text": "[28]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Motivations."
        },
        {
            "text": "As domain-specific languages, high-level smart contract programming languages, such as Solidity, Vyper, Bamboo, etc, intend to implement the correct or desired semantics of smart contracts although they may not actually achieve this. This means that these languages are semantically similar in order to interpret the same high-level semantics of smart contracts. For instance, Vyper is quite similar to Solidity in spite of syntax differences and the semantics interpreted by Bamboo is consistent with that of Solidity (cf. Section 2.1 for details). Considering this fact, we propose a generalized formal semantic framework based on a general semantic model of smart contracts. Different from previous works which either analyze and verify smart contracts on EVM semantics or interpret Solidity semantics with the semantics of intermediate languages, the proposed framework aims to generate a direct executable formal semantics of a particular high-level smart contract programming language to facilitate the high-level verification of contracts and reason about compiler bugs. Furthermore, this framework provides a uniform formal specification of smart contracts, making it possible to apply verification techniques to contracts written in different languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivations."
        },
        {
            "text": "Challenges. The challenges of developing a generalized formal semantic framework mainly lie in the construction of a general semantic model of smart contracts. Firstly, different high-level smart contract programming languages differ in syntax which limits state transitions. Compared with Solidity, Vyper [8] and Bamboo [1] have more syntax limits to exclude some vulnerabilities reported in Solidity. For instance, Vyper eliminates gasless send by blocking recursive calls and infinite loops, and reentrancy attacks by excluding the possibility of state changes after external calls [40] . In addition, there are no state variables in Bamboo and each contract represents a particular execution state, making it possible to limit operations to certain states to prevent attacks. Therefore, we need to take into account the syntax differences when constructing a general semantic model for smart contracts. Secondly, semantics developed with the general semantic model must be direct to guarantee the validity of the verification. For instance, as discussed above, even though intermediate languages may be a good solution to construct a general semantic model, they introduce semantic-level equivalence checking issues due to pure syntax translations.",
            "cite_spans": [
                {
                    "start": 306,
                    "end": 309,
                    "text": "[8]",
                    "ref_id": null
                },
                {
                    "start": 321,
                    "end": 324,
                    "text": "[1]",
                    "ref_id": null
                },
                {
                    "start": 585,
                    "end": 589,
                    "text": "[40]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Motivations."
        },
        {
            "text": "Contributions. In this work, we develop a generalized formal semantic framework for smart contracts. The contributions of this work lie in three aspects. Firstly, our work is the first approach, to our knowledge, to a generalized formal semantic framework for smart contracts which can directly handle con-tracts written in different high-level programming languages. Secondly, a general semantic model of smart contracts is constructed with rewriting logic in the K-framework. With the general semantic model, a direct executable formal semantics of a particular high-level smart contract programming language can be constructed as long as its core features fall into the ones defined in this model. The general semantic model is validated with its interpretation in Solidity using the Solidity compiler test set [6] and evaluation results show that it is complete and correct. Lastly, the generated semantics facilitates the formal verification of smart contracts written in a particular high-level programming language as a formal specification of the corresponding language. Together with low-level specifications [24, 21] , it allows us to conduct equivalence checking on high-level programs and low-level bytecode to reason about compiler bugs and guarantee that security properties are preserved at both levels.",
            "cite_spans": [
                {
                    "start": 814,
                    "end": 817,
                    "text": "[6]",
                    "ref_id": null
                },
                {
                    "start": 1118,
                    "end": 1122,
                    "text": "[24,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 1123,
                    "end": 1126,
                    "text": "21]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Motivations."
        },
        {
            "text": "Outline. The remaining part of this paper is organized as follows. In Section 2, we introduce smart contracts and the K-framework. The general semantic model of smart contracts is introduced in Section 3. In Section 4, we take Solidity as an example to illustrate how to generate a direct executable formal semantics of a particular high-level smart contract programming language based on the general semantic model. Section 5 shows the evaluation results of the proposed framework. Section 6 concludes this work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivations."
        },
        {
            "text": "In this section, we briefly introduce smart contracts and the K-framework.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Solidity Smart Contracts. Ethereum [2, 47] , proposed in late 2013 by Vitalik Buterin, is a blockchain-based distributed computing platform supporting the functionality of smart contracts. It provides a decentralized international network where each participant node equipped with EVM can execute smart contracts. It also provides a cryptocurrency called \"ether\" (ETH) which can be transferred between different accounts and used to compensate participant nodes for their computations on smart contracts.",
            "cite_spans": [
                {
                    "start": 35,
                    "end": 38,
                    "text": "[2,",
                    "ref_id": null
                },
                {
                    "start": 39,
                    "end": 42,
                    "text": "47]",
                    "ref_id": "BIBREF45"
                }
            ],
            "ref_spans": [],
            "section": "Smart Contracts"
        },
        {
            "text": "Solidity is one of the high-level programming languages to implement smart contracts on Ethereum. A smart contract written in Solidity can be compiled into EVM bytecode and executed by any participant node equipped with EVM. A Solidity smart contract is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain [7]. Fig. 1 shows an example of Solidity smart contracts, named Coin, implementing a very simple cryptocurrency. In line 2, the public state variable minter of type address is declared to store the address of the minter of the cryptocurrency, i.e., the owner of the smart contract. The constructor, denoted by constructor(), is defined in lines 5-7. Once the smart contract is created and deployed 3 , its constructor is invoked automatically, and minter is set to be the address of its creator (owner), represented by the built-in keyword msg.sender. In line 3, the public state variable balances is declared to store the balances of users. It is of type mapping, which can be considered as a hash-table mapping from keys to values. In this example, balances maps from a user (represented as an address) to his/her balance (represented as an unsigned integer value). The mint function, defined in lines 9-12, is supposed to be invoked only by its owner to mint coins, the number of which is specified by amount, for the user located at the receiver address. If mint is called by anyone except the owner of the contract, nothing will happen because of the guarding if statement in line 10. The send function, defined in lines 14-18, can be invoked by any user to transfer coins, the number of which is specified by amount, to another user located at the receiver address. If the balance is not sufficient, nothing will happen because of the guarding if statement in line 15; otherwise, the balances of both sides will be updated accordingly.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 379,
                    "end": 385,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Smart Contracts"
        },
        {
            "text": "A blockchain is actually a globally-shared transactional database or ledger. If one wants to make any state change on the blockchain, he or she has to create a so-called transaction which has to be accepted and validated by all other participant nodes. Furthermore, once a transaction is applied to the blockchain, no other transactions can alter it. For example, deploying the Coin smart contract generates a transaction because the state of the blockchain is going to be changed, i.e., one more smart contract instance will be included. Similarly, any invocation of the function mint or send also generates a transaction because the state of the contract instance, which is a part of the whole blockchain, is going to be changed. Transactions have to be selected and added into blocks to be appended to the blockchain. This procedure is the so-called mining, and the participant nodes are called miners.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Smart Contracts"
        },
        {
            "text": "Vyper Smart Contracts. Vyper is a high-level programming language for smart contracts running on EVM. As an alternative to Solidity, Vyper is con- sidered to be more secure by blocking recursive calls and infinite loops to avoid gasless send, and excluding the possibility of state changes after external calls to prevent reentrancy attacks [40] . Thus, it is more difficult to write vulnerable code in Vyper. In addition, it supports bounds and overflow checking, and strong typing. Particularly, timing features such as block timestamps are supported as types, making it possible to detect the vulnerability of timestamp dependence [32] on Vyper semantics. This is not possible on Solidity semantics since Solidity does not support timing features. Apart from security, simplicity is another goal of Vyper. It aims to provide a more human-readable language, and a simpler compiler implementation. An example Vyper smart contract corresponding to the Solidity smart contract illustrated in Fig. 1 is shown in Fig. 2 .",
            "cite_spans": [
                {
                    "start": 341,
                    "end": 345,
                    "text": "[40]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 634,
                    "end": 638,
                    "text": "[32]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [
                {
                    "start": 991,
                    "end": 997,
                    "text": "Fig. 1",
                    "ref_id": null
                },
                {
                    "start": 1010,
                    "end": 1016,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Smart Contracts"
        },
        {
            "text": "Bamboo Smart Contracts. Bamboo is another high-level programming language for Ethereum smart contracts. In Bamboo, state variables are eliminated and each contract represents a particular execution state, making state transitions explicit to avoid reentrancy attacks by default. This is because operations in functions are limited to certain states. An example Bamboo smart contract which is equivalent to the Solidity smart contract illustrated in Fig. 1 is shown in Fig. 3 . In this example, explicit state transitions are applied to strictly limit operations in the constructor to a certain state. To be specific, the default part in the contract PreCoin which is equivalent to the constructor in Fig. 1 can only be invoked once, after which the state is always Coin. This is consistent with the fact that the constructor of a Solidity smart contract is only invoked once when a new contract instance is created.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 449,
                    "end": 455,
                    "text": "Fig. 1",
                    "ref_id": null
                },
                {
                    "start": 468,
                    "end": 474,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 700,
                    "end": 706,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Smart Contracts"
        },
        {
            "text": "Comparison. As introduced above, Vyper smart contracts are similar to Solidity smart contracts regardless of the differences in syntax formats. Compared with Solidity, Vyper simply excludes the vulnerabilities reported in Solidity at syntax level. Apart from the syntax differences, explicit state transitions are applied in Bamboo to prevent potential attacks. Despite the limits in syntax and state transitions, high-level smart contract programming languages have a lot in common in semantics due to the fact that they have to be functionally the same. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Smart Contracts"
        },
        {
            "text": "The K-framework (K) [39] is a rewriting logic [33] based formal executable semantics definition framework. The semantics definitions of various programming languages have been developed using K, such as Java [13] , C [18] , etc. Particularly, an executable semantics of EVM [24] , the bytecode language of smart contracts, has been constructed in the K-framework. K backends, like the Isabelle theory generator, the model checker, and the deductive verifier, can be utilized to prove properties on the semantics and construct verification tools [42] .",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 24,
                    "text": "[39]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 46,
                    "end": 50,
                    "text": "[33]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 208,
                    "end": 212,
                    "text": "[13]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 217,
                    "end": 221,
                    "text": "[18]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 274,
                    "end": 278,
                    "text": "[24]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 545,
                    "end": 549,
                    "text": "[42]",
                    "ref_id": "BIBREF40"
                }
            ],
            "ref_spans": [],
            "section": "The K-framework"
        },
        {
            "text": "A language semantics definition in the K-framework consists of three main parts, namely the language syntax, the configuration specified by the developer and a set of rules constructed based on the syntax and the configuration. Given a semantics definition and some source programs, the K-framework executes the source programs based on the semantics definition. In addition, specified properties can be verified by the formal analysis tools in K backends. We take IMP [37] , a simple imperative language, as an example to show how to define a language semantics in the K-framework.",
            "cite_spans": [
                {
                    "start": 469,
                    "end": 473,
                    "text": "[37]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "The K-framework"
        },
        {
            "text": "The configuration of the IMP language is shown in Fig. 4 . There are only two cells, namely k and state, in the whole configuration cell T. The cells in the configuration are used to store some information related to the program execution. For instance, the cell k stores the program for execution Pgm, and in the cell state a map is used to store the variable state.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 50,
                    "end": 56,
                    "text": "Fig. 4",
                    "ref_id": null
                }
            ],
            "section": "The K-framework"
        },
        {
            "text": "Here, we introduce some basic rules in the K-IMP semantics. These rules are allocate, read and write. The syntax of IMP is also given in Fig. 5 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 137,
                    "end": 143,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Fig. 4. IMP Configuration"
        },
        {
            "text": "Pgm ::= \" int \" Ids \";\" Stmt Ids ::= List { Id , \" ,\"} AExp ::= Int | Id | \" -\" Int | AExp \"/\" AExp > AExp \"+\" AExp | \"(\" AExp \")\" BExp ::= Bool | AExp \" <=\" AExp | \"!\" BExp > BExp \"&&\" BExp | \"(\" BExp \")\" Block ::= \"{\" \"}\" | \"{\" Stmt \"}\" Stmt ::= Block | Id \"=\" AExp \";\" | \" if \" \"(\" BExp \")\" Block \" else \" Block | \" while \" \"(\" BExp \")\" Block > Stmt Stmt .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 4. IMP Configuration"
        },
        {
            "text": "Let us start with the rule of memory allocations in IMP shown in Allocate. When Pgm, interpreted as int X,Xs;S, is encountered, we need to store a list of variables (X,Xs) starting from X in the cell state with a list of mappings. Here state can be regarded as a physical memory or storage, and Xs is also a list of variables which can be empty. X is popped out of the cell k and a new mapping from X to 0 is created in the cell state, which means that a memory slot has been allocated for X to store its initial value 0. No duplicate names are allowed in state, which is guaranteed by the require condition. Then we go like this until Xs becomes empty, which means that all the variables have already been stored in state. At this point, the execution of the first part of Pgm has been finished and we proceed to the execution of the statement S. This can be summarized in Finish-Allocate where .Ids is an empty list of identifiers, which means that the variable list is empty. Please note that . means an empty set in the K-framework. If a rule ends with ., it means that nothing will be executed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 4. IMP Configuration"
        },
        {
            "text": "Then we come to the rules of read and write for variables. As shown in Read, if we want to look up the value of the variable X, we need to search it in the cell state by mapping the variable name X to its value I. So the evaluation of this expression X is its value I. If we cannot find a mapping for X, the program execution will stop at this point. Particularly, ... means there can be something in the corresponding position. For instance, the mapping of X can be in any position in the cell state. However, for rules in the cell k, ... can only be at the end since the program which is stored in k is executed sequentially. As illustrated in Write, if we want to assign the integer I to the variable X, similarly we need to search it in state by mapping the variable name. We also need to rewrite the value of X, denoted by \" \" which is a placeholder, to I.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 4. IMP Configuration"
        },
        {
            "text": "Rewriting logic facilitates the construction of a general semantic model for smart contracts. This is because a rewriting logic style semantics consists of a set of rewriting steps from the language syntax to its evaluations. In spite of syntax differences, different smart contract languages have a lot in common in logical aspects to achieve the equivalent functionality. Rewriting logic makes it possible to separate the language syntax from the common logical aspects based on which the general semantic model is constructed. The semantics rules introduced above can be general and not specific to IMP. We show the general rules for read, write and allocate in Read-General, Write-General and Allocate-General, respectively. In these rules, #read, #write and #allocate represent the functions to read, write and allocate memory slots for variables with specified parameters and their syntax is shown in Fig. 6 . The semantics rules for memory operations in IMP can be obtained by rewriting the corresponding IMP syntax to the general memory operations defined above, namely #read, #write and #allocate, which form a general semantic model. The semantics rules for read, write and allocate in IMP based on the general semantic model are shown in Read-IMP, Write-IMP and Allocate-IMP, respectively. Particularly, the symbol means \"followed by\". The semantics rules interpreted with the internal semantics of the general memory operations defined in Fig. 6 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 907,
                    "end": 913,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1451,
                    "end": 1457,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Fig. 4. IMP Configuration"
        },
        {
            "text": "Different high-level smart contract programming languages vary in syntax but have a lot in common semantically to achieve the equivalent functionality. Considering this fact, we construct a general semantic model for smart contracts based on the commonly shared high-level semantic features that are independent of any specific language or platform. The semantics of a high-level smart contract programming language can be summarized into three aspects in terms of its functionality, namely memory operations, new contract instance creations and function calls. Particularly, new contract instance creations and function calls are the two kinds of transactions on the blockchain. In this section, we present an overview of the desired semantics of these three core features.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A General Semantic Model"
        },
        {
            "text": "The syntax of the general semantic model is defined in the K-framework and shown in Fig. 7 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 84,
                    "end": 90,
                    "text": "Fig. 7",
                    "ref_id": null
                }
            ],
            "section": "Syntax"
        },
        {
            "text": "The runtime configuration indicates program states at each execution step, making detailed runtime features available. The runtime configuration of the general semantic model is illustrated in Fig. 8 . Due to limit of space, only a part of the cells is presented here. In this configuration, there are six main cells in the whole configuration cell T and they are k, controlStacks, contracts, functions, contractInstances and transactions. The value of each cell is initialized in the configuration with its type specified. A dot followed by any type represents an empty set of this type. For instance, .List is an empty list. Particularly, K is the most general type which can be any specific type defined in the K-framework.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 193,
                    "end": 199,
                    "text": "Fig. 8",
                    "ref_id": null
                }
            ],
            "section": "Configuration"
        },
        {
            "text": ". . > f unction * > f unctions",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Configuration"
        },
        {
            "text": "In k, source programs, called SourceUnit, are stored for execution. If the programs stored in k terminate in a proper way, there will be a dot in this cell, indicating that this cell is empty and there are no more programs to execute.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 8. Runtime Configuration of the General Semantic Model"
        },
        {
            "text": "controlStacks consists of contractStack, functionStack, newStack and blockStack. To be specific, contractStack keeps track of the current contract instance. functionStack stores a list of function calls. newStack records a list of new contract instance creations. blockStack stores a list of variable contexts to look up and assign values to variables in different scopes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 8. Runtime Configuration of the General Semantic Model"
        },
        {
            "text": "In contracts, a set of contract definitions is stored. Each cell contract represents a contract definition. The number of distinct contracts is counted in cntContractDefs. In contract, the contract name is stored in cName. State variable information is stored in stateVars. In addition, Constructor indicates whether the contract has a constructor or not and its initial value is false.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 8. Runtime Configuration of the General Semantic Model"
        },
        {
            "text": "Similarly, functions stores a set of function definitions. Each cell function represents a function definition. The total number of function definitions is stored in cntFunctions. For each function definition, the function Id and the function name are stored in fId and fName, respectively. In addtion, function parameters, including input parameters and return parameters, are recorded in the corre-sponding cells. We also store the function body in the cell Body and the function quantifiers which can be modifiers or specifiers in the cell funQuantifiers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 8. Runtime Configuration of the General Semantic Model"
        },
        {
            "text": "In contractInstances, there is a set of contract instances. Each cell contract-Instance represents a contract instance. The number of contract instances is counted in cntContracts. We store the contract instance Id and the name of its associated contract in the cells ctId and ctName, respectively. Four different mappings are applied to keep track of more information of a variable. Specifically speaking, ctContext, ctType, ctLocation and ctStorage/Memory record the mappings from a variable name to its logical address in the storage or memory, a variable name to its type, a variable name to its location information, namely \"global\" or \"local\", and the logical address of a variable in the storage or memory to its value, respectively. globalContext keeps track of the state variable context. The number of memory slots taken by variables is calculated in slotNum. The cell Balance records the balance of each contract instance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 8. Runtime Configuration of the General Semantic Model"
        },
        {
            "text": "In the cell transactions, we keep track of the number of transactions in cntTrans, every transaction in tranComputation and also \"msg\" information in Msg and msgStack. \"msg\" is a keyword in smart contracts to represent transaction information. For instance, \"msg.sender\" is the caller of the function and \"msg.value\" specifies the amount of ether to be transferred in Solidity. The cell msgStack stores a list of transaction information tuples while Msg records the current one. We simulate transactions of smart contracts with a \"Main\" contract which is similar to the main function in C. In the \"Main\" contract, new contract instances can be created and external function calls to these instances are available. The Id of the \"Main\" contract is \"-1\", since other contract instances start from 0. Therefore, the initialized content in contractStack is ListItem(-1), and cntTrans is counted from 1, which means that the creation of the \"Main\" contract is the first transaction recorded in tranComputation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 8. Runtime Configuration of the General Semantic Model"
        },
        {
            "text": "We introduce the semantics rules for the core features in smart contracts. Due to limit of space, the implementation details (cf. [3] ) of the sub-steps are omitted.",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 133,
                    "text": "[3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "Memory Operations. We present an overview of the semantics rules for memory operations on elementary types, such as int, uint and address in Solidity, each of which takes only one memory slot. Complex types, such as arrays, mappings, etc, are compositions of elementary types. A memory operation on a complex type can be regarded as a set of recursive memory operations on elementary types. For instance, the memory allocation for a one-dimensional fixed-size array is equivalent to allocating an elementary type for each index of this array. Reading and writing a particular index involve recursive steps to retrieve the logical address of this index from the base address of the array. Mappings are similar to dynamic arrays. For a mapping from address to uint, the memory allocation for this mapping is equivalent to allocating an unsigned integer type at each address involved. Reference types which refer to pre-defined instances can be simply implemented as mappings in the K-framework. . . . > k Let us start with the read operation on elementary types shown in Read. Here, we consider the object X as a variable which is an Id type. The first thing to do is to get the current execution context. This is achieved by retrieving the current contract instance Id N in contractStack and mapping the corresponding contract instance with N in the cell ctId. After that, we retrieve the logical address of X, denoted by Addr, in ctContext and the location information of X, denoted by L, in ctLocation. With these two parameters, we can obtain the evaluation of X through readAddress which retrieves the value located at Addr in the associated cell specified by L. To be specific, if L specifies this variable as a global one, the search space is ctStorage. Otherwise, the value is retrieved in Memory. write is similar to read. After retrieving the logical address of X, denoted by Addr, and the location information of X, denoted by L, we rewrite the value at Addr to the value V in the cell specified by L through writeAddress.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "Then we come to the allocation for elementary types shown in Allocate. The first input parameter N indicates the object contract instance Id. The variable information including the name X, the type T, the location information L and the initial value V, is stored in #varInfo. First, we retrieve the corresponding instance by mapping the Id N in ctId. Then the number of memory slots is increased by 1 in slotNum. After that, the variable information is recorded in the associated cells. To be specific, we record the logical address Addr, the type T, and the location information L in ctContext, ctType and ctLocation, respectively. Finally, a memory slot is allocated for this variable through allocateAddress.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "New Contract Instance Creations. As illustrated in New-Contract-Instance-Creation, the contract name X and the arguments in the constructor E are taken as input parameters to create a new instance of X. There are altogether three sub-steps for this transaction and they are updateState, allocateStorage and initInstance. To be specific, updateState updates the blockchain states, including the states of contract instances and transactions, and the stack information to indicate the new contract instance creation. In addition, allocateStorage allocates state variables and initInstance deals with initialization issues, such as calling the constructor, in the new instance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "Function Calls. In order to make the semantics of function calls general for all kinds of calls and extensible for different smart contract languages, a uniform format is applied to generalize the semantics. The uniform format is functionCall(Id of Caller; Id of Recipient; Function Name; Arguments; Msg Info). Particularly, Msg Info represents the transaction information, including the Ids of the caller and the recipient instances, the value of digital assets to be transferred and the transaction fees to be consumed. The semantics rule for function calls based on this format is shown in Function-Call.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "In the rule Function-Call, the caller of this function is C and the recipient is R. F is the function name and Es specifies the function call arguments. M is the \"msg\" information to keep track of transactions. In particular, the types of these parameters have been specified. The semantics of function calls is designed from a general point of view. Each external function call is regarded as an extension of an internal function call. Whenever there is an external function call, we first switch to the recipient instance and then call the function in this instance as an internal call. Finally, we switch back to the caller instance. In this way, external function calls can be achieved through internal function calls and switches of contract instances. This mechanism also applies to internal function calls where the caller is the same as the recipient. There are three sub-steps in Function-Call. The first one is to switch to the recipient instance from the caller through switchContext. The second is an internal function call functionCall. The last one is to return to the caller instance through returnContext.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "Particularly, the semantics of function calls is equipped with exception handling features. If an exception is encountered, it will be propagated to the transactional function call to revert the whole transaction. The propagation of exceptions is a sub-step in returnContext. The exception handling mechanism is also general, making it possible to deal with all kinds of exception handling features in smart contracts, such as revert and assert in Solidity, in a similar way. There are two stages in handling exceptions. The first one is the propagation of exceptions to the transactional function call as shown in Exception-Propagation, and the second is the reversion of the transaction as shown in Transaction-Reversion. The first stage is present in nested calls to propagate exceptions to the transactional function call, while the second stage is only present in the transactional function call stemming from the \"Main\" contract. In the stage of propagating exceptions, the exception state is updated through updateExceptionState() to indicate that an exception has been encountered. Particularly, the Id of the caller instance should be larger than or equal to 0 since the caller cannot be the \"Main\" contract. And in the stage of reverting transactions, the caller is the \"Main\" contract whose Id is \"-1\". In addition to updating the exception state, the whole transaction is reverted through revertState().",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Semantics of the Core Features"
        },
        {
            "text": "A direct semantics of a high-level smart contract programming language can be developed based on the general semantic model introduced above. From the perspective of rewriting logic, a language semantics is a set of rewriting steps from the language syntax to its evaluations. Each of these rewriting steps implements a function to move the syntax a step further to its final evaluations. The general semantic model which consists of a set of internal rewriting steps and defines the desired semantics of smart contracts can be regarded as a logical intermediate language. A direct semantics of a high-level smart contract programming language can be constructed by rewriting its syntax to the features in the general semantic model with several functional steps. This also indicates the process of smart contract language design. We take Solidity as an example to illustrate how to generate the semantics based on the general semantic model. The semantics rules presented below are based on the Solidity syntax defined in [7] .",
            "cite_spans": [
                {
                    "start": 1023,
                    "end": 1026,
                    "text": "[7]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Direct Semantics Generation"
        },
        {
            "text": "Let us start with the look-up operation in Solidity. As shown in Look-Up, the object is considered to be a variable X. X is evaluated with read in the general semantic model. We simply rewrite the corresponding Solidity syntax to read. assignment is similar to look-up. As shown in Assignment, we simply rewrite the assignment syntax in Solidity to write in the general semantic model. In New-Instance-Solidity, the syntax of new contract instance creations in Solidity is rewritten to createNewInstance in the general semantic model.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Direct Semantics Generation"
        },
        {
            "text": "Function calls in Solidity are written in a format similar to member access. For instance, target.deposit.value(2)() is a typical function call in Solidity. To be specific, target specifies the recipient instance and deposit is the function MsgValue and MsgGas represent msg.value and msg.gas, respectively. The semantics rules for function calls apply to all kinds of function calls in Solidity, including high-level and low-level calls, constructors and fallback functions. For instance, if there is no function name specified in a function call or the specified function name does not match any existing function in the recipient instance, the first decomposed part in Function-Call-Solidity will be #memberAccess(R:Int, String2Id(\"fallback\")) where R is the Id of the recipient instance and \"fallback\" refers to the fallback function in that instance. In this case, the fallback function in R will be invoked. In addition, in the case of delegatecall, the recipient instance R is the same as the caller instance C since the execution takes place in the caller's context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Direct Semantics Generation"
        },
        {
            "text": "Exception handling features in Solidity can be interpreted with the semantics of exception() in the general semantic model. The semantics rules for revert, assert and require are shown in Revert, Assert and Require, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Direct Semantics Generation"
        },
        {
            "text": "We evaluate the proposed generalized formal semantic framework for smart contracts by showing that the generated semantics, an interpretation of the general semantic model with a particular language, is consistent with the semantics interpreted by the corresponding official compiler on benchmarks. The testing language makes no difference to the evaluation since it aims to validate the semantics of the commonly shared high-level features defined in the general semantic model. We take Solidity as an object for the evaluation since there are sufficient Solidity smart contracts available for testing the generated Solidity The generated Solidity semantics is evaluated from two perspectives: the first one is its coverage (i.e., completeness), and the second is its correctness (i.e., consistency with Solidity compilers). Evaluation results show that the Solidity semantics developed with the proposed framework completely covers the supported high-level core language features specified by the official Solidity documentation [7] and is consistent with the official Solidity compiler Remix [5] .",
            "cite_spans": [
                {
                    "start": 1095,
                    "end": 1098,
                    "text": "[5]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Evaluation"
        },
        {
            "text": "We evaluate and test the Solidity semantics developed with the proposed framework with the Solidity compiler test set [6] . This test set is regarded as a standard test set or benchmarks for evaluating Solidity semantics since the test programs are written in a standard or correct way defined by the language developers and cover all the features in Solidity. There are altogether 482 tests in the Solidity compiler test set. The evaluation is done by manually comparing the execution behaviours of the generated Solidity semantics with the ones of the Remix compiler on the test programs. We consider the generated Solidity semantics is correct if the execution behaviours indicated in the configuration are consistent with the ones of the Remix compiler. A feature is considered to be fully covered if all the compiler tests involving this feature are passed. We list the coverage of the generated Solidity semantics in Table 1 from the perspective of each feature specified by the official documentation.",
            "cite_spans": [
                {
                    "start": 118,
                    "end": 121,
                    "text": "[6]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 923,
                    "end": 930,
                    "text": "Table 1",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Evaluation"
        },
        {
            "text": "From Table 1 , we can observe that the generated Solidity semantics completely covers the supported high-level core features of Solidity. As for types, the generated Solidity semantics covers the following elementary types: address, bool, string, Int, Uint and Byte. Fixed and Ufixed are not covered because they are not fully supported by Solidity yet [7] . User-defined types, including struct, contract types and enum, are covered. Mappings, arrays, function types and address payable are also covered. In addition, the semantics associated with functions, such as function definitions and function calls, is fully covered. The semantics of statements is completely covered except that of inline assembly statements which are considered to be low-level features accessing EVM (i.e., this part of semantics can be integrated with KEVM [24] ). All kinds of expressions in Solidity are covered. Lastly, the semantics of event is also covered and the parts of semantics for using for and inheritance are covered with rewriting. For all the parts of covered semantics, they are considered to be correct since the execution behaviours involved are consistent with the ones of Remix. Therefore, the generated Solidity semantics can be considered to be complete and correct in terms of the supported high-level core features of Solidity, indicating the completeness and correctness of the general semantic model.",
            "cite_spans": [
                {
                    "start": 353,
                    "end": 356,
                    "text": "[7]",
                    "ref_id": null
                },
                {
                    "start": 837,
                    "end": 841,
                    "text": "[24]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [
                {
                    "start": 5,
                    "end": 12,
                    "text": "Table 1",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Evaluation"
        },
        {
            "text": "Threats to Validity. We validate the general semantic model with its interpretation in Solidity. The validity of the proposed framework holds for any particular high-level smart contract programming language as long as its core features fall into or can be properly rewritten to the ones defined in the general semantic model. The proposed framework may not work if the core features cannot be interpreted with the ones defined in the general semantic model. However, this is unlikely due to the nature of smart contract executions. For instance, transactions in existing instances are implemented with or can be transformed into function calls regardless of the platforms of smart contract programs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation"
        },
        {
            "text": "In this paper, we propose a generalized formal semantic framework for smart contracts. This framework can directly handle smart contracts written in different high-level programming languages, such as Solidity, Vyper, Bamboo, etc, without translating them into EVM bytecode or intermediate languages. In this framework, a direct executable formal semantics of a particular high-level smart contract programming language is constructed based on a general semantic model with rewriting logic. The general semantic model is validated with its interpretation in Solidity and evaluation results show that it is complete and correct. Furthermore, the proposed framework provides a formal specification of smart contracts written in different languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Amani",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "B\u00e9gel",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bortin",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Staples",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs",
            "volume": "",
            "issn": "",
            "pages": "66--77",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "A Survey of Attacks on Ethereum Smart Contracts (SoK)",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Atzei",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bartoletti",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Cimoli",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Held as Part of the European Joint Conferences on Theory and Practice of Software",
            "volume": "10204",
            "issn": "",
            "pages": "164--186",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-54455-6_8"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "A Minimal Core Calculus for Solidity Contracts",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bartoletti",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Galletta",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Murgia",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "DPM/CBT@ESORICS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Formal Verification of Smart Contracts: Short Paper",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Bhargavan",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Delignat-Lavaud",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Fournet",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gollamudi",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Gonthier",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Kobeissi",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Kulatova",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rastogi",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Sibut-Pinote",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Swamy",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "Z"
                    ],
                    "last": "B\u00e9guelin",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security",
            "volume": "",
            "issn": "",
            "pages": "91--96",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Bogdanas",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        ":"
                    ],
                    "last": "Rosu",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "K-Java",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "445--456",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Token-Scope: Automatically Detecting Inconsistent Behaviors of Cryptocurrency Tokens in Ethereum",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Luo",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Cao",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Xiao",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Cavallaro",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kinder",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "1503--1520",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Is Solidity Solid Enough?",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Crafa",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pirro",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Zucca",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Financial Cryptography Workshops",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Step by Step Towards Creating a Safe Smart Contract: Lessons and Insights from a Cryptocurrency Lab",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Delmolino",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Arnett",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "E"
                    ],
                    "last": "Kosba",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Shi",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Clark",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Meiklejohn",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "Y A"
                    ],
                    "last": "Ryan",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "S"
                    ],
                    "last": "Wallach",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Brenner",
                    "suffix": ""
                },
                {
                    "first": "Voting",
                    "middle": [],
                    "last": "Bitcoin",
                    "suffix": ""
                },
                {
                    "first": "Wahc",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": "Christ",
                    "middle": [],
                    "last": "Church",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Financial Cryptography and Data Security -FC 2016 International Workshops",
            "volume": "9604",
            "issn": "",
            "pages": "79--94",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-53357-4_6"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "An Executable Formal Semantics of C with Applications",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ellison",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Rosu",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 39th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "533--544",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Slither: A Static Analysis Framework for Smart Contracts",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Feist",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Grieco",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Groce",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain",
            "volume": "",
            "issn": "",
            "pages": "8--15",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Surviving Out-of-gas Conditions in Ethereum Smart Contracts. PACMPL 2(OOPSLA)",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Grech",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kong",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Jurisevic",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Brent",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Scholz",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Smaragdakis",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "116",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "A Semantic Framework for the Security Analysis of Ethereum Smart Contracts",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Grishchenko",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Maffei",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Schneidewind",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Principles of Security and Trust -7th International Conference, POST 2018, Held as Part of the European Joint Conferences on Theory and Practice of Software",
            "volume": "10804",
            "issn": "",
            "pages": "243--269",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-89722-6_10"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Online Detection of Effectively Callback Free Objects with Applications to Smart Contracts",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Grossman",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Abraham",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Golan-Gueta",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Michalevsky",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Rinetzky",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sagiv",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zohar",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "PACMPL",
            "volume": "2",
            "issn": "",
            "pages": "1--48",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "solc-verify: A Modular Verifier for Solidity Smart Contracts",
            "authors": [
                {
                    "first": "\u00c1",
                    "middle": [],
                    "last": "Hajdu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jovanovic",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "KEVM: A Complete Formal Semantics of the Ethereum Virtual Machine",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Hildenbrandt",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Saxena",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Rodrigues",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhu",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Daian",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Guth",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "M"
                    ],
                    "last": "Moore",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Stefanescu",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ro\u015fu",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "31st IEEE Computer Security Foundations Symposium",
            "volume": "",
            "issn": "",
            "pages": "204--217",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Defining the Ethereum Virtual Machine for Interactive Theorem Provers",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Hirai",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Brenner",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Rohloff",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bonneau",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "Y A"
                    ],
                    "last": "Ryan",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Teague",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bracciali",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sala",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Pintore",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Wahc",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Bitcoin",
                    "suffix": ""
                },
                {
                    "first": "Wtsc",
                    "middle": [],
                    "last": "Voting",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "A"
                    ],
                    "last": "Sliema",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Malta",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Financial Cryptography and Data Security -FC 2017 International Workshops",
            "volume": "10323",
            "issn": "",
            "pages": "520--535",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-70278-0_33"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "K"
                    ],
                    "last": "Chan",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, ASE 2018",
            "volume": "",
            "issn": "",
            "pages": "259--269",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "ZEUS: Analyzing Safety of Smart Contracts",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kalra",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Goel",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Dhawan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sharma",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "25th Annual Network and Distributed System Security Symposium",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Exploiting the Laws of Order in Smart Contracts",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kolluri",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Nikolic",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sergey",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Saxena",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis",
            "volume": "",
            "issn": "",
            "pages": "363--373",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "teEther: Gnawing at Ethereum to Automatically Exploit Smart Contracts",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Krupp",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rossow",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "27th USENIX Security Symposium, USENIX Security",
            "volume": "",
            "issn": "",
            "pages": "1317--1333",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Formal Specification and Verification of Smart Contracts for Azure Blockchain",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "K"
                    ],
                    "last": "Lahiri",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Dillig",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Making Smart Contracts Smarter",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Luu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Chu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Olickel",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Saxena",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "R"
                    ],
                    "last": "Weippl",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Katzenbeisser",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kruegel",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "254--269",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Rewriting Logic: Roadmap and Bibliography",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Mart\u00ed-Oliet",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Theor. Comput. Sci",
            "volume": "285",
            "issn": "",
            "pages": "121--154",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Manticore: A User-Friendly Symbolic Execution Framework for Binaries and Smart Contracts",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mossberg",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Manzano",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Hennenfent",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Groce",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Grieco",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Feist",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Brunson",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Dinaburg",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019",
            "volume": "",
            "issn": "",
            "pages": "1186--1189",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Deductive Proof of Ethereum Smart Contracts Using Why3",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Nehai",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bobot",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Finding the Greedy, Prodigal, and Suicidal Contracts at Scale",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Nikolic",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kolluri",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sergey",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Saxena",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 34th Annual Computer Security Applications Conference, ACSAC 2018",
            "volume": "",
            "issn": "",
            "pages": "653--663",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "IMP: A Simple Imperative Language. Concrete Semantics",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Sereum: Protecting Existing Smart Contracts Against Re-Entrancy Attacks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Rodler",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "O"
                    ],
                    "last": "Karame",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Davi",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "26th Annual Network and Distributed System Security Symposium, NDSS 2019",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "An Overview of the K Semantic Framework",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ro\u015fu",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "F"
                    ],
                    "last": "\u015eerb\u0203nu\u0163\u0203",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Journal of Logic and Algebraic Programming",
            "volume": "79",
            "issn": "6",
            "pages": "397--434",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Scilla: A Smart Contract Intermediate-level Language",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sergey",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kumar",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Understanding the DAO Attack",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Siegel",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Semantics-based Program Verifiers for All Languages",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Stefanescu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Yuwen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ro\u015fu",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2016, part of SPLASH 2016",
            "volume": "",
            "issn": "",
            "pages": "74--91",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "SmartCheck: Static Analysis of Ethereum Smart Contracts",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Tikhomirov",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Voskresenskaya",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Ivanitskiy",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Takhaviev",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Marchenko",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Alexandrov",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "1st IEEE/ACM International Workshop on Emerging Trends in Software Engineering for Blockchain",
            "volume": "",
            "issn": "",
            "pages": "9--16",
            "other_ids": {}
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "Securify: Practical Security Analysis of Smart Contracts",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Tsankov",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "M"
                    ],
                    "last": "Dan",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Drachsler-Cohen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gervais",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "B\u00fcnzli",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "T"
                    ],
                    "last": "Vechev",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "67--82",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "VULTRON: Catching Vulnerable Smart Contracts Once and for All",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ma",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 41st International Conference on Software Engineering: New Ideas and Emerging Results, ICSE (NIER) 2019",
            "volume": "",
            "issn": "",
            "pages": "1--4",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "Detecting Nondeterministic Payment Bugs in Ethereum Smart Contracts. PACMPL 3(OOPSLA)",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Su",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "189",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Ethereum: A Secure Decentralised Generalised Transaction Ledger. Ethereum project yellow paper",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Wood",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "151",
            "issn": "",
            "pages": "1--32",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Lolisa: Formal Syntax and Semantics for a Subset of the Solidity Programming Language",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lei",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "Towards Verification of Ethereum Smart Contracts: A Formalization of Core of Solidity",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Zakrzewski",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Verified Software. Theories, Tools, and Experiments -10th International Conference",
            "volume": "11294",
            "issn": "",
            "pages": "229--247",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-03592-1_13"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "send ( receiver : address , amount : wei_value ): 15 if ( self . balances [ msg . sender ] < amount ): return 16 self . balances [ msg . sender ] -= amount 17 self . balances [ receiver ] += amount",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Vyper Smart Contract Example",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Bamboo Smart Contract Example",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Syntax . . > k < . . . X |-> I . . . > state RULE Write < X = I:Int;",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": ". . X |-> I . . . > state RULE Write-General < #write(X, I) . . . . > k < . . . Syntax of General Memory Operations",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": ":= read ( Expression ) | readAddress ( Int , Id ) | write ( Expression , Value ) | writeAddress ( Int , Id , Value ) | allocate ( Int , VarInfo ) | allocate Ad d re ss ( Int , Int , Id , Value ) N e w I n st a n c e C r e a t i o n ::= c r e a t e N e w I n s t a n c e ( Id , Ex pression List ) | updateState ( Id ) | al l oc at eS t or ag e ( Id ) | initInstance ( Id , Expres sionLis t ) I n s t a nc e S t a t e U p d a t e ::= functionCall ( Expression ; Expression ; Id ; ExpressionLi st ; Msg ) | functionCall ( Id ; Expr essionLi st ) | switchContext ( Int , Int , Id , Msg ) | returnContext ( Int ) | exception () | u p d a t e E x c e p t i o n S t a t e () | revertState () Expression ::= Id | Value | Msg | VarInfo | MemberAccess ExpressionList ::= List { Expression , \" ,\"} | Values Value ::= Int | Bool Values ::= List { Value , \" ,\"} Msg ::= # msgInfo ( Int , Int , Int , Int ) VarInfo ::= # varInfo ( Id , TypeName , Id , Value ) MemberAccess ::= # memberAccess ( Expression , Id ) TypeName ::= El e m e n t a r y T y p e N a m e | Co m pl ex Ty p eN am e | Syntax of the General Semantic Model",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": ". > k < ListItem(N:Int) . . . > contractStack < < N > ctId < . . . X |-> Addr . . . > ctContext < . . . X |-> L . . . > ctLocation < . . . X |-> T:ElementaryTypeName . . . > ctT ype . . . > contractInstance RULE Write < write(X:Id, V:Value) writeAddress(Addr, L, V) . . . > k < ListItem(N:Int) . . . > contractStack < < N > ctId < . . . X |-> Addr . . . > ctContext < . . . X |-> L . . . > ctLocation < . . . X |-> T:ElementaryTypeName . . . > ctT ype . . . > contractInstance RULE Allocate < allocate(N:Int, #varInfo(X:Id, T:ElementaryTypeName, L:Id, V:Value)) allocateAddress(N, Addr, L, V) . . . > k < < N > ctId < Addr Addr +Int 1 > slotN um < TYPE:Map TYPE (X |-> T) > ctT ype < CON:Map CON (X |-> Addr) > ctContext < LOC:Map LOC (X |-> L) > ctLocation . . . > contractInstance RULE New-Contract-Instance-Creation < createNewInstance(X:Id,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "ListItem(R)ListItem(C) . . . > contractStack requires C >=Int 0 TransactionListItem(R)ListItem(-1) > contractStack",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": ". . > k RULE Assignment < X:Id = V:Value write(X, V) . . . > k RULE New-Instance-Solidity < new X:Id (E:ExpressionList) createNewInstance(X, E) . . . > k Both state and local variable allocations are achieved through allocate in the general semantic model. State variables are allocated when new contract instances are created, while local variables are allocated right after declarations.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Fig. 1. Solidity Smart Contract Example",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "are equivalent to those developed from scratch, namely Read, Write and Allocate. Rather than pure syntax translations to intermediate languages, a general semantic model enables semantic-level mappings to commonly shared high-level features.",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "ComplexTypeName refers to mappings, arrays and Byte. ReferenceTypeName involves user-defined types and function types. Id stands for identifiers. Int and Bool represent integers and Boolean values, respectively. Values, a subset of ExpressionList, is a list of Value types which can be integers (Int) or Boolean types (Bool). Msg is the type of transaction information. VarInfo stores variable information. MemberAccess deals with expressions in member access formats.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "RULEFunction-Call-Solidity < #memberAccess(R:Int, F:Id) Es:Values MsgValue:Int MsgGas:Int functionCall(C; R; F; Es; #msgInfo(C, R, MsgValue, MsgGas)) . . . > k < ListItem(C:Int) . . . > contractStack RULE Revert < revert(.ExpressionList); exception() . . . > k RULE Assert < assert(true);to be called in that instance. value specifies msg.value as 2. In addition, we can specify other parameters, such as msg.gas, function arguments, etc. When it comes to the semantics of function calls in Solidity, the first thing to do is to decompose the member access like format and transform it into the one in the general semantic model. As shown in Function-Call-Solidity, each decomposed part in Solidity calls is reorganized in functionCall. Specifically speaking, #memberAccess(R:Int, F:Id) specifies the recipient instance R and the function to be called in this instance F. Es specifies the function arguments.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "Coverage of the Generated Solidity Semantics FC: Fully Covered and Consistent with Solidity IDE N: Not Covered semantics. The Solidity semantics developed with the proposed framework is publicly available at https://github.com/kframework/solidity-semantics.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgements. This work is supported by the Ministry of Education, Singapore under its Tier-2 Project (Award Number: MOE2018-T2-1-068) and partially supported by the National Research Foundation, Singapore under its NSoE Programme (Award Number: NSOE-TSS2019-03).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        },
        {
            "text": "Open Access This chapter is licensed under the terms of the Creative Commons Attribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made.The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "annex"
        }
    ]
}