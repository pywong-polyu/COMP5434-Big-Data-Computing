{
    "paper_id": "3663aea99dc6f89ad26fbf6f92900ddb0996c686",
    "metadata": {
        "title": "Design of quantum optical experiments with logic artificial intelligence",
        "authors": [
            {
                "first": "Alba",
                "middle": [],
                "last": "Cervera-Lierta",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Chemical Physics Theory Group",
                    "institution": "University of Toronto",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": ""
            },
            {
                "first": "Mario",
                "middle": [],
                "last": "Krenn",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Chemical Physics Theory Group",
                    "institution": "University of Toronto",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": ""
            },
            {
                "first": "Al\u00e1n",
                "middle": [],
                "last": "Aspuru-Guzik",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Chemical Physics Theory Group",
                    "institution": "University of Toronto",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Logic Artificial Intelligence (AI) is a subfield of AI where variables can take two defined arguments, True or False, and are arranged in clauses that follow the rules of formal logic. Several problems that span from physical systems to mathematical conjectures can be encoded into these clauses and solved by checking their satisfiability (SAT). In contrast to machine learning approaches where the results can be approximations or local minima, Logic AI delivers formal and mathematically exact solutions to those problems. In this work, we propose the use of logic AI for the design of optical quantum experiments. We show how to map into a SAT problem the experimental preparation of an arbitrary quantum state and propose a logic-based algorithm, called Klaus, to find an interpretable representation of the photonic setup that generates it. We compare the performance of Klaus with the state-of-the-art algorithm for this purpose based on continuous optimization. We also combine both logic and numeric strategies to find that the use of logic AI improves significantly the resolution of this problem, paving the path to developing more formal-based approaches in the context of quantum physics experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The emergence of the artificial intelligence (AI) has led to the proposal of alternative ways to tackle hard nonanalytical problems. The AI canonical approach comes in the form of inductive generalizations through the use of big data, the well-known and established machine learning (ML) field. Although ML grounds rely on mathematical theorems related to continuous function representation, its probabilistic nature usually does not yield performance guarantees, even less understanding about why it works (or not) in a particular problem. Despite the progress in unraveling the learning paths of ML algorithms, ML sibling, logic AI [1] [2] [3] , has the intrinsic potential of providing the validity and consistency of the answers we seek.",
            "cite_spans": [
                {
                    "start": 634,
                    "end": 637,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 638,
                    "end": 641,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 642,
                    "end": 645,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Logic AI is a subfield of AI that uses symbolic representation in the form of Boolean variables to extract formal deductions. In its basic form, it consists of encoding a set of rules into Boolean instances which validity can be checked with, for instance, satisfiability (SAT) solvers. The recent advances in SAT solvers have allowed the automatic resolution of extremely complex problems involving thousands of variables [4] . Long-standing conjectures such as the Boolean Pythagorean triples problem [5] , the Keller's conjecture (unresolved for 90 years) [6] , among others [7] [8] [9] have been solved using logic AI providing, in some cases, intricate, long [10] but correct deduction steps.",
            "cite_spans": [
                {
                    "start": 423,
                    "end": 426,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 503,
                    "end": 506,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 559,
                    "end": 562,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 578,
                    "end": 581,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 582,
                    "end": 585,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 586,
                    "end": 589,
                    "text": "[9]",
                    "ref_id": null
                },
                {
                    "start": 664,
                    "end": 668,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In a quantum mechanical context, the use of logic AI has been slightly explored so far. A few examples propose a logic encoding and a SAT solver as an equivalent quantum circuit checker [11] , to find the mapping between a quantum circuit and a particular chip topology [12] or to reduce the gate count [13] . There are also works that find Boolean representations of quantum circuits [14] . These proposals use the logic as a checker or optimizer. Here, we exploit logic AI for the design of quantum experiments.",
            "cite_spans": [
                {
                    "start": 186,
                    "end": 190,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 270,
                    "end": 274,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 303,
                    "end": 307,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 385,
                    "end": 389,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In this work, we propose a logic-based algorithm capable of designing a realistic quantum experiment. To be precise, our goal is to find a feasible photonic setup that generates an arbitrary quantum state. We benchmark our approach by comparing its performance with the best algorithm up to date, which is based on continuous numerical optimization, Theseus [15] . To that aim, we will take advantage of the graph-theoretical representation that these setups can take, which can also be used for other quantum experiments such as gate-based quantum circuits or unitary operations generation.",
            "cite_spans": [
                {
                    "start": 358,
                    "end": 362,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "The structure of this paper is as follows. In the next section, we summarize the graph representation of optical setups and explain how to formulate a state preparation problem. In section III, we show how to map the design problem into a set of propositional logic clauses. Section IV introduces the main algorithm, Klaus, that uses the logical instances presented in the previous section to find the minimal graph that corresponds to the optimal setup. In V, we benchmark Klaus and compare it with both the state-of-the-art algorithm Theseus and an hybrid algorithm proposal. Finally, we conclude and point to numerous exciting extensions of logical AI in quantum physics.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "A few years ago, a previously hidden bridge between quantum optical experiments and graph theory was discovered [17] [18] [19] and has since been generalized as a highly efficient automated design algorithm for new quantum experiments [20] . The underlying principle is that every quantum experiments can be described by an edgecolored weighted graph, and every graph stands for a quantum optical setup. In particular, every vertex of these graphs stands for a photon path (or a detector), every edge stands for a correlated photon path, the color represents the mode number and the complex edge weight stands for the amplitude of the photon pair. Such graphs can represent quantum states generated and transformed using linear optics, non-linear pair creation crystals, heralding and auxiliary photons, single-photon sources, photon number (non-)resolving detectors and others.",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 116,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 117,
                    "end": 121,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 122,
                    "end": 126,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 235,
                    "end": 239,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "The quantum state emerging from the experimental setup can directly be computed from the properties of the graph. A very commonly used technique in quantum optics conditions the experimental result on the simultaneous detection of exactly one photon in each of the detectors [21] . In the graph, this situation corresponds to a subset of edges which contain every vertex exactly once. This property of a graph is called a perfect matching (PM). The final quantum state under this condition is then a coherent superposition of all PMs in the graph. A more detailed analysis about the equivalence between graph PMs and quantum states is presented in App. VI A 1.",
            "cite_spans": [
                {
                    "start": 275,
                    "end": 279,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "Given one of these graph representations, it will contain one or more PM, each of them composed by different subsets of edges of different colors. As stated above, each of these edges represent a photon pair creation in the path (represented by the vertices) that they join. Each of these photons will have a mode represented by the color of the edge. This leads to the inherited vertex coloring of the PM, i.e. we assign a color to each vertex corresponding to the color of the incident edge. The vertex coloring determine the basis element created in superposition with the other PMs vertex colorings. The amplitude of the basis element is determined by the weight of the PM, i.e. the product of the edges weights. Different PMs can lead to the same vertex coloring but not necessarily the same PM weight. Thus, to compute the total amplitude of the basis element generated, one needs to sum all PM weights that generate that element, i.e. to compute the weight of the vertex coloring. Since these weights can take complex values, they can cancel each other, thus having a set of PM with a given vertex coloring does not directly imply that the corresponding basis element is generated, as this interference may occur.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "Let's illustrate how can we set the quantum state preparation problem using an example of these graph representations. The formal definitions of this problem are provided in App. VI B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "To generate a particular state, the weights of each vertex coloring that correspond to the basis states must match the state amplitudes, and the rest of the vertex coloring weights must be zero. Imagine that our goal is to generate the GHZ state of n = 6 parties and d = 3 dimensions, i.e., there are three possible different colors available (the 0, 1 and 2 modes). This state has three basis elements, each with amplitude 1/ \u221a 3:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "The general goal is the following: at least one of the contributions for the three basis elements must exist in the graph, while all other terms should vanish. Fig.1a shows an example of a cancellation that must take place to cancel the generation of the basis state |000011 , not present in the GHZ state. Fig.1b , on the other hand, shows that the combination of PM with a unique coloring (in the figure, red) must be different from zero, in particular, it should be 1/ \u221a 3. Notice that if we only assume monochromatic edges, there is only one PM for each tri-colored vertex coloring and, thus, the only possible solution is forcing this PM to be zero (Fig.1c) . However, if we allow bi-chromatic edges, there could be more tricolored PM, allowing cancellations as in the bi-colored cases (Fig.1d) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 160,
                    "end": 166,
                    "text": "Fig.1a",
                    "ref_id": null
                },
                {
                    "start": 307,
                    "end": 313,
                    "text": "Fig.1b",
                    "ref_id": null
                },
                {
                    "start": 654,
                    "end": 662,
                    "text": "(Fig.1c)",
                    "ref_id": null
                },
                {
                    "start": 791,
                    "end": 799,
                    "text": "(Fig.1d)",
                    "ref_id": null
                }
            ],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "A mathematical conjecture has been proposed that states physically that it is not possible to generate a high-dimensional GHZ state with 6 or more photons with perfect quality and finite count rates without additional resources (such as auxiliary photons). Mathematically, this is equivalent to the question of whether there exists a weighted graph with at least three different vertex colorings of one color each [22, 23] , e.g. for n = 6 a graph with PMs with all paths either blue, green or red and any other vertex coloring cancelled out. The special case for positive weights was solved in 2017 by Ilya Bogdanov [17, 24] , but the case for negative and complex weights is open and contains the exciting possibility of using intricate quantum interference effects as a resource in quantum state preparation and transformation in quantum optics. The question can be translated into a set of d n coupled nonlinear equations with n(n\u22121) 2 d 2 complex variables [25] . The algebraic question is whether there exist solutions to this equation system for n \u2265 6 and d \u2265 3 and complex finite weights. The conjecture reduces to the simple statement that the equation system has no solution.",
            "cite_spans": [
                {
                    "start": 414,
                    "end": 418,
                    "text": "[22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 419,
                    "end": 422,
                    "text": "23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 617,
                    "end": 621,
                    "text": "[17,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 622,
                    "end": 625,
                    "text": "24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 962,
                    "end": 966,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "The emergence of obstructions such as the one shown in Fig.1c suggests that combinatorics may play an important role in the generation of quantum states using this methodology. It is precisely the combinatorial nature of this problem that we will exploit with the help of a logic-based algorithm. a) Basis state generated: |000011 , vertex coloring:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 55,
                    "end": 61,
                    "text": "Fig.1c",
                    "ref_id": null
                }
            ],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "ab w 00 cd w 11 ef + w 00 ac w 00 bd w 11 ef + w 00 ad w 00 bc w 11 ef = 0 b) Basis state generated: |000000 , vertex coloring:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "w 00 ab w 00 cd w 00 ef + w 00 ac w 00 bd w 00 ef + w 00 ad w 00 bc w 00 ef + \u00b7 \u00b7 \u00b7 = 0 c) Basis state generated: |001122 , vertex coloring:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "w 00 ae w 11 bd w 22 cf + w 01 ab w 22 cf w 10 de + w 01 ad w 10 be w 22 cf + \u00b7 \u00b7 \u00b7 = 0 There are three PMs for each two-colored combination assuming monocolored edges. b) To generate the basis state |000000 one needs to obtain a non-zero solution of the equation that sums the 15 PMs that generate that basis element. c) For monocolored edges, the three-colored PMs are unique, which imposes that they must be zero. This imposes a very strong constraint that we will exploit later on for the logic encoding. d) However, if we assume bicolored edges, there are 15 PMs for each color combination, including the three-colored ones. Thus it reduces the strength of the previous constraint. From these graphs, we can construct the photonic experimental setup following the mapping proposed in Ref. [16] . For instance, each edge corresponds to a SPDC that generates a photon pair with the corresponding mode (color) in each path (letter).",
            "cite_spans": [
                {
                    "start": 794,
                    "end": 798,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "II. GRAPH-BASED REPRESENTATION FOR QUANTUM OPTICS"
        },
        {
            "text": "In a Boolean algebra, the variables, called literals, can take two Boolean values: True-False or 0-1. The available operations on these literals are disjunctions \u2228 (OR), conjunctions \u2227 (AND) and negationsx (\u00ac or NOT). Given a Boolean formula, the satisfiability (SAT) problem consist of finding a literals assignment that satisfies it, i.e. outputs True or 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "III. LOGIC AND SAT"
        },
        {
            "text": "In the following subsections, we will encode the state preparation problem described in the previous section into a set of Boolean expressions which satisfiability will give us a solution of the problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "III. LOGIC AND SAT"
        },
        {
            "text": "We will explore the combinatorial nature of this graph problem to construct a set of logical clauses that can deliver a definite solution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "In this problem, the literals will be each of the edges of the graph e \u03b1\u03b2 ij , where (i, j) are the vertices joined by the edge (with i < j) and (\u03b1, \u03b2) are the inherited modes of the vertices, respectively. They will take the value True if they are present and False if they do not. Notice that we do not take into account that each edge can have a complex weight and thus there can be cancellations between PMs with the same vertex coloring. Even though we do not encode the entire information and possibilities of the graph, we still get highly complex and powerful obstructions that we can use constructively in conjunc-tion with SAT solvers. This is by no means a restriction of the representation. Negative and complex numbers numbers can be represented by boolean variables effortlessly. As a simple example, we introduce another bit representing the sign of the number s and the value bit v, such that numbers numbers \u22121, 0, 1 for 11 b , 00 b , 01. All boolean operations can be adjusted accordingly. Of course, in this way we can also introduce more complex number systems such as fractions or complex numbers, but this is out of scope of the current manuscript.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "The logic clause to define a graph PM consist of replacing the PM weights by their corresponding (Boolean) edges and the products of the weights by \u2227. If one of the edges is False (there is no edge), the clause is False, and, therefore, we do not have that PM. The formal derivation of these clauses is presented in App.VI C. In the following paragraphs, we will show how this logic works using examples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "Let's start with a four-vertex graph example with six edges with the same color (mode 0) {e 00 ab , e 00 cd , e 00 ac , e 00 bd , e 00 ad , e 00 bc }. The logic clause that states the existance of the three PM P 1 , P 2 and P 3 is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "where (0, 0, 0, 0) represents the inherited vetex coloring (all photons are in mode 0). If only one of the edges in these PMs is False, that PM does not exist. We require that at least one PM exist for each vertex coloring that appears in the target state. Following the",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "ab \u2227 e 11 cd \u2228 e 11 ad \u2227 e 11 bc \u2228 e 11 ac \u2227 e 11 bd \u2227 e 00 ab \u2227 e 00 cd \u2228 e 00 ad \u2227 e 00 bc \u2228 e 00 ac \u2227 e 00 These weights also carry another degree of freedom, the color, which has as many dimensions d as the state. The bar on top of a Boolean variable or expression corresponds to the negation of its value. Each PM is composed by the conjunction (\u2227) of all edges that compose it, so all edges must evaluate to True to have that PM. For those basis elements that appear in the target state, the logic instance corresponds to the disjunction (\u2228) of all PMs; to evaluate to True, at least one of the PMs must exist, i.e. evaluate to True. This logic is represented in the top part of the figure, where the total expression must evaluate to True to obtain the superposition |0000 + |1111 . For those basis elements that are not in the target state, we can construct some obstructions. If all PMs except one evaluate to False, the remaining one has to be False as well. Other cases, like only one of them being False, can allow interference between the True PMs, a property not encoded in the logic. In the example (bottom part of the figure), the state |0011 must not appear, so the total expression must evaluate to True, as its negation will be added to the total set of clauses to be evaluated by the SAT solver.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "previous example, if the state |0000 appears in the target state, then at least one of the previous PM must be True:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "(3) The above clause evaluates to True if at least one of the subclauses b is True.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "If there are other basis elements in the target state, then all clauses of the form of B must evaluate to True. An example is shown in Fig.2a . The target state is the GHZ state of n = 4 and d = 2. There are two vertex colorings in the target state, the one corresponding to the |0000 basis element and the |1111 element, where the |0 and |1 states are represented in red and blue colors, respectively. Each PM is composed by two edges and, assuming the full-connected graph, there are three possible combinations:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 135,
                    "end": 141,
                    "text": "Fig.2a",
                    "ref_id": null
                }
            ],
            "section": "A. Logic encoding"
        },
        {
            "text": "Since we want to generate a monocolored basis state, all edges have the same color on both ends. To obtain the two basis elements, at least one of the blue PMs and one of the red PMs has to evaluate to True. This is represented with the clause",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "The remaining vertex colorings that do not appear in the target state must be False. However, as we mentioned before, the existence of more than one PM with a given coloring might be possible since there could induce a cancellation between the weighted PMs. The logic encoding that we propose cannot encode these cancellations, but we can include extreme cases independent of the weight values. We can have all PMs of a particular coloring and still obtain a cancellation between them, but if all PMs except one does not exist (they are False), the remaining one cannot exist either (should be False as well) because it cannot be canceled with anyone else. Figure 2b shows the clause for those PMs that generate the basis element |0011 , which does not appear in the GHZ state. Let's analyse it piece by piece. The first part of the clause reads",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 657,
                    "end": 666,
                    "text": "Figure 2b",
                    "ref_id": null
                }
            ],
            "section": "A. Logic encoding"
        },
        {
            "text": "If the three PMs exist (are True), this expression is True. If only two of them are True, the expression is still True. This two cases illustrate the fact that there could be cancellations between the PMs, so keeping them can be a solution once we search for the weights. If the first two PMs are False, the third one has to be False as well in order to keep the expression True. We must add the other two possibilities, i.e. that the other pairs of PMs are False, so the remaining one is forced to be False as well. This is why, the total clause shown in Fig. 2b contains three subclauses, to account for the permutations of PMs.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 556,
                    "end": 563,
                    "text": "Fig. 2b",
                    "ref_id": null
                }
            ],
            "section": "A. Logic encoding"
        },
        {
            "text": "Altogether, the global set of clauses that encode the possible solutions for the generation of a particular state using graph PMs is a conjunction of clauses of type S, the ones that guarantee the existence of at least one PM for each target state basis element, and clauses of type C, a set of constraints on the PMs that should not appear in the final graph:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "Given a set of edges, if K =False we can conclude it is not possible to obtain the target state. However, K =True does not guarantee the generation of this state due to the possible interference between PMs is not encoded in the clauses. For this reason, solutions such as the complete graph (all possible edges are True) outputs K =True, although heuristic optimization algorithms such as Theseus [15] show that some states are not representable by graphs. For this reason, we mix this optimization strategies with Klaus to obtain and guarantee physical and interpretable solutions.",
            "cite_spans": [
                {
                    "start": 398,
                    "end": 402,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "A. Logic encoding"
        },
        {
            "text": "The logical clauses presented in the previous section are general for both monochromatic and bi-chromatic edges. However, for graphs with only monochromatic edges, the problem simplifies substantially as the number of possible vertex coloring is much more constrained, therefore the logical approach is more powerful. One example is the one shown in Fig.2c , where for the case of n = 6 vertices tricolored vertex colorings are formed with unique PM. The same argument extends to more than three colors. In general, for a graph of n vertices and monochromatic edges, vertex colorings composed by d = n/2 colors are unique. This fact implies that the condition of these vertex colorings is composed of a single clause: either that PM is True (if that coloring appears in the target state) or is False (if it does not). In the first case, it fixes the \"trueness\" of all edges that form that PM. In the second case, it imposes that at least one of the edges must be zero. In either case, it could trigger a chain reaction on the rest of the clauses.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 350,
                    "end": 356,
                    "text": "Fig.2c",
                    "ref_id": null
                }
            ],
            "section": "B. Monochromatic edge obstructions"
        },
        {
            "text": "We test this approach to check if there exists a graph with monochromatic edges that generate the GHZ state of n > 4 parties and d \u2265 n/2 local dimensions. We check if the set of clauses K from Eq.(6) is satisfiable, i.e. if there exists a solution for the literals that evaluates to True. We use the SAT solver from Mathematica language (which corresponds to MiniSAT in Mathematica 11). We obtained K =False for n up to 8 and d = n/2 colors. For bigger systems, the amount of RAM required was out of range for our current computational capabilities. With these results we formulate the following conjecture to be added to other graph edge coloring conjectures such as the ones presented in Ref. [23] : Conjecture. It is not possible to generate a graph G with n > 4 vertices and monochromatic edges each with one of d \u2265 n/2 possible colors, such that it contains single-colored PMs for each of these d colors while no PMs with other vertex colorings are generated (or the amount of these PMs does not allow cancellations).",
            "cite_spans": [
                {
                    "start": 695,
                    "end": 699,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "B. Monochromatic edge obstructions"
        },
        {
            "text": "In the language of quantum state generation with photonic setups: it is not possible to generate exactly a GHZ state of n > 4 parties and d \u2265 n/2 dimensions (and n = 4 and d > 3) using this graph approach without additional quantum resources (such as auxiliary photons).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Monochromatic edge obstructions"
        },
        {
            "text": "SAT solvers look for a solution that is satisfiable no matter the number of True literals that it includes (looking for a particular solution will take exponential time), thus some of the solutions obtained may be cumbersome to interpret by humans. For instance high-dense graphs with many True edges are allowed solutions of K making it difficult to map them into a physical setup or to interpret the result to gain some understanding about how these states are physically generated. Moreover, the logic clauses do not provide the weights of the graph that generate the correct state amplitudes, so we need at least one extra step in our algorithm to compute these weights. We propose a heuristic algorithm based on propositional logic named Klaus that aims to find a simplification of the satisfiable solutions of the logical clauses K and to find the state amplitudes of the generated state. Figure 3 shows the schematic representation of the Klaus algorithm. It starts with the fully connected graph, randomly selects one edge and sets it to False. Then, it checks if K is satisfiable using a SAT solver. If K =True, it means that edge was unnecessary to achieve the target state, so it \"deletes\" it, i.e., sets it to False permanently. If K =False, it means the edge was indispensable to generate the state, so it has to be True. The process is repeated selecting randomly another edge, assigning it to False, and checking again if K is satisfiable. The loop continues until all edges are classified either as disposable (all deleted edges) or indispensable (the rest of edges). We end up with a much-reduced list of edges that, according to K, can generate the target state. However, we still need to check if the final solution can generate the state by finding the corresponding weights. The last step of the Klaus algorithm consists of minimizing the infidelity of the resulting graph to find the weights of its edges.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 895,
                    "end": 903,
                    "text": "Figure 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "IV. KLAUS ALGORITHM"
        },
        {
            "text": "Many possible solutions may satisfy the K clauses. Moreover, the smallest the graph, the faster is the SAT solver, which accelerates the algorithm as it evolves. We can completely trust the logical clauses if they evaluate to False (implying that it is impossible to generate the state with that set of edges). However, the True solutions must still pass the possible interference test between the surviving PMs with the same vertex coloring. It could be the case that a final solution output by Klaus cannot generate the target state because the requiring cancellations cannot occur. This is because all graph PMs constitute a 6)) is satisfiable using a SAT solver. If the SAT solver outputs True, the edge selected is disposable to generate the target state, so we can delete it, i.e., set it to False permanently. On the other side, if SAT is False, it means that edge is required to generate the state, so it has to be True. The algorithm repeats the process of picking the other edges until all of them are classified as disposable (False) or indispensable (True). As a result, we obtain a significantly sparsed graph. The final step consists of obtaining the graph weights that generate the required amplitudes to obtain the target state. This is done by numerically minimizing the infidelity of the graph obtained when replacing the edges with their corresponding weights.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "IV. KLAUS ALGORITHM"
        },
        {
            "text": "highly coupled system of equations. In some cases, some edges turned out to be indispensable once we minimize the infidelity, so if Klaus has deleted them, then it is not possible to generate the state afterward. In our benchmarks (presented in the next section), we found these cases to be unlikely but they open the path to better understand the combinatorial nature of this problem and to find new obstruction clauses to include in our logic instances. We leave the investigation of these constraints for future work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "IV. KLAUS ALGORITHM"
        },
        {
            "text": "We test and compare the Klaus algorithm with Theseus [15] , a purely numerical strategy, to find the minimal graphs that generate a given state. Theseus starts with the fully connected graph and minimizes the infidelity with respect to the target state. In the original proposal, after this minimization, it selects the smallest weight, deletes it (i.e., sets it to zero), and repeats the minimization process until no more weights can be deleted without compromising the infidelity. We found that this approach can be improved significantly by deleting more than one edge at once. In particular, after each mini-mization, we delete all edges with weights smaller than a certain threshold.",
            "cite_spans": [
                {
                    "start": 53,
                    "end": 57,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "Although this improved version of Theseus is much faster than the original one, it is not sensitive to those cases where only a subset of weights with similar values can be deleted. Therefore, there is no way to certify that more edges can be removed than trying to delete them one by one, as in the original proposal. Since the goal of these algorithms is to provide the minimal solution, it is necessary to include a final step in Theseus that checks if there is an even smaller solution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "We try to certify the minimal solution of Theseus following two strategies. Both strategies check if it is possible to remove more edges by proceeding one by one. The first strategy, which we call Theseus optimization (The-seusOpt), is performed by following the original Theseus approach, i.e., deleting one edge, minimizing the infidelity, and keeping it if it gets compromised or deleting it definitively otherwise. In the second strategy, called Klaus optimization (KlausOpt), we use Klaus instead, i.e., checking if K is still satisfiable when we delete one by one the remaining edges and minimizing the infidelity only at the very end of the algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "We start our benchmarks by checking the performance of these four algorithms (Klaus, Theseus, TheseusOpt, and KlausOpt) with the generation of target states from which we know there exist a graph [19] . We check the computational time that they need and the number of edges of the solution. Since all these algorithms have a heuristic component (the selection of random edges to delete), we run them 25 independent times for each target state to obtain an average performance.",
            "cite_spans": [
                {
                    "start": 196,
                    "end": 200,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "The test states have different entanglement properties quantified by the Schmidt Rank Vector (SRV) [26] , a different number of parties n, and a different number of basis elements. In particular, we look for the graphs for the GHZ(n,d) states GHZ(4,3) and GHZ (6, 2) , and states with SRV equal to (5, 4, 4) , (6, 4, 4) , (6, 5, 4) and (9, 5, 5) . The wave functions of these states are written explicitly in App. VI D. The SRV states are composed of three parties. Thus, we will find the graphs of the heralded state, in particular |\u03c8 = |\u03c8 |0 , where |\u03c8 is the real target state.",
            "cite_spans": [
                {
                    "start": 99,
                    "end": 103,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 260,
                    "end": 263,
                    "text": "(6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 264,
                    "end": 266,
                    "text": "2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 298,
                    "end": 301,
                    "text": "(5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 302,
                    "end": 304,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 305,
                    "end": 307,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 310,
                    "end": 313,
                    "text": "(6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 314,
                    "end": 316,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 317,
                    "end": 319,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 322,
                    "end": 325,
                    "text": "(6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 326,
                    "end": 328,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 329,
                    "end": 331,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 336,
                    "end": 339,
                    "text": "(9,",
                    "ref_id": null
                },
                {
                    "start": 340,
                    "end": 342,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 343,
                    "end": 345,
                    "text": "5)",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "Besides checking if Klaus and Theseus can find states that can be generated from graphs, we also test those states that cannot be exactly constructed this way. These states will be the GHZ(6, 3) and two states with SRV equal to (5, 4, 4) and (6, 4, 4) different from the above ones. For these states, however, we can obtain approximate solutions by setting those forbidden vertex colorings weights close to zero. Notice that these solutions are forbidden by the logic clauses in Klaus, so we expect that Klaus will have more difficulties finding them. Figure 4 shows the average performance and its standard deviation over 25 independent runs of the four algorithms for the aforementioned target states. The plots show the number of edges of the minimal solution, the fidelity with respect to the target state, and the total computational time (on a 2.4 GHz CPU with 16 GB of RAM). Besides the pure algorithmic optimization time, the computational time for Klaus and KlausOpt includes the generation of the logical clauses.",
            "cite_spans": [
                {
                    "start": 228,
                    "end": 231,
                    "text": "(5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 232,
                    "end": 234,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 235,
                    "end": 237,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [
                {
                    "start": 552,
                    "end": 560,
                    "text": "Figure 4",
                    "ref_id": null
                }
            ],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "We can appreciate how Klaus is, on average, faster than Theseus. Klaus finds the minimal solution for those states that can be represented with graphs. However, for those without a graph representation, Klaus obtains solutions with more edges and worse fidelities. We expect this behavior since the logical instances may forbid the aforementioned approximate solutions that Theseus can find. The sometimes big standard deviations are a consequence of the heuristic nature of these algorithms, specially Theseus, when it gets trapped in local minima. In any case, KlausOpt is significantly better than TheseusOpt in terms of number of edges of the final solution and specially the computational time required, establishing a clear advantage of using the SAT solver instead of multiple numerical minimizations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "V. BENCHMARKS"
        },
        {
            "text": "We have shown how logic AI can contribute to the discovery of novel quantum optical setups and experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VI. DISCUSSION AND CONCLUSIONS"
        },
        {
            "text": "Theseus, TheseusOpt, and KlausOpt algorithms. We take a set of target states that can be generated by graphs and some that cannot (indicated with a * in the plot). We compare the number of edges of the minimal graph solution, the fidelity with respect to the target state, and the total computational time. Since all these algorithms are heuristic, we run each of them 25 times and compute the average and standard deviation of their results. On average, Klaus succeeds in both finding the minimal solution and in spending less computational time than the other algorithms. However, although faster, it fails to find approximate solutions to those states that cannot be generated by graphs. We expect this result from a propositional logic algorithm, where the clauses K will be False for those approximate solutions. KlausOpt algorithm is significantly better than TheseusOpt, showing the advantage of using a hybrid numerical-logical approach in contrast to purely numeric strategies.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FIG. 4. Comparison of the average performance of Klaus,"
        },
        {
            "text": "We introduce a Boolean encoding of the graph representation of these setups and present a mapping from the state preparation problem to a k\u2212SAT. With this approach, we can check the conjecture that it is not possible to generate a GHZ state of n parties and d \u2265 n/2 dimensions using these experiments. Then, we design a logic-heuristic algorithm, Klaus, which starting from the complete graph, finds the minimal representation that corresponds to the generation of the target state. We benchmark Klaus with the state-of-the-art algorithm Theseus [15] , based on numerical optimization. Klaus is on average faster than Theseus and it finds the minimal graphs for the different test states. We also show how Theseus, a continuous optimization algorithm, can be improved with the assistance of Klaus, a logic-based algorithm.",
            "cite_spans": [
                {
                    "start": 546,
                    "end": 550,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "FIG. 4. Comparison of the average performance of Klaus,"
        },
        {
            "text": "At the very end, Klaus has to numerically minimize a loss function consisting of the infidelity between the remaining graph and the target state. However, the process of deleting edges from the fully connected graph simplifies that minimization substantially. There are several potential advantages of using Klaus in contrast to fullynumerical approaches such as the Theseus algorithm: i) if K =False we know for sure that the graph cannot be exactly generated, while a non-successful purely numerical minimization may imply that we got trapped in local minima; ii) the final minimization step involves a small subset of weights, increasing the probability of a successful optimization, in contrast with Theseus, where a minimization involving all weights is performed at the very beginning of algorithm; iii) SAT solvers have improved in the last years, becoming a powerful tool in computation that can solve huge problems involving thousands of literals. It makes them a very convenient tool for problems that grow exponentially with the number of parties involved.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FIG. 4. Comparison of the average performance of Klaus,"
        },
        {
            "text": "The experimental preparation of quantum states is a key feature in the quantum technologies era. Quantum computing paradigms such as measurement-based quantum computation [27] relies on the initial optimal preparation of highly entangled states. Some quantum machine learning algorithms require the encoding of arbitrary data into the amplitudes of a general quantum states [28] , including those early proposals that solve system of linear equations [29] . Besides these state preparation applications, the power of the graph representation introduced in [15] can also be extended to general quantum operations and quantum circuit design that lead to novel ways to construct, for instance, multilevel multiphotonic experiments [30, 31] , whether integrated [32, 33] or in bulk optics [32, 34, 35] . Although a fullyprogrammable quantum computer can theoretically prepare any state or perform any unitary operation, not all hardware implementation have direct access to all of the required quantum gates. In this context, providing alternative representations and algorithms based on them, will prove valuable in the coming years.",
            "cite_spans": [
                {
                    "start": 171,
                    "end": 175,
                    "text": "[27]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 374,
                    "end": 378,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 451,
                    "end": 455,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 556,
                    "end": 560,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 728,
                    "end": 732,
                    "text": "[30,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 733,
                    "end": 736,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 758,
                    "end": 762,
                    "text": "[32,",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 763,
                    "end": 766,
                    "text": "33]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 785,
                    "end": 789,
                    "text": "[32,",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 790,
                    "end": 793,
                    "text": "34,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 794,
                    "end": 797,
                    "text": "35]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "FIG. 4. Comparison of the average performance of Klaus,"
        },
        {
            "text": "Although current SAT solvers are extremely efficient and capable of dealing with thousands of literals and clauses, it is worth noting the efforts of quantum and quantum-inspired approaches to solve classical satisfiability problems. In particular, a quantum computing paradigm such as quantum annealing [36, 37] is especially suitable to map classical logical clauses into a quantum Hamiltonian and obtain the solution by adiabatically preparing its ground state. Digital quantum computations can also be programmed to prepare these ground states, even in near-term quantum devices [38, 39] . Moreover, quantum-inspired classical techniques such as tensor networks can also be applied to solve SAT problems [40] .",
            "cite_spans": [
                {
                    "start": 304,
                    "end": 308,
                    "text": "[36,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 309,
                    "end": 312,
                    "text": "37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 583,
                    "end": 587,
                    "text": "[38,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 588,
                    "end": 591,
                    "text": "39]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 708,
                    "end": 712,
                    "text": "[40]",
                    "ref_id": "BIBREF40"
                }
            ],
            "ref_spans": [],
            "section": "FIG. 4. Comparison of the average performance of Klaus,"
        },
        {
            "text": "Logic AI, a paradigm proposed in the 50's, is experiencing its expansion in the recent years, with the improvements in SAT solvers. Traditionally, it has been mainly used in circuit design, but its applications go beyond that. The increasing interest on understanding concepts such as how a machine learns or how to tackle hard mathematical conjectures, has recently promoted this AI subfield. The use of formal reasoning can form fascinating synergies with other approaches. As an example, one can introduce a logic-based piece in a standard ML loss function [41] . Within this work, we present one of the aforementioned synergies by entangling a purely numerical algorithm with a logical one and extend the applicability of logic AI to the design of quantum experiments.",
            "cite_spans": [
                {
                    "start": 560,
                    "end": 564,
                    "text": "[41]",
                    "ref_id": "BIBREF41"
                }
            ],
            "ref_spans": [],
            "section": "FIG. 4. Comparison of the average performance of Klaus,"
        },
        {
            "text": "The Mathematica notebook with Klaus algorithm can be found at https://github.com/AlbaCL/Klaus.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CODE AVAILABILITY"
        },
        {
            "text": "In a Boolean algebra, the variables, called literals, can take two Boolean values: True-False or 0-1. The available operations on these literals are disjunctions \u2228 (OR), conjunctions \u2227 (AND) and negationsx (\u00ac or NOT). A Boolean formula includes its literals and the operations between them. It is usually more practical to translate a Boolean formula into one of its canonical forms: conjuctive normal form (CNF) or disjuntive normal form (DNF). A CNF expressions is a conjunction of clauses, each composed by disjunction of literals. Similarly, a DNF expression is the opposite of a CNF, a disjunction of clauses, where each of them is composed by the conjunction of its literals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CODE AVAILABILITY"
        },
        {
            "text": "Given a Boolean formula, the satisfiability (SAT) problem consist of finding a literals assignment that satisfies it, i.e. outputs True or 1. The complexity of a SAT problem depends on the structure of its canonical forms, CNF or DNF. This is why the first step towards solving a SAT consist on rewriting the Boolean expression into CNF or DNF. In both cases, we can use logical equivalence rules to find these forms, although this translation can be very costly. In the case of CNF there exist the Tseitin transformation [42] which is in general more efficient. This is the reason why big SAT problems are normally translated into CNF instead of DNF.",
            "cite_spans": [
                {
                    "start": 522,
                    "end": 526,
                    "text": "[42]",
                    "ref_id": "BIBREF42"
                }
            ],
            "ref_spans": [],
            "section": "CODE AVAILABILITY"
        },
        {
            "text": "A CNF clause with k literals is called a k\u2212clause. A k\u2212SAT problem coonsist of finding if there is any assignment of literals such that a CNF expression composed by k\u2212clauses is True. For k = 2, 2-SAT, the problem is in P complexity class, meaning it can be solved in polynomial time. For k > 2, the SAT is an NP-complete problem. This means it can be verified in polynomial time, but whether it can be solved in such time depends on a solution of a famous complexity theory open problem whether P=NP. On top of that, any other NP problem can be reduced in polynomial time to k\u2212SAT, thus any advances in solving k\u2212SAT will impact the whole NP family. As a final remark, although NP is usually used as a synonym of hardness, not all NP problems (or, equivalently, k\u2212SAT problems) are hard: the solution of the hardest instance is unknown to be available in polynomial time, but not all problems have them. As a matter of fact, on average, a k\u2212SAT problem can be solved relatively quickly and it is actually difficult to find these hard instances to benchmark the SAT solvers. This is why using logic AI and these solvers is a valid strategy even though they are tackling NP problems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CODE AVAILABILITY"
        },
        {
            "text": "The science of SAT solvers is extremely complex and requires the knowledge and manipulation of logical instances. Once we have our expression in CNF, the SAT solver manipulates it using Boolean algebra trying to find contradictions (such as x \u2227x), simplifications and structures that prevents it to perform a brute-force search. Precisely, a complete SAT solver can use a binary tree approach to check all branches until it finds one that is satisfiable, but it will be highly unefficient. Instead, as it explores the binary tree, it checks if the expression can be simplified and what are the implication relations between the clauses that will trigger a chain reaction depending on the value of one of them. Figure 5 shows some SAT solvers examples and some Boolean algebra manipulations that they use. One of the most famous approaches are the Davis-Putnam-Logemann-Loveland (DPLL) algorithm [43] and the Conflict Driven Clause Learning (CDCL), from which the algorithms used in this work, the MiniSAT, is based [44, 45] .",
            "cite_spans": [
                {
                    "start": 895,
                    "end": 899,
                    "text": "[43]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 1015,
                    "end": 1019,
                    "text": "[44,",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 1020,
                    "end": 1023,
                    "text": "45]",
                    "ref_id": "BIBREF45"
                }
            ],
            "ref_spans": [
                {
                    "start": 710,
                    "end": 718,
                    "text": "Figure 5",
                    "ref_id": null
                }
            ],
            "section": "CODE AVAILABILITY"
        },
        {
            "text": "In this appendix, we provide the explicit equivalence between the graph-theoretical representation of photonic experiments and the quantum states generated by them.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "From states to graphs"
        },
        {
            "text": "The main component of the photonic graph-theoretical representation are the photonic sources, i.e. the SPDC. Each SPDC create a photon pair at two paths, each with a particular mode. Each SPDC is represented with an edge between two nodes (the paths where the photons are created) and the color of that edge indicates the modes of the photons created.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "From states to graphs"
        },
        {
            "text": "Mathematically speaking, each SPDC corresponds to ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "From states to graphs"
        },
        {
            "text": "Disjunctive Normal Form (DNF). Disjunction of clauses formed by conjunction of literals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "From states to graphs"
        },
        {
            "text": "Conditioning. Set x =True: removex literals and clauses with x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "e.g.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Resolution. Combine clauses with x andx to remove x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Unit resolution (UR). Unit clauses simplify the expression.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Unit propagation (UP). UR until a literal is removed from all clauses.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Boolean Satisfiability Problem k -clause. Clause (CNF or DNF) formed by k literals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "k -SAT. Is there an assignment of values to the literals such that a Boolean formula composed by k-clauses evaluates to True? . SAT problems are NP-complete, which means it does not exist an efficient algorithm that solves them but once the solution is provided, it can be easily verified. However, it is possible to design highly efficient algorithms that go much more beyond the naive binary-tree search.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "the following operation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "where a and b are the labels of the two paths where the photons are created, k is the mode of the photons and g 1. When the setup starts, the first SPDC act on the vacuum state, thus",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "i.e. one photon with mode k is created at path a and one photon with mode k is created at path b. Imagine that we apply another SPDC on the same paths but with a different mode l:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "thus we have now a superposition of two photons with mode k and two with mode l at paths a and b. If the SPDC creates photons with the same mode as before, k, the result will become",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "In any case, we can discard those states containing zero or more than 2 photons since we condition the state on the simultaneous photon detection events in all detectors Let's see how these manipulations can be analyzed using the graph PMs instead with a four-path photonic example.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Take the left graph from Fig.6 . It corresponds with two SPDC that create photons in the |0 mode in paths a, b, c and d. The state that arrives to the photon detectors is",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 25,
                    "end": 30,
                    "text": "Fig.6",
                    "ref_id": null
                }
            ],
            "section": "Boolean Algebra"
        },
        {
            "text": "where we avoided the annihilation operators since they are discarded when act on the vacuum state. Since we are interested in those photonic states that involve one photon per path, the surviving term is the |0000 state with amplitude g 2 . Now, let's take the center graph from Fig.6 . After the 0-mode SPDC we apply 1-mode SPDC on the same pairs of paths. As a result:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 279,
                    "end": 284,
                    "text": "Fig.6",
                    "ref_id": null
                }
            ],
            "section": "Boolean Algebra"
        },
        {
            "text": "|\u2205\u2205\u2205\u2205 + g 2 |0000 + g (|00\u2205\u2205 + |\u2205\u220500 )) = |\u2205\u2205\u2205\u2205 + g (|00\u2205\u2205 + |\u2205\u220500 ) + g 2 |0000 +g (|11\u2205\u2205 + |\u2205\u220511 ) + g 2 |1111 +g 2 (|0011 + |1100 ) + \u00b7 \u00b7 \u00b7 . (12)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Thus, those states that contain one photon each, the state generated becomes",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Finally, let's consider the right graph from Fig.6 . The second row of SPDC is applyied on different pairs of paths than the first one. Thus:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 45,
                    "end": 50,
                    "text": "Fig.6",
                    "ref_id": null
                }
            ],
            "section": "Boolean Algebra"
        },
        {
            "text": "This time, the surviving terms are two. g 2 (|0000 + |1111 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "So, we can draw three conclusions from this analysis: 6 . Some examples of four-vertex graphs and the onephoton states that they generate.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 54,
                    "end": 55,
                    "text": "6",
                    "ref_id": null
                }
            ],
            "section": "Boolean Algebra"
        },
        {
            "text": "1. Each graph PM generates a basis element corresponding to the modes (colors) incident to the paths (vertices).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "2. The final superposition state corresponds to adding all graph PMs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "3. The edge weight corresponds to some power of the SPDC coupling g. The exponent corresponds to n/2 where n are the total paths.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boolean Algebra"
        },
        {
            "text": "Let us formulate the graph-based representation of optical experiments in a more formal way (for a more detailed mathematical description, check Ref. [23] ).",
            "cite_spans": [
                {
                    "start": 150,
                    "end": 154,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "B. Formal definitions of graph representation of optical experiments"
        },
        {
            "text": "Given a graph with n vertices and a set of undirected edges E, a perfect matching (PM, in plural PMs) corresponds to a set of edges e \u2208 E such that each vertex is matched with exactly one edge. For weighted graphs, i.e., for graphs where each edge has an associated weight w \u2208 C, the total weight of a PM corresponds to the product of the weights that forms it. We can add more degrees of freedom by associating another property to the edges: color. We assume that each edge of G contains up to two colors (bi-chromatic graphs). A bi-chromatic edge with a color pair (\u03b1, \u03b2) will join two vertices (i, j), giving color \u03b1 to vertex i and color \u03b2 to vertex j. Then, each edge contains five properties: the two vertices it joins, the corresponding colors that deliver to each vertex, and its complex weight.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Formal definitions of graph representation of optical experiments"
        },
        {
            "text": "We label each edge with e \u03b1\u03b2 ij , where (i, j) with i < j are the vertex pair and (\u03b1, \u03b2) are the corresponding colors. Similarly, the weights of each edge will be labelled as w \u03b1\u03b2 ij \u2208 C. Thus, a PM P and its associated weight w P are defined as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Formal definitions of graph representation of optical experiments"
        },
        {
            "text": "w P (c) :=",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Formal definitions of graph representation of optical experiments"
        },
        {
            "text": "where c is the color combination inherited by the vertices. As example, take the first graph from 1a. The n = 6 graph with edges E = {e 00 ab , e 00 cd , e 11 ef } form one PM P with weight w P (c) = w 00 ab w 00 cd w 11 ef and c = (0, 0, 0, 0, 1, 1). A general graph may contain several PMs. In particular, a complete graph with n vertices contains (2n\u22121)!! = (2n \u2212 1)!/(2 n\u22121 (n \u2212 1)!) PMs. If each edge of the graph has the extra color degrees of freedom, the number of PMs increases to d n (2n \u2212 1)!!, where d is the number of different colors. Therefore, there could be more than one PM with the same inherited vertex coloring, i.e. the same color combination inherited by the vertices from the bicolored edges that touch them. As explained before, each color vertex combination corresponds to the generation of a basis state. Thus, to obtain the total basis state amplitude, we need to sum up the weights of all PMs that generates it. The weight of a vertex coloring c of a graph is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Formal definitions of graph representation of optical experiments"
        },
        {
            "text": "where M is the set of perfect matching of G with the same coloring c and w p are the corresponding PM weights of each P \u2208 M. Coming back to the previous example, if we add to the list of edges the edges e 00 ac and e 00 bd , the resultant graph contains E = {e 00 ab , e 00 cd , e 11 ef , e 00 ac , e 00 bd } and thus it generates a second PM, the second one shown in Fig.1a . That PM has the same vertex coloring as the previous one, c = (0, 0, 0, 0, 1, 1). Thus, the weight of that vertex coloring is W (c) = w P (c) = w 00 ab w 00 cd w 11 ef + w 00 ac w 00 bd w 11 ef .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 368,
                    "end": 374,
                    "text": "Fig.1a",
                    "ref_id": null
                }
            ],
            "section": "B. Formal definitions of graph representation of optical experiments"
        },
        {
            "text": "For a given PM P , its Boolean expression becomes",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "where e \u03b1\u03b2 ij are the graph edges (and the Boolean literals), i < j are the graph vertices and c coloring will be defined by the particular colors \u03b1 and \u03b2 associated with each edge in canonical order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "We require that at least one PM exist for each vertex coloring that appears in the target state. Thus, the collection of clauses that encode this logical statement becomes",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "where M is the set of PMs with c vertex coloring and B c is False only if all PMs are False, and True otherwise. As required, we need at least one PM with vertex coloring c to generate the state with that coloring. In total, we need that this property is fulfilled for each of the vertex colorings that appear in the target state that we want to generate. Thus, the total logical clause for the target state elements becomes ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "where C is the set of vertex coloring that appear in the target state and M c are the set of PMs for each of these colorings.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "To encode the obstructions to those basis elements that do not appear in the target state, we use the following logic: if all PMs except one that generate that basis elements are False, the remaining one has to be False as well. However, other possibilities, e.g. two or more are True, are allowed since there can be cancellations between the weights of these PMs. For each of these forbidden basis elements, we encode this logical statement in the following way:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "where M are the set of PMs with vertex coloring c. Take a subset of all PMs with the same vertex coloring consisting of all PMs except one. If all PMs of this subset are False, its conjunction will be False. Therefore, to C(c) =True, the remaining PM must evaluate to False as well. For example, imagine we have three PMs with a vertex coloring c that must not appear in the target state, namely P M 1 , P M 2 and P M 3 . If P M 2 = P M 3 =False, then P M 2 \u2228 P M 3 =False. As a consequence, P M 1 =False, so P M 1 =True in order to obtain C(c) =True. Considering all basis elements that do not appear in the target state, the obstruction clause becomes",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "where O is the set of vertex colorings that do not appear in the state. This clause evaluates to True only when all subclauses are fulfilled, i.e. each C(c) =True.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. Logic clauses construction"
        },
        {
            "text": "The states used in the benchmarks are the GHZ states",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "in particular the GHZ states for n = 4, 6, 8 and local dimension 2 or 3: Besides these states, we also consider highly entangled states with different Schmidt Rank Vector (SRV) [26] . This figure of merit is well-defined for states consisting of 3 parties. That is why to generated these states we introduce a forth party in the |0 state, i.e. we look for the graph that generates the state |\u03c8 |0 , where |\u03c8 is the true target state. The explicit wave-functions of these states are",
            "cite_spans": [
                {
                    "start": 177,
                    "end": 181,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "|\u03a8 644 = 1 \u221a 6 (|000 + |111 + |222",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "|\u03a8 654 = 1 \u221a 6 (|000 + |111 + |222",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "|\u03a8 955 = 1 \u221a 9 (|000 + |111 + |222",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "The subindex of the |\u03c8 states indicate their SRV. We also use two ststes with SRV= (5, 4, 4) , (6, 4, 4) for which it does not exist an exact graph that generates them. These states are",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 86,
                    "text": "(5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 87,
                    "end": 89,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 90,
                    "end": 92,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 95,
                    "end": 98,
                    "text": "(6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 99,
                    "end": 101,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 102,
                    "end": 104,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "We also try to generate the GHZ(6,3), which we know it is not representable by an exact graph,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Benchmark states"
        },
        {
            "text": "We run the algorithms benchmarks 25 times for each target state and present the average performance in the main article. Figures 7 and 8 show the results of each of these runs. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 121,
                    "end": 136,
                    "text": "Figures 7 and 8",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "D. Benchmark states"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Programs with common sense (RLE and MIT computation center",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mccarthy",
                    "suffix": ""
                }
            ],
            "year": 1960,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Probabilistic logic revisited, Artificial intelligence",
            "authors": [
                {
                    "first": "N",
                    "middle": [
                        "J"
                    ],
                    "last": "Nilsson",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "",
            "volume": "59",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/0004-3702(93)90167-A"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Three modern roles for logic in ai",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Darwiche",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 39th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS'20",
            "volume": "",
            "issn": "",
            "pages": "229--243",
            "other_ids": {
                "DOI": [
                    "10.1145/3375395.3389131"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "A time leap challenge for sat-solving",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "K"
                    ],
                    "last": "Fichte",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hecher",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Szeider",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "International Conference on Principles and Practice of Constraint Programming",
            "volume": "",
            "issn": "",
            "pages": "267--285",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-58475-7_16"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Solving and verifying the boolean pythagorean triples problem via cube-and-conquer",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Heule",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kullmann",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "W"
                    ],
                    "last": "Marek",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "International Conference on Theory and Applications of Satisfiability Testing",
            "volume": "",
            "issn": "",
            "pages": "228--245",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-40970-2_15"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "The resolution of keller's conjecture",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brakensiek",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Heule",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mackey",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Narv\u00e1ez",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "International Joint Conference on Automated Reasoning",
            "volume": "",
            "issn": "",
            "pages": "48--65",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-51074-9_4"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "The chromatic number of the plane is at least 5",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "D"
                    ],
                    "last": "De Grey",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1804.02385"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Heesch numbers of unmarked polyforms",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Kaplan",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:2105.09438"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Two-hundred-terabyte maths proof is largest ever",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Lamb",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Nature News",
            "volume": "534",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1038/nature.2016.19990"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "A compact and efficient sat encoding for quantum circuits",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Wille",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Przigoda",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Drechsler",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Africon",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {
                "DOI": [
                    "10.1109/AFRCON.2013.6757630"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Mapping quantum circuits to ibm qx architectures using the minimal number of swap and h operations",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Wille",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Burgholzer",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zulehner",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "2019 56th ACM/IEEE Design Automation Conference (DAC",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Sat-based {CNOT, T} quantum circuit synthesis",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Meuli",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Soeken",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "De Micheli",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "International Conference on Reversible Computation",
            "volume": "",
            "issn": "",
            "pages": "175--188",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-99498-7_12"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Symbolic verification of quantum circuits",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ying",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Ji",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:2010.03032"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Conceptual understanding through efficient automated design of quantum optical experiments",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kottmann",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Tischler",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Aspuru-Guzik",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Physical Review X",
            "volume": "11",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevX.11.031044"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Entanglement by path identity",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hochrainer",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lahiri",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zeilinger",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Phys. Rev. Lett",
            "volume": "118",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.118.080401"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Quantum experiments and graphs: Multiparty states as coherent superpositions of perfect matchings",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Gu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zeilinger",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Phys. Rev. Lett",
            "volume": "119",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.119.240403"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Quantum experiments and graphs ii: Quantum interference, computation, and state generation",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Gu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Erhard",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zeilinger",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the National Academy of Sciences",
            "volume": "116",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1073/pnas.1815884116"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Quantum experiments and graphs. iii. high-dimensional and multiparticle entanglement",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Gu",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zeilinger",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Phys. Rev. A",
            "volume": "99",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevA.99.032338"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Computerinspired quantum experiments",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Erhard",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zeilinger",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Nature Reviews Physics",
            "volume": "2",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1038/s42254-020-0230-4"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Multiphoton entanglement and interferometry",
            "authors": [
                {
                    "first": "J.-W",
                    "middle": [],
                    "last": "Pan",
                    "suffix": ""
                },
                {
                    "first": "Z.-B",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "C.-Y",
                    "middle": [],
                    "last": "Lu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Weinfurter",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zeilinger",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "\u017bukowski",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Rev. Mod. Phys",
            "volume": "84",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/RevModPhys.84.777"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "A graph coloring problem from quantum physics",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Mixon",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Questions on the structure of perfect matchings inspired by quantum physics",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Gu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Solt\u00e9sz",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 2nd Croatian Combinatorial Days",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.5592/CO/CCD.2018.05"
                ]
            }
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Solution to graphs with only disjoint perfect matchings",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Bogdanov",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "2021--2029",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Combinatorial equation system with exponentially many equations in quadratic many variables",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krenn",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "2021--2029",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Structure of multidimensional entanglement in multipartite systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Huber",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "I"
                    ],
                    "last": "De Vicente",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Phys. Rev. Lett",
            "volume": "110",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.110.030501"
                ]
            }
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Measurement-based quantum computation on cluster states",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Raussendorf",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Browne",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "J"
                    ],
                    "last": "Briegel",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Phys. Rev. A",
            "volume": "68",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevA.68.022312"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Prediction by linear regression on a quantum computer",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schuld",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sinayskiy",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Petruccione",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Phys. Rev. A",
            "volume": "94",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevA.94.022342"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Quantum algorithm for linear systems of equations",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "W"
                    ],
                    "last": "Harrow",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hassidim",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lloyd",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Phys. Rev. Lett",
            "volume": "103",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.103.150502"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Multidimensional quantum entanglement with large-scale integrated optics",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Paesani",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Ding",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Santagati",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Skrzypczyk",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Salavrakos",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tura",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Augusiak",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Man\u010dinska",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Bacco",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Science",
            "volume": "360",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "https:/www.science.org/doi/10.1126/science.aar7053"
                ]
            }
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Scheme for universal high-dimensional quantum computation with linear optics",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Paesani",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "F F"
                    ],
                    "last": "Bulmer",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "E"
                    ],
                    "last": "Jones",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Santagati",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Laing",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Phys. Rev. Lett",
            "volume": "126",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.126.230504"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Boson sampling with 20 input photons and a 60-mode interferometer in a 10 14 -dimensional hilbert space",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Qin",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Ding",
                    "suffix": ""
                },
                {
                    "first": "M.-C",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "You",
                    "suffix": ""
                },
                {
                    "first": "Y.-M",
                    "middle": [],
                    "last": "He",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "You",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Schneider",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "J"
                    ],
                    "last": "Renema",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "H\u00f6fling",
                    "suffix": ""
                },
                {
                    "first": "C.-Y.",
                    "middle": [],
                    "last": "Lu",
                    "suffix": ""
                },
                {
                    "first": "J.-W",
                    "middle": [],
                    "last": "Pan",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Phys. Rev. Lett",
            "volume": "123",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevLett.123.250503"
                ]
            }
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Integrated photonic quantum technologies",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Sciarrino",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Laing",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "G"
                    ],
                    "last": "Thompson",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Nature Photonics",
            "volume": "14",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1038/s41566-019-0532-1"
                ]
            }
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Generalized multiphoton quantum interference",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Tillmann",
                    "suffix": ""
                },
                {
                    "first": "S.-H",
                    "middle": [],
                    "last": "Tan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "E"
                    ],
                    "last": "Stoeckl",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "C"
                    ],
                    "last": "Sanders",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "De Guise",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Heilmann",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Nolte",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Szameit",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Walther",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Phys. Rev. X",
            "volume": "5",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevX.5.041015"
                ]
            }
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Quantum computational advantage using photons",
            "authors": [
                {
                    "first": "Y.-H",
                    "middle": [],
                    "last": "Peng",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Luo",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Qin",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Ding",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Hu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "370",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "https:/www.science.org/doi/full/10.1126/science.abe8770"
                ]
            }
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Optimization by quantum annealing: Lessons from hard satisfiability problems",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "A"
                    ],
                    "last": "Battaglia",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "E"
                    ],
                    "last": "Santoro",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tosatti",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Phys. Rev. E",
            "volume": "71",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevE.71.066707"
                ]
            }
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "A quantum annealing approach for boolean satisfiability problem",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Su",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Tu",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "He",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "2016 53nd ACM/EDAC/IEEE Design Automation Conference (DAC",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {
                "DOI": [
                    "10.1145/2897937.2897973"
                ]
            }
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Three \"quantum\" algorithms to solve 3-sat",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Leporati",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Felloni",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Theoretical Computer Science",
            "volume": "372",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2006.11.026"
                ]
            }
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "A quantum approximate optimization algorithm",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Farhi",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Goldstone",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Gutmann",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1411.4028"
                ]
            }
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "An exact tensor network for the 3sat problem",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Garc\u00eda-S\u00e1ez",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "I"
                    ],
                    "last": "Latorre",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Quantum Information & Computation",
            "volume": "12",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "https:/dl.acm.org/doi/abs/10.5555/2230976.2230984"
                ]
            }
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "A semantic loss function for deep learning with symbolic knowledge",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Friedman",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Liang",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Broeck",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "International conference on machine learning",
            "volume": "",
            "issn": "",
            "pages": "5502--5511",
            "other_ids": {}
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "On the complexity of derivation in propositional calculus",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "S"
                    ],
                    "last": "Tseitin",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "Automation of reasoning",
            "volume": "",
            "issn": "",
            "pages": "466--483",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-81955-1_28"
                ]
            }
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "A machine program for theorem-proving",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Davis",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Logemann",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Loveland",
                    "suffix": ""
                }
            ],
            "year": 1962,
            "venue": "Communications of the ACM",
            "volume": "5",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/368273.368557"
                ]
            }
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "An extensible SAT-solver",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "E\u00e9n",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "S\u00f6rensson",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "International conference on theory and applications of satisfiability testing",
            "volume": "",
            "issn": "",
            "pages": "502--518",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-24605-3_37"
                ]
            }
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "The MiniSAT page (2021)",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "E\u00e9n",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "S\u00f6rensson",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Boolean algebra and satisfiability",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "PMs equations examples for the generation of the GHZ(6, 3) state. a) Two-colored PMs like the ones that generate the basis state |000011 can be canceled with each other by adjusting the weights of the edges.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "e 01 ad \u2227 e 01 bd \u2227 (e 01 ac \u2227 e 01 bd ) \u2227 e 00 ab \u2227 e 11 cd \u2227 (e 01 ad \u2227 e 01 bd ) \u2227 e 01 ac \u2227 e 01 bd \u2227 (e 00 ab \u2227 e 11 cd ) \u2227 e 01 ad \u2227 e 01 bd \u2227 e 01 ac \u2227 e 01 bd FIG. 2. Logic example for the GHZ state of n = 4 and d = 2. Assuming the edges can be bicolored, there are three possible PMs for each basis element. The Boolean variables are the edges of the graph e \u03b1\u03b2 ij where i, j correspond to the vertices and they are False if there is no edge and True otherwise.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Diagram of Klaus algorithm. It starts with the complete graph, i.e., all edges are True. It randomly picks one of the edges, sets it to False, and check if the set of clauses that encode the generation of the target state (see Eq.(",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Form (CNF). Conjunction of clauses formed by disjunction of literals.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "exploring UNSAT UP to simplify the tree DPLL with causal graphs (O(2 n ) with n literals) branches to find conflicts Opening the logic black box. SAT solvers are extremely sophisticated algorithms capable of dealing with thousands of variables and clauses. They are based on Boolean algebra which variables (called literals) can take two definite values, True-False or 0-1. SAT solvers find the values of these literals that satisfies a Boolean formula (normally written in CNF). If it does not exist a solution, we say the clauses are unsatisfiable (UNSAT)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "+ |11111111 ) . (26) Explicit data states from which there does not exist a graph",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Explicit data states from which there exist a graph",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}