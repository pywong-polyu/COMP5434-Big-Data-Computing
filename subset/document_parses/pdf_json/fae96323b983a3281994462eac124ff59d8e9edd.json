{
    "paper_id": "fae96323b983a3281994462eac124ff59d8e9edd",
    "metadata": {
        "title": "Recompression: Technique for Word Equations and Compressed Data",
        "authors": [
            {
                "first": "Artur",
                "middle": [],
                "last": "Je\u017c",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Wroc law",
                    "location": {
                        "addrLine": "Joliot-Curie 15, 50383 Wroc law",
                        "country": "Poland"
                    }
                },
                "email": "aje@cs.uni.wroc.pl"
            }
        ]
    },
    "abstract": [
        {
            "text": "In this talk I will present the recompression technique on the running example of word equations. In word equation problem we are given an equation u = v, where both u and v are words of letters and variables, and ask for a substitution of variables by words that equalizes the sides of the equation. The recompression technique is based on employing simple compression rules (replacement of two letters ab by a new letter c, replacement of maximal repetitions of a by a new letter), and modifying the equations (replacing a variable X by bX or Xa) so that those operations are sound and complete. The simple analysis focuses on the size of the instance and not on the combinatorial properties of words that are used. The recompression-based algorithm for word equations runs in nondeterministic linear space.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "The approach turned out to be quite robust and can be applied to various generalized, simplified and related problems, in particular, to problems in the area of grammar compressed words. I will comment on some of those applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Partial commutation. Another natural generalization is to allow partial commutation between the letters, i.e. for each pair of letters we specify, whether ab = ba or not. Such partially commutative words are usually called traces and the corresponding groups are usually known as Right-Angled Artin Groups, RAAGs for short. Decidability for trace equations was shown by Matiyasevich [57] and for RAAGs by Diekert and Muscholl [15]. In both cases, the main step in the proof was a reduction from a partially commutative case to a non-commutative one. Terms. We can view words as very simple terms: each letter is a function symbol of arity 1. In this way word equations are equations over (very simple) terms. It is known, that term unification can be decided in polynomial time, assuming that variables represent closed (full) terms [69]; thus such a problem is unlikely to generalise word equations. A natural generalisation of term unification and word equations is a secondorder unification, in which we allow variables to represent functions that take arguments (which need to be closed terms). However, it is known that this problem is undecidable, even in many restricted subcases [16, 26, 47, 49] . Context unification [7, 8, 74] is a natural problem 'in between': we allow variables representing functions, but we insist that they use their argument exactly once. It is easy to show that such defined problem generalises word equations, on the other hand, the undecidability proofs for second-order unification do not transfer directly to this model. Being a natural generalisation is not enough to explain the interest in this problem, more importantly, context unification has natural connections with other, well-studied problems (equality up to constraints [61], linear secondorder unification [47,50], one-step term rewriting [62], bounded second order unification [76], . . . ). Unfortunately, for over two decades the question of decidability of context unification remained open. Despite intensive research, not much is known about the decidability of this problem: only results for some restricted subcases are known: [8, 19, 47, 48, 51, 75, 77, 78] .",
            "cite_spans": [
                {
                    "start": 1187,
                    "end": 1191,
                    "text": "[16,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1192,
                    "end": 1195,
                    "text": "26,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 1196,
                    "end": 1199,
                    "text": "47,",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 1200,
                    "end": 1203,
                    "text": "49]",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 1230,
                    "end": 1232,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1233,
                    "end": 1236,
                    "text": "74]",
                    "ref_id": "BIBREF75"
                },
                {
                    "start": 2135,
                    "end": 2138,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 2139,
                    "end": 2142,
                    "text": "19,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 2143,
                    "end": 2146,
                    "text": "47,",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 2147,
                    "end": 2150,
                    "text": "48,",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 2151,
                    "end": 2154,
                    "text": "51,",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 2155,
                    "end": 2158,
                    "text": "75,",
                    "ref_id": "BIBREF76"
                },
                {
                    "start": 2159,
                    "end": 2162,
                    "text": "77,",
                    "ref_id": "BIBREF78"
                },
                {
                    "start": 2163,
                    "end": 2166,
                    "text": "78]",
                    "ref_id": "BIBREF79"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The word equation problem, i.e. solving equations in the algebra of words, was first investigated by Markov in the fifties. In this problem we get as an input an equation of the form u = v where u and v are strings of letters (from a fixed alphabet) as well as variables and a solution is a substitution of words for variables that turns this formal equation into a true equality of strings of letters (over the same fixed alphabet). It is relatively easy to show a reduction of this problem to the Hilbert's 10-th problem, i.e. the question of solving systems of Diophantine equations. Already then it was generally accepted that Hilbert's 10-th problem is undecidable and Markov wanted to show this by proving the undecidability of word equations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Word Equations"
        },
        {
            "text": "Alas, while Hilbert's 10-th problem is undecidable, the word equation problem is decidable, which was shown by Makanin [54] . The termination proof of his algorithm is very complex and yields a relatively weak bound on the computational complexity, thus over the years several improvements and simplifications over the original algorithm were proposed [27, 29, 43, 79] . Simplifications have many potential advantages: it seems natural that simpler algorithm can be generalised or extended more easily (for instance, to the case of equations in groups) than a complex one. Moreover, simpler algorithm should be more effective in practical applications and should have a lower complexity bounds.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 123,
                    "text": "[54]",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 352,
                    "end": 356,
                    "text": "[27,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 357,
                    "end": 360,
                    "text": "29,",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 361,
                    "end": 364,
                    "text": "43,",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 365,
                    "end": 368,
                    "text": "79]",
                    "ref_id": "BIBREF80"
                }
            ],
            "ref_spans": [],
            "section": "Word Equations"
        },
        {
            "text": "Subcases. It is easy to show NP-hardness for word equations, so far no better computational complexity lower bound is known. Such hardness stimulated a search for a restricted subclasses of the problem for which efficient (i.e. polynomial) algorithms can be given [4] . One of such subclasses is defined by restricting the amount of different variables that can be used in an equation: it is known that equations with one [11, 45] and two [4, 10, 28] variables can be solved in polynomial time. Already for three variables it is not known, whether they are in NP or not [71] and partial results require nontrivial analysis [71] .",
            "cite_spans": [
                {
                    "start": 264,
                    "end": 267,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 422,
                    "end": 426,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 427,
                    "end": 430,
                    "text": "45]",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 439,
                    "end": 442,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 443,
                    "end": 446,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 447,
                    "end": 450,
                    "text": "28]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 570,
                    "end": 574,
                    "text": "[71]",
                    "ref_id": "BIBREF72"
                },
                {
                    "start": 623,
                    "end": 627,
                    "text": "[71]",
                    "ref_id": "BIBREF72"
                }
            ],
            "ref_spans": [],
            "section": "Word Equations"
        },
        {
            "text": "Generalisations. Since Makanin's original solution much effort was put into extending his algorithm to other structures. Three directions seemed most natural:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Word Equations"
        },
        {
            "text": "-adding constraints to word equations; -equations in free groups; -partial commutation; -equations in terms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Word Equations"
        },
        {
            "text": "From the application point of view, it is advantageous to consider word equations that can also use some additional constraints, i.e. we require that the solution for X has some additional properties. This was first done for regular constraints [79] , on the other hand, for several types of constraints, for instance length-constraints, it is still open, whether the resulting problem is decidable or not (it becomes undecidable, if we allow counting occurrences of particular letter in the substitutions and arithmetic operations on such counts [3] ). Free groups. From the algebraic point of view, the word equation problem is solving equations in a free semigroup. It is natural to try to extend an algorithm from the free semigroup also to the case of free groups and then perhaps even to a larger class of groups (observe, that there are groups and semigroups for which the word problem is undecidable). The first algorithm for the group case was given by Makanin [55, 56] , his algorithm was not primitivelyrecursive [44] . Furthermore, Razborov showed that this algorithm can be used to give a description of all solutions of an equation [68] (more readable description of the Razborov's construction is available in [41] ). As a final comment, note that such a description was the first step in proving the Tarski's Conjecture for free groups (that the theory of free groups is decidable) [42] .",
            "cite_spans": [
                {
                    "start": 245,
                    "end": 249,
                    "text": "[79]",
                    "ref_id": "BIBREF80"
                },
                {
                    "start": 547,
                    "end": 550,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 970,
                    "end": 974,
                    "text": "[55,",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 975,
                    "end": 978,
                    "text": "56]",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 1024,
                    "end": 1028,
                    "text": "[44]",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 1146,
                    "end": 1150,
                    "text": "[68]",
                    "ref_id": "BIBREF69"
                },
                {
                    "start": 1225,
                    "end": 1229,
                    "text": "[41]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 1398,
                    "end": 1402,
                    "text": "[42]",
                    "ref_id": "BIBREF43"
                }
            ],
            "ref_spans": [],
            "section": "Constraints."
        },
        {
            "text": "For more than 20 years since Makanin's original solution there was very small progress in algorithms for word equations: the algorithm was improved in many places, in particular this lead to a better estimation of the running time; however, the main idea (and the general complexity of the proof) was essentially the same. The breakthrough was done by Plandowski and Rytter [67] , who, for the first time, used the compression to solve word equations. They showed, that the shortest solution (of size N ) of the word equation (of size n) has an SLP representation of size poly(n, log N ); here a Straight Line Programme (SLP for short) is simply a context free grammar generating exactly one word. Using the algorithm for testing the equality of two SLPs [63] this easily yields a (nondeterministic) algorithm running in time poly(n, log N ). Unfortunately, this work did not provide any bound on N and the only known bound (4 times exponential in n) came directly from Makanin's algorithm, together those two results yielded a 3NEXPTIME algorithm. Soon after the bound on the size of the shortest solution was improved to triply exponential [27] , which immediately yielded an algorithm from class 2NEXPTIME, however, the same paper [27] improved Makanin's algorithm, so that it workd in EXPSPACE.",
            "cite_spans": [
                {
                    "start": 374,
                    "end": 378,
                    "text": "[67]",
                    "ref_id": "BIBREF68"
                },
                {
                    "start": 755,
                    "end": 759,
                    "text": "[63]",
                    "ref_id": "BIBREF64"
                },
                {
                    "start": 1142,
                    "end": 1146,
                    "text": "[27]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 1234,
                    "end": 1238,
                    "text": "[27]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Compression and Word Equations"
        },
        {
            "text": "Next, Plandowski gave a better (doubly exponential) bound on the size of the shortest solution [64] and thus obtained a NEXPTIME algorithm, in particular, at that time this was the best known algorithm for this problem. The proof was based on novel factorisations of words. By better exploiting the interplay between factorisations and compression, he improved the algorithm so that it worked in PSPACE [65] .",
            "cite_spans": [
                {
                    "start": 95,
                    "end": 99,
                    "text": "[64]",
                    "ref_id": "BIBREF65"
                },
                {
                    "start": 403,
                    "end": 407,
                    "text": "[65]",
                    "ref_id": "BIBREF66"
                }
            ],
            "ref_spans": [],
            "section": "Compression and Word Equations"
        },
        {
            "text": "It is worth mentioning, that the solution proposed by Plandowski is essentially different than the one given by Makanin. In particular, it allowed generalisations more easily: Diekert, Guti\u00e9rrez and Hagenah [13] showed, that Plandowski's algorithm can be extended to the case in which we allow regular constraints in the equation (i.e. we want that the word substituted for X is from a regular language, whose description by a finite automaton is part of the input) and inversion; such an extended algorithm still works in polynomial space. It is easy to show that solving equations in free groups reduces to the above-mentioned problem of word equations with regular constraints and inversion [13] (it is worth mentioning, that in general we do not know whether solving equations in free groups is easier or harder than solving the ones in a free semigroup).",
            "cite_spans": [
                {
                    "start": 207,
                    "end": 211,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 694,
                    "end": 698,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Compression and Word Equations"
        },
        {
            "text": "On the other hand, Plandowski showed, that his algorithm can be used to generate a finite representation of all solutions of a word equation [66] , which allows solving several decision problems concerning the set of all solutions (finiteness, boundedness, boundedness of the exponent of periodicity etc.). It is not known, whether this algorithm can be generalised so that it generates all solutions also in the case of regular constraints and inversion (or in a free group).",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 145,
                    "text": "[66]",
                    "ref_id": "BIBREF67"
                }
            ],
            "ref_spans": [],
            "section": "Compression and Word Equations"
        },
        {
            "text": "The new, simpler algorithm for word equations and demonstration of connections between compression and word equations gave a new hope for solving the context unification problem. The first results were very promising: by using 'tree' equivalents of SLPs [2] computational complexity of some problems related to context unification was established [9, 19, 48] . Unfortunately, this approach failed to fully generalise Plandowski's algorithm for words: the equivalent of factorisations that were used in the algorithm were not found for trees.",
            "cite_spans": [
                {
                    "start": 254,
                    "end": 257,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 347,
                    "end": 350,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 351,
                    "end": 354,
                    "text": "19,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 355,
                    "end": 358,
                    "text": "48]",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "Compression and Word Equations"
        },
        {
            "text": "It is worth mentioning, that Rytter and Plandowski's approach, in which we compress a solution using SLPs (or in the non-deterministic case-we guess the compressed representation of the solution) and then perform the computation directly on the SLP-compressed representations using known algorithm that work in polynomial time, turned out to be extremely fruitful in many branches of computer science. The recent survey by Lohrey gives several such successful applications [53] .",
            "cite_spans": [
                {
                    "start": 473,
                    "end": 477,
                    "text": "[53]",
                    "ref_id": "BIBREF54"
                }
            ],
            "ref_spans": [],
            "section": "Compression and Word Equations"
        },
        {
            "text": "Recompression was developed for a specific problem concerning compressed data (fully compressed membership problem for finite automata [30] ) and was later successfully applied to word equations [36] and other problems related to compressed representations. The usual approach for word equations (and compressed data in general) is that one tries to extract information about the combinatorics of the underlying words from the equation (compressed representation) and use this structure to solve the problem at hand. This is somehow natural: if the word can be represented compactly (be it as a solution of a word equation or using some compression mechanism) then it should have a lot of internal structure.",
            "cite_spans": [
                {
                    "start": 135,
                    "end": 139,
                    "text": "[30]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 195,
                    "end": 199,
                    "text": "[36]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [],
            "section": "Recompression"
        },
        {
            "text": "Recompression takes a different approach: our aim is to perform simple compression operations on the solution word of the word equation directly on the compressed representation. We need to modify the equation a bit in order to do that, however, the choice of the compression operation and the analysis focuses on the compressed representation and its properties and (almost) completely ignores the properties of the solution. The idea of performing the compression operation is somehow natural in view of the already mentioned Plandowski and Rytter result [67] , that the (length-minimal) solution has a small SLP: since such an SLP exists, we can try to build it bottom-up, i.e. the SLP has a rule a \u2192 bc and so we will replace each bc in the solution by a. (There are some complications in case of b = c, as then the compression is ambiguous: we solve this by replacing the maximal repetitions of b letter instead of replacing bb).",
            "cite_spans": [
                {
                    "start": 557,
                    "end": 561,
                    "text": "[67]",
                    "ref_id": "BIBREF68"
                }
            ],
            "ref_spans": [],
            "section": "Recompression"
        },
        {
            "text": "Of course, performing such a compression on the equation might be difficult or even impossible at all and we sometimes need to modify the equation. However, it turns out that a greedy choice suffices to guarantee that the kept equation is of quadratic size. The correctness and size analysis turns out to be surprisingly easy. The method is also very robust, so that it can be applied to various scenarios related to word equations: one variable word equations [35] , equations in free groups [14] , twisted word equations [12] , context unification [31] , . . . See the following Sections for details of some of those results.",
            "cite_spans": [
                {
                    "start": 461,
                    "end": 465,
                    "text": "[35]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 493,
                    "end": 497,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 523,
                    "end": 527,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 550,
                    "end": 554,
                    "text": "[31]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [],
            "section": "Recompression"
        },
        {
            "text": "Due to ever-increasing amount of data, compression is widely applied in order to decrease the data's size. Still, the stored data is accessed and processed. Decompressing it on each such an occasion basically wastes the gain of reduced storage size. Thus there is a demand for algorithms dealing directly with the compressed data, without explicit decompression. Indeed, efficient algorithms for fundamental text operations (pattern matching, equality testing, etc.) are known for various practically used compression methods (LZ77, LZW, their variants, etc.) [20] [21] [22] [23] [24] [25] 63] .",
            "cite_spans": [
                {
                    "start": 560,
                    "end": 564,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 565,
                    "end": 569,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 570,
                    "end": 574,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 575,
                    "end": 579,
                    "text": "[23]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 580,
                    "end": 584,
                    "text": "[24]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 585,
                    "end": 589,
                    "text": "[25]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 590,
                    "end": 593,
                    "text": "63]",
                    "ref_id": "BIBREF64"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "Note that above the compression can be seen as a source of problem that we want to overcome. However, as demonstrated by Plandowski and Rytter [67] , the compression can also be seen as a solution to some problems, i.e. if we can show that the instance or its solutions is (highly) compressible, then we can compress it and, using the algorithms mentioned above, perform the computation on the compressed representation. See a recent survey of Lohrey [53] , which gives examples of application of this approach in various fields, ranging from group theory, computational topology to program verification.",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 147,
                    "text": "[67]",
                    "ref_id": "BIBREF68"
                },
                {
                    "start": 451,
                    "end": 455,
                    "text": "[53]",
                    "ref_id": "BIBREF54"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "Compression standards differ in the main idea as well as in details. Thus when devising algorithms for compressed data, quite early one needs to focus on the exact compression method, to which the algorithm is applied. The most practical (and challenging) choice is one of the widely used standards, like LZW or LZ77. However, a different approach is also pursued: for some applications (and most of theory-oriented considerations) it would be useful to model one of the practical compression standard by a more mathematically well-founded and 'clean' method. The already mentioned Straight-Line Programs (SLPs), are such a clean formulation for many block compression methods: each LZ77 compressed text can be converted into an equivalent SLP of size O(n log(N/n)) and in O(n log(N/n)) time [5, 70] (where N is the size of the decompressed text), while each SLP can be converted to an equivalent LZ77-like of O(n) size in polynomial time. Other reasons of popularity of SLPs is that usually they compress well the input text [46, 60] Lastly, a greedy grammar compression can be efficiently implemented and thus can be used as a preprocessing to other compression methods, like those based on Burrows-Wheeler transform [39] .",
            "cite_spans": [
                {
                    "start": 792,
                    "end": 795,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 796,
                    "end": 799,
                    "text": "70]",
                    "ref_id": "BIBREF71"
                },
                {
                    "start": 1026,
                    "end": 1030,
                    "text": "[46,",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 1031,
                    "end": 1034,
                    "text": "60]",
                    "ref_id": "BIBREF61"
                },
                {
                    "start": 1219,
                    "end": 1223,
                    "text": "[39]",
                    "ref_id": "BIBREF40"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "One can treat an SLP as a system of (very simple) word equations, i.e. a production X \u2192 \u03b1 is rewritten as X = \u03b1, and so the recompression algorithm generalizes also to such setting. It can be then seen as a variant of locally consistent parsing [1, 58, 72] , and indeed those techniques were one of the sources of the recompression approach.",
            "cite_spans": [
                {
                    "start": 245,
                    "end": 248,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 249,
                    "end": 252,
                    "text": "58,",
                    "ref_id": "BIBREF59"
                },
                {
                    "start": 253,
                    "end": 256,
                    "text": "72]",
                    "ref_id": "BIBREF73"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "It is no surprise that the highly non-deterministic recompression algorithm determinises when applied to SLPs, what is surprising is that it can be made efficient. In particular, it can be used to checking the equality of two SLPs in roughly quadratic time, which is the fastest known algorithm for this problem [33] (and also for the generalisation of this problem, the fully compressed pattern matching).",
            "cite_spans": [
                {
                    "start": 312,
                    "end": 316,
                    "text": "[33]",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "The main drawback of grammar compression is that the size of the smallest grammar cannot be even approximated within (small enough) constant factor [5, 80] . There are many algorithms that achieve a logarithmic approximation ratio [5, 70, 73] , recompression can also be used to obtain one (in fact: two different). One of those algorithms [32] seems to have a slightly better practical behaviour than the other ones, the second has much simpler analysis than other approximation algorithms [34] (as it is essentially a greedy left-to-right scan).",
            "cite_spans": [
                {
                    "start": 148,
                    "end": 151,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 152,
                    "end": 155,
                    "text": "80]",
                    "ref_id": "BIBREF82"
                },
                {
                    "start": 231,
                    "end": 234,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 235,
                    "end": 238,
                    "text": "70,",
                    "ref_id": "BIBREF71"
                },
                {
                    "start": 239,
                    "end": 242,
                    "text": "73]",
                    "ref_id": "BIBREF74"
                },
                {
                    "start": 340,
                    "end": 344,
                    "text": "[32]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 491,
                    "end": 495,
                    "text": "[34]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "Just as recompression generalizes from word equations to context unification (i.e. term equations), the approximation algorithm based on recompression for strings can be generalized to trees [38] , in which case it produces a so-called tree SLP [2] . This was the first approximation algorithm for this problem.",
            "cite_spans": [
                {
                    "start": 191,
                    "end": 195,
                    "text": "[38]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 245,
                    "end": 248,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Algorithms for Grammar-Based Compression"
        },
        {
            "text": "As this is an informal survey presentations, most of the proofs are only sketched or omitted. Due to space constraints, only some applications and results are explained in detail.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Survey's Limitations"
        },
        {
            "text": "We begin with a formal definition of the word equations problem: Consider a finite alphabet \u03a3 and set of variables X ; during the algorithm \u03a3 will be extended by new letters, but it will always remain finite. Word equation is of a form 'u = v', where u, v \u2208 (\u03a3 \u222a X ) * and its solution is a homomorphism S : \u03a3 \u222a X \u2192 \u03a3 * , which is constant on \u03a3, that is S(a) = a, and satisfies the equation, i.e. words S(u) and S(v) are equal. By n we denote the size of the equation, i.e. |u| + |v|. The algorithm requires only small improvements so that it applies also to systems of equations, to streamline the presentation we will not consider this case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Fix any solution S of the equation u = v, without loss of generality we can assume that this is the shortest solution, i.e. the one minimising |S(u)|; let N denote the length of the solution, that is |S(u)|. By the earlier work of Plandowski and Rytter [67] , we know that S(u) (and also S(X) for each variable X) has an SLP (of size poly(n, log N )), in fact the same conclusion can be to drawn from the later works of Plandowski [64] [65] [66] . Regardless of the form of S and SLP, we know, that at least one of the productions in this SLP is of the form c \u2192 ab, where c is a nonterminal of the SLP while a, b \u2208 \u03a3 are letters. Let us 'reverse' this production, i.e. replace in S(u) all pairs of letters ab by c. It is relatively easy to formalise this operation for words, it is not so clear, what should be done in case of equations, so let us inspect the easier fragment first. Consider an explicitly given word w. Performing the 'ab-pair compression' on it is easy (we replace each pair ab by c), as long as a = b: replacing pairs aa is ambiguous, as such pairs can 'overlap'. Instead, we replace maximal blocks of a letter a: block a is maximal, when there is no letter a to left nor to the right of it (in particular, there could be no letter at all).",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 257,
                    "text": "[67]",
                    "ref_id": "BIBREF68"
                },
                {
                    "start": 431,
                    "end": 435,
                    "text": "[64]",
                    "ref_id": "BIBREF65"
                },
                {
                    "start": 436,
                    "end": 440,
                    "text": "[65]",
                    "ref_id": "BIBREF66"
                },
                {
                    "start": 441,
                    "end": 445,
                    "text": "[66]",
                    "ref_id": "BIBREF67"
                }
            ],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Formally, the operations are defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "ab pair compression For a given word w replace all occurrences of ab in w by a fresh letter c. -a block compression For a given word w replace all occurrences of maximal blocks a for > 1 in w by fresh letters a .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "We always assume, that in the ab-pair compression the letters a and b are different.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Observe, that those operations are indeed 'inverses' of SLP productions: replacing ab with c corresponds to a production c \u2192 ab, similarly replacing a with a corresponds to a production a \u2192 a .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "let a \u2208 \u03a3 be an unused letter 3:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "replace all maximal blocks a in w by a",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Iterating the pair and blocks compression results in a compression of word w, assuming that we treat the introduced symbols as normal letters. There are several possible ways to implement such iteration, different results are obtained by altering the order of the compressions, exact treatment of new letters and so on. Still, essentially each 'reasonable' variant works.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Observe, that if we compress two words, say w 1 and w 2 , in parallel then the resulting words w 1 and w 2 are equal if and only if w 1 and w 2 are. This justifies the usage of compression operations to both sides of the word equation in parallel, it remains to show, how to do that.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Let us fix a solution S, a pair ab (where a = b); consider how does a particular occurrence of ab got into S(u). Pair ba is crossing (as the first letter of S(Y ) is a and first Y is preceded by a letter b, moreover, the last letter of S(Y ) is b and the second Y is succeeded by a letter a), pair ab is non-crossing. Letter b is non-crossing, letter a is crossing (as X is preceded by a letter a on the left-hand side of the equation and on the right-hand side of the equation X is succeeded by a letter a). Unfortunately Lemma 1 is not enough to simulate Compression(w) directly on the equation: In general there is no guarantee that the pair ab (letter a) is non-crossing, moreover, we do not know which pairs have only implicit occurrences. It turns out, that the second problem is trivial: if we restrict ourselves to the shortest solutions then every pair that has an implicit occurrence has also a crossing or explicit one, a similar statement holds also for blocks of letters. The proof is simple: suppose that a pair has only implicit occurrences. Then we could remove them and the obtained solution is shorter, contradicting the assumption. The argument for blocks is a bit more involved, as they can overlap. Getting back to the crossing pairs (and blocks), if we fix a pair ab (letter a), then it is easy to 'uncross' it: by Definition 1 we can conclude that the pair ab is crossing if and only if for some variables X and Y (not necessarily different) one of the following conditions holds (we assume that the solution does not assign an empty word to any variable-otherwise we could simply remove such a variable from the equation): In each of these cases the 'uncrossing' is natural: in (1) we 'pop' from X a letter b to the left, in (2) we pop a to the right from Y , in (3) we perform both operations. It turns out that in fact we can be even more systematic: we do not have to look at the occurrences of variables, it is enough to consider the first and last letter of S(X) for each variable X:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "-If S(X) begins with b then we replace X with bX (changing implicitly the solution S(X) = bw to S (X) = w), if in the new solution S(X) = , i.e. it is empty, then we remove X from the equation; -if S(X) ends with a then we apply a symmetric procedure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "Such an algorithm is called Pop. if the first letter of S(X) is b then Guess 3:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "replace every X w 'u = v' by bX Implicitly change solution S(X) = bw to S(X) = w 4:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "if S(X) = then Guess 5:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "remove X from u and v 6:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": ". . .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Recompression for Word Equations"
        },
        {
            "text": "It is easy to see, that for appropriate non-deterministic choices the obtained equation has a solution for which ab is non-crossing: for instance, if aX occurs in the equation and S(X) begins with b then we make the corresponding nondeterministic choices, popping b to the left and obtaining abX; a simple proof requires a precise statement of the claim as well as some case analysis.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Perform a symmetric operation for the last letter and a"
        },
        {
            "text": "Thus, we know how to proceed with a crossing ab-pair compression: we first turn ab into a non-crossing pair (Pop) and then compress it as a non-crossing pair (PairComp).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 3. If the equation 'u = v' has a solution S then for an appropriate run of Pop(a, b, 'u = v') (for appropriate non-deterministic choices) the obtained equation u = v has a corresponding solution S , i.e. S(u) = S (u ), for which ab is a non-crossing pair. If the obtained equation has a solution then also the original equation had one."
        },
        {
            "text": "We would like to perform similar operations for block compression. For noncrossing blocks we can naturally define a similar algorithm BlockComp(a,'u = v'). It remains to show how to 'uncross' a letter a. Unfortunately, if aX occurs in the equation and S(X) begins with a then replacing X with aX is not enough, as S(X) may still begin with a. In such a case we iterate the procedure until the first letter of X is not a (this includes the case in which we remove the whole variable X). Observe, that instead of doing this letter by letter, we can uncross a in one step: it is enough to remove from variable X its whole a-prefix and a-suffix of S(X) (if w = a w a r , where w does not begin nor end with a, a-prefix w is a and a-suffix is a r ; if w = a then a-suffix and w are empty). Such an algorithm is called CutPrefSuff. Similarly as in Pop, we can show that after an appropriate run of CutPrefSuff the obtained equation has a (corresponding) solution for which a is non-crossing. Unfortunately, there is another problem: we need to write down the lengths and r of a-prefixes and suffixes. We can write them as binary numbers, in which case they use O(log + log r) bits of memory. However in general those still can be arbitrarily large numbers. Fortunately, we can show that in some solution those values are at most exponential (and so their description is polynomial-size). This easily follows from the exponential bound on exponent of periodicity [43] . For the moment it is enough that we know that:",
            "cite_spans": [
                {
                    "start": 1456,
                    "end": 1460,
                    "text": "[43]",
                    "ref_id": "BIBREF44"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 3. If the equation 'u = v' has a solution S then for an appropriate run of Pop(a, b, 'u = v') (for appropriate non-deterministic choices) the obtained equation u = v has a corresponding solution S , i.e. S(u) = S (u ), for which ab is a non-crossing pair. If the obtained equation has a solution then also the original equation had one."
        },
        {
            "text": "Thus in Pop we can restrict ourselves to a-prefixes and suffixes of at most exponential length.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4 ([43]). In the shortest solution of the equation 'u = v' each a-prefix and a-suffix has at most exponential length (in terms of |u| + |v|)."
        },
        {
            "text": "After Pop we can compress a-blocks using BlockComp(a,'u = v'), observe that afterwards long a-blocks are replaced with single letters.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5. Let S be a shortest solution of 'u = v'. For some non-deterministic choices, i.e. after some run of CutPrefSuff(a, 'u = v'), the obtained equation 'u = v ' has a corresponding solution S , such that S (u ) = S(u), and a is a noncrossing letter for S , moreover, the explicit a blocks in 'u = v ' have at most exponential length. If the obtained equation has a solution then also the original equation had one."
        },
        {
            "text": "We are now ready to simulate Compression directly on the equation. The question is, in which order we should compress pairs and blocks? We make the choice nondeterministically: if there are any non-crossing pairs or letters, we compress them. This is natural, as such compression decreases both the size of the equation and the size of the length-minimal solution of the equation. If all pairs and letters are crossing, we choose greedily, i.e. the one that leads to the smallest equation (in one step). It is easy to show that such a strategy keeps the equation quadratic, more involved strategy, in which we compress many pairs/blocks in parallel, leads to a linear-length equation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5. Let S be a shortest solution of 'u = v'. For some non-deterministic choices, i.e. after some run of CutPrefSuff(a, 'u = v'), the obtained equation 'u = v ' has a corresponding solution S , such that S (u ) = S(u), and a is a noncrossing letter for S , moreover, the explicit a blocks in 'u = v ' have at most exponential length. If the obtained equation has a solution then also the original equation had one."
        },
        {
            "text": "WordEqSAT Deciding the satisfiability of word equations 1: while |u| > 1 or |u| > 1 do 2:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 7."
        },
        {
            "text": "L \u2190 list of letters in u, v 3:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 7."
        },
        {
            "text": "Choose a pair ab \u2208 P 2 or a letter a \u2208 P Guess 4:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 7."
        },
        {
            "text": "if it is crossing then Guess 5: uncross it 6: compress it 7: Solve the problem naively Call one iteration of the main loop a phase. The correctness of the algorithm follows from the earlier discussion on the correctness of BlockComp, CutPrefSuff, PairComp and Pop. In particular, the length of the length-minimal solution drops by at least 1 in each iteration, thus the algorithm terminates.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 7."
        },
        {
            "text": "Let us bound the space needed by the algorithm: we claim that for appropriate nondeterministic choices the stored equation has at most 8n 2 letters (and n variables). To see this, observe first that each Pop introduces at most 2n letters, one at each side of the variable. The same applies to CutPrefSuff (formally, CutPrefSuff introduces long blocks but they are immediately replaced with single letters, and so we can think that in fact we introduce only 2n letters). By (1) With some effort we can make the above if analysis much tighter, see Sect. 4.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 6. Algorithm WordEqSAT has O(N ) phases, where N is the length of the shortest solution of the input equation."
        },
        {
            "text": "Moreover, with some extra effort one can remove also the logarithmic dependency, and show that satisfiability of word equations is in non-deterministic linear space, i.e. the problem is context sensitive. Surprisingly, it is enough to employ Huffman coding for the equation and run a variant of the algorithm. However, the analysis requires a deeper understanding of how fragments of the equation are changed during the algorithm and how they depend one on another.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 ([36]). The recompression based algorithm (nondeterministically) decides word equations problem in O(n log n) bit-space; moreover, the stored equation has linear length."
        },
        {
            "text": "where m is the bit-size encoding of the input using any prefix-free code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2 ([37]). A variant of recompression based algorithm which encodes the equation using Huffman coding (nondeterministically) decides word equations problem in O(m) bit-space;"
        },
        {
            "text": "Note that we allow some bit-optimization in the size of the input problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2 ([37]). A variant of recompression based algorithm which encodes the equation using Huffman coding (nondeterministically) decides word equations problem in O(m) bit-space;"
        },
        {
            "text": "As a reminder: a PSPACE algorithm for this problem was already known [65] . Its memory consumption is not stated explicitly in that work, however, it is much larger than O(n log n): the stored equations are of length O(n 3 ) and during the transformations the algorithm uses essentially more memory.",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 73,
                    "text": "[65]",
                    "ref_id": "BIBREF66"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 2 ([37]). A variant of recompression based algorithm which encodes the equation using Huffman coding (nondeterministically) decides word equations problem in O(m) bit-space;"
        },
        {
            "text": "In order to improve the space consumption from quadratic to O(n log n) we want to perform several compressions in parallel. To make it more precise, observe that -All block compressions (also for different letters) can be performed in parallel, as such blocks do not overlap. Moreover, uncrossing different letters can also be done in parallel: if a is the first letter of S(X) and b the last, then we pop from X the a-prefix and b-suffix. -If \u03a3 and \u03a3 r are disjoint, then the pair compressions for ab with a \u2208 \u03a3 and b \u2208 \u03a3 r can be done in parallel. Similarly as in the previous case, uncrossing can be done in parallel, by popping first letter if it is from \u03a3 r and last if it is from \u03a3 . -We do not compress all pairs, only those from O(1) partitions \u03a3 , \u03a3 r that cover 'many' occurrences of pairs in the equation and in the solution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "O(n log n) Space"
        },
        {
            "text": "The crucial things is the choice of partitions. It turns out that choosing a random partition reduces the length of the solution by a constant fraction: consider two consecutive letters ab in S(X). If a = b then they will be compressed as part of the maximal block. If a = b then there is 1/4 chance that ab \u2208 \u03a3 \u03a3 r . Thus, in expectation, the length of the word shortens by one fourth of its length.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "O(n log n) Space"
        },
        {
            "text": "A similar argument also shows that the number of letters in the equation remains linear, when a random partition is chosen. Thus, the equation will be of linear size (though each letter may need O(log n) bits for the encoding).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "O(n log n) Space"
        },
        {
            "text": "As already mentioned, it is natural and important to extend the word equations by regular constraints and inversion, in particular this leads to an algorithm for equations in free groups [13] (the reduction between those two problems is fully syntactical and does not depend on the particular algorithm for solving word equations). Note that it is not known, whether the algorithm generating a representation of all solutions can be also extended by regular constraints and inversion. Thus the only previously known algorithm for representation of all solutions of an equation in a free group was due to Razborov [68] , and it was based on Makanin's algorithm for word equations in free groups. Adding the regular constraints to the recompression based algorithm Word-EqSAT is fairly standard: We can encode all constraints using one nondeterministic finite automaton (the constraints for particular variables differ only in the set of accepting states). For each letter c we store its transition function, i.e. a function f c : Q \u2192 2 Q , which says that the automaton in state q after reading a letter c reaches a state in f c (q). This function naturally extends to words: it still defines which states can be reached from q after reading w.",
            "cite_spans": [
                {
                    "start": 187,
                    "end": 191,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 613,
                    "end": 617,
                    "text": "[68]",
                    "ref_id": "BIBREF69"
                }
            ],
            "ref_spans": [],
            "section": "Equations with Regular Constraints and Inversion; Equations in Free Groups"
        },
        {
            "text": "i p \u2208 f a (q )} for a letter a. If we introduce a new letter c (which replaces a word w) then we naturally define the transition function f c \u2190 f w . We can express the regular constraints in terms of this function: saying that S(X) is accepted by an automaton means that f S(X) (q 0 ) is one of the accepting states. So it is enough to guess the value of f S(X) which satisfies this condition; in this way we can talk about the value f X for a variable X. Popping letters from a variable means that we need to adjust the transition function, i.e. when we replace X by aX then f X = f a \u2022 f X , we similarly define f X when we pop letters to the right.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Equations with Regular Constraints and Inversion; Equations in Free Groups"
        },
        {
            "text": "More problems are caused by the inversion: intuitively it corresponds to taking the inverse element in the group and on the semigroup level we this is simulated by requiring that a = a for each letter a and a 1 a 2 . . . a m = a m . . . a 2 a 1 . This has an impact on the compression: when we compress a pair ab to c, then we should also replace ab = ba by a letter c. At the first sight this looks easy, but becomes problematic, when those two pairs are not disjoint, i.e. when a = a (or b = b); in general we cannot exclude such a case and if it happens, in a sequence bab during the pair compression for ba we want to simultaneously replace ba and ab, which is not possible. Instead, we replace maximal fragments that can be fully covered with pairs ab or ba, in this case this: the whole triple bab. In the worst case (when a = a and b = b) we need to replace whole sequences of the form (ab) n , which is a common generalisation of both pairs and blocks compression.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 179,
                    "end": 244,
                    "text": "a = a for each letter a and a 1 a 2 . . . a m = a m . . . a 2 a 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Equations with Regular Constraints and Inversion; Equations in Free Groups"
        },
        {
            "text": "Recall that the context unification is a generalisation of word equations to the case of terms (Fig. 2) . What type of equations we would like to consider? Clearly we consider terms over a fixed signature (which is usually part of the input), and allow occurrences of constants and variables. If we allow only that the variables represent full terms, then the satisfiability of such equations is decidable in polynomial time [69] and so probably does not generalise the word equations (which are NP-hard). This is also easy to observe when we look closer at a word equation: the words represented by the variables can be concatenated at both ends, i.e. they represent terms with a missing argument.",
            "cite_spans": [
                {
                    "start": 425,
                    "end": 429,
                    "text": "[69]",
                    "ref_id": "BIBREF70"
                }
            ],
            "ref_spans": [
                {
                    "start": 95,
                    "end": 103,
                    "text": "(Fig. 2)",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Context Unification"
        },
        {
            "text": "We arrive at a conclusion that our generalisation should use variables with arguments, i.e. the (second-order) variables take an argument that is a full term and can use it, perhaps several times. Such a definition leads to a second-order unification, which is known to be undecidable even in very restricted subcases [16, 26, 47, 49] .",
            "cite_spans": [
                {
                    "start": 318,
                    "end": 322,
                    "text": "[16,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 323,
                    "end": 326,
                    "text": "26,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 327,
                    "end": 330,
                    "text": "47,",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 331,
                    "end": 334,
                    "text": "49]",
                    "ref_id": "BIBREF50"
                }
            ],
            "ref_spans": [],
            "section": "Context Unification"
        },
        {
            "text": "Thus we would like to have a subclass of second order unification that still generalises word equations. In order to do that we put additional restriction on the solutions: each argument can be used by the term exactly once. Observe that this still generalises the word equations: using the argument exactly once naturally corresponds to concatenation (Fig. 1) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 352,
                    "end": 360,
                    "text": "(Fig. 1)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Context Unification"
        },
        {
            "text": "Formally, in the context unification problem [7, 8, 74] , we consider an equation u = v in which we use term variables (representing closed terms), which we denote by letters x, y, as well as context variables (representing terms with one 'hole' for the argument, they are usually called contexts), which we denote by letters X, Y . Syntactically, u and v are terms that use letters from signature \u03a3 X = Pair and block compression easily generalise to sequences of letters of arity 1 (we can think of them as words), unfortunately, there is no guarantee that a term has even one such letter. Intuitively, we rather expect that it has mostly leaves and symbols of larger arity. This leads us to another local compression operation: leaf compression. Consider a node labelled with f and its i-th child that is a leaf. We want to compress f with this child, leaving other children (and their subtrees) unchanged. Formally, given f of arity at least 1, position 1 \u2264 i \u2264 ar(f ) and a letter c of arity 0 the LeafComp(f, i, c, t) operation (leaf compression) replaces in term t nodes labelled with f and subterms t 1 , . . . , t i\u22121 , c, t i+1 , . . . , t ar(f ) (where c and position i are fixed, while other terms t 1 , . . . , t i\u22121 , t i+1 , . . . , t ar(f ) -varying) by a term labelled with f and subterms t 1 , . . . , t i\u22121 , t i+1 , . . . , t ar(f ) that are obtained by applying recursively LeafComp to terms t 1 , . . . , t i\u22121 , t i+1 , . . . , t ar(f ) ; in other words, we first change the label from f to f and then remove the i-th child, which has a label c and we apply such a compression to all occurrences of f and c in parallel.",
            "cite_spans": [
                {
                    "start": 45,
                    "end": 48,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 49,
                    "end": 51,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 52,
                    "end": 55,
                    "text": "74]",
                    "ref_id": "BIBREF75"
                }
            ],
            "ref_spans": [
                {
                    "start": 1092,
                    "end": 1141,
                    "text": "f and subterms t 1 , . . . , t i\u22121 , c, t i+1 , .",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Context Unification"
        },
        {
            "text": "The notion of crossing pair generalizes to this case in a natural way and the uncrossing replaces a term variable with a constant or replaces X(t) with X(f (x 1 , . . . , x i , t, x i+1 , . . . , x )). Note that this introduces new variables. Now the whole algorithm looks similar as in the case of word equations, we simply use additional compression operation. However, the analysis is much more involved, as the new uncrossing introduces fresh term variables. However, their number at any point can be linearly bounded and the polynomial upper-bound follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Context Unification"
        },
        {
            "text": "The recompression technique is (partially) inspired by methods coming from the algorithm's design [1, 58] . In this section we show that it is able to contribute back to algorithmics: some algorithmic questions for compressed data can be solved using a recompression technique. The obtained solutions are as good and sometimes better than the known ones, which is surprising taking into the account the robustness of the method.",
            "cite_spans": [
                {
                    "start": 98,
                    "end": 101,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 102,
                    "end": 105,
                    "text": "58]",
                    "ref_id": "BIBREF59"
                }
            ],
            "ref_spans": [],
            "section": "Recompression and Compressed Data"
        },
        {
            "text": "Recall that the Straight Line Programme (SLP ) was defined as a context-free grammar whose each nonterminal generates exactly one word. We employ the following naming conventions for SLPs: its nonterminals are ordered (without loss of generality: X 1 , X 2 , . . . , X m ), each nonterminal has exactly one production and if X j occurs in the production for X i then j < i; we will use symbols A, B, etc. to denote an SLP. The unique word generated by a nonterminal X i is denoted by val(X i ), while the whole SLP A defines a word val(A) = val(X m ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "We can treat SLP as a system of word equations (in variables X 1 , . . . , X m ): production X i \u2192 \u03b1 i corresponds to an equation X i = \u03b1 i ; observe that such an equality is meaningful as val(X) = val(\u03b1) (where val is naturally extended to strings of letters and nonterminals), moreover, this is the unique solution of this equation. Thus the recompression technique can be applied to SLPs as well (so far we used recompression only to one equation but it easily generalises also to a system of equations).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "However, there are two issues that need to be solved: non-determinism and efficiency: the recompression for word equations is highly non-deterministic while algorithms for SLPs should, if possible, be deterministic and we usually want them to be efficient, i.e. we want as small polynomial degree as possible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "Let us inspect the source of non-determinism of recompression-based approach, it is needed to:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "1. establish, whether val(X i ) = ; 2. establish the first (and last) letter of val(X i ); 3. establish the length of a-prefix and suffix of val(X i ); 4. the choice of the partition to compress.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "The first three question ask about some basic properties of the solution and can be easily answered in case of SLPs: assuming that we already know the answers for X j for j < i: let X i \u2192 \u03b1 i , then we first remove from \u03b1 i all nonterminals X j , for which val(X j ) = , and then 1. val(X i ) = if and only if \u03b1 i = ; 2. the first letter of val(X i ) is the first letter of \u03b1 i or the first letter of val(X j ), if the first symbol of \u03b1 i is X j ; 3. the length of the a-prefix depends only on the letters a in \u03b1 i and the lengths of a-prefixes in nonterminals in \u03b1 i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "All those conditions can be verified in linear time. The last question is of different nature. However, the argument used to show that a good choice of a partition exists actually shown that in expectation the choice is a good one and this approach can be easily derandomised using conditional expectation approach.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "In particular, this subprocedure can be implemented in linear time. Concerning the running time, the generalisations of Pop, PairComp, CutPref-Suff and BlockComp can be implemented in linear time, thus the recompression for SLPs runs in polynomial (in SLP's size) time, so polynomial in total. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Straight Line Programs and Recompression"
        },
        {
            "text": "One of the first (and most important) problems considered for SLPs is the equality testing, i.e. for two SLPs we want to decide if they define the same word. The first polynomial algorithm for this problem was given in 1994 by Plandowski [63] , to be more precise, his algorithm run in O(n 4 ) time. Afterwards research was mostly focused on the more general problem of fully compressed pattern matching: for given SLPs A and B we want to decide, whether val(A) occurs in val(B) (as a subword). The first solution to this problem was given by Karpi\u0144ski et al. [40] in 1995. Gasieniec et al. [21] gave a faster randomised algorithm. In 1997 Miyazaki et al. [59] constructed an O(n 4 ) algorithm. Finally, Lifshits gave an O(n 3 ) algorithm for this problem [52] . All of the mentioned papers were based on the same original idea as Plandowski's algorithm.",
            "cite_spans": [
                {
                    "start": 238,
                    "end": 242,
                    "text": "[63]",
                    "ref_id": "BIBREF64"
                },
                {
                    "start": 560,
                    "end": 564,
                    "text": "[40]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 591,
                    "end": 595,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 656,
                    "end": 660,
                    "text": "[59]",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 756,
                    "end": 760,
                    "text": "[52]",
                    "ref_id": "BIBREF53"
                }
            ],
            "ref_spans": [],
            "section": "SLP Equality and Fully Compressed Pattern Matching"
        },
        {
            "text": "Recompression can be naturally applied to equality testing of SLPs: given two SLPs A and B we add an equation X mA = Y mA and ask about the satisfiability of the whole system. As already observed, the recompression based algorithm will work in polynomial time. It turns out that the proper implementation (using many nontrivial algorithmic techniques) In order to use the recompression technique for the fully compressed pattern matching problem, we need some essential modifications: consider ba-pair compression on a pattern ab and text bab. We obtain the same pattern ab and text cb, loosing the only occurrence of the pattern in the text. This happens because the compression (on the text) is done partially on the pattern occurrence and partially outside it. To remedy this, we perform the compression operations in a particular order, which takes into the account what are the first and last letters of pattern and text. (In the considered example, we make the ab-pair compression first and this preserves the occurrences of the pattern.) Similar approach works also for block compression. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SLP Equality and Fully Compressed Pattern Matching"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Pattern matching in dynamic texts",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Alstrup",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "S"
                    ],
                    "last": "Brodal",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Rauhe",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "SODA",
            "volume": "",
            "issn": "",
            "pages": "819--828",
            "other_ids": {
                "DOI": [
                    "10.1145/338219.338645"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Efficient memory representation of XML document trees",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Busatto",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lohrey",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Maneth",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Inf. Syst",
            "volume": "33",
            "issn": "4-5",
            "pages": "456--474",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Definability in the existential theory of concatenation and undecidable extensions of this theory",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "R"
                    ],
                    "last": "B\u00fcchi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Senger",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Math. Log. Q",
            "volume": "34",
            "issn": "4",
            "pages": "337--342",
            "other_ids": {
                "DOI": [
                    "10.1002/malq.19880340410"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Word equations with two variables",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Charatonik",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pacholski",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "IWWERT",
            "volume": "",
            "issn": "",
            "pages": "43--56",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-56730-5_30"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "The smallest grammar problem",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Charikar",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "IEEE Trans. Inf. Theory",
            "volume": "51",
            "issn": "7",
            "pages": "2554--2576",
            "other_ids": {
                "DOI": [
                    "10.1109/TIT.2005.850116"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Solution sets for equations over free groups are EDT0L languages",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ciobanu",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Elder",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "IJAC",
            "volume": "26",
            "issn": "5",
            "pages": "843--886",
            "other_ids": {
                "DOI": [
                    "10.1142/S0218196716500363"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Completion of rewrite systems with membership constraints. Part I: deduction rules",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Comon",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Symb. Comput",
            "volume": "25",
            "issn": "4",
            "pages": "397--419",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.1997.0185"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Completion of rewrite systems with membership constraints. Part II: constraint solving",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Comon",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Symb. Comput",
            "volume": "25",
            "issn": "4",
            "pages": "421--453",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.1997.0186"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "One-context unification with STG-compressed terms is in NP",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Creus",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gasc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Godoy",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "23rd International Conference on Rewriting Techniques and Applications (RTA 2012). LIPIcs",
            "volume": "15",
            "issn": "",
            "pages": "149--164",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.RTA.2012.149"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Solving two-variable word equations",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Dabrowski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "D\u00edaz",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Karhum\u00e4ki",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lepist\u00f6",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "ICALP 2004",
            "volume": "3142",
            "issn": "",
            "pages": "408--419",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-27836-8_36"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "On word equations in one variable",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Dabrowski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Algorithmica",
            "volume": "60",
            "issn": "4",
            "pages": "819--828",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-009-9375-3"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Solutions of twisted word equations, EDT0L languages, and context-free groups",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Elder",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Chatzigiannakis",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Indyk",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Kuhn",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "14. Schloss Dagstuhl -Leibniz-Zentrum fuer Informatik",
            "volume": "80",
            "issn": "",
            "pages": "1--96",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.ICALP.2017.96"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "The existential theory of equations with rational constraints in free groups is PSPACE-complete",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Hagenah",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Inf. Comput",
            "volume": "202",
            "issn": "2",
            "pages": "105--140",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2005.04.002"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Finding all solutions of equations in free groups and monoids with involution",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Inf. Comput",
            "volume": "251",
            "issn": "",
            "pages": "263--286",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2016.09.009"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Solvability of equations in free partially commutative groups is decidable",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Muscholl",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Conference version in Proceedings of ICALP 2001",
            "volume": "16",
            "issn": "",
            "pages": "543--554",
            "other_ids": {
                "DOI": [
                    "10.1142/S0218196706003372"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Simple second-order languages for which unification is undecidable",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "M"
                    ],
                    "last": "Farmer",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Theor. Comput. Sci",
            "volume": "87",
            "issn": "1",
            "pages": "80003--80007",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(06)80003-4"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Context matching for compressed terms",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gasc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Godoy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Proceedings of the Twenty-Third Annual IEEE Symposium on Logic in Computer Science, LICS 2008",
            "volume": "",
            "issn": "",
            "pages": "93--102",
            "other_ids": {
                "DOI": [
                    "10.1109/LICS.2008.17"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Unification and matching on compressed terms",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gasc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Godoy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "ACM Trans. Comput. Log",
            "volume": "12",
            "issn": "4",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/1970398.1970402"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Context unification with one context variable",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gasc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Godoy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tiwari",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Symb. Comput",
            "volume": "45",
            "issn": "2",
            "pages": "173--193",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jsc.2008.10.005"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Efficient algorithms for Lempel-Ziv encoding",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Gasieniec",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Karpi\u0144ski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "SWAT",
            "volume": "",
            "issn": "",
            "pages": "392--403",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-61422-2_148"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Randomized efficient algorithms for compressed strings: the finger-print approach",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Gasieniec",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Karpi\u0144ski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "39--49",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-61258-0_3"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Almost optimal fully LZW-compressed pattern matching",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Gasieniec",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "316--325",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Pattern matching in Lempel-Ziv compressed strings: fast, simple, and deterministic",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gawrychowski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "",
            "volume": "6942",
            "issn": "",
            "pages": "421--432",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-23719-5_36"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Tying up the loose ends in fully LZW-compressed pattern matching",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gawrychowski",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "STACS. LIPIcs",
            "volume": "14",
            "issn": "",
            "pages": "624--635",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Optimal pattern matching in LZW compressed strings",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gawrychowski",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ACM Trans. Algorithms",
            "volume": "9",
            "issn": "3",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/2483699.2483705"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "The undecidability of the second-order unification problem",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "D"
                    ],
                    "last": "Goldfarb",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Theor. Comput. Sci",
            "volume": "13",
            "issn": "",
            "pages": "225--230",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(81)90040-2"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Satisfiability of word equations with constants is in exponential space",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "FOCS",
            "volume": "",
            "issn": "",
            "pages": "112--119",
            "other_ids": {
                "DOI": [
                    "10.1109/SFCS.1998.743434"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Two-variable word equations",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ilie",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "ITA",
            "volume": "34",
            "issn": "6",
            "pages": "467--501",
            "other_ids": {
                "DOI": [
                    "10.1051/ita:2000126"
                ]
            }
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Minimal and complete word unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jaffar",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "J. ACM",
            "volume": "37",
            "issn": "1",
            "pages": "47--85",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "The complexity of compressed membership problems for finite automata",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Theory Comput. Syst",
            "volume": "55",
            "issn": "",
            "pages": "685--718",
            "other_ids": {
                "DOI": [
                    "10.1007/s00224-013-9443-6"
                ]
            }
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Context unification is in PSPACE",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ICALP. LNCS",
            "volume": "8573",
            "issn": "",
            "pages": "244--255",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-43951-7_21"
                ]
            }
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Approximation of grammar-based compression via recompression",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Theor. Comput. Sci",
            "volume": "592",
            "issn": "",
            "pages": "115--134",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2015.05.027"
                ]
            }
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Faster fully compressed pattern matching by recompression",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ACM Trans. Algorithms",
            "volume": "11",
            "issn": "3",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/2631920"
                ]
            }
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "A really simple approximation of smallest grammar",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci",
            "volume": "616",
            "issn": "",
            "pages": "141--150",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2015.12.032"
                ]
            }
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "One-variable word equations in linear time",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Algorithmica",
            "volume": "74",
            "issn": "",
            "pages": "1--48",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-014-9931-3"
                ]
            }
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Recompression: a simple and powerful technique for word equations",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "J. ACM",
            "volume": "63",
            "issn": "1",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/2743014"
                ]
            }
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Word equations in nondeterministic linear space",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Chatzigiannakis",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Indyk",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Kuhn",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "pp. 95:1-95:13. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik",
            "volume": "80",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.4230/LIPIcs.ICALP.2017.95"
                ]
            }
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Approximation of smallest linear tree grammar",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lohrey",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Inf. Comput",
            "volume": "251",
            "issn": "",
            "pages": "215--251",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2016.09.007"
                ]
            }
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Grammar precompression speeds up Burrows-Wheeler compression",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "K\u00e4rkk\u00e4inen",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Mikkola",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kempa",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Calder\u00f3n-Benavides",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Gonz\u00e1lez-Caro",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ch\u00e1vez",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "SPIRE 2012",
            "volume": "7608",
            "issn": "",
            "pages": "330--335",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-34109-0_34"
                ]
            }
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "Pattern-matching for strings with short descriptions",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Karpinski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shinohara",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "CPM 1995",
            "volume": "937",
            "issn": "",
            "pages": "205--214",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-60044-2_44"
                ]
            }
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "II: systems in triangular quasi-quadratic form and description of residually free groups",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kharlampovich",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Myasnikov",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Algebra",
            "volume": "200",
            "issn": "",
            "pages": "517--570",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "Elementary theory of free non-abelian groups",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kharlampovich",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Myasnikov",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. Algebra",
            "volume": "302",
            "issn": "",
            "pages": "451--552",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "Complexity of Makanin's algorithm",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ko\u015bcielski",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pacholski",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "J. ACM",
            "volume": "43",
            "issn": "4",
            "pages": "670--684",
            "other_ids": {
                "DOI": [
                    "10.1145/234533.234543"
                ]
            }
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Makanin's algorithm is not primitive recursive",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ko\u015bcielski",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pacholski",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Theor. Comput. Sci",
            "volume": "191",
            "issn": "1-2",
            "pages": "321--321",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(96)00321-0"
                ]
            }
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Word equations with one unknown",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Laine",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Int. J. Found. Comput. Sci",
            "volume": "22",
            "issn": "2",
            "pages": "345--375",
            "other_ids": {
                "DOI": [
                    "10.1142/S0129054111008088"
                ]
            }
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "Offline dictionary-based compression",
            "authors": [
                {
                    "first": "N",
                    "middle": [
                        "J"
                    ],
                    "last": "Larsson",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Moffat",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Data Compression Conference",
            "volume": "",
            "issn": "",
            "pages": "296--305",
            "other_ids": {
                "DOI": [
                    "10.1109/DCC.1999.755679"
                ]
            }
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "Linear second-order unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "RTA 1996",
            "volume": "1103",
            "issn": "",
            "pages": "332--346",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-61464-8_63"
                ]
            }
        },
        "BIBREF49": {
            "ref_id": "b49",
            "title": "On the complexity of bounded secondorder unification and stratified context unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Villaret",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Log. J. IGPL",
            "volume": "19",
            "issn": "6",
            "pages": "763--789",
            "other_ids": {
                "DOI": [
                    "10.1093/jigpal/jzq010"
                ]
            }
        },
        "BIBREF50": {
            "ref_id": "b50",
            "title": "On the undecidability of second-order unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Veanes",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Inf. Comput",
            "volume": "159",
            "issn": "1-2",
            "pages": "125--150",
            "other_ids": {
                "DOI": [
                    "10.1006/inco.2000.2877"
                ]
            }
        },
        "BIBREF51": {
            "ref_id": "b51",
            "title": "Linear second-order unification and context unification with tree-regular constraints",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Villaret",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "RTA 2000",
            "volume": "1833",
            "issn": "",
            "pages": "156--171",
            "other_ids": {
                "DOI": [
                    "10.1007/10721975_11"
                ]
            }
        },
        "BIBREF52": {
            "ref_id": "b52",
            "title": "Currying second-order unification problems",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Villaret",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "RTA 2002",
            "volume": "2378",
            "issn": "",
            "pages": "326--339",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-45610-4_23"
                ]
            }
        },
        "BIBREF53": {
            "ref_id": "b53",
            "title": "Processing compressed texts: a tractability border",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Lifshits",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "CPM 2007",
            "volume": "4580",
            "issn": "",
            "pages": "228--240",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-73437-6_24"
                ]
            }
        },
        "BIBREF54": {
            "ref_id": "b54",
            "title": "Algorithmics on SLP-compressed strings: a survey",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lohrey",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Groups Complex. Cryptol",
            "volume": "4",
            "issn": "2",
            "pages": "241--299",
            "other_ids": {}
        },
        "BIBREF55": {
            "ref_id": "b55",
            "title": "The problem of solvability of equations in a free semigroup",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Makanin",
                    "suffix": ""
                }
            ],
            "year": 1977,
            "venue": "Matematicheskii Sbornik",
            "volume": "2",
            "issn": "103",
            "pages": "147--236",
            "other_ids": {}
        },
        "BIBREF56": {
            "ref_id": "b56",
            "title": "English translation in Math",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Makanin",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "Izv. Akad. Nauk SSR Ser. Math",
            "volume": "46",
            "issn": "",
            "pages": "1199--1273",
            "other_ids": {}
        },
        "BIBREF57": {
            "ref_id": "b57",
            "title": "Decidability of the universal and positive theories of a free group",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Makanin",
                    "suffix": ""
                }
            ],
            "year": 1984,
            "venue": "Russian. English translation. In: Math. USSR Izvestija",
            "volume": "48",
            "issn": "",
            "pages": "75--88",
            "other_ids": {}
        },
        "BIBREF58": {
            "ref_id": "b58",
            "title": "Some decision problems for traces",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Matiyasevich",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "LFCS 1997",
            "volume": "1234",
            "issn": "",
            "pages": "248--257",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-63045-7_25"
                ]
            }
        },
        "BIBREF59": {
            "ref_id": "b59",
            "title": "Maintaining dynamic sequences under equality tests in polylogarithmic time",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Mehlhorn",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Sundar",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Uhrig",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Algorithmica",
            "volume": "17",
            "issn": "2",
            "pages": "183--198",
            "other_ids": {
                "DOI": [
                    "10.1007/BF02522825"
                ]
            }
        },
        "BIBREF60": {
            "ref_id": "b60",
            "title": "An improved pattern matching algorithm for strings in terms of straight-line programs",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Miyazaki",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shinohara",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Takeda",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "CPM 1997",
            "volume": "1264",
            "issn": "",
            "pages": "1--11",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-63220-4_45"
                ]
            }
        },
        "BIBREF61": {
            "ref_id": "b61",
            "title": "Identifying hierarchical structure in sequences: a linear-time algorithm",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "G"
                    ],
                    "last": "Nevill-Manning",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [
                        "H"
                    ],
                    "last": "Witten",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "J. Artif. Intell. Res. (JAIR)",
            "volume": "7",
            "issn": "",
            "pages": "67--82",
            "other_ids": {
                "DOI": [
                    "10.1613/jair.374"
                ]
            }
        },
        "BIBREF62": {
            "ref_id": "b62",
            "title": "On equality up-to constraints over finite trees, context unification, and one-step rewriting",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Niehren",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pinkal",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ruhrberg",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "CADE 1997",
            "volume": "1249",
            "issn": "",
            "pages": "34--48",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-63104-6_4"
                ]
            }
        },
        "BIBREF63": {
            "ref_id": "b63",
            "title": "A uniform approach to under specification and parallelism",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Niehren",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pinkal",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ruhrberg",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "410--417",
            "other_ids": {
                "DOI": [
                    "10.3115/979617.979670"
                ]
            }
        },
        "BIBREF64": {
            "ref_id": "b64",
            "title": "Testing equivalence of morphisms on context-free languages",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "ESA 1994",
            "volume": "855",
            "issn": "",
            "pages": "460--470",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0049431"
                ]
            }
        },
        "BIBREF65": {
            "ref_id": "b65",
            "title": "Satisfiability of word equations with constants is in NEXPTIME",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "STOC",
            "volume": "",
            "issn": "",
            "pages": "721--725",
            "other_ids": {
                "DOI": [
                    "10.1145/301250.301443"
                ]
            }
        },
        "BIBREF66": {
            "ref_id": "b66",
            "title": "Satisfiability of word equations with constants is in PSPACE",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "J. ACM",
            "volume": "51",
            "issn": "3",
            "pages": "483--496",
            "other_ids": {
                "DOI": [
                    "10.1145/990308.990312"
                ]
            }
        },
        "BIBREF67": {
            "ref_id": "b67",
            "title": "An efficient algorithm for solving word equations",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "STOC",
            "volume": "",
            "issn": "",
            "pages": "467--476",
            "other_ids": {
                "DOI": [
                    "10.1145/1132516.1132584"
                ]
            }
        },
        "BIBREF68": {
            "ref_id": "b68",
            "title": "Application of Lempel-Ziv encodings to the solution of word equations",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "ICALP 1998",
            "volume": "1443",
            "issn": "",
            "pages": "731--742",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0055097"
                ]
            }
        },
        "BIBREF69": {
            "ref_id": "b69",
            "title": "On systems of equations in free groups",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "A"
                    ],
                    "last": "Razborov",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF70": {
            "ref_id": "b70",
            "title": "A machine-oriented logic based on the resolution principle",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Robinson",
                    "suffix": ""
                }
            ],
            "year": 1965,
            "venue": "J. ACM",
            "volume": "12",
            "issn": "1",
            "pages": "23--41",
            "other_ids": {}
        },
        "BIBREF71": {
            "ref_id": "b71",
            "title": "Application of Lempel-Ziv factorization to the approximation of grammar-based compression",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Theor. Comput. Sci",
            "volume": "302",
            "issn": "1-3",
            "pages": "777--783",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(02)00777-6"
                ]
            }
        },
        "BIBREF72": {
            "ref_id": "b72",
            "title": "On the complexity of Hmelevskii's theorem and satisfiability of three unknown equations",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Saarela",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "DLT 2009",
            "volume": "5583",
            "issn": "",
            "pages": "443--453",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-02737-6_36"
                ]
            }
        },
        "BIBREF73": {
            "ref_id": "b73",
            "title": "Symmetry breaking for suffix tree construction",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "C"
                    ],
                    "last": "Sahinalp",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Vishkin",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "300--309",
            "other_ids": {
                "DOI": [
                    "10.1145/195058.195164"
                ]
            }
        },
        "BIBREF74": {
            "ref_id": "b74",
            "title": "A fully linear-time approximation algorithm for grammar-based compression",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Sakamoto",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "J. Discrete Algorithms",
            "volume": "3",
            "issn": "2-4",
            "pages": "416--430",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jda.2004.08.016"
                ]
            }
        },
        "BIBREF75": {
            "ref_id": "b75",
            "title": "Unification of stratified second-order terms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF76": {
            "ref_id": "b76",
            "title": "A decision algorithm for stratified context unification",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "J. Log. Comput",
            "volume": "12",
            "issn": "6",
            "pages": "929--953",
            "other_ids": {
                "DOI": [
                    "10.1093/logcom/12.6.929"
                ]
            }
        },
        "BIBREF77": {
            "ref_id": "b77",
            "title": "Decidability of bounded second order unification",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Inf. Comput",
            "volume": "188",
            "issn": "2",
            "pages": "143--178",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2003.08.002"
                ]
            }
        },
        "BIBREF78": {
            "ref_id": "b78",
            "title": "On the exponent of periodicity of minimal solutions of context equations",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "U"
                    ],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "RTA 1998",
            "volume": "1379",
            "issn": "",
            "pages": "61--75",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0052361"
                ]
            }
        },
        "BIBREF79": {
            "ref_id": "b79",
            "title": "Solvability of context equations with two context variables is decidable",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "U"
                    ],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "J. Symb. Comput",
            "volume": "33",
            "issn": "1",
            "pages": "77--122",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.2001.0438"
                ]
            }
        },
        "BIBREF80": {
            "ref_id": "b80",
            "title": "Makanin's algorithm for word equations-two improvements and a generalization",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "U"
                    ],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "IWWERT 1990",
            "volume": "572",
            "issn": "",
            "pages": "85--150",
            "other_ids": {}
        },
        "BIBREF82": {
            "ref_id": "b82",
            "title": "The macro model for data compression",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Storer",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "G"
                    ],
                    "last": "Szymanski",
                    "suffix": ""
                }
            ],
            "year": 1978,
            "venue": "STOC",
            "volume": "",
            "issn": "",
            "pages": "30--39",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "PairComp(ab, w) Compression of pair ab 1: let c \u2208 \u03a3 be an unused letter 2: replace all occurrences of ab in w by c",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "For an equation u = v, solution S and pair ab an occurrence of ab in S(u) (or S(v)) is -explicit, if it consists solely of letters coming from u (or v); -implicit, if it consists solely of letters coming from a substitution S(X) for a fixed occurrence of some variable X; -crossing, otherwise. A pair ab is crossing (for a solution S) if it has at least one crossing occurrence and non-crossing (for a solution S) otherwise. We similarly define explicit, implicit and crossing occurrences for blocks of letter a; a is crossing, if at least one of its blocks has a crossing occurrence. (In other words: aa is crossing). Example 1. Equation aaXbbabababa = XaabbY abX has a unique solution S(X) = a, S(Y ) = abab, under which sides evaluate to aaabbabababa = aaabbabababa.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "PairComp(ab, 'u = v') Pair compression for ab in an equation u = v 1: let c \u2208 \u03a3 be a fresh letter 2: replace all occurrences of ab in 'u = v' by c Algorithm 4 . BlockComp(a, 'u = v') Block compression for a letter a in an equation 'u = v' 1: for > 1 do 2:let a \u2208 \u03a3 be a fresh letter 3:replace all occurrences of maximal blocks a in 'u = v' by a Fix a pair ab and a solution S of the equation u = v. If ab is non-crossing, performing PairComp(ab, S(u)) is easy: we need to replace every explicit occurrence (which we do directly on the equation) as well as each implicit occurrence, which is done 'implicitly', as the solution is not stored, nor written anywhere. Due to the similarities to PairComp we will simply use the name PairComp(ab,'u = v'), when we make the pair compressions on the equation. The argument above shows, that if the equation had a solution for which ab is non-crossing then also the obtained equation has a solution. The same applies to the block compression, called BlockComp(a,'u = v') for simplicity. On the other hand, if the obtained equation has a solution, then also the original equation had one (this solution is obtained by replacing each letter c by ab, the argument for the block compressions the same).Lemma 1. Let the equation u = v have a solution S, such that ab is noncrossing for S. Then u = v obtained by PairComp(ab,'u = v') is satisfiable. If the obtained equation u = v is satisfiable, then also the original equation u = v is. The same applies to BlockComp(a,'u = v').",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "[67]). Let S be a shortest solution of an equation 'u = v'. Then: -If ab is a substring of S(u), where a = b, then a, b have explicit occurrences in the equation and ab has an explicit or crossing occurrence. -If a k is a maximal block in S(u) then a has an explicit occurrence in the equation and a k has an explicit or crossing occurrence.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "CP1) aX occurs in the equation and S(X) begins with b; (CP2) Y b occurs in the equation and S(Y ) ends with a; (CP3) Y X occurs in the equation, S(X) begins with b and b S(Y ) ends with a.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Pop(a, b, 'u = v') 1: for X: variable do 2:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "CutPrefSuff(a, 'u = v') Popping prefixes and suffixes 1: for X: variable do 2: guess the lengths , r of a-prefix and suffix of S(X) S(X) = a wa r If S(X) = a then r = 0 3:replace occurrences of X in u and v by a Xa r a , a r are stored in a compressed way 4:Implicitly change the solution S(X) = a wb r to S(X) = w 5:if S(X) = then Guess 6:remove X from u and v",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "-(3) we know that there are at most 2n crossing pairs and crossing letters (as each crossing pair/each crossing letter corresponds to one occurrence of a variable and one 'side' of such an occurrence). If the equation has m letters (and at most n occurrences of variables) and there is an occurrence of a non-crossing pair or block then we choose it for compression. Otherwise, there are m letters in the equation and each is covered by at least one pair/block, so for one of 2n choice at least m 2n letters are covered, so at least m 4n letters are removed by some compression. Thus the new equation has at most 2 \u2212 2n + 2n = 8n 2 letters, where the inequality follows by the inductive assumption that m \u2264 8n 2 . Going for the bit-size, each symbol requires at most logarithmic number of bits, and so Lemma 7. WordEqSAT runs in O(n 2 log n) (bit) space.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "The recompression for SLPs runs in O(n log N ) \u2264 O(n 2 ) time, where n is the size of the input SLP and N is the length of the defined word.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "runs in time O(n log N ), where N = | val(A)| = | val(B)| (if | val(A)| = | val(B)| then clearly A and B are not equal) and n the sum of sizes of SLPs A and B. In order to obtain such a running time, we need several optimisations. Theorem 5 ([33]). The recompression based algorithm for equality testing for SLPs runs in O(n log N ) time, where n is the sum of SLPs' sizes while N the size of the defined (decompressed) words.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "[33]). The recompression based algorithm for fully compressed pattern matching runs in O(n log M ) time, where n is the sum of SLPs' sizes while M the length of the (uncompressed) pattern.",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "(which is part of the input), term variables and context variables, the former are treated as symbols of arity 0, while the latter as symbols of arity 1. A substitution S assigns to each variable a closed term over \u03a3 and to each context variable it assigns a context, i.e. a term over \u03a3 \u222a {\u03a9} in which the special symbol \u03a9 has arity 0 and is used exactly once. (Intuitively it corresponds to a place in which we later substitute the argument). S is extended to u, v in a natural way, note that for a context variable X the term S(X(t)) is obtained by replacing in S(X) the unique symbol \u03a9 by S(t). A solution is a substitution satisfying S(u) = S(v). Term f (h(c, c, c), f(c, f (c, c) )) viewed as a tree, f is of arity 2, h: 3 and c: 0.We try to apply the main idea of the recompression also in the case of terms: we iterate local compression operations and we guarantee that the word (term) equation is polynomial size. Since several term problems were solved using compression-based methods [9, [17] [18] [19] 48] , there is a reasonable hope that our approach may succeed.",
            "cite_spans": [
                {
                    "start": 994,
                    "end": 997,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 998,
                    "end": 1002,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1003,
                    "end": 1007,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1008,
                    "end": 1012,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1013,
                    "end": 1016,
                    "text": "48]",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [
                {
                    "start": 651,
                    "end": 684,
                    "text": "Term f (h(c, c, c), f(c, f (c, c)",
                    "ref_id": null
                }
            ],
            "section": "annex"
        }
    ]
}