{
    "paper_id": "624dd173fd7d995d9d551d1704053cc36c729e58",
    "metadata": {
        "title": "An adaptive dimension reduction algorithm for latent variables of variational autoencoder",
        "authors": [
            {
                "first": "Yiran",
                "middle": [],
                "last": "Dong",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Chuanhou",
                "middle": [],
                "last": "Gao",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "This paper proposes a new pattern of inactivating variables to address the dimension reduction issue of latent variables in VAE related models. By introducing \u03c0 vector whose elements are 0 or 1, and further utilizing the element-wise multiplication between \u03c0 and variables, we develop an adaptive dimension reduction algorithm to remove those latent variables inactivated by 0 component of \u03c0 for the purpose of dimension reduction. We make some theoretical analysis about the convergence and local convexity of the algorithm output, i.e., the convergent dimension. These encouraging results are also supported by numerical experiments. Six frequently-used data sets, including two large-sized ones, are illustrated that the proposed algorithm is quite effective both in precision and in efficiency. A potential application of the algorithm is to generate VAE related models with more compact structure and higher precision, except for reducing dimension.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "V ariational autoencoder (VAE) has been one of the most popular modeling methods since it was pioneered by Kingma and Welling [1] . Essentially, it is a kind of generative modeling approach, like Generative Adversarial Nets (GAN) [2] , that handles models of distribution about datapoints. VAE is built on neural networks and trained with stochastic gradient descent. From the viewpoint of structure, there include encoder, latent variables layer and decoder in a VAE model, and for encoder and decoder there may be multi-layers of hidden layer therein. Fig. 1 exhibits a schematic of VAE. Throughout the working process, the encoder encodes the original samples into latent variables while the decoder reconstruct new samples from latent variables. The whole workflow is implemented through unsupervised learning of neural networks. A more detailed introduction on VAE may be found in the tutorial paper [3] . Benefiting from complete mathematical support, VAE has exhibited strong power in generating many complex data, such as handwritten digits [1] , [4] , faces [1] , [5] and CIFAR images [6] etc.",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 129,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 230,
                    "end": 233,
                    "text": "[2]",
                    "ref_id": null
                },
                {
                    "start": 905,
                    "end": 908,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1049,
                    "end": 1052,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1055,
                    "end": 1058,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1067,
                    "end": 1070,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1073,
                    "end": 1076,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1094,
                    "end": 1097,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 554,
                    "end": 560,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "! 1 Introduction"
        },
        {
            "text": "Following the rapid development of VAE, some improved versions consecutively emerge. A typical one is conditional variational autoencoder (CVAE) [7] , [8] , which, instead of unsupervised learning in VAE, models complicated distributions about datapoints through supervised learning. Liu and Wang [9] came up with Stein VAE, which uses stein variational gradient descent to maximize the evidence lower bound (ELBO) and update network parameters. To balance the independent constraint of decoder and the information capacity in encoder, Higgins et. al. [10] developed Beta VAE that introduce a hyperparameter \u03b2 to multiply the KL divergence in ELBO. The Structure VAE [11] was proposed with the purpose of using more complicated graph to approach the actual posterior distribution. These improvements further witness the success of VAE.",
            "cite_spans": [
                {
                    "start": 145,
                    "end": 148,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 151,
                    "end": 154,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 297,
                    "end": 300,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 552,
                    "end": 556,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 667,
                    "end": 671,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "! 1 Introduction"
        },
        {
            "text": "However, when VAE works, it usually involves many neural nodes. This can be seen from Fig. 1 , where either the hidden layers in encoder and decoder or the latent variables layer contain a great deal of neural nodes. Since the number of neural nodes directly determines the number of parameters in the model, too many neural nodes may lead to the extreme complexity of model and serious time-consuming training. It thus needs to remove those redundant neural nodes that may contain useless information even noise to model. Dimension reduction is a feasible solution to the above issue. Naturally, it is not a novel project in the field of machine learning, and some classical methods, such as principal component analysis [12] etc., have been widely used in many fields. Here, we continue to select this strategy to address the curse of dimensionality in the VAE related models. However, unlike those traditional dimension reduction techniques where various projections usually need to be defined between original features and the reduced ones, the current proposed method (called adaptive dimension reduction algorithm in the context), getting inspiration from sequential minimal optimization [13] , works through judging whether each feature contains too much noise. We put forward a new pattern to realize the above process. By introducing \u03c0 vector whose elements are 0 or 1, and further utilizing the element-wise multiplication between \u03c0 and latent variables, the algorithm will remove those latent variables inactivated by 0 component of \u03c0 while keep those activated by 1 component of \u03c0. The algorithm is also proved to have convergence and local convexity about the output. These properties are further verified by a great deal of numerical experiments. The potential effect of the algorithm is, on the one hand, to obtain higher precision and more efficient VAE related models, one the other hand, to generate a complete new highefficiency model.",
            "cite_spans": [
                {
                    "start": 722,
                    "end": 726,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1194,
                    "end": 1198,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [
                {
                    "start": 86,
                    "end": 92,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "! 1 Introduction"
        },
        {
            "text": "The rest of the paper is organized as follows. Section 2 presents some preliminaries about VAE and CVAE. In Section 3, our main work, the adaptive dimension reduction algorithm as well as its convergence and application, is presented. This is followed by some experimental studies of the proposed algorithms in Section 4. Finally, Section 5 concludes the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "! 1 Introduction"
        },
        {
            "text": "In this section we will give a short introduction on VAE and CVAE [3] , and then present the assumption that is used for algorithms development.",
            "cite_spans": [
                {
                    "start": 66,
                    "end": 69,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "VAE is a kind of typical latent variable model, whose main purpose is to generate sample points sharing the same distribution with the original samples as far as possible through utilizing latent variables.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VAE and CVAE"
        },
        {
            "text": "Let D = {x \u2208 R N } represent a data set, and the task is to infer the distribution of x, P(x), so as to generate new sample points. VAE addresses this issue by introducing latent variables z \u2208 R m obeying the standardized normal distribution N(0, I), and further minimizing the KL divergence between the true posterior distribution P(z|x) and the learned one Q(z|x) on D. The graphical model of VAE is exhibited in Fig. 2 . Here, the KL divergence is essentially about the expectation calculation, defined by",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 415,
                    "end": 421,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "VAE and CVAE"
        },
        {
            "text": "By adding P(x) and applying Bayes rule to P(z|x), the above expression can be rewritten as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VAE and CVAE"
        },
        {
            "text": "which is the core formula in VAE. The left hand side of the formula is just right the maximization objective with the first term to represent the likelihood of P(x) while the second term to express minus error of estimating P(z|x) by Q(z|x). The right hand side takes a form of autoencoder, where Q is \"encoding\" x into z, and P is \"decoding\" it to reconstruct x. It can be also seen as a lower bound of log P(x) due to the nonnegativity of KL[Q(z|x) P(z|x)], usually called ELBO. The inner two terms are both computable, so the whole often acts as the cost function one can optimize via stochastic gradient descent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VAE and CVAE"
        },
        {
            "text": "To optimize Eq. (2), it needs to know a specific form about Q(z|x). The usual choice for it, and also for P(x|z) is the Gaussian distribution, i.e.,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VAE and CVAE"
        },
        {
            "text": "where \u00b5, \u03a3 and f are arbitrary deterministic functions that can be learned via neural networks, \u03a3 constrained to be a diagonal matrix, and \u03c3 2 the constant convariance. With these distributions, the \"reparameterization trick\" is further adopted, then backpropagation can compute a gradient used for stochastic gradient descent, which completes the learning process. CVAE is a kind of conditional VAE that nearly has the same working procedures as VAE except simply conditioning the entire generative process on an input. Mathematically, it can be modeled by input-output pairs (x, y) instead of unlabelled input x in VAE, so it is more potential in handling images that have different categories. The graphical structure of CVAE is also displayed in Fig. 2 , and a schematic of CVAE including 3 layers of encoder and of decoder is given in Fig. 3 . In this work, we will use both of VAE and CVAE to validate the dimension reduction algorithms. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 750,
                    "end": 756,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 840,
                    "end": 846,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "VAE and CVAE"
        },
        {
            "text": "In order to facilitate the design of dimension reduction algorithms, the following assumption is made for VAE and CVAE. We denote the training precision loss function by h z , where z is identified as an m-dimensional latent variable vector in the related model M. Further, we introduce a special m-dimensional vector \u03c0, whose elements are ones or zeros, to build a new model with latent variables z \u2297 \u03c0 where the symbol \u2297 represents the element-wise multiplication. Then the assumption states:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Assumption"
        },
        {
            "text": "Assumption: \u2200\u03c0 1 , \u03c0 2 satisfying \u03c0 1 i \u2264 \u03c0 2 i for any i = 1, ..., m and furthermore \u03a3 i The physical meaning of the above assumption is that if continuate two times dimension reduction of the latent variables can both generate higher-precision models than M, then the second time dimension reduction can obtain higher-precision model than that by the first time dimension reduction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Assumption"
        },
        {
            "text": "It should be noted that the assumption is reasonable to a certain extent. Essentially, the purpose of dimension reduction is to remove redundant neural nodes that carry useless information in the model, also thought as noise. If the continuate dimension reduction both generate better models than the original one, it is reasonable to think that the dimension reduction truly deletes the redundant neural, so the more the redundant neural nodes are removed, the higher precision the model has. Another point should be noted that the assumption can work not only for VAE and CVAE, but for other autoencoder models.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Assumption"
        },
        {
            "text": "In this section, we will develop the adaptive dimension reduction algorithm for latent variables in VAE and CVAE, and also give the corresponding theoretical analysis.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Adaptive dimension reduction algorithm"
        },
        {
            "text": "In the process of algorithm design, we expect to find a model with latent variablesz that has the minimum precision loss compared to the original model with latent variables z. Mathematically, it can be modelled as, for enough small \u03b5 \u2265 0,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "Utilizing \u03c0 vector, we rebuild a new model to be",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "From the expression \u03c0 \u2297 z, the latent variable z i is activated if the corresponding \u03c0 i = 1; otherwise, z i is inactivated, and the information about z i cannot pass to the decoder and is seen as noise. Fig. 4 exhibits the generation process of new latent variables utilizing \u03c0. For the new model of (5), we have (5), then (4) holds true from (5). Proof. If m i=1 \u03c0 i =m, \u03c0 \u2297 z will define a group of new latent variables, which corresponds to a new model includingm latent variables, but shares the same parameters with M. Note that the modelM having training precision loss function hz has been trained to possess better training precision in all models withm latent variables, so hz \u2264 h z\u2297\u03c0 , i.e., the result is true.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 204,
                    "end": 210,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Lagrange Loss"
        },
        {
            "text": "The following task for the algorithm development is to minimize m i=1 \u03c0 i satisfying (5). Based on (2), we take the loss function as the minus of ELBO, i.e.,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "Similarly, we can express h z , by combining which with (6) and further inserting them into (5) we can get the following convex optimization model",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "where 1 is a m-dimensional vector with every element to be 1. Note that in the above model, the first term of the left side of the inequality constraint is closely related to the distance | f (\u03c0\u2297z)\u2212 f (z)| while the second term measures the KL divergence between the latent variables one discards and the Gaussian noise. The former needs to be small enough so that the expectation values, f (\u03c0 \u2297 z) and f (z), can approach the original data x, which means that the discarded units from z do not contain too much information of data set. However, the latter should be large enough, which needs to discard units from z as many as possible since the latent variables are i.i.d. We thus introduce a new parameter \u03b7, named gap hyperparameter, to split the constraint in (8) into two inequalities and develop a relatively relaxed optimization model",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "The solution of (9) will discard the latent variables that contain little information of data set and are also contaminated by noise heavily.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "Further by introducing the Lagrange multipliers \u03b1 and \u03b2, we rewrite (9) to be min z L(Q, P, \u03c0) (10)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "We name L(Q, P, \u03c0) by Lagrange loss in the context. Unlike the traditional pattern, here the Lagrange multipliers \u03b1 and \u03b2 are set to be hyperparameters that represent a preference of decreasing dimension or keeping information. To make the constraints of (9) be \"hard\" [14] , a feasible selection is to set them as functions of sample x, given by",
            "cite_spans": [
                {
                    "start": 269,
                    "end": 273,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "We will set them as some constants in the subsequent experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lagrange Loss"
        },
        {
            "text": "The main purpose of designing adaptive dimension reduction algorithm is to minimize the Lagrange loss. Note that there is only a decision variable z in (10) , and other parameters \u03b1, \u03b2, \u03b5 and \u03b7 are set to be hyperparameters. We firstly develop algorithm to be able to pick out the optimal combination units in \u03c0 for any given number of units, shown in Algorithm 1. In this algorithm, we consider the fixed encoder and decoder which have been trained on training set ahead of being input, and decide to keep or discard the units in latent variable vector based on the Lagrange Loss.",
            "cite_spans": [
                {
                    "start": 152,
                    "end": 156,
                    "text": "(10)",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "Algorithm 1 Optimization of L(\u03c0) regarding n combination units in \u03c0 Input: n \u2208 [1, m], L(\u03c0) 1: \u03c0 =ones(m), a function to produce a vector with all elements to be 1; 2: while not convergent do 3: randomly generate n non-repetitive indexes, denoted by i 1 , ..., i n ; 4: \u2200 j \u2208 [1, n] set \u03c0 i j = 0 or 1, and enumerably generate 2 n vectors, labeled by \u03a0 = {\u03c0 1 , ..., \u03c0 2 n }; 5: for \u03be in \u03a0 do 6: if L(\u03be) < L(\u03c0) then 7:",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 194,
                    "text": "3:",
                    "ref_id": null
                },
                {
                    "start": 267,
                    "end": 269,
                    "text": "4:",
                    "ref_id": null
                },
                {
                    "start": 376,
                    "end": 378,
                    "text": "5:",
                    "ref_id": null
                },
                {
                    "start": 393,
                    "end": 395,
                    "text": "6:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "end for 10: end while Output: \u03c0 Theorem 1. For any given integer n \u2208 [1, m], the Lagrange loss L(\u03c0) in Algorithm 1 is convergent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "Proof. Since \u03c0 is m-dimensional, which is finite, and its component is 0 or 1, Algorithm 1 will create a monotone sequence L(\u03be 1 ) > L(\u03be 2 ) > ... Also, since the function values of Lagrange loss are finite, there must exist the lowest bound, which completes the proof. Remark 1. Algorithm 1 suggests that for any n, L(\u03c0) or \u03c0 is convergent. However, the convergent results may be quite different even though the same inputs are fed into, since in Line 3 of the algorithm those n location indexes of \u03c0 are generated randomly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "Remark 2. Theoretically, the appearance of the minimum Lagrange loss in Algorithm 1 may require to run it at a large n, which will be very time-consuming since each element in \u03a0 should be covered to compare all L(\u03c0) s. A practical strategy is to implement an early stopping rule that calls the algorithm off if the Lagrange loss or the sum of \u03c0 keeps unchanged for several epochs. However, the rule needs to make sure every element in \u03c0 to be visited in a large probability.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "The output of Algorithm 1 essentially suggests a convergent dimension of latent variables in the model with respect to the Lagrange loss. The following theorem indicates that this result also induces the local minimum of the training precision loss. Proof. See Appendix A for the detailed proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "For convenience, we use the expression Opt(L(Q, P, \u03c0), n) to represent the optimization strategy of \u03c0 through Algorithm 1. Then the adaptive dimension reduction algorithm, labeled by Algorithm 2, can be described as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm design and theoretical analysis"
        },
        {
            "text": "Input: Q(z|x), P(x|z) (after training on training set), \u03c0 =ones(m), L(Q, P, \u03c0) and n 1: while not convergent do 2: \u03c0=Opt(L(Q, P, \u03c0), n); 3: set new latent variablesz withm = m i=1 \u03c0 i ; 4: retrain VAE or CVAE on training set to get new Q(z|x) and P(x|z);",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 114,
                    "text": "2:",
                    "ref_id": null
                },
                {
                    "start": 137,
                    "end": 139,
                    "text": "3:",
                    "ref_id": null
                },
                {
                    "start": 186,
                    "end": 188,
                    "text": "4:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Algorithm 2 Adaptive dimension reduction algorithm"
        },
        {
            "text": "Q = Q(z|x), P = P(x|z); 6: \u03c0 =ones(m); 7: end while Output:m",
            "cite_spans": [
                {
                    "start": 24,
                    "end": 26,
                    "text": "6:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "5:"
        },
        {
            "text": "Here we use \"adaptive\" in the name of Algorithm 2. The main reason is that the algorithm, unlike other traditional dimension reduction algorithms, such as principal component analysis etc., that usually work in need of setting the result beforehand, can compute the reduced dimension adaptively according to the data sets. A further look at the above algorithm reveals that Line 2 implements Algorithm 1. As said in Remark 1, the result of Algorithm 1 is random, which may subconsciously affect the result of Algorithm 2. However, the following theorem suggests Algorithm 2 to be convergent. Remark 3. The output of Algorithm 2 is the dimension of latent variables inM, which is actually sensitive to the initial m and n due to running Algorithm 1. However, the invariance of convergent dimension do not rely on the initial dimension and the randomicity. The VAE model after every epoch in Algorithm 2 is guaranteed to be better than the last one according to training loss. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "5:"
        },
        {
            "text": "Except for reducing the dimension of latent variables, the algorithms can be also used to generate the hidden layers of encoder and decoder in VAE, and get better VAE.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms application to generate better VAE"
        },
        {
            "text": "Consider an initial VAE only with a single layer of encoder (input layer), a middle layer of latent variables and a single layer of decoder (output layer). We use Algorithm 2 to generate the hidden layers in encoder and decoder in the form of symmetry. The first time of application of the algorithms will yield better dimension of the latent variables. Then we use this \"better dimension\" as the number of neural units to construct the first layer of hidden layers in encoder and decoder. Based on the new VAE (with new encode, latent variables and decoder), we make the second time of applications of Algorithm 2. The same procedures are implemented repeatedly until the number of hidden layers reach the desired value. The detailed process to generate better VAE is exhibited in Fig. 5 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 782,
                    "end": 788,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Algorithms application to generate better VAE"
        },
        {
            "text": "Noticeably, the above \"better VAE\" is generated in a greedy way. During every time of applying Algorithm 2, the neural units in the hidden layers of encoder and decoder are generated as few as possible. A potential advantage of this generation pattern is that the generated VAE has fast forwarding speed and strong robustness due to reduction of neural units.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms application to generate better VAE"
        },
        {
            "text": "In this section, we use 6 data sets to evaluate our algorithms, including MNIST, FashionMNIST, ATTfaces 1 , Covid-19 2 , CACD [15] and CAT 3 . The basic information about them is listed in Table  1 . In terms of the numbers of pictures and of pixels in one picture, we sort the first two data sets as small-sized data sets, the middle two data sets as middle-sized data sets while the last two as largesized data sets. All data sets are used to test the algorithms on VAE while only the data sets of MNIST and Covid-19 are employed on CVAE. The initial dimensions of latent variables for every data set depend on the number of pixels on one image, which are given in Table 2 . We also provide the values of all hyperparameters used in the models, and the setting of the training set and testing set in this table. Here, the hyperparameters \u03b1 and \u03b2 are set around the initial 1. https://www.r-bloggers.com/wp-content/uploads/2010/09/ATTfaces.tar.gz 2. https://www.kaggle.com/pranavraikokte/covid19-image-dataset/metadata 3. https://www.kaggle.com/crawford/cat-dataset dimension of latent variables for the purpose of making a balance between dimension reduction and information reservation. ",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 130,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 139,
                    "end": 140,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 189,
                    "end": 197,
                    "text": "Table  1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 667,
                    "end": 674,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Experimental Studies and Discussions"
        },
        {
            "text": "In this subsection, the reduction dimension algorithm is applied to the VAE model. For the small-sized data sets, we use DNN to construct the encoder and decoder of VAE. With those experimental setups reported in Table 2 , Algorithm 2 is implemented on their training sets, respectively, and outputs the optimal dimension of latent variables to be 22 for MNIST and 15 for FashionMNIST. The comparisons between the initial dimension and the optimal one are displayed in Table 3 . It is clear that the proposed algorithms can reduce the dimension of latent variables greatly, both from the initial 100 to the current low values. These results imply a large possibility that there will be serious overfitting phenomena in the models with 100-dimensional latent variables.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 213,
                    "end": 220,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 469,
                    "end": 476,
                    "text": "Table 3",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Experimental results of VAE"
        },
        {
            "text": "To observe these phenomena, we further make experiments on the testing sets of these two data sets using the VAE models with latent variables of initial dimension, convergent dimension and others. The dimensions selection in the experiments is in large gaps at the beginning stage of initial dimension while in small gaps whilst being close to the convergent dimension. The reason is that the change of dimension will have a little effect on the model if it is far away from the convergent dimension. Shown in Table 4 are the results, where the \"Loss\" items are computed according to (6) and (7). As can be seen from this table, the \"Loss\" values at the initial dimensions are apparently lower than those at the convergent dimensions. Moreover, the latter reach the 75.9148 10 66.8908 \u2020 \"Loss\" represents the loss function of VAE which is minus of right part of (2) evaluated on the testing set; \u00a7 The bold represents the results are yielded at the convergent dimension. The above two pieces of descriptions also apply to Tables 5, 6 and 8.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 510,
                    "end": 517,
                    "text": "Table 4",
                    "ref_id": "TABREF3"
                }
            ],
            "section": "Experimental results of VAE"
        },
        {
            "text": "To observe the effect of Algorithm 2 more visually, we use the trained VAE model to generate new images at some different dimensions of latent variables, especially at the convergent dimension, with the results shown in Figs. 6 and 7 for MNIST and FashionMNIST, respectively. As can be seen from these two figures, at the convergent dimensions the generated images look very clear (sub-figures (b) ), nearly approaching the original images (sub-figures (a)). However, at other dimensions, the generated images look not so clear (sub-figures (c) and (d)), and there exist some blurry parts in the images, identified by the red frames. These observations confirm again that Algorithm 2 is quite valid in improving the VAE model precision through reducing the dimension of latent variables.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 381,
                    "end": 397,
                    "text": "(sub-figures (b)",
                    "ref_id": null
                }
            ],
            "section": "Experimental results of VAE"
        },
        {
            "text": "Following the same procedures, we continue to test Algorithm 2 on the middle-sized (ATTfaces and Covid-19) and large-sized (CACD and CAT) data sets given in Table 1 . The experimental setups are also presented in Table 2 . Since the pixels on one picture is rather high for these sample sets, to save space and time we use convolutional neural network (CNN) and ReLU activation function to construct the encoder, and transposed convolution neural network (TCNN) to construct the decoder in the VAE model. Table 3 reports the convergent results for these four data sets, being 100, 4, 40 and 19, respectively. It is amazing to notice that there is significant decrease from the initial dimension to the convergent dimension for ATTfaces, Covid-19 and CACD, especially for Covid-19, the decrease from 100 to 4 attaining 25 times. This will bring a good result that the training time of the VAE model will reduce dramatically. We also evaluate the results of Algorithm 2 using the testing sets of these four data sets. The results are displayed in Tables 5 and 6. As one may expect, the VAE models still have the best performance at the convergent dimension of latent variables for middle-sized and large-sized data sets. Similarly, we use the trained VAE models to generate new ATTfaces and Covid-19 images at different dimensions of latent variables, exhibited in Figs. 8 and 9 . The results show again that the images generated at the convergent dimensions approach the original images most (sub-figures (b)) while other cases contains too many unclear parts, especially like Fig. 8(c), Fig. 9 (c)(d), nearly the whole pictures being unclear. Hence, Algorithm 2 is still quite strong to handle middle-sized and large-sized data sets under consideration. Finally, we use Algorithm 2 to generate better VAE through learning the data set of MNIST according to the procedures described in Section 3.3. We begin the application experiments with the initial dimension of latent variables to be 450. After the first round of running Algorithm 2, we get the convergent dimension of latent variables to be 272. We put 272 neural nodes both into the encoder and decoder to construct the first layer of hidden layer therein. Then we use the new VAE model with new encoder, 272-dimensional latent variables and new decoder to begin the second round of applying Algorithm 2. The resulting convergent dimension is 24, at which we further get the \"Loss\" on the testing set to be 69.664. This value is a little less than the best result \"69.6778\" reported in Table 4 , which corresponds to the VAE model with a layer of 400-dimensional hidden layer in the encoder and decoder, and 22-dimensional latent variables. We also provide the image generated by the new better VAE model in Fig. 9 , from which the image generated by this new model (subfigure (b)) looks a little more clear than other one (subfigure (c)). Superficially, the \"Loss\" criterion seems not a strong evidence to say the new VAE better than the previous convergent VAE. To make a farther comparison, we provide the number of parameters contained in these two models in Table 7 . Clearly, there is a great difference between the total parameters numbers of two models. For the new better VAE model, the total parameters number is 447456, which decreases about 32%, compared to the result 655228 that the convergent VAE model has. Hence, with so few parameters, the new better VAE will have dramatic improvement on the speed of training and forwarding.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 157,
                    "end": 164,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 213,
                    "end": 220,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 505,
                    "end": 512,
                    "text": "Table 3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 1363,
                    "end": 1376,
                    "text": "Figs. 8 and 9",
                    "ref_id": "FIGREF8"
                },
                {
                    "start": 1576,
                    "end": 1593,
                    "text": "Fig. 8(c), Fig. 9",
                    "ref_id": "FIGREF8"
                },
                {
                    "start": 2543,
                    "end": 2550,
                    "text": "Table 4",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 2765,
                    "end": 2771,
                    "text": "Fig. 9",
                    "ref_id": "FIGREF9"
                },
                {
                    "start": 3120,
                    "end": 3127,
                    "text": "Table 7",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Experimental results of VAE"
        },
        {
            "text": "Note that from the viewpoint of technique, this application just uses the adaptive dimension reduction algorithm based on a greedy strategy, so it is still possible to have a better combination of different layers in the model. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental results of VAE"
        },
        {
            "text": "In this subsection, the CVAE model works for validating the reduction dimension algorithm, which, unlike VAE, is supervised learning. Every image is thus assigned a label beforehand, and the loss function, the optimization model, and the Lagrange loss are quite similar to those for VAE, just adding the label information y in the corresponding conditions of probability expressions. Here, we use one-hot encoding to represent the label of each image, so there are two vectors in the latent layer, i.e., the latent variables and the labels. In this case, only two data sets, a small-sized MNIST and a middle-sized Covid-19, are considered. For the MNIST data set, each image is assigned a number, ranging from 0 to 9, as the label, i.e., the dimension of onehot encoding is 10, which is fixed in the latent layer. And for Covid-19, a three classification task is designed, i.e., each image is labeled by a patient with Covid-19, a patient with other disease or a healthy patient. We use the parameters given in Table 2 and the initial dimension presented in Table 3 , then we get the convergent dimension to be 4 and 5 for these two data sets, also exhibited in Table 3 , after applying Algorithm 2 to CVAE. Further, we make some comparison experiments through testing sets between the CVAE models at the convergent dimensions and at others. The results are reported in Table 8 . Also, as one might expect, the optimal results appear at the convergent dimension. In addition, the generated MNIST and Covid-19 images, shown in Figs. 11 and 12, respectively, support this point likewise. Hence, Algorithm 2 witnesses success again for CVAE working on the used data sets. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1011,
                    "end": 1018,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 1058,
                    "end": 1065,
                    "text": "Table 3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 1162,
                    "end": 1169,
                    "text": "Table 3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 1370,
                    "end": 1377,
                    "text": "Table 8",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "Experimental results of CVAE"
        },
        {
            "text": "As a kind of popular generative models, VAE may be compared favorably with GAN. The proposed dimension reduction strategy further enhances the performance of VAE in generating clearer images. However, compared with GAN, the current model is still within the framework of VAE, and possesses the intrinsic weaknesses that VAE has. A key one is that only the lower bound, i.e., ELBO, of log P(x), but not itself, is optimized in the VAE model. Another weakness is the strong assumption to the distribution of fake images that says every pixel is independent of each other. These may lead to less clear fake images than those generated by GAN. We display their comparisons in Fig. 9 , where MNIST image in subfigure (d) is generated by GAN [2] and the yellow frames point out the most clear digits. By comparing them to the same most clear digits in subfigure (b), we can find digits \"9\" and \"8\" look more clear in (d).",
            "cite_spans": [
                {
                    "start": 736,
                    "end": 739,
                    "text": "[2]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 672,
                    "end": 678,
                    "text": "Fig. 9",
                    "ref_id": "FIGREF9"
                }
            ],
            "section": "Comparisons with other start-of-the-art methods"
        },
        {
            "text": "However, VAE has its own advantages. This first one is that it can generate specific images we want, but GAN takes the Gaussian noise as an input and generates the images randomly, with the whole process totally uncontrollable. In addition, the images generative process of GAN is unstable and needs more computation resource [2] . Finally, instead of training a generator directly, VAE combines the encoder and decoder as a generator which gives more interpretability to the model [3] . This can be seen from the right hand side of the Eq. (2), where the second term measures the information from data x with the Gaussian noise i.e. how much information is encoded from data set, and the first term measures the information we need to reconstruct x from z sampled from encoder.",
            "cite_spans": [
                {
                    "start": 326,
                    "end": 329,
                    "text": "[2]",
                    "ref_id": null
                },
                {
                    "start": 482,
                    "end": 485,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Comparisons with other start-of-the-art methods"
        },
        {
            "text": "This paper has proposed an adaptive dimension reduction algorithm to reduce the dimension of latent variables contained in VAE related models. By introducing \u03c0 and Lagrange loss, we have proved that the algorithm is convergent and has the property of invariance of convergent result, although there are many random factors during the operating steps. We have also proved the convergent dimension of every time experiment is the local minimum point of the infimum of the training loss function around its finite range. We use six frequently-used data sets, including two large-sized data sets, to validate that the algorithm is rather effective both in precision and in efficiency, where the latter is reflected by a great reduction of the model parameters after implementing the algorithm. In addition, the algorithm, with the help of \u03c0, provides another point of interpretability to neural networks that which units contain noise (inactivate) and which units contain useful information (activate) in the latent variables layer. As an extra finding, the algorithm can be applied again and again to generate more compact and higher-precision VAE by symmetrically constructing hidden layers in encoder and decoder.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Note that in this paper the proposed algorithm works within the framework of VAE or CVAE. Actually, it can work for any model with the similar structure of VAE. The trick of using element-wise multiplication of \u03c0 is also extended to other dimension reduction techniques.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Proof. Let \u03c0m = Opt(L(ones(m)), n) where \u03c0m \u2208 \u03a0m. Since \u03c0m is unchanged after enough epochs, then inf \u03c0m\u2208\u03a0m h z\u2297\u03c0m = h z\u2297\u03c0m , for i=1,2,...\u00f1",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Proof of Theorem 2"
        },
        {
            "text": "where \u03c0m +i \u2208 \u03a0m +i . By the assumption, we get h z\u2297\u03c0m < h z\u2297\u03c0m+i .The units of latent variables which is related to zeros are considered as noise and the units which related to ones are considered contain information, thus the equality is achieved for any \u03c0m, then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Proof of Theorem 2"
        },
        {
            "text": "In another hand, for any \u03c0m \u2212i \u2208 \u03a0m \u2212i ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Proof of Theorem 2"
        },
        {
            "text": "Therefore, h z\u2297\u03c0m < h z\u2297\u03c0m\u2212i , by the arbitrariness of \u03c0m \u2212i , we have",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Proof of Theorem 2"
        },
        {
            "text": "Combining the equation (13), (14) and the fact that inf ",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 33,
                    "text": "(14)",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "A. Proof of Theorem 2"
        },
        {
            "text": "Proof. First of all, we assume that the Q(z|x),P(x|z) have been trained on the training set and have the same parameters as Q(\u03c0 \u2297 z|x),P(x|\u03c0 \u2297 z) do. we use z i to represent the latent variable whose dimension is i It is easy to prove that m = 0 can not be the convergent dimension since m = 0 means no data are passed to the decoder, the fake data generated by the decoder is all noise and the equation (4) can not be achieved, so if we set z 1 as the initial latent variable, it will not decrease anymore. Since the z i is finite, there is a integer s such that dim z s+1 as the initial latent variable is changeable and z s is unchangeable. That is to say the Algorithm 2 is convergent We assume that we run the Algorithm 2 at the initial dimension m and returnm, then by the definition of the algorithm,m is convergent dimension if and only if for i=1,2...min(\u00f1,m),",
            "cite_spans": [
                {
                    "start": 404,
                    "end": 407,
                    "text": "(4)",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "B. Proof of Theorem 3"
        },
        {
            "text": "Sincem is unchanged after enough epoch, by the arbitrariness of \u03c0m \u2212i , we have inf \u03c0m\u2212i\u2208\u03a0m\u2212i hz \u2297\u03c0m\u2212i \u2212 hz \u2265 , which is independent with the choice of \u03c0m \u2212i , thus is independent with the randomicity of Algorithm 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Proof of Theorem 3"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Auto-encoding variational bayes",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "P"
                    ],
                    "last": "Kingma",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Welling",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "CoRR",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Tutorial on variational autoencoders",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Doersch",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Markov chain monte carlo and variational inference: Bridging the gap",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Salimans",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kingma",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Welling",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "International Conference on Machine Learning",
            "volume": "",
            "issn": "",
            "pages": "1218--1226",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Stochastic backpropagation and approximate inference in deep generative models",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "J"
                    ],
                    "last": "Rezende",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mohamed",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wierstra",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "International conference on machine learning",
            "volume": "",
            "issn": "",
            "pages": "1278--1286",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Draw: A recurrent neural network for image generation",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Gregor",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Danihelka",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Graves",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Rezende",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wierstra",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "International Conference on Machine Learning",
            "volume": "",
            "issn": "",
            "pages": "1462--1471",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Learning structured output representation using deep conditional generative models",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Sohn",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Yan",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "NIPS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "An uncertain future: Forecasting from static images using variational autoencoders",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Walker",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Doersch",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gupta",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hebert",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "ArXiv",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Stein variational gradient descent: A general purpose bayesian inference algorithm",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "NIPS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Beta-vae: Learning basic visual concepts with a constrained variational framework",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Higgins",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lm",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Cb",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mb",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proc. ICLR",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Composing graphical models with neural networks for structured representations and fast inference",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Johnson",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "K"
                    ],
                    "last": "Duvenaud",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wiltschko",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "P"
                    ],
                    "last": "Adams",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Datta",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Advances in neural information processing systems",
            "volume": "29",
            "issn": "",
            "pages": "2946--2954",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Principal component analysis: a review and recent developments",
            "authors": [
                {
                    "first": "I",
                    "middle": [
                        "T"
                    ],
                    "last": "Jolliffe",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Cadima",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences",
            "volume": "374",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Sequential minimal optimization : A fast algorithm for training support vector machines",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Platt",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Convex optimization",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Boyd",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "P"
                    ],
                    "last": "Boyd",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Vandenberghe",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Cross-age reference coding for age-invariant face recognition and retrieval",
            "authors": [
                {
                    "first": "B.-C",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "C.-S",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "H"
                    ],
                    "last": "Hsu",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the European Conference on Computer Vision (ECCV)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "VAE with 3 layers of encoder and 3 layers of decoder.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "The graphical structure of (a) VAE and (b) CVAE.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "CVAE with 3 layers of encoder and 3 layers of decoder.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Schematic of generating new latent variables by \u03c0.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Assume \u03c0m \u2208 \u03a0m is the output of Algorithm 1, where \u03a0m = {\u03c0 | \u03a3 i \u03c0 i =m}, then the infimum of the training loss function inf \u03c0m\u2208\u03a0m h z\u2297\u03c0m is achieved by the result of Algorithm 1 \u03c0m, and inf \u03c0\u03b1\u2208\u03a0\u03b1 h z\u2297\u03c0\u03b1 will attain the strict local minimum at \u03b1 =m for all integers \u03b1 \u2208 [m \u2212\u00f1,m +\u00f1] with\u00f1 = min{n,m, m \u2212m}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Given a group of specific m and n, Algorithm 2 is convergent, and the invariance of convergent dimension under it is independent of the randomicity of the optimizer in Line 2.Proof. The detailed proof can be found in Appendix B.Theorem 4. Every iteration in Algorithm 2 returns a VAE with smaller loss on training set. Proof. Consider a random epoch in Algorithm 2, let m be the dimension of the latent variables vector z at the beginning of this epoch andm be the dimension of the latent variables vectorz we get after this epoch, then there is a \u03c0m \u2208 \u03a0m such that \u03c0m = Opt(L(Q m , p m , ones(m)), n), thush z\u2297\u03c0m \u2212 h z \u2264Without losing generality, we let = 0, we have h z\u2297\u03c0m \u2264 h z , and by the Lemma 1, hz \u2264 h z .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "The generation process of VAE through applying Algorithm 2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "MNIST images generated by the VAE models with different latent variables: (a) original images; (b) 22 dimensions (convergent); (c) 50 dimensions; (d) 100 dimensions. The red frames identify some unclear parts of images. The same mark is used in Figs. FashionMNIST images generated by the VAE models with different latent variables: (a) original images; (b) 15 dimensions (convergent); (c) 50 dimensions; (d) 100 dimensions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "ATTfaces images generated the VAE models with different latent variables: (a) original images; (b) 100 dimensions (convergent); (c) 150 dimensions; (d) 400 dimensions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "MNIST images: (a) original image, the same to Fig. 6(a); (b) generated by the new better VAE model; (c) the same to Fig. 6 (b); (d) generated by GAN from [2]. The yellow frames in (b) serves for identifying the most clear digits for comparisons with the same most clear ones in (d).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Covid-19 images generated by the VAE models with different latent variables: (a) original images; (b) 4 dimensions (convergent); (c) 50 dimensions; (d) 100 dimensions. Covid-19 images generated by the CVAE models with different latent variables: (a) original images; (b) 5 dimensions (convergent); (c) 50 dimensions; (d) 100 dimensions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "MNIST images generated by the CVAE models: (a) original images; (b) 22 dimensions (convergent); (c) 50 dimensions; (d)70 dimensions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "z\u2297\u03c0m , we have that inf \u03c0m\u2208\u03a0m h z\u2297\u03c0m is a local minimum, since the number of elements in \u03a0m +i and \u03a0m \u2212i is finite which means inf \u03c0m\u2212i\u2208\u03a0m\u2212i h z\u2297\u03c0m\u2212i and inf \u03c0m+i\u2208\u03a0m+i h z\u2297\u03c0m+i are achievable, so we can replace the \u2264 into <, then we have the strictness of this local minimum.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Basic information about six data sets",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Experimental setups for six data sets",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Comparisons between the initial dimension and the convergent one of latent variables on six data sets Loss\" values will increase, which means the remain units have important information about data set. At this point, the convergent dimensions seem to be the \"turning points\" to distinguish noise and information of units of latent variables in VAE in modelling the data sets of MNIST and FashionMNIST. This conversely indicates that Algorithm 2 can work effectively for weakening overfitting phenomenon through reducing dimension of latent variables in the VAE model.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Testing results of VAE on MNIST and FashionM-NIST at different dimensions of latent variables",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "Comparison between the number of parameters in previous convergent VAE and in new better VAE",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}