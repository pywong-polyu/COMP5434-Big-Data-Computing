{"paper_id": "7996942f52548a63ecd5b5c7ecaaf9d779f8ee86", "metadata": {"title": "SAT-Based Encodings for Optimal Decision Trees with Explicit Paths", "authors": [{"first": "Mikol\u00e1\u0161", "middle": [], "last": "Janota", "suffix": "", "affiliation": {"laboratory": "", "institution": "Universidade de Lisboa", "location": {"settlement": "Lisbon", "country": "Portugal"}}, "email": "mikolas.janota@gmail.com"}, {"first": "Ant\u00f3nio", "middle": [], "last": "Morgado", "suffix": "", "affiliation": {"laboratory": "", "institution": "Universidade de Lisboa", "location": {"settlement": "Lisbon", "country": "Portugal"}}, "email": ""}]}, "abstract": [{"text": "Decision trees play an important role both in Machine Learning and Knowledge Representation. They are attractive due to their immediate interpretability. In the spirit of Occam's razor, and interpretability, it is desirable to calculate the smallest tree. This, however, has proven to be a challenging task and greedy approaches are typically used to learn trees in practice. Nevertheless, recent work showed that by the use of SAT solvers one may calculate the optimal size tree for real-world benchmarks. This paper proposes a novel SAT-based encoding that explicitly models paths in the tree, which enables us to control the tree's depth as well as size. At the level of individual SAT calls, we investigate splitting the search space into tree topologies. Our tool outperforms the existing implementation. But also, the experimental results show that minimizing the depth first and then minimizing the number of nodes enables solving a larger set of instances.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Decision trees play an important role in machine learning either on their own [6] or in the context of ensembles [5] . Learning decision trees is especially attractive in the context of interpretable machine learning due to their simplicity. However, despite this simplicity, minimization of decision trees is well-known to be an NPhard problem [10, 16] . Yet, smaller trees are likely to generalize better.", "cite_spans": [{"start": 78, "end": 81, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 113, "end": 116, "text": "[5]", "ref_id": "BIBREF5"}, {"start": 345, "end": 349, "text": "[10,", "ref_id": "BIBREF10"}, {"start": 350, "end": 353, "text": "16]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Introduction"}, {"text": "To learn trees, suboptimal, greedy algorithms are used in practice. With the rise of powerful reasoning engines, recent research has tackled the problem by the use of SAT, CSP, or MILP solvers [1, 27, 37, 38] . Indeed, the state-ofthe-art technology shows that many (NP) hard problems are often successfully solved. Conversely, such applications drive the reasoning technology by providing interesting benchmarks. This paper, follows this line of research and proposes a novel SAT-based encoding. This encoding enables finding a decision tree conforming to the given set of examples with a given depth and number of nodes. A minimal tree is found by iterative calls to a SAT solver while minimizing size and depth.", "cite_spans": [{"start": 193, "end": 196, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 197, "end": 200, "text": "27,", "ref_id": "BIBREF28"}, {"start": 201, "end": 204, "text": "37,", "ref_id": "BIBREF38"}, {"start": 205, "end": 208, "text": "38]", "ref_id": "BIBREF39"}], "ref_spans": [], "section": "Introduction"}, {"text": "Focusing not only on size but also on depth of the tree brings about opportunities for further analysis. Intuitively, more shallow trees are less likely to over-fit.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Indeed, modern packages such as Scikit [30] enable imposing a threshold on the depth, which users have to set manually. Also, a shallow tree is more likely to be interpretable by a human because less memory is required to keep track of a single branch.", "cite_spans": [{"start": 39, "end": 43, "text": "[30]", "ref_id": "BIBREF31"}], "ref_spans": [], "section": "Introduction"}, {"text": "The problem at hand is of challenging complexity. In practice, we may need to deal with a high number of features and examples, which brings the searchspace of possible trees into extreme dimensions. Looking for an optimal tree means not only finding such tree but also proving that no smaller tree exists.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "The SAT technology has recently shown a lot of promise in tackling difficult combinatorial questions, e.g. Erd\u0151s' discrepancy [22] or the Boolean Pythagorean triples problem [13] , among others. Inspired by these results we also investigate the splitting of search-space based on the topology of the decision tree. The paper has the following main contributions.", "cite_spans": [{"start": 126, "end": 130, "text": "[22]", "ref_id": "BIBREF22"}, {"start": 174, "end": 178, "text": "[13]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Introduction"}, {"text": "1. It proposes a novel SAT-based encoding for decision trees, along with a number of optimizations. 2. Compared to existing encoding, rather than representing nodes it represents paths of the tree. This enables natively controlling not only the tree's size but also the tree's depth. 3 . It shows that minimizing depth first and then size enables tackling harder instances. 4 . It shows that search-space splitting by topologies enables tackling harder instances. 5. The implemented tool outperforms existing work [27] .", "cite_spans": [{"start": 284, "end": 285, "text": "3", "ref_id": "BIBREF3"}, {"start": 374, "end": 375, "text": "4", "ref_id": "BIBREF4"}, {"start": 514, "end": 518, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Introduction"}, {"text": "Standard notions and notation for propositional logic are assumed [36] . A literal is a Boolean variable (x) or its negation (denoted \u00acx); a clause is a disjunction of literals a cube is a conjunction of literals. A formula is in conjunctive normal form (CNF) if it is a conjunction of clauses. General Boolean formulas are also considered constructed by using the standard connectives conjunction (\u2227), disjunction (\u2228), implication (\u2192), bi-implication (\u2194). State-of-the-art SAT solvers typically accept input in CNF. Non-CNF formulas are converted to CNF by standard equisatisfiable clausification methods [31] .", "cite_spans": [{"start": 66, "end": 70, "text": "[36]", "ref_id": "BIBREF37"}, {"start": 606, "end": 610, "text": "[31]", "ref_id": "BIBREF32"}], "ref_spans": [], "section": "Preliminaries"}, {"text": "Several constraints in the paper also rely on cardinality constraints [34] . These are also turned into CNF through standard means, the implementation avails of the cardinality encodings in the tool PySAT [18, 26] .", "cite_spans": [{"start": 70, "end": 74, "text": "[34]", "ref_id": "BIBREF35"}, {"start": 205, "end": 209, "text": "[18,", "ref_id": "BIBREF18"}, {"start": 210, "end": 213, "text": "26]", "ref_id": "BIBREF27"}], "ref_spans": [], "section": "Preliminaries"}, {"text": "Standard setting of supervised learning is assumed [35] . Following notation and concepts of [27] we expect features to be binary (with values 0, 1). Non-binary features can be reduced to binary by unary or binary encoding. Analogously, classes are also binary (positive, negative). ", "cite_spans": [{"start": 51, "end": 55, "text": "[35]", "ref_id": "BIBREF36"}, {"start": 93, "end": 97, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Training Data"}, {"text": "The objective is to develop a propositional formula whose models are decision trees congruent with the given set of samples. Such model then is found by a call to an off-the-shelf SAT solver. As customary, we take the approach of optimizing by solving a series of decision problems. This means finding a decision tree with a certain size and diminishing the size until no such tree exists. Alternatively, other type of search can be used, e.g., binary or progression.", "cite_spans": [], "ref_spans": [], "section": "SAT-Based Optimization of Decision Trees"}, {"text": "This paper targets two optimization criteria: size and depth. Minimizing any combination of the two may be potentially be of interest. Section 5 discusses the exact type of search used in the implementation.", "cite_spans": [], "ref_spans": [], "section": "SAT-Based Optimization of Decision Trees"}, {"text": "The structure of binary trees guarantees a number of well-known properties. Any tree with n nodes has (n + 1)/2 leaves and (n \u2212 1)/2 internal nodes. Further, n is always odd and the number of leaves is equal to the number of paths going from the root to a leaf. Our encoding heavily exploits this property: Rather than modeling nodes of a tree, we model the set of unique paths from the root to leaves.", "cite_spans": [], "ref_spans": [], "section": "SAT-Based Optimization of Decision Trees"}, {"text": "The optimization algorithm has two levels. At the first level, search is being carried out on the tree's size and depth. At the second level, the decision problem of finding a tree with such depth and size is solved via a SAT solver. The SAT solver is used in a black-box fashion, i.e., the problem is encoded into its propositional form and any off-the-shelf SAT solver may be used to solve it.", "cite_spans": [], "ref_spans": [], "section": "SAT-Based Optimization of Decision Trees"}, {"text": "In the remainder of this section we focus on the decision problem, which is invoked with a given number of paths P (controlling size) and maximum allowed number of steps in a path S (controlling depth).", "cite_spans": [], "ref_spans": [], "section": "SAT-Based Optimization of Decision Trees"}, {"text": "The steps in a path are numbered in the following way. In the first step, each path is in the root. In the last step of a path, the path goes from an internal node to a leaf. This means that if we are looking for a tree with a particular depth and particular number of nodes we set S and P accordingly. If we are looking only for a tree with minimal number of nodes but with an arbitrary depth, the value of S is set to P \u2212 1, which corresponds to the number of internal nodes.", "cite_spans": [], "ref_spans": [], "section": "SAT-Based Optimization of Decision Trees"}, {"text": "The encoding we propose models each path from the root to a leaf separately while imposing relations between them that guarantee that the paths form a binary tree. Throughout the paper, we use the convention that for a node labeled by a feature f , the left child corresponds to the value 0 of f and the right child corresponds to the value 1 of f . To model the tree, introduce a matrix of variables, where each row represents a path and each column represents a step in the path. The first row (the first path) is a path that only goes to the left-it is the leftmost path in the tree. Analogously, the last row (the last path) is a path that only goes to the right-it is the rightmost path in the tree. In general, the paths are ordered in the way they would be obtained by running DFS that goes to the left first.", "cite_spans": [], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "Each path corresponds to a sequence of 0's and 1's so that 0 is a step to the left and 1 is a step to the right. Then, we consider these paths in a lexicographic order. Each path is represented by a sequence of variables, one for each step, where the variable represents whether the path goes left or right in that step. Additionally, for each step we need to remember whether the path has already terminated and which prefix is shared with the previous path. Table 1 summarizes the main variables of the encoding. The direction of each step s in a path p is determined by the variable g p s . What is somewhat unusual about this encoding is that paths may share prefixes. To that effect, the variable e p s represents that the path p in step s is in the same node as the preceding path p \u2212 1. The semantics of the variables e p s is defined inductively. All paths share the root and therefore e p 1 must be always true. In further steps, paths p and p \u2212 1 remain equal as long as both paths take steps in the same direction.", "cite_spans": [], "ref_spans": [{"start": 460, "end": 467, "text": "Table 1", "ref_id": "TABREF1"}], "section": "Path-Based Encoding"}, {"text": "Since it is unknown beforehand how many steps are in either path, the variables t p s determine whether the path has already terminated or not. Observe that the variables t p s go up to step S + 1, whereas the variables g p s go only to step S. This is because the g p s variables correspond to edges in the path while termination is tracked for nodes (as well as equality). A terminated path remains terminated and cannot terminate if it is still equal to the previous one. Any path ", "cite_spans": [], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "Example 1. Figure 1 shows a binary tree along with the values of the topology variables (g p s , t p s , and e p s ). The tree is comprising 4 leaves, therefore 4 paths. In this simple example each path makes two steps and then it terminates. The second path shares everything with the first one except for the leaf. The third path only shares the root with the second path. The last path shares everything with the third path, except for the leaf. Observe that since this is a full binary tree, the g p s variables represent the binary numbers from 0 to 3. Now it is necessary to ensure that the paths are lexicographically ordered. The first path always goes left and the last one always goes right. If a path p in step s is in the same node as path p \u2212 1, the path p can go left only if p \u2212 1 also went left (otherwise they would cross).", "cite_spans": [], "ref_spans": [{"start": 11, "end": 19, "text": "Figure 1", "ref_id": "FIGREF0"}], "section": "Path-Based Encoding"}, {"text": "The lexicographic order alone does not guarantee a correct topology. Since the tree is binary, any path must adhere to the following pattern. For a certain number of steps it shares the prefix with the preceding path until it breaks off. Once it breaks off, it has to go only to the left (or terminate). At the same time, the preceding path can only go right after the break-off point (or terminate). Otherwise, there would be a gap in the tree. Figure 2 illustrates these constraints. Consider the blue path, R \u2192 A \u2192 B \u2192 E and the red path, R \u2192 A \u2192 C \u2192 F , where the blue one is lexicographically smaller. The paths diverge in node A-blue goes left, the red goes right. Afterwards, the blue path may only go right or terminate. In contrast, the red path may only go left or terminate. The reason why this has to be the case is that for the red one to follow blue in our ordering, the blue one has to contain the last path for the subtree rooted in B while the red one has to contain the first path for the subtree rooted in C.", "cite_spans": [], "ref_spans": [{"start": 446, "end": 454, "text": "Figure 2", "ref_id": "FIGREF1"}], "section": "Path-Based Encoding"}, {"text": "Assigning Features and Their Semantics. The encoding of semantics of the training data is similar to the one in [27] but with two major differences:", "cite_spans": [{"start": 112, "end": 116, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "1. Here classification is only per path, while in [27] it is per node because any node can potentially be a leaf, which means semantics of the examples in our approach need only to be repeated (n + 2)/2 times rather than n times. 2. Our encoding introduces explicit variables to track whether a given training example is matched for a given path, this is useful for one of the optimizations (see Sect. 3.2).", "cite_spans": [{"start": 50, "end": 54, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "We make sure that each step is assigned exactly one feature and that no feature appears more than once on any path.", "cite_spans": [], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "Recall that an example is seen as a set of feature-value pairs. We say that a feature-value pair f, v is matched on a path if the path makes a step in the direction of v in the node that is assigned the feature f . An example is matched if all its feature-value pairs are matched. These two concepts are modeled by the variables m p f,v and m p q , respectively. Observe that f, v is also matched on any path that does not contain f at all. Finally, once a path matches any positive example, it must be classified as positive and the other way around.", "cite_spans": [], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "Summary of the Encoding. The constraints (1)- (16) are parameterized by natural numbers P and S and their satisfying assignments represent a sequence of P paths in a binary tree from the root to a leaf, where each path has at most S edges. The paths are lexicographically ordered, starting from the leftmost path and ending in the rightmost one. Additionally, the encoding ensures that there are no gaps between paths and therefore these represent the whole binary tree. Each node in a path is labeled by a feature in a way that shared prefixes among paths are labeled by the same features. Each path is assigned a classification class that must be congruent with the training examples given on the input.", "cite_spans": [{"start": 46, "end": 50, "text": "(16)", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Path-Based Encoding"}, {"text": "The enforce that the child of a node assigned in the direction of the value v is a leaf classified with the class c. At the formula level, we add the following constraint for s \u2208 1..S and p \u2208 1..P.", "cite_spans": [], "ref_spans": [], "section": "Path Encoding Optimizations"}, {"text": "Path Lower Bounds. We propose to use MaxSAT to obtain lower bounds on the length of a path. The question we ask is what is the shortest possible path that separates positive and negatives examples. Since the lower bound considers only one path at a time, the order of features on that path is irrelevant. In preliminary experiments we have observed rather small lower bounds. However, the bound can be improved for the leftmost and rightmost branches. This gives us three types of bounds: for the leftmost and rightmost branches, and for any branch in between. In any path a feature either does not appear, or appears on a step that goes left or on a step that goes right. To model this behavior we introduce two variables for each feature x 0 f and x 1 f (similar to the dual rail encoding [25] ). This corresponds to the following hard and soft constraints.", "cite_spans": [{"start": 791, "end": 795, "text": "[25]", "ref_id": "BIBREF26"}], "ref_spans": [], "section": "Path Encoding Optimizations"}, {"text": "Upon initial experiments, we observed that the SAT solver may struggle even on decision trees of modest size, e.g. 9 nodes. This is somewhat surprising because the number of topologies does not initially grow that much; see Table 2 . This suggests splitting the search space into individual topologies and call the SAT solver for each one of them separately. Like so, the SAT solver only needs to find the labeling of the tree. Intuitively this should be an easier problem because the SAT solver only needs to deal with one type of decisions. This approach is not generally viable because eventually the number of topologies is too large. To which we propose the following approach. The upper part of the topology is fixed-until a certain depth-and the rest is left for the SAT solver to complete. This gives rise to topology templates. Each topology template is a tree, where each leaf is an actual leaf ( ) of the topology or an incomplete subtree ( ). ", "cite_spans": [], "ref_spans": [{"start": 224, "end": 231, "text": "Table 2", "ref_id": "TABREF3"}], "section": "Search-Space Splitting by Topologies"}, {"text": "Algorithm 1 recursively enumerates incomplete topologies on n nodes with the cut-off parameter d. In order to avoid repetitions in enumeration, certain cases need to be treated separately. If the cut-off parameter reaches 1, the children of the current node will either be leaves ( ) or incomplete subtrees ( ). This, in general gives three scenarios where either the left or the right child is a leaf and the second child is a subtree, or both are subtrees. However, in the case of n = 3, n = 5 the scenarios are different. Observe that because of the cut-off parameter, the generated topology template may have less than n nodes.", "cite_spans": [], "ref_spans": [], "section": "Search-Space Splitting by Topologies"}, {"text": "We study topology enumeration both for our encoding as well as the encoding of Narodytska et al. [27] . A given topology template in the encoding of Narodytska et al. is enforced by a cube corresponding to the child relation and the information whether a node is a leaf or not. An important property of our generation procedure is that the cut-off parameter is equal on all branches. This means that numbering the topology template by BFS gives the same numbers as a BFS on any topology corresponding to it. Since the encoding of mindt relies on BFS, this property lets us directly translate the relation into a cube.", "cite_spans": [{"start": 97, "end": 101, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Search-Space Splitting by Topologies"}, {"text": "Our path-based encoding does not allow easily encoding a topology template because the number of paths in an incomplete subtree ( ) is unknown. To this effect, we introduce a variation on the topology template where the leaves of the topology template are actual leaves ( ) or an incomplete subtree with a given cardinality (#k). These topology templates can be easily enumerated as shown by Algorithm 2. Observe that the number of these topology templates may be larger than in the previous version. Such topology template is encoded into our path-based model in a straightforward fashion. Each path in the topology template fixes the direction in prefixes in a certain number of paths. The number of these paths corresponds to the #k node at the end of the path. Any path terminating in corresponds exactly to one path in the path-based model.", "cite_spans": [], "ref_spans": [], "section": "Search-Space Splitting by Topologies"}, {"text": "A cube describing a topology template can either be encoded into assumptions to enable incremental SAT solving [7] or appended as a set of unit clauses. We observed that in our case incremental solving does not pay off for hard instances. However, at the same time, if a large number of topology templates need to be examined, initializing a new SAT solver for each one of them is too costly. Therefore, the implementation employs both modes, incremental and nonincremental, depending on the number of topology templates to be examined. Another point of interest is the order in which the topology templates are examined. In the case of non-incremental SAT solving and unsatisfiable instances, the order does not matter because all formulas need to be solved independently of one another. Hence, the order plays mainly a role in the case of satisfiable instances. The order heuristics we propose is the following.", "cite_spans": [{"start": 111, "end": 114, "text": "[7]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Topology Enumeration"}, {"text": "We start with the assumption that we already have a suboptimal solution to the problem from a greedy (fast) algorithm. We would like to first focus on topologies that are similar to the topology of this suboptimal solution. In order to do so, we need some notion of difference between topologies (and topology templates). For this purpose we define a simple function that recursively compares the two topologies and accumulates a penalty once they are different. Additionally, subtrees with lower depth are accounted with less weight.", "cite_spans": [], "ref_spans": [], "section": "Topology Enumeration"}, {"text": "Algorithm 3 shows the function. If one of the given trees is empty, the penalty is the size of the other tree weighted by the factor w. Otherwise, the penalties are calculated as a sum of the left and the right subtrees, respectively. As the recursion descends, the weight is gradually decayed by the factor \u0394 \u2208 (0, 1]. In the implementation we chose the ad-hoc value of 0.75.", "cite_spans": [], "ref_spans": [], "section": "Topology Enumeration"}, {"text": "When partitioning the search space, the topology templates are enumerated in the increasing order of the difference from the suboptimal solution.", "cite_spans": [], "ref_spans": [], "section": "Topology Enumeration"}, {"text": "The tool was implemented on top of the PySAT package [18] , which interfaces with a number of modern SAT solvers and provides a number of implementations of cardinality encodings. We used the CaDiCaL solver [3] and the k-Cardinality Modulo Totalizer [26] . This configuration was chosen after some careful preliminary experiments. We show that this configuration performs significantly better than the configuration used in the evaluation of Narodytska et al.", "cite_spans": [{"start": 53, "end": 57, "text": "[18]", "ref_id": "BIBREF18"}, {"start": 207, "end": 210, "text": "[3]", "ref_id": "BIBREF3"}, {"start": 250, "end": 254, "text": "[26]", "ref_id": "BIBREF27"}], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "Our preliminary experiments also informed other ad-hoc choices that had to be made as the search and encodings can be configured in a large number of ways. An alternative would be to employ automated parameter tuning in the spirit of ParamILS [15] ; we leave this as future work.", "cite_spans": [{"start": 243, "end": 247, "text": "[15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "The SAT solver is used in a non-incremental fashion, i.e., every decision problem is solved independently of the other ones. The exception is topology enumeration: if the number of topologies is larger than 500, the incremental mode is employed (see Sect. 4).", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "A suboptimal greedy solution is obtained by the popular modern machine learning library Scikit-learn [30] , which also enables a seamless integration with the Python implementation. The greedy solution is used in two scenarios: 1) to obtain an upper bound on the number of nodes in the solution 2) to inform the ordering of topologies during enumeration (see Sect. 4).", "cite_spans": [{"start": 101, "end": 105, "text": "[30]", "ref_id": "BIBREF31"}], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "The experiments were performed on servers with Intel(R) Xeon(R) CPU at 2.60 GHz, 24 cores, 64 GB RAM, while always running 4 tasks in parallel. The time limit was set to 1000 s and the memory limit to 3 GB. The experimental results report on the following search modes:", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "(1) binary search on the number of nodes with no restriction on the depth without topology enumeration (with sklearn upper-bound) (2) linearly increasing the number of nodes with no restriction on the depth with topology enumeration (linear UNSAT-SAT search) (3) linearly increasing depth and linearly increasing number of nodes for each considered depth.", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "Searches (1) and (2) find the smallest tree just as in [27] . The search (3) finds the smallest tree in the lexicographic ordering of the pair depth-size.", "cite_spans": [{"start": 55, "end": 59, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "The evaluation was carried out on the benchmarks used in [27] , kindly provided by Narodytska. These benchmarks were originally obtained by sampling a large set of instances [29] , with sampling percentages of 20%, and 50% (we have used the same exact sampled benchmarks as Narodytska et al.). The reader is referred to [27] for the details of the sampling procedure.", "cite_spans": [{"start": 57, "end": 61, "text": "[27]", "ref_id": "BIBREF28"}, {"start": 174, "end": 178, "text": "[29]", "ref_id": "BIBREF30"}, {"start": 320, "end": 324, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "We compare our tools with the state-of-the-art tool mindt [27] . Our tool is run in the following configurations. The configuration dtfinder corresponds to the search (1), i.e. size minimization via binary search and path-based encoding. The configuration dtfinder-DT1 is the same type of search but with encoding of Narodytska et al. The suffix -T in a configuration indicates topology-based ing. The configuration d-dtfinder corresponds to the search (3), i.e. depth-size minimization. Table 3 summarizes results for all the considered benchmarks and tools. The first row (%) shows the percentage of random samplings used to construct the instance, the second row the average number of features (nf.) and samples (ns.). The third row (#I) shows the number of benchmarks in that category. The remaining rows are grouped according to the tool they represent. For each of the tools we present four values: the average number of nodes discovered (#nd); the average depth of the tree reported (depth); the average CPU time taken in solved instances (cpu-time); and the number of instances solved (#slv). Figure 3 shows a histogram of the sizes of the optimal trees per solver. The vertical axis shows the number of solved instances and the horizontal groups the solvers according to the number of nodes of the reported decision trees. More detailed overview of the data can be found here on the authors' website [20] . Table 3 enables the following conclusions. Our implementation (dtfinder) outperforms the tool by Narodytska et al. (mindt) in all cases. This is also the case for their encoding; We attribute this to the choice of cardinality encoding and the SAT solver. We used k-Cardinality Modulo Totalizer and CaDiCaL while mindt uses sequential counter and glucose-0.3.", "cite_spans": [{"start": 58, "end": 62, "text": "[27]", "ref_id": "BIBREF28"}, {"start": 1409, "end": 1413, "text": "[20]", "ref_id": null}, {"start": 1513, "end": 1538, "text": "Narodytska et al. (mindt)", "ref_id": null}], "ref_spans": [{"start": 488, "end": 495, "text": "Table 3", "ref_id": null}, {"start": 1101, "end": 1109, "text": "Figure 3", "ref_id": "FIGREF4"}, {"start": 1416, "end": 1423, "text": "Table 3", "ref_id": null}], "section": "Experimental Evaluation"}, {"text": "Comparing dtfinder with d-dtfinder, we can see that d-dtfinder is faster to compute a minimum depth solution than dtfinder is to compute a minimum size solution and even more interestingly, again solves even more instances.", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "The topology search-space splitting is beneficial in all encodings except for depth minimization. Both our encoding and encoding of Narodytska et al. solves more instances with topology enumeration. Not always this helps the average CPU time; however, it went from 60s to 39s in path-based encoding for the 0.5 instances. The ordering of topologies enables a minor speed-up but overall the effect is small.", "cite_spans": [], "ref_spans": [], "section": "Experimental Evaluation"}, {"text": "The distribution of sizes of solved instances (Fig. 3) shows that the hardness of an instance grows drastically with the size. While depth minimization is able to solve a handful of instances of size 29, the path-based encoding solves just 1, our implementation of Narodytska et al. none and, surprisingly mindt 1. This can be attributed to the number of topologies (see Table 2 ).", "cite_spans": [], "ref_spans": [{"start": 46, "end": 54, "text": "(Fig. 3)", "ref_id": "FIGREF4"}, {"start": 371, "end": 378, "text": "Table 2", "ref_id": "TABREF3"}], "section": "Experimental Evaluation"}, {"text": "Overall, focusing on minimizing depth first is computationally advantageous, yet yielding decision trees of good quality. We illustrate this on a particular instance. Figure 4 shows decision trees calculated by our approach minimizing depth first (d-dtfinder) and calculated by the greedy approach (sklearn). The optimal tree gives depth 6 and size 29, the greedy approach gives depth 11 and size 37. In contrast, the other approaches timeout on this instance in 1000 s.", "cite_spans": [], "ref_spans": [{"start": 167, "end": 175, "text": "Figure 4", "ref_id": "FIGREF5"}], "section": "Experimental Evaluation"}, {"text": "Greedy algorithms for learning decision trees based on recursive splitting are well-known [6, 32, 33] ; see also [8] for an overview.", "cite_spans": [{"start": 90, "end": 93, "text": "[6,", "ref_id": "BIBREF6"}, {"start": 94, "end": 97, "text": "32,", "ref_id": "BIBREF33"}, {"start": 98, "end": 101, "text": "33]", "ref_id": "BIBREF34"}, {"start": 113, "end": 116, "text": "[8]", "ref_id": "BIBREF8"}], "ref_spans": [], "section": "Related Work"}, {"text": "Various notions of optimality of decision trees appear in the literature. Some approaches focus on finding a tree with a fixed depth but with the best accuracy [1, 37, 38] . These approaches assume a full (perfectly balanced) binary tree of the fixed depth whose accuracy is to be optimized. While the problem is still very hard, it is in some sense easier because the topology is fixed and only the labeling needs to be calculated. However, combinations of these approaches in our approach is an interesting line of research.", "cite_spans": [{"start": 160, "end": 163, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 164, "end": 167, "text": "37,", "ref_id": "BIBREF38"}, {"start": 168, "end": 171, "text": "38]", "ref_id": "BIBREF39"}], "ref_spans": [], "section": "Related Work"}, {"text": "Another approach is taken by [14] , which optimizes a linear combination of accuracy and size. However, this approach is based on brute force search and in our experiments we were only able to synthesize trees with a handful of features while the considered benchmarks contain hundreds of features.", "cite_spans": [{"start": 29, "end": 33, "text": "[14]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Related Work"}, {"text": "Closest to our work is [27] , which uses SAT encoding to construct a sizeoptimal decision tree for a given set of consistent samples. In contrast to our work, individual nodes and their children relation are modeled explicitly. This means that a path from the root to a leaf is implicit. In principle, one could also restrict the depth of these implicit paths by adding additional counters or some other form of cardinality constraints. This is bound to be less efficient. Further, our encoding is closer to the idea of a tree. If the tree is modeled through nodes, it must be ensured that is in fact a tree via cardinality constraints-ensuring that each node has one and only one parent (except for the root) and that each internal node has two children. These cardinality constraints are not needed in our encoding. Since in our case, classes are per path rather than node we save half of the semantic constraint (see Sect. 3.1). It is interesting to compare how symmetries are broken in [27] , where restrictions are imposed on the possible children nodes. In our approach paths are ordered lexicographically rather than in an arbitrary order. This order lets us single out the leftmost in the rightmost branches, which turned out to be useful in lower-bounding the depth (Sect. 3.2). We remark that lexicographic order is a popular means of breaking symmetries in general graphs, cf. [12] .", "cite_spans": [{"start": 23, "end": 27, "text": "[27]", "ref_id": "BIBREF28"}, {"start": 990, "end": 994, "text": "[27]", "ref_id": "BIBREF28"}, {"start": 1388, "end": 1392, "text": "[12]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Related Work"}, {"text": "Earlier work for minimization of decision tree using Constraint Programming (CP) exists [2] . It was shown in [27] , that the approach by Narodytska et al. strictly outperforms the approach of Bessiere at al. this is most likely to be attributed to the fact that the CP encoding is asymptotically much larger.", "cite_spans": [{"start": 88, "end": 91, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 110, "end": 114, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Related Work"}, {"text": "Synthesis by calls to a SAT/SMT solver has seen increased interest in the recent years, cf. [19, 21, 28] . Haaswi et al. used topology enumeration to synthesize Boolean circuits [9] . The general idea is analogous to our approach (see Sect. 4). However, the set of possible topologies is partitioned differently. The possible topologies are DAGs, whereas they are trees in our case. Topologies in their approach belong to the same partition if they have the same number of nodes at each level (levels are obtained by BFS). This approach is unlikely to give good partitioning for binary trees and is more expensive to encode than our approach. Further, in our approach, the enumeration of topologies simply goes over all possible topologies if the number of nodes is small.", "cite_spans": [{"start": 92, "end": 96, "text": "[19,", "ref_id": "BIBREF19"}, {"start": 97, "end": 100, "text": "21,", "ref_id": "BIBREF21"}, {"start": 101, "end": 104, "text": "28]", "ref_id": "BIBREF29"}, {"start": 178, "end": 181, "text": "[9]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Related Work"}, {"text": "The well-known technique of cube-and-conquer (CnC) splits the search-space by a lookahead solver [11, 17] . The lookahead solver is run with a bound, which yields cubes to be decided by a traditional CDCL solver. Compared to our approach, CnC is much more general since it is applicable to any SAT instance, and, the lookahead solver is less likely to generate cubes that will be decided trivially. The downside is that CnC may not come up with a splitting as a human would. Further, the lookahead solver can be very costly. In our preliminary experiments, CnC performs much more poorly than a plain SAT solver on our instances. The order in which cubes are decided is also investigated by Heule et al. [11] .", "cite_spans": [{"start": 97, "end": 101, "text": "[11,", "ref_id": "BIBREF11"}, {"start": 102, "end": 105, "text": "17]", "ref_id": "BIBREF17"}, {"start": 703, "end": 707, "text": "[11]", "ref_id": "BIBREF11"}], "ref_spans": [], "section": "Related Work"}, {"text": "This paper proposes a novel SAT-based encoding for decision trees, which enables natively controlling both the tree's size and depth. We also study search-space splitting by topology enumeration. Our implementation outperforms existing work of [27] but also enables a finer control due to the explicit representation of paths of the tree. This finer control lets us optimize practically interesting instances that had been out of reach.", "cite_spans": [{"start": 244, "end": 248, "text": "[27]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "The proposed approaches open a number of avenues for future research. The solving itself could be further improved by better splitting, parallelization, and combining with cube-and-conquer [11] . While some preprocessing of the examples was already used in our optimization techniques (Sect. 3.2), further inspection could be used to draw more information from them, e.g. introduction of extended variables in the spirit of [23] . The proposed techniques could also be integrated into more expressive approaches, e.g. SMT-based synthesis [21] .", "cite_spans": [{"start": 189, "end": 193, "text": "[11]", "ref_id": "BIBREF11"}, {"start": 424, "end": 428, "text": "[23]", "ref_id": "BIBREF23"}, {"start": 538, "end": 542, "text": "[21]", "ref_id": "BIBREF21"}], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "At the application level, we are investigating the integration of our tool with some greedy approaches, e.g. ensembles, where only limited depth is considered. Or, consider a hybrid between a greedy approach and an exact approach where an exact approach is invoked on smaller sub-problems. It would be interesting to investigate whether trees with a smaller depth are really easier to understand and interpret, and, what is the trade-off between depth and size. Our approach provides the means to exactly quantify these metrics.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "The experimental evaluation shows that SAT solvers poorly handle a searchspace with many topologies. We believe that this represents an important challenge for the SAT community.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "INFOCOS with reference PTDC/CCI-COM/32378/2017. The results were supported by the Ministry of Education, Youth and Sports within the dedicated program ERC CZ under the project POSTMAN with reference LL1902.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Optimal classification trees", "authors": [{"first": "D", "middle": [], "last": "Bertsimas", "suffix": ""}, {"first": "J", "middle": [], "last": "Dunn", "suffix": ""}], "year": 2017, "venue": "Mach. Learn", "volume": "106", "issn": "7", "pages": "1039--1082", "other_ids": {"DOI": ["10.1007/s10994-017-5633-9"]}}, "BIBREF1": {"ref_id": "b1", "title": "Minimising decision tree size as combinatorial optimisation", "authors": [{"first": "C", "middle": [], "last": "Bessiere", "suffix": ""}, {"first": "E", "middle": [], "last": "Hebrard", "suffix": ""}, {"first": "B", "middle": [], "last": "O&apos;sullivan", "suffix": ""}], "year": null, "venue": "CP 2009", "volume": "5732", "issn": "", "pages": "173--187", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "CaDiCaL, Lingeling, PLingeling, Treengeling and YalSAT entering the SAT competition 2017", "authors": [{"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": 2017, "venue": "", "volume": "", "issn": "", "pages": "14--15", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Handbook of Satisfiability", "authors": [{"first": "A", "middle": [], "last": "Biere", "suffix": ""}, {"first": "M", "middle": [], "last": "Heule", "suffix": ""}, {"first": "H", "middle": [], "last": "Van Maaren", "suffix": ""}], "year": 2009, "venue": "", "volume": "185", "issn": "", "pages": "", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Random forests", "authors": [{"first": "L", "middle": [], "last": "Breiman", "suffix": ""}], "year": 2001, "venue": "Mach. Learn", "volume": "45", "issn": "1", "pages": "5--32", "other_ids": {"DOI": ["10.1023/A:1010933404324"]}}, "BIBREF6": {"ref_id": "b6", "title": "Classification and Regression Trees", "authors": [{"first": "L", "middle": [], "last": "Breiman", "suffix": ""}, {"first": "J", "middle": ["H"], "last": "Friedman", "suffix": ""}, {"first": "R", "middle": ["A"], "last": "Olshen", "suffix": ""}, {"first": "C", "middle": ["J"], "last": "Stone", "suffix": ""}], "year": 1984, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "Temporal induction by incremental SAT solving", "authors": [{"first": "N", "middle": [], "last": "E\u00e9n", "suffix": ""}, {"first": "N", "middle": [], "last": "S\u00f6rensson", "suffix": ""}], "year": 2003, "venue": "Electron. Notes Theor. Comput. Sci", "volume": "89", "issn": "4", "pages": "82542--82545", "other_ids": {"DOI": ["10.1016/S1571-0661(05)82542-3"]}}, "BIBREF8": {"ref_id": "b8", "title": "Decision tree", "authors": [{"first": "J", "middle": [], "last": "F\u00fcrnkranz", "suffix": ""}], "year": 2017, "venue": "Encyclopedia of Machine Learning and Data Mining", "volume": "", "issn": "", "pages": "330--335", "other_ids": {"DOI": ["10.1007/978-1-4899-7687-1_66"]}}, "BIBREF9": {"ref_id": "b9", "title": "SAT based exact synthesis using DAG topology families", "authors": [{"first": "W", "middle": [], "last": "Haaswijk", "suffix": ""}, {"first": "A", "middle": [], "last": "Mishchenko", "suffix": ""}, {"first": "M", "middle": [], "last": "Soeken", "suffix": ""}, {"first": "G", "middle": ["D"], "last": "Micheli", "suffix": ""}], "year": 2018, "venue": "Proceedings of the 55th Annual Design Automation Conference, DAC", "volume": "53", "issn": "", "pages": "1--53", "other_ids": {"DOI": ["10.1145/3195970.3196111"]}}, "BIBREF10": {"ref_id": "b10", "title": "Lower bounds on learning decision lists and trees", "authors": [{"first": "T", "middle": ["R"], "last": "Hancock", "suffix": ""}, {"first": "T", "middle": [], "last": "Jiang", "suffix": ""}, {"first": "M", "middle": [], "last": "Li", "suffix": ""}, {"first": "J", "middle": [], "last": "Tromp", "suffix": ""}], "year": 1996, "venue": "Inf. Comput", "volume": "126", "issn": "2", "pages": "114--122", "other_ids": {"DOI": ["10.1006/inco.1996.0040"]}}, "BIBREF11": {"ref_id": "b11", "title": "Cube and conquer: guiding CDCL SAT solvers by lookaheads", "authors": [{"first": "M", "middle": ["J H"], "last": "Heule", "suffix": ""}, {"first": "O", "middle": [], "last": "Kullmann", "suffix": ""}, {"first": "S", "middle": [], "last": "Wieringa", "suffix": ""}, {"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": 2012, "venue": "HVC 2011", "volume": "7261", "issn": "", "pages": "50--65", "other_ids": {"DOI": ["10.1007/978-3-642-34188-5_8"]}}, "BIBREF12": {"ref_id": "b12", "title": "Optimal symmetry breaking for graph problems", "authors": [{"first": "M", "middle": ["J H"], "last": "Heule", "suffix": ""}], "year": 2019, "venue": "Math. Comput. Sci", "volume": "13", "issn": "4", "pages": "533--548", "other_ids": {"DOI": ["10.1007/s11786-019-00397-5"]}}, "BIBREF13": {"ref_id": "b13", "title": "Solving and verifying the boolean pythagorean triples problem via cube-and-conquer", "authors": [{"first": "M", "middle": ["J H"], "last": "Heule", "suffix": ""}, {"first": "O", "middle": [], "last": "Kullmann", "suffix": ""}, {"first": "V", "middle": ["W"], "last": "Marek", "suffix": ""}], "year": 2016, "venue": "SAT 2016", "volume": "9710", "issn": "", "pages": "228--245", "other_ids": {"DOI": ["10.1007/978-3-319-40970-2_15"]}}, "BIBREF14": {"ref_id": "b14", "title": "Optimal sparse decision trees", "authors": [{"first": "X", "middle": [], "last": "Hu", "suffix": ""}, {"first": "C", "middle": [], "last": "Rudin", "suffix": ""}, {"first": "M", "middle": [], "last": "Seltzer", "suffix": ""}], "year": 2019, "venue": "Neural Information Processing Systems NeurIPS", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "ParamILS: an automatic algorithm configuration framework", "authors": [{"first": "F", "middle": [], "last": "Hutter", "suffix": ""}, {"first": "H", "middle": ["H"], "last": "Hoos", "suffix": ""}, {"first": "K", "middle": [], "last": "Leyton-Brown", "suffix": ""}, {"first": "T", "middle": [], "last": "St\u00fctzle", "suffix": ""}], "year": 2009, "venue": "J. Artif. Intell. Res", "volume": "36", "issn": "", "pages": "267--306", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Constructing optimal binary decision trees is NPcomplete", "authors": [{"first": "L", "middle": [], "last": "Hyafil", "suffix": ""}, {"first": "R", "middle": ["L"], "last": "Rivest", "suffix": ""}], "year": 1976, "venue": "Inf. Process. Lett", "volume": "5", "issn": "1", "pages": "90095--90103", "other_ids": {"DOI": ["10.1016/0020-0190(76)90095-8"]}}, "BIBREF17": {"ref_id": "b17", "title": "Partitioning SAT instances for distributed solving", "authors": [{"first": "A", "middle": ["E J"], "last": "Hyv\u00e4rinen", "suffix": ""}, {"first": "T", "middle": [], "last": "Junttila", "suffix": ""}, {"first": "I", "middle": [], "last": "Niemel\u00e4", "suffix": ""}], "year": 2010, "venue": "LPAR 2010", "volume": "6397", "issn": "", "pages": "372--386", "other_ids": {"DOI": ["10.1007/978-3-642-16242-8_27"]}}, "BIBREF18": {"ref_id": "b18", "title": "PySAT: a python toolkit for prototyping with SAT oracles", "authors": [{"first": "A", "middle": [], "last": "Ignatiev", "suffix": ""}, {"first": "A", "middle": [], "last": "Morgado", "suffix": ""}, {"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": 2018, "venue": "SAT 2018", "volume": "10929", "issn": "", "pages": "428--437", "other_ids": {"DOI": ["10.1007/978-3-319-94144-8_26"]}}, "BIBREF19": {"ref_id": "b19", "title": "A SAT-based approach to learn explainable decision sets", "authors": [{"first": "A", "middle": [], "last": "Ignatiev", "suffix": ""}, {"first": "F", "middle": [], "last": "Pereira", "suffix": ""}, {"first": "N", "middle": [], "last": "Narodytska", "suffix": ""}, {"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": 2018, "venue": "IJCAR 2018", "volume": "10900", "issn": "", "pages": "627--645", "other_ids": {"DOI": ["10.1007/978-3-319-94205-6_41"]}}, "BIBREF21": {"ref_id": "b21", "title": "Learning SMT(LRA) constraints using SMT solvers", "authors": [{"first": "S", "middle": [], "last": "Kolb", "suffix": ""}, {"first": "S", "middle": [], "last": "Teso", "suffix": ""}, {"first": "A", "middle": [], "last": "Passerini", "suffix": ""}, {"first": "L", "middle": ["D"], "last": "Raedt", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.24963/ijcai.2018/323"]}}, "BIBREF22": {"ref_id": "b22", "title": "Computer-aided proof of Erd\u0151s discrepancy properties", "authors": [{"first": "B", "middle": [], "last": "Konev", "suffix": ""}, {"first": "A", "middle": [], "last": "Lisitsa", "suffix": ""}], "year": 2015, "venue": "Artif. Intell", "volume": "224", "issn": "", "pages": "103--118", "other_ids": {"DOI": ["10.1016/j.artint.2015.03.004"]}}, "BIBREF23": {"ref_id": "b23", "title": "Factoring out assumptions to speed up MUS extraction", "authors": [{"first": "J.-M", "middle": [], "last": "Lagniez", "suffix": ""}, {"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": null, "venue": "SAT 2013", "volume": "7962", "issn": "", "pages": "276--292", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "Proceedings of the Twenty-Seventh International Joint Conference on Artificial Intelligence (IJCAI 2018)", "authors": [{"first": "J", "middle": [], "last": "Lang", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "13--19", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "Prime implicant computation using satisfiability algorithms", "authors": [{"first": "V", "middle": ["M"], "last": "Manquinho", "suffix": ""}, {"first": "P", "middle": ["F"], "last": "Flores", "suffix": ""}, {"first": "J", "middle": ["P M"], "last": "Silva", "suffix": ""}, {"first": "A", "middle": ["L"], "last": "Oliveira", "suffix": ""}], "year": 1997, "venue": "9th International Conference on Tools with Artificial Intelligence ICTAI", "volume": "", "issn": "", "pages": "232--239", "other_ids": {"DOI": ["10.1109/TAI.1997.632261"]}}, "BIBREF27": {"ref_id": "b27", "title": "MSCG: robust core-guided MaxSAT solving", "authors": [{"first": "A", "middle": [], "last": "Morgado", "suffix": ""}, {"first": "A", "middle": [], "last": "Ignatiev", "suffix": ""}, {"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": 2015, "venue": "JSAT", "volume": "9", "issn": "", "pages": "129--134", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "Learning optimal decision trees with SAT", "authors": [{"first": "N", "middle": [], "last": "Narodytska", "suffix": ""}, {"first": "A", "middle": [], "last": "Ignatiev", "suffix": ""}, {"first": "F", "middle": [], "last": "Pereira", "suffix": ""}, {"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "1362--1368", "other_ids": {"DOI": ["10.24963/ijcai.2018/189"]}}, "BIBREF29": {"ref_id": "b29", "title": "Assessing heuristic machine learning explanations with model counting", "authors": [{"first": "N", "middle": [], "last": "Narodytska", "suffix": ""}, {"first": "A", "middle": [], "last": "Shrotri", "suffix": ""}, {"first": "K", "middle": ["S"], "last": "Meel", "suffix": ""}, {"first": "A", "middle": [], "last": "Ignatiev", "suffix": ""}, {"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": 2019, "venue": "SAT 2019", "volume": "11628", "issn": "", "pages": "267--278", "other_ids": {"DOI": ["10.1007/978-3-030-24258-9_19"]}}, "BIBREF30": {"ref_id": "b30", "title": "PMLB: a large benchmark suite for machine learning evaluation and comparison", "authors": [{"first": "R", "middle": ["S"], "last": "Olson", "suffix": ""}, {"first": "W", "middle": ["G L"], "last": "Cava", "suffix": ""}, {"first": "P", "middle": [], "last": "Orzechowski", "suffix": ""}, {"first": "R", "middle": ["J"], "last": "Urbanowicz", "suffix": ""}, {"first": "J", "middle": ["H"], "last": "Moore", "suffix": ""}], "year": 2017, "venue": "BioData Min", "volume": "10", "issn": "1", "pages": "1--36", "other_ids": {"DOI": ["10.1186/s13040-017-0154-4"]}}, "BIBREF31": {"ref_id": "b31", "title": "Scikit-learn: machine learning in Python", "authors": [{"first": "F", "middle": [], "last": "Pedregosa", "suffix": ""}], "year": 2011, "venue": "J. Mach. Learn. Res", "volume": "12", "issn": "", "pages": "2825--2830", "other_ids": {}}, "BIBREF32": {"ref_id": "b32", "title": "A structure-preserving clause form translation", "authors": [{"first": "D", "middle": ["A"], "last": "Plaisted", "suffix": ""}, {"first": "S", "middle": [], "last": "Greenbaum", "suffix": ""}], "year": 1986, "venue": "J. Symb. Comput", "volume": "2", "issn": "3", "pages": "293--304", "other_ids": {}}, "BIBREF33": {"ref_id": "b33", "title": "Induction of decision trees", "authors": [{"first": "J", "middle": ["R"], "last": "Quinlan", "suffix": ""}], "year": 1986, "venue": "Mach. Learn", "volume": "1", "issn": "1", "pages": "81--106", "other_ids": {}}, "BIBREF34": {"ref_id": "b34", "title": "C4.5: Programs for Machine Learning", "authors": [{"first": "J", "middle": ["R"], "last": "Quinlan", "suffix": ""}], "year": 1993, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF35": {"ref_id": "b35", "title": "Pseudo-boolean and cardinality constraints", "authors": [{"first": "O", "middle": [], "last": "Roussel", "suffix": ""}, {"first": "V", "middle": ["M"], "last": "Manquinho", "suffix": ""}], "year": 2009, "venue": "Frontiers in Artificial Intelligence and Applications", "volume": "185", "issn": "", "pages": "695--733", "other_ids": {"DOI": ["10.3233/978-1-58603-929-5-695"]}}, "BIBREF36": {"ref_id": "b36", "title": "Artificial Intelligence: A Modern Approach", "authors": [{"first": "S", "middle": ["J"], "last": "Russell", "suffix": ""}, {"first": "P", "middle": [], "last": "Norvig", "suffix": ""}], "year": 2010, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF37": {"ref_id": "b37", "title": "Conflict-driven clause learning SAT solvers", "authors": [{"first": "J", "middle": ["P M"], "last": "Silva", "suffix": ""}, {"first": "I", "middle": [], "last": "Lynce", "suffix": ""}, {"first": "S", "middle": [], "last": "Malik", "suffix": ""}], "year": 2009, "venue": "Frontiers in Artificial Intelligence and Applications", "volume": "185", "issn": "", "pages": "131--153", "other_ids": {"DOI": ["10.3233/978-1-58603-929-5-131"]}}, "BIBREF38": {"ref_id": "b38", "title": "Learning optimal decision trees using constraint programming", "authors": [{"first": "H", "middle": [], "last": "Verhaeghe", "suffix": ""}, {"first": "S", "middle": [], "last": "Nijssen", "suffix": ""}, {"first": "G", "middle": [], "last": "Pesant", "suffix": ""}, {"first": "C", "middle": [], "last": "Quimper", "suffix": ""}, {"first": "P", "middle": [], "last": "Schaus", "suffix": ""}], "year": 2019, "venue": "31st Benelux Conference on Artificial Intelligence (BNAIC)", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF39": {"ref_id": "b39", "title": "Learning optimal classification trees using a binary linear program formulation", "authors": [{"first": "S", "middle": [], "last": "Verwer", "suffix": ""}, {"first": "Y", "middle": [], "last": "Zhang", "suffix": ""}], "year": 2019, "venue": "The Thirty-Third AAAI Conference on Artificial Intelligence (AAAI)", "volume": "", "issn": "", "pages": "1625--1632", "other_ids": {"DOI": ["10.1609/aaai.v33i01.33011624"]}}}, "ref_entries": {"FIGREF0": {"text": "Assignment to the variables determining the tree's topology must be terminated after the last step.", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Two consecutive paths R-E and R-F diverging in node A.(Color figure online)", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Topology enumeration, with -leaf, -subtree 1 Function TE (n, d) begin 2 if n = 1 then return { } // leaf 3 if d = 0 then return { } // incomplete subtree 4 if d = 1 then 5 if n = 3 then return { tree ( , ) } 6 else if n = 5 then return { tree ( , ), tree ( , ) } 7 else return { tree ( , ), tree ( , ), tree ( , ) } 8 return {tree(l, r)", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Topology enumeration with cardinalities 1 Function TE # (n, d) begin 2 if n = 1 then return { } // leaf 3 if d = 0 then return {#n} // incomplete subtree of size n Algorithm 3. Measuring difference between topologies 1 Function TDiff (t1, t2, w) begin 2 if |t1| = 0 then return w|t2| 3 else if |t2| = 0 then return w|t1| 4 else return TDiff(t1.left, t2.left, w\u0394) + TDiff(t1.right, t2.right, w\u0394)", "latex": null, "type": "figure"}, "FIGREF4": {"text": "Distribution of the sizes of calculated optimal trees", "latex": null, "type": "figure"}, "FIGREF5": {"text": "postoperative-patient-data-un 1-un with 50% sampling", "latex": null, "type": "figure"}, "TABREF0": {"text": "Examples are defined on a fixed set of features 1..F given as two sets, one containing the negative examples (E \u2212 ) and second containing positive examples (E + ). The examples are assumed consistent, i.e. E \u2212 \u2229 E + = \u2205. We write E for the whole set of examples, i.e. E = E \u2212 \u222a E + . Each example consists of feature-value pairs. We write \u03c3(q, f ) for the value of a feature f in an example q. We assume that all the examples are complete, i.e. \u03c3(q) is total on 1..F.", "latex": null, "type": "table"}, "TABREF1": {"text": "Variables used in the encoding", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>\u00a0</td><td>Range\n</td></tr><tr><td>Variable Semantics gps Path p at step tps Path p at step eps Path p at step </td><td>s goes right=1/left=0 </td><td>p \u2208 1..P, s \u2208 1..S\n</td></tr><tr><td>s is terminated </td><td>p \u2208 1..P, s \u2208 1..S + 1\n</td></tr><tr><td>s is equal to path p \u2212 1 </td><td>p \u2208 2..P, s \u2208 1..S + 1\n</td></tr><tr><td>aps,f </td><td>Path p at step s is assigned feature f </td><td>p \u2208 1..P, s \u2208 1..S, f \u2208 1..F\n</td></tr><tr><td>mpq </td><td>Path p matches an example q </td><td>p \u2208 1..P, q \u2208 E\n</td></tr><tr><td>mpf,v </td><td>Path p matches on value v for feature f </td><td>p \u2208 1..P, f \u2208 1..F, v \u2208 {0, 1}\n</td></tr><tr><td>cp </td><td>Path p is classified as positive </td><td>p \u2208 1..P\n</td></tr></table></body></html>"}, "TABREF2": {"text": "encoding described above permits constructing any decision tree conforming to the given set of examples. However, certain optimizations can be made if we assume that we are not interested in superfluous nodes. Enforcing Example Matching. We make sure that any path (equivalently any leaf), matches at least one of the given examples. If it does not, its classification does not come from the examples and may therefore be arbitrary, which means it can be removed from any tree without violating the classification of the examples. At the formula level, additional constraints are added. Pure Features. Features with the same value in all the examples can be ignored as they never permit distinguishing between two examples of a different class. This is done at the preprocessing level, so the encoder never sees them. Quasi-pure Features. A feature may appear with a fixed value v within all the examples of one of the classes c. If such feature is assigned with the direction v, then the tree can immediately terminate with a leaf classified with c. As such, we", "latex": null, "type": "table"}, "TABREF3": {"text": "Table 3. Results on all the benchmarks divided by the percentage of random sampling.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>% </td><td>\u00a0</td><td>\u00a0</td><td>0.2 </td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>0.5\n</td><td>\u00a0</td></tr><tr><td>nf./ns </td><td>\u00a0</td><td>\u00a0</td><td>447/136 </td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>473/357\n</td><td>\u00a0</td></tr><tr><td>#I </td><td>\u00a0</td><td>\u00a0</td><td>754 </td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>709\n</td><td>\u00a0</td></tr><tr><td>#nd </td><td>depth </td><td>cpu-time </td><td>#slv </td><td>#nd </td><td>depth </td><td>cpu-time </td><td>#slv\n</td></tr><tr><td>mindt </td><td>6 </td><td>3 </td><td>58 </td><td>394 </td><td>5 </td><td>3 </td><td>52 </td><td>249\n</td></tr><tr><td>dtfinder-DT1 </td><td>7 </td><td>3 </td><td>14 </td><td>457 </td><td>6 </td><td>3 </td><td>43 </td><td>337\n</td></tr><tr><td>dtfinder-DT1-T </td><td>7 </td><td>3 </td><td>28 </td><td>473 </td><td>7 </td><td>3 </td><td>41 </td><td>345\n</td></tr><tr><td>dtfinder-DT1-T-O </td><td>7 </td><td>3 </td><td>27 </td><td>473 </td><td>7 </td><td>3 </td><td>39 </td><td>345\n</td></tr><tr><td>dtfinder </td><td>7 </td><td>3 </td><td>14 </td><td>458 </td><td>7 </td><td>3 </td><td>60 </td><td>339\n</td></tr><tr><td>dtfinder-T </td><td>7 </td><td>3 </td><td>29 </td><td>470 </td><td>7 </td><td>3 </td><td>42 </td><td>342\n</td></tr><tr><td>dtfinder-T-O </td><td>7 </td><td>3 </td><td>30 </td><td>471 </td><td>7 </td><td>3 </td><td>39 </td><td>341\n</td></tr><tr><td>d-dtfinder </td><td>8 </td><td>3 </td><td>65 </td><td>519 </td><td>7 </td><td>3 </td><td>73 </td><td>352\n</td></tr><tr><td>d-dtfinder-T-O </td><td>8 </td><td>3 </td><td>49 </td><td>486 </td><td>7 </td><td>3 </td><td>57 </td><td>345\n</td></tr><tr><td>vbs </td><td>8 </td><td>- </td><td>69 </td><td>528 </td><td>7 </td><td>- </td><td>46 </td><td>355\n</td></tr></table></body></html>"}}, "back_matter": [{"text": "Acknowledgements. This work was supported by national funds through FCT, Funda\u00e7\u00e3o para a Ci\u00eancia e a Tecnologia, under project UIDB/50021/2020, the project", "cite_spans": [], "ref_spans": [], "section": "acknowledgement"}, {"text": "search (search (2)). The suffix -T-O topology-based is search with heuristic order-", "cite_spans": [], "ref_spans": [], "section": "annex"}]}