{
    "paper_id": "5fc0826d4fec3b7018059fe195fb98e85ca5e691",
    "metadata": {
        "title": "Quotients of Bounded Natural Functors",
        "authors": [
            {
                "first": "Basil",
                "middle": [],
                "last": "F\u00fcrer",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "ETH Z\u00fcrich",
                    "location": {
                        "settlement": "Zurich",
                        "country": "Switzerland"
                    }
                },
                "email": ""
            },
            {
                "first": "Andreas",
                "middle": [],
                "last": "Lochbihler",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Joshua",
                "middle": [],
                "last": "Schneider",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "ETH Z\u00fcrich",
                    "location": {
                        "settlement": "Zurich",
                        "country": "Switzerland"
                    }
                },
                "email": "joshua.schneider@inf.ethz.ch"
            },
            {
                "first": "Dmitriy",
                "middle": [],
                "last": "Traytel",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "ETH Z\u00fcrich",
                    "location": {
                        "settlement": "Zurich",
                        "country": "Switzerland"
                    }
                },
                "email": "traytel@inf.ethz.ch"
            }
        ]
    },
    "abstract": [
        {
            "text": "The functorial structure of type constructors is the foundation for many definition and proof principles in higher-order logic (HOL). For example, inductive and coinductive datatypes can be built modularly from bounded natural functors (BNFs), a class of well-behaved type constructors. Composition, fixpoints, and-under certain conditionssubtypes are known to preserve the BNF structure. In this paper, we tackle the preservation question for quotients, the last important principle for introducing new types in HOL. We identify sufficient conditions under which a quotient inherits the BNF structure from its underlying type. We extend the Isabelle proof assistant with a command that automates the registration of a quotient type as a BNF by lifting the underlying type's BNF structure. We demonstrate the command's usefulness through several case studies.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The functorial structure of type constructors forms the basis for many definition and proof principles in proof assistants. Examples include datatype and codatatype definitions [3, 9, 37] , program synthesis [13, 19, 24] , generalized term rewriting [36] , and reasoning based on representation independence [6, 19, 23] and about effects [26, 27] .",
            "cite_spans": [
                {
                    "start": 177,
                    "end": 180,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 181,
                    "end": 183,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 184,
                    "end": 187,
                    "text": "37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 208,
                    "end": 212,
                    "text": "[13,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 213,
                    "end": 216,
                    "text": "19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 217,
                    "end": 220,
                    "text": "24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 250,
                    "end": 254,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 308,
                    "end": 311,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 312,
                    "end": 315,
                    "text": "19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 316,
                    "end": 319,
                    "text": "23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 338,
                    "end": 342,
                    "text": "[26,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 343,
                    "end": 346,
                    "text": "27]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A type constructor becomes a functor through a mapper operation that lifts functions on the type arguments to the constructed type. The mapper must be functorial, i.e., preserve identity functions (id) and distribute over function composition (\u2022) . For example, the list type constructor list 1 has the well-known mapper map :: (\u03b1 \u2192 \u03b2) \u2192 \u03b1 list \u2192 \u03b2 list, which applies the given function to every element in the given list. It is functorial:",
            "cite_spans": [
                {
                    "start": 243,
                    "end": 246,
                    "text": "(\u2022)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Most applications of functors can benefit from even richer structures. In this paper, we focus on bounded natural functors (BNFs) [37] (Sect. 2.1). A BNF 1 Type constructors are written postfix in this paper. comes with additional setter operators that return sets of occurring elements, called atoms, for each type argument. The setters must be natural transformations, i.e., commute with the mapper, and bounded, i.e., have a fixed cardinality bound on the sets they return. For example, set :: \u03b1 list \u2192 \u03b1 set returns the set of elements in a list. It satisfies set \u2022 map f = f \u2022 set, where f denotes the function that maps a set X to f X = {f x | x \u2208 X}, i.e., the image of X under f . Moreover, since lists are finite sequences, set xs is always a finite set.",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 134,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 154,
                    "end": 155,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Originally, BNFs were introduced for modularly constructing datatypes and codatatypes [9] in the Isabelle/HOL proof assistant. Although (co)datatypes are still the most important use case, the BNF structure is used nowadays in other contexts such as reasoning via free theorems [29] and transferring theorems between types [22, 28] .",
            "cite_spans": [
                {
                    "start": 86,
                    "end": 89,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 278,
                    "end": 282,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 323,
                    "end": 327,
                    "text": "[22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 328,
                    "end": 331,
                    "text": "28]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Several type definition principles in HOL preserve the BNF structure: composition (e.g., (\u03b1 list) list), datatypes and codatatypes [37] , and-under certain conditions-subtypes [7, 28] . Subtypes include records and type copies. Accordingly, when a new type constructor is defined via one of these principles from an existing BNF, then the new type automatically comes with a mapper and setters and with theorems for the BNF properties.",
            "cite_spans": [
                {
                    "start": 131,
                    "end": 135,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 176,
                    "end": 179,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 180,
                    "end": 183,
                    "text": "28]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "One important type definition principle is missing above: quotients [18, 19, 21, 34, 35] (Sect. 2.2). A quotient type identifies elements of an underlying type according to a (partial) equivalence relation \u223c. That is, the quotient type is isomorphic to the equivalence classes of \u223c. For example, unordered pairs \u03b1 upair are the quotient of ordered pairs \u03b1 \u00d7 \u03b1 and the equivalence relation \u223c upair generated by (x, y) \u223c upair (y, x). Similarly, finite sets, bags, and cyclic lists are quotients of lists where the equivalence relation permutes or duplicates the list elements as needed.",
            "cite_spans": [
                {
                    "start": 68,
                    "end": 72,
                    "text": "[18,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 73,
                    "end": 76,
                    "text": "19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 77,
                    "end": 80,
                    "text": "21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 81,
                    "end": 84,
                    "text": "34,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 85,
                    "end": 88,
                    "text": "35]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we answer the question when and how a quotient type inherits its underlying type's BNF structure. It is well known that a quotient preserves the functorial properties if the underlying type's mapper preserves \u223c; then the quotient type's mapper is simply the lifting of the underlying type's mapper to equivalence classes [3] . For setters, the situation is more complicated. We discovered that if the setters are defined as one would expect, the resulting structure may not preserve empty intersections, i.e., it is unsound in Ad\u00e1mek et al.'s [2] terminology. All BNFs, however, are sound. To repair the situation, we characterize the setters in terms of the mapper and identify a definition scheme for the setters that results in sound functors. We then derive sufficient conditions on the equivalence relation \u223c for the BNF properties to be preserved for these definitions (Sect. 3). With few exceptions, we omit proofs and refer to our technical report [15] , which contains them.",
            "cite_spans": [
                {
                    "start": 336,
                    "end": 339,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 558,
                    "end": 561,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 971,
                    "end": 975,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Moreover, we have implemented an Isabelle/HOL command that automates the registration of a quotient type as a BNF (Sect. 4); the user merely needs to discharge the conditions on \u223c. One of the conditions, subdistributivity, often requires considerable proof effort, though. We therefore developed a novel sufficient criterion using confluent relations that simplifies the proofs in our case studies (Sect. 3.4). Our implementation is distributed with the Isabelle2020 release.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Contributions. The main contributions of this paper are the following: [14] , an extension of linear temporal logic with regular expressions. LDL's syntax is usually given as two mutually recursive datatypes of formulas and regular expressions [5, 14] . Here, we opt for nested recursion, which has the modularity benefit of being able to formalize regular expressions separately. We define regular expressions \u03b1 re:",
            "cite_spans": [
                {
                    "start": 71,
                    "end": 75,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 244,
                    "end": 247,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 248,
                    "end": 251,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Often, it is useful to consider regular expressions modulo some syntactic equivalences. For example, identifying expressions modulo the associativity, commutativity, and idempotence (ACI) of the alternation constructor Alt results in a straightforward construction of deterministic finite automata from regular expressions via Brzozowski derivatives [32] . We define the ACI-equivalence \u223c aci as the least congruence relation satisfying:",
            "cite_spans": [
                {
                    "start": 350,
                    "end": 354,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Alt r s \u223c aci Alt s r Alt r r \u223c aci r Next, we define the quotient type of regular expressions modulo ACI \u03b1 re aci and the datatype of LDL formulas ldl, which uses nested recursion through \u03b1 re aci . quotient type \u03b1 re aci = \u03b1 re/\u223c aci datatype ldl = Prop string | Neg ldl | Conj ldl ldl | Match (ldl re aci ) For the last declaration to succeed, Isabelle must know that \u03b1 re aci is a BNF. We will show in Sect. 3.4 how our work allows us to lift \u03b1 re's BNF structure to \u03b1 re aci . \u2666",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We work in Isabelle/HOL, Isabelle's variant of classical higher-order logic-a simply typed theory with Hilbert choice and rank-1 polymorphism. We refer to a textbook for a detailed introduction to Isabelle/HOL [31] and only summarize relevant notation here. Types are built from type variables \u03b1, \u03b2, . . . via type constructors. A type constructor can be nullary (nat) or have some type arguments (\u03b1 list, \u03b1 set, (\u03b1, \u03b2) upair). Type constructor application is written postfix. Exceptions are the binary type constructors for sums (+), products (\u00d7), and functions (\u2192), all written infix. Terms are built from variables x, y, . . . and constants c, d, . . . via lambda-abstractions \u03bbx. t and applications t u. The sum type's embeddings are Inl and Inr and the product type's projections are fst and snd.",
            "cite_spans": [
                {
                    "start": 210,
                    "end": 214,
                    "text": "[31]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "The primitive way of introducing new types in HOL is to take a non-empty subset of an existing type. For example, the type of lists could be defined as the set of pairs (n :: nat, f :: nat \u2192 \u03b1) where n is the list's length and f i is the list's ith element for i < n and some fixed unspecified element of type \u03b1 for i \u2265 n. To spare the users from such low-level encodings, Isabelle/HOL offers more highlevel mechanisms for introducing new types, which are internally reduced to primitive subtyping. In fact, lists are defined as an inductive datatype \u03b1 list = [] | \u03b1 # \u03b1 list, where [] is the empty list and # is the infix list constructor. Recursion in datatypes and their coinductive counterparts may take place only under well-behaved type constructors, the bounded natural functors (Sect. 2.1). Quotient types (Sect. 2.2) are another high-level mechanism for introducing new types.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "For n-ary definitions, we use the vector notation x that denotes x 1 , . . . , x n where n is clear from the context. Vectors spanning several variables indicate repetition with synchronized indices. For example, map F (g \u2022 f ) abbreviates map F (g 1 \u2022 f 1 ) . . . (g n \u2022 f n ). Abusing notation slightly, we write \u03b1 \u2192 \u03b2 for the n-ary function type \u03b1 1 \u2192 \u00b7 \u00b7 \u00b7 \u2192 \u03b1 n \u2192 \u03b2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "To simplify notation, we identify the type of binary predicates \u03b1 \u2192 \u03b2 \u2192 B and sets of pairs (\u03b1 \u00d7 \u03b2) set, and write \u03b1 \u2297 \u03b2 for both. These types are different in Isabelle/HOL and the BNF ecosystem works with binary predicates. The identification allows us to use set operations, e.g., the subset relation \u2286 or relation composition \u2022 (both written infix).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "A bounded natural functor (BNF) [37] is an n-ary type constructor \u03b1 F equipped with the following polymorphic constants. Here and elsewhere, i implicitly ranges over {1, . . . , n}:",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 36,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "The shape and content intuition [37] is a useful way of thinking about elements of \u03b1 F . The mapper map F leaves the shape unchanged but modifies the contents by applying its function arguments. The n setters set F,i extract the contents (and dispose of the shape). For example, the shape of a list is given by its length, which map preserves. The cardinal bound bd F is a fixed bound on the number of elements returned by set F,i . Cardinal numbers are represented in HOL using particular well-ordered relations [10] . Finally, the relator rel F lifts relations on the type arguments to a relation on \u03b1 F and \u03b2 F . Thereby, it only relates elements of \u03b1 F and \u03b2 F that have the same shape.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 36,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 513,
                    "end": 517,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "The BNF constants must satisfy the following properties:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "Properties map id and map comp capture the mapper's functoriality; set map the setters' naturality. Moreover, the mapper and the setters must agree on what they identify as content (map cong). Any set returned by set F,i must be bounded (set bd); the operator \u2264 o compares cardinal numbers [10] . The bound is required to be infinite (bd), which simplifies arithmetics. The relator can be expressed in terms of the mapper and the setter (in rel) and must distribute over relation composition (rel comp). The other inclusion, namely",
            "cite_spans": [
                {
                    "start": 290,
                    "end": 294,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "follows from these properties. We refer to rel comp as subdistributivity because it only requires one inclusion.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "A useful derived operator is the action on sets F :: \u03b1 set \u2192 \u03b1 F set, which generalizes the type constructor's action on its type arguments. Formally,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "Most basic types are BNFs, notably, sum and product types. BNFs are closed under composition, e.g., 1 + \u03b1 \u00d7 \u03b2 is a BNF with the mapper \u03bbf g. map 1+ (map \u00d7 f g), where 1 is the unit type (consisting of the single element ) and map 1+ h = map + id h. Moreover, BNFs support fixpoint operations, which correspond to (co)datatypes, and are closed under them [37] . For instance, the datatype command internally computes a least solution for the fixpoint type equation \u03b2 = 1 + \u03b1 \u00d7 \u03b2 to define the \u03b1 list type. Closure means that the resulting datatype, here \u03b1 list, is equipped with the BNF structure, e.g., the mapper map. Also subtypes inherit the BNF structure under certain conditions [7] . For example, the subtype \u03b1 nelist of non-empty lists {xs :: \u03b1 list | xs = []} is a BNF.",
            "cite_spans": [
                {
                    "start": 354,
                    "end": 358,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 684,
                    "end": 687,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Bounded Natural Functors"
        },
        {
            "text": "An equivalence relation \u223c on a type T partitions the type into equivalence classes. Isabelle/HOL supports the definition of the quotient type Q = T /\u223c, which yields a new type Q isomorphic to the set of equivalence classes [21] . For example, consider \u223c fset that relates two lists if they have the same set of elements, i.e., xs \u223c fset ys iff set xs = set ys. The following command defines the type \u03b1 fset of finite sets as a quotient of lists:",
            "cite_spans": [
                {
                    "start": 223,
                    "end": 227,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "This command requires a proof that \u223c fset is, in fact, an equivalence relation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "The Lifting and Transfer tools [19, 22] automate the lifting of definitions and theorems from the raw type T to the quotient Q. For example, the image operation on finite sets can be obtained by lifting the list mapper map using the command",
            "cite_spans": [
                {
                    "start": 31,
                    "end": 35,
                    "text": "[19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 36,
                    "end": 39,
                    "text": "22]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "Lifting is only possible for terms that respect the quotient. For fimage, respectfulness states that map f xs \u223c fset map f ys whenever xs \u223c fset ys.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "Lifting and Transfer are based on transfer rules that relate two terms of possibly different types. The lift definition command automatically proves the transfer rule",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "where A \u21d2 B (right-associative) relates two functions iff they map A-related arguments to B-related results. The correspondence relation cr fset relates a list with the finite set that it represents, i.e., the set whose corresponding equivalence class contains the list. Every quotient is equipped with such a correspondence relation. The meaning of the above rule is that applying map f to a list representing the finite set X results in a list that represents fimage f X, for all f . The transfer rule's relation (=) \u21d2 cr fset \u21d2 cr fset is constructed according to the types of the related terms. This enables the composition of transfer rules to relate larger terms. For instance, the Transfer tool automatically derives",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "such that the equation \u2200X. fimage id X = X can be proved by reasoning about lists.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotient Types"
        },
        {
            "text": "We develop the theory for when a quotient type inherits the underlying type's BNF structure. We consider the quotient \u03b1 Q = \u03b1 F/\u223c of an n-ary BNF \u03b1 F over an equivalence relation \u223c on \u03b1 F. The first idea is to define map Q and set Q,i in terms of F 's operations:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotients of Bounded Natural Functors"
        },
        {
            "text": "These three commands require the user to discharge the following proof obligations:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotients of Bounded Natural Functors"
        },
        {
            "text": "The first two conditions are as expected: \u223c must be an equivalence relation, by (1) , and compatible with F 's mapper, by (2), i.e., map F preserves \u223c. The third condition, however, demands that equivalent values contain the same atoms. This rules out many practical examples including the following simplified (and therefore slightly artificial) one.",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 83,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Quotients of Bounded Natural Functors"
        },
        {
            "text": "where Inl is the sum type's left embedding. That is, \u223c P identifies all values of the form Inl z and thus \u03b1 Q P = \u03b1 F P /\u223c P is isomorphic to the type 1 + \u03b1. However, Inl x and Inl y have different sets of atoms {x} and {y}, assuming x = y. \u2666",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotients of Bounded Natural Functors"
        },
        {
            "text": "We derive better definitions for the setters and conditions under which they preserve the BNF properties. To that end, we characterize setters in terms of the mapper (Sect. 3.1). Using this characterization, we derive the relationship between set Q,i and set F,i and identify the conditions on \u223c (Sect. 3.2). Next, we do the same for the relator (Sect. 3.3). We thus obtain the conditions under which \u03b1 Q preserves F 's BNF properties. One of the conditions, the relator's subdistributivity over relation composition, is often difficult to show directly in practice. We therefore present an easier-to-establish criterion for the special case where a confluent rewrite relation over-approximates \u223c (Sect. 3.4).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotients of Bounded Natural Functors"
        },
        {
            "text": "We now characterize set F,i in terms of map F for an arbitrary BNF \u03b1 F . Observe that F 's action F A on sets contains all values that can be built with atoms from A. Hence, set F,i x is the smallest set A i such that x can be built from atoms in A i . Formally:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Characterization of the BNF Setter"
        },
        {
            "text": "Only atoms of type \u03b1 i are restricted; all other atoms \u03b1 j may come from UNIV, the set of all elements of type \u03b1 j . Moreover, F can be defined without set F,i , namely by trying to distinguish values using the mapper. Informally, x contains atoms not from A iff map F f x differs from map F g x for some functions f and g that agree on A. Hence, we obtain:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Characterization of the BNF Setter"
        },
        {
            "text": "Proof. From left to right is trivial with map cong. So let x be such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Characterization of the BNF Setter"
        },
        {
            "text": "Equations 4 and 5 reduce the setters set F,i of a BNF to its mapper map F . In the next section, we will use this characterization to derive a definition of set Q,i in terms of set F,i . Yet, this definition does not give us naturality out of the box.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Characterization of the BNF Setter"
        },
        {
            "text": "Consider the functor \u03b1 F ae = nat \u2192 \u03b1 of infinite sequences with x \u223c ae y whenever {n | x n = y n} is finite. That is, two sequences are equivalent iff they are equal almost everywhere. Conditions (1) and (2) hold, but not the naturality for the corresponding map Q and set Q . \u2666 Gumm [16] showed that set F as defined in terms of (4) and (5) is a natural transformation iff F preserves wide intersections and preimages, i.e.,",
            "cite_spans": [
                {
                    "start": 285,
                    "end": 289,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Example 3 ([2, Example 4.2, part iii])"
        },
        {
            "text": "where",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3 ([2, Example 4.2, part iii])"
        },
        {
            "text": "The quotient in Example 3 does not preserve wide intersections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3 ([2, Example 4.2, part iii])"
        },
        {
            "text": "In theory, we have now everything we need to define the BNF operations on the quotient \u03b1 Q = \u03b1 F/\u223c: Define map Q as the lifting of map F . Define Q and set Q,i using (5) and (4) in terms of map Q , and the relator via in rel. Prove that Q preserves preimages and wide intersections. Prove that rel Q satisfies subdistributivity (rel comp).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3 ([2, Example 4.2, part iii])"
        },
        {
            "text": "Unfortunately, the definitions and the preservation conditions are phrased in terms of Q, not in terms of F and \u223c. It is therefore unclear how set Q,i and rel Q relate to set F,i and rel F . In practice, understanding this relationship is important: we want to express the BNF operations and discharge the proof obligations in terms of F 's operations and later use the connection to transfer properties from set F and rel F to set Q and rel Q . We will work out the precise relationships for the setters in Sect. 3.2 and for the relator in Sect. 3.3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3 ([2, Example 4.2, part iii])"
        },
        {
            "text": "We relate Q's setters to F 's operations and \u223c. We first look at Q , which characterizes set Q,i via (4). Let [x] \u223c = {y | x \u223c y} denote the equivalence class that x :: \u03b1 F belongs to, and [A] \u223c = {[x] \u223c | x \u2208 A} denote the equivalence classes of elements in A. We identify the values of \u03b1 Q with \u03b1 F 's equivalence classes. Then, it follows using (1), (2) , and (5) ",
            "cite_spans": [
                {
                    "start": 353,
                    "end": 356,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "The Quotient's Setter"
        },
        {
            "text": "The converse does not hold in general, as shown next.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Equation 8 differs from (5) only in that the equality in map"
        },
        {
            "text": "This problematic behavior occurs only for empty sets A i . To avoid it, we change types: Instead of \u03b1 F/\u223c, we consider the quotient (1 + \u03b1) F/\u223c, where 1+\u03b1 i adds a new atom = Inl to the atoms of type \u03b1 i . We write e :: \u03b1 \u2192 1+\u03b1 for the embedding of \u03b1 into 1 + \u03b1 (i.e., e = Inr). Then, we have the following equivalence:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 2 (continued). For the example viewing 1 + \u03b1 as a quotient of \u03b1 F"
        },
        {
            "text": "Proof. From left to right: Let x \u2208 F A and set f i y = e y for y \u2208 A i and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 2 (continued). For the example viewing 1 + \u03b1 as a quotient of \u03b1 F"
        },
        {
            "text": "From right to left: Let x such that map F e x \u223c y for some y \u2208 F ({ } \u222a e A ). Let f and g such that f i a = g i a for all a \u2208 A i and all i. Then, map F f x \u223c map F g x holds by the following reasoning, where e \u22121 denotes the left-inverse of e and map 1+ h satisfies map 1+ h (e a) = e (h a) and map 1+ h = : (6) and (7) on Q in terms of \u223c and F . For wide intersections, the condition is as follows (the other inclusion holds trivially):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 2 (continued). For the example viewing 1 + \u03b1 as a quotient of \u03b1 F"
        },
        {
            "text": "The conclusion is as expected: for sets of the form F A, taking equivalence classes preserves wide intersections. The assumption is the interesting part: preservation is needed only for non-empty intersections. Non-emptiness suffices because Lemma 1 relates F A to F ({ } \u222a e A ) and all intersections of interest therefore contain . (The condition does not explicitly mention because Lemma 1 holds for any element that is not in A.) Condition 9 is satisfied trivially for equivalence relations that preserve set F,i , i.e., satisfy (3) . Examples include permutative structures like finite sets and cyclic lists.",
            "cite_spans": [
                {
                    "start": 533,
                    "end": 536,
                    "text": "(3)",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Example 2 (continued). For the example viewing 1 + \u03b1 as a quotient of \u03b1 F"
        },
        {
            "text": "In contrast, the non-emptiness assumption is crucial for quotients that identify values with different sets of atoms, such as Example 2. In general, such quotients do not preserve empty intersections (Sect. 5).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. Suppose that \u223c satisfies (3). Then, [ F A] \u223c = F A and condition (9) holds."
        },
        {
            "text": "We can factor condition (9) into a separate property for each type argument i:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. Suppose that \u223c satisfies (3). Then, [ F A] \u223c = F A and condition (9) holds."
        },
        {
            "text": "This form is used in our implementation (Sect. 4). It is arguably more natural to prove for a concrete functor F because each property focuses on a single setter. (1) and (2) . Then, (9) holds iff (10) holds for all i.",
            "cite_spans": [
                {
                    "start": 171,
                    "end": 174,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 2. Suppose that \u223c satisfies (3). Then, [ F A] \u223c = F A and condition (9) holds."
        },
        {
            "text": "Preservation of preimages amounts to the following unsurprising condition:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 3. Suppose that \u223c satisfies"
        },
        {
            "text": "As for wide intersections, taking equivalence classes must preserve non-empty preimages (the inclusion from right to left holds trivially). Again, non-emptiness comes from being contained in all sets of interest. We do not elaborate on preimage preservation any further as it follows from subdistributivity, which we will look at in the next subsection.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 3. Suppose that \u223c satisfies"
        },
        {
            "text": "Under conditions (9) and (11), we obtain the following characterization for set Q :",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 20,
                    "text": "(9)",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 3. Suppose that \u223c satisfies"
        },
        {
            "text": "Q,i [x] \u223c = y\u2208[map F e x]\u223c {a | e a \u2208 set F,i y}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Setter characterization). set"
        },
        {
            "text": "In the previous section, we have shown that it is not a good idea to naively lift the setter and a more general construction is needed. We now show that the same holds for the relator. The following straightforward definition lift definition rel Q :: So what is the relationship between rel Q and rel F and under what conditions does the subdistributivity property rel comp hold? Like for the setter, we avoid the problematic case of empty relations by switching to 1 + \u03b1. The relator rel 1+ adds the pair ( , ) to every relation R and thereby ensures that all relations and their compositions are non-empty. Accordingly, we obtain the following characterization:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Quotient's Relator"
        },
        {
            "text": "(",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2 (Relator characterization)."
        },
        {
            "text": "Moreover, the following condition on \u223c characterizes when rel Q satisfies rel comp. Again, the non-emptiness assumptions for R i \u2022 S i come from rel 1+ extending any relation R with the pair ( , ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2 (Relator characterization)."
        },
        {
            "text": "It turns out that this condition implies the respectfulness of the mapper (2). Intuitively, the relator is a generalization of the mapper. Furthermore, it is well known that subdistributivity implies preimage preservation [17] . Since our conditions on \u223c characterize these preservation properties, it is no surprise that the latter implication carries over. (12) implies respectfulness (2) and preimage preservation (11) .",
            "cite_spans": [
                {
                    "start": 222,
                    "end": 226,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 359,
                    "end": 363,
                    "text": "(12)",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 387,
                    "end": 390,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 417,
                    "end": 421,
                    "text": "(11)",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 2 (Relator characterization)."
        },
        {
            "text": "In summary, we obtain the following main preservation theorem: (9) , and (12) . The setters and relator are given by Theorems 1 and 2, respectively. ",
            "cite_spans": [
                {
                    "start": 63,
                    "end": 66,
                    "text": "(9)",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 73,
                    "end": 77,
                    "text": "(12)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 4. Condition"
        },
        {
            "text": "Our goal is the construction of (co)datatypes with recursion through quotients such as (\u03b1, \u03b2) tllist. As a realistic example, consider an inductive model of a finite interactive system that produces a possibly unbounded sequence of outputs out for every input in:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4. Condition"
        },
        {
            "text": "This datatype declaration is only possible if tllist is a BNF in \u03b2. Previously, this had to be shown by manually defining the mapper and setters and proving the BNF properties. Theorem 3 identifies the conditions under which tllist inherits the BNF structure of its underlying type, and it allows us to automate these definitions and proofs. For tlllist, the conditions can be discharged easily using automatic proof methods and a simple lemma about llist's relator (stating that related lists are either both finite or infinite). \u2666",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4. Condition"
        },
        {
            "text": "Among the BNF properties, subdistributivity (rel comp) is typically the hardest to show. For example, distinct lists, type \u03b1 dlist, have been shown to be a BNF. The manual proof requires 126 lines. Of these, the subdistributivity proof takes about 100 lines. Yet, with the theory developed so far, essentially the same argument is needed for the subdistributivity condition (12) . We now present a sufficient criterion for subdistributivity that simplifies such proofs. For dlist, this shortens the subdistributivity proof to 58 lines. With our lift bnf command (Sect. 4), the whole proof is now 64 lines, half of the manual proof. Equivalence relations are often (or can be) expressed as the equivalence closure of a rewrite relation . For example, the subdistributivity proof for distinct lists views \u03b1 dlist as the quotient \u03b1 list/\u223c dlist with xs \u223c dlist ys iff remdups xs = remdups ys, where remdups xs keeps only the last occurrence of every element in xs. So, \u223c dlist is the equivalence closure of the following relation dlist , where \u00b7 concatenates two lists: We use the following notation: denotes the reverse relation, i.e., x y iff y",
            "cite_spans": [
                {
                    "start": 374,
                    "end": 378,
                    "text": "(12)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Subdistributivity via Confluent Relations"
        },
        {
            "text": "x. Further, * denotes the reflexive and transitive closure, and * the equivalence closure. A relation is confluent iff whenever x * y and x * z, then there exists a u such that y * u and z * u-or, equivalently in pointfree",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Subdistributivity via Confluent Relations"
        },
        {
            "text": "Let an equivalence relation \u223c satisfy (2) and (3) . Then, it also satisfies (9) and (12) if there is a confluent relation with the following properties:",
            "cite_spans": [
                {
                    "start": 38,
                    "end": 41,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 46,
                    "end": 49,
                    "text": "(3)",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 76,
                    "end": 79,
                    "text": "(9)",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "(i) The equivalence relation is contained in 's equivalence closure: (\u223c) \u2286 ( * ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "(ii) The relation factors through projections: If map F fst x y then there exists a y such that y = map F fst y and x \u223c y , and similarly for snd.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "Proof. The wide intersection condition (9) follows from (3) by Lemma 2. The proof for the subdistributivity condition (12) is illustrated in Fig. 1 . The proof starts at the top with (x, z) \u2208 (rel F R \u2022 \u223c \u2022 rel F S), i.e., there are y and y such that (x, y) \u2208 rel F R and y \u223c y and (y , z) \u2208 rel F S. We show (x, z) \u2208 (\u223c \u2022 rel F (R \u2022 S) \u2022 \u223c) by establishing the path from x to z via x and z along the three other borders of the diagram. First 1 , by in rel, there is a u \u2208 F R such that x = map F fst u and y = map F snd u. Similarly, rel F S y z yields a v with the corresponding properties 2 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 141,
                    "end": 147,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "Second, by (i), y \u223c y implies y * y . Since is confluent, there exists a w such that y * w and y * w 3 . By induction on * using (ii), y * w factors through the projection y = map F snd u and we obtain a u such that u \u223c u and w = map F snd u 4 . Analogously, we obtain v corresponding to y and v 5 . Set x = map F fst u and z = map F snd v . As map F preserves \u223c by (2), we have x \u223c x and z \u223c z 6 .",
            "cite_spans": [
                {
                    "start": 296,
                    "end": 297,
                    "text": "5",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "Next, we focus on the two triangles at the bottom 7 . By Lemma 2 and (3), u \u223c u and u \u2208 F R imply u \u2208 F R; similarly v \u2208 F S. Now, u and v are the witnesses to the existential in in rel for x and w, and w and z , respectively. So (x , w) \u2208 rel F R and (w, z ) \u2208 rel F S, i.e., (x , z ) \u2208 (rel F R \u2022 rel F S). Finally, as F is a BNF, (x , z ) \u2208 rel F (R \u2022 S) follows with subdistributivity rel comp 8 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "Example 5. For distinct lists, we have (\u223c dlist ) = ( * dlist ) and dlist is confluent. Yet, condition (ii) of Theorem 4 does not hold. For example, for x = [(1, a), (1, b) ], we have map list fst x = [1, 1] dlist [1] . However, there is no y such that x \u223c dlist y and map list fst y = [1] . The problem is that the projection map list fst makes different atoms of x equal and dlist removes equal atoms, but the removal cannot be mimicked on x itself. Fortunately, we can also add equal atoms instead of removing them. Define dlist by",
            "cite_spans": [
                {
                    "start": 214,
                    "end": 217,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 286,
                    "end": 289,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 153,
                    "end": 172,
                    "text": "x = [(1, a), (1, b)",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "Then, dlist is confluent and factors through projections. So distinct lists inherit the BNF structure from lists by Theorem 4. \u2666 Example 6. The free monoid over atoms \u03b1 consists of all finite lists \u03b1 list. The free idempotent monoid \u03b1 fim is then the quotient \u03b1 list/\u223c fim where \u223c fim is the equivalence closure of the idempotence law for list concatenation xs \u00b7 ys \u00b7 zs fim xs \u00b7 ys \u00b7 ys \u00b7 zs",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "We have oriented the rule such that it introduces rather than removes the duplication. In term rewriting, the rule is typically oriented in the other direction [20] such that the resulting rewriting system terminates; however, this classical relation fim is not confluent: ababcbabc has two normal forms ababcbabc fim ababc fim abc and ababcbabc fim abcbabc (redexes are underlined). In contrast, our orientation yields a confluent relation fim , although the formal proof requires some effort. The relation also factors through projections. So by Theorem 4, the free idempotent monoid \u03b1 fim is also a BNF. \u2666 The quotient \u03b1 cyclist = \u03b1 list/ * rotate is a BNF as rotate satisfies the conditions of Theorem 4. \u2666 Example 1 (continued). We prove the fact that \u03b1 re aci is a BNF using Theorem 4. The confluent rewrite relation aci that satisfies the conditions of Theorem 4 and whose equivalence closure is \u223c aci is defined inductively as follows.",
            "cite_spans": [
                {
                    "start": 160,
                    "end": 164,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "Alt (Alt r s) t aci Alt r (Alt s t) Alt r (Alt s t) aci Alt (Alt r s) t Alt r s aci Alt s r r aci Alt r r r aci r r aci r =\u21d2 s aci s =\u21d2 Alt r s aci Alt r s r aci r =\u21d2 s aci s =\u21d2 Conc r s aci Conc r s r aci r =\u21d2 Star r aci Star r \u2666",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4 (Subdistributivity via confluent relations)."
        },
        {
            "text": "We provide an Isabelle/HOL command that automatically lifts the BNF structure to quotient types. The command was implemented in 1590 lines of Isabelle/ML. It requires the user to discharge our conditions on the equivalence relation. Upon success, it defines the mapper, setters, and the relator, and proves the BNF axioms and transfer rules. All automated proofs are checked by Isabelle's kernel. Eventually, the command registers the quotient type with the BNF infrastructure for use in future (co)datatype definitions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Implementation"
        },
        {
            "text": "Our implementation extends the interface of the existing lift bnf command for subtypes [7] . Given a quotient type \u03b1 Q = \u03b1 F/\u223c, lift bnf \u03b1 Q asks the user to prove the conditions (9) and (12) of Theorem 3, where (9) is expressed in terms of (10) according to Lemma 3. Since the quotient construction already requires that \u223c be an equivalence relation, the remaining condition (1) holds trivially. After the assumptions have been proved by the user, the command defines the BNF constants. Their definitions use an abstraction function abs Q :: \u03b1 F \u2192 \u03b1 Q and a representation function rep Q :: \u03b1 Q \u2192 \u03b1 F, as in HOL Q is distinct from (but isomorphic to) the set of equivalence classes. Concretely, we define the quotient's mapper by",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 90,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "The lift bnf command"
        },
        {
            "text": "The quotient's setters use the function set 1+ , which maps e a to {a} and to {}:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The lift bnf command"
        },
        {
            "text": "This definition is equivalent to the characterization in Theorem 1. The relator (Theorem 2) is lifted similarly using rep Q .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The lift bnf command"
        },
        {
            "text": "The relationship of a quotient's BNF structure to its underlying type allows us to prove additional properties about the former. This is achieved by transfer rules, which drive Isabelle's Transfer tool [19] (Sect. 2.2). Our command automatically proves parametrized transfer rules for the lifted mapper, setters, and relator. Parametrized transfer rules are more powerful because they allow the refinement of nested types [22, Section 4.3] . They involve a parametrized correspondence relation pcr Q A = rel F A\u2022cr Q , where the parameters A relate the type arguments of F and Q.",
            "cite_spans": [
                {
                    "start": 202,
                    "end": 206,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 422,
                    "end": 426,
                    "text": "[22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 427,
                    "end": 439,
                    "text": "Section 4.3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Transfer Rule Generation"
        },
        {
            "text": "Since map Q is lifted canonically, its transfer rule is unsurprising:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transfer Rule Generation"
        },
        {
            "text": "Setters are not transferred to set F but to the more complex function from (13):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transfer Rule Generation"
        },
        {
            "text": "Similarly, the rule for Q's relator follows its definition in Theorem 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transfer Rule Generation"
        },
        {
            "text": "Recall that terminated coinductive lists satisfy the conditions for lifting the BNF structure. Thus, we obtain the setter set tllist,2 :: (\u03b1, \u03b2) tllist \u2192 \u03b2 set among the other BNF operations. We want to prove that set tllist,2 x is empty for all infinite lists x. To make this precise, let the predicate lfinite :: \u03b1 llist \u2192 bool characterize finite coinductive lists. We lift it to (\u03b1, \u03b2) tllist by projecting away the terminator:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 4 (continued)."
        },
        {
            "text": "lift definition tlfinite :: (\u03b1, \u03b2) tllist \u2192 bool is (\u03bbx. lfinite (fst x)) Therefore, we have to show that \u2200x. \u00ac tlfinite x =\u21d2 set tllist,2 x = {}. Using the transfer rules for the setter and the lifted predicate tlfinite, the transfer proof method reduces the proof obligation to",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 4 (continued)."
        },
        {
            "text": "where x :: (\u03b1, \u03b2) F , and (\u03b1, \u03b2) F = (\u03b1 llist\u00d7\u03b2) is the underlying functor of tllist. The rest of the proof, which need not refer to tllist anymore, is automatic. \u2666",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 4 (continued)."
        },
        {
            "text": "We have also extended lift bnf to generate transfer rules for subtypes. There, the setters and the relator do not change: if T is a subtype of F , e.g., then set T,i is transferred to set F,i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 4 (continued)."
        },
        {
            "text": "Quotient constructions have been formalized and implemented, e.g., in Isabelle/HOL [19, 21, 34, 35] , HOL4 [18] , Agda [40, 41] , Cedille [30] , Coq [11, 12] , Lean [3] , and Nuprl [33] . None of these works look at the preservation of functor properties except for Avigad et al. [3] (discussed in Sect. 5.2) and Veltri [41] . Veltri studies the special case of when the delay monad is preserved by a quotient of weak bisimilarity, focusing on the challenges that quotients pose in intensional type theory. Abbot et al. [1] introduce quotient containers as a model of datatypes with permutative structure, such as unordered pairs, cyclic lists, and multisets. The map function of quotient containers does not change the shape of the container. Quotient containers therefore cannot deal with quotients where the equivalence relation takes the identity of elements into account, such as distinct lists, finite sets, and the free idempotent monoid. Overall our construction strictly subsumes quotient containers.",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 88,
                    "end": 91,
                    "text": "21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 92,
                    "end": 95,
                    "text": "34,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 96,
                    "end": 99,
                    "text": "35]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 107,
                    "end": 111,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 119,
                    "end": 123,
                    "text": "[40,",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 124,
                    "end": 127,
                    "text": "41]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 138,
                    "end": 142,
                    "text": "[30]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 149,
                    "end": 153,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 154,
                    "end": 157,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 165,
                    "end": 168,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 181,
                    "end": 185,
                    "text": "[33]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 280,
                    "end": 283,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 320,
                    "end": 324,
                    "text": "[41]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 520,
                    "end": 523,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "BNFs are accessible functors in the category of Sets. We therefore relate to the literature on when quotients preserve functors and their properties in Set.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "Trnkov\u00e1 [38] showed that all Set functors preserve non-empty intersections:",
            "cite_spans": [
                {
                    "start": 8,
                    "end": 12,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "Empty intersections need not be preserved though. Functors that do are called regular [39] or sound [2] . All BNFs are sound as F A = {x | set F x \u2286 A}. As shown in Example 2, the naive quotient construction can lead to unsound functors.",
            "cite_spans": [
                {
                    "start": 86,
                    "end": 90,
                    "text": "[39]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 100,
                    "end": 103,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "Every unsound functor can be \"repaired\" by setting F {} to the distinguished points dp F . We write F for the repaired action.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "Trnkov\u00e1 characterizes the distinguished points dp F as the natural transforma- Barr [4] and Gumm [16] use equalizers instead of natural transformations to define the distinguished points of univariate functors:",
            "cite_spans": [
                {
                    "start": 79,
                    "end": 87,
                    "text": "Barr [4]",
                    "ref_id": null
                },
                {
                    "start": 97,
                    "end": 101,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "The case distinction in (14) (15) . The resulting quotient is the same because [",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 33,
                    "text": "(15)",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "Given the other BNF properties, subdistributivity is equivalent to the functor preserving weak pullbacks. Ad\u00e1mek et al. [2] showed that an accessible Set functor preserves weak pullbacks iff it has a so-called dominated presentation in terms of flat equations E over a signature \u03a3. This characterization does not immediately help with proving subdistributivity, though. For example, the finite set quotient \u03b1 fset = \u03b1 list/\u223c fset comes with the signature \u03a3 = {\u03c3 n | n \u2208 N} and the equations \u03c3 n (x 1 , . . . x n ) = \u03c3 m (y 1 , . . . , y m ) whenever {x 1 , . . . , x n } = {y 1 , . . . , y m }. Proving domination for this presentation boils down to proving subdistributivity directly. Our criterion using a confluent relation (Theorem 4) is only sufficient, not necessary, but it greatly simplifies the actual proof effort.",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 123,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Quotients in the Category of Sets"
        },
        {
            "text": "Avigad et al. [3] proposed quotients of polynomial functors (QPF) as a model for datatypes. QPFs generalize BNFs in that they require less structure: there is no setter and the relator need not satisfy subdistributivity. Nevertheless, the quotient construction is similar to ours. Without loss of generality, we consider in our comparison only the univariate case \u03b1 Q = \u03b1 F/\u223c.",
            "cite_spans": [
                {
                    "start": 14,
                    "end": 17,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Comparison with Lean's Quotients of Polynomial Functors"
        },
        {
            "text": "The main difference lies in the definition of the liftings lift F of predicates P :: \u03b1 \u2192 B and relations R :: \u03b1 \u2297 \u03b2. In our notation, lift F P corresponds to \u03bbx. x \u2208 F {a | P a} and lift F R to rel F R. QPF defines these liftings for the quotient Q as follows: For example, suppose that a user has already shown lift Q P 1 x and lift Q P 2 x for some value x and two properties P 1 and P 2 . Then, to deduce lift F (\u03bba. P 1 a \u2227 P 2 a) x, they would have to prove that the two properties do not contradict each other, i.e., \u2203a. P 1 a \u2227 P 2 a. Obviously, this makes modular proofs harder as extra work is needed to combine properties. QPF uses lift F P in the induction theorem for datatypes. So when a datatype recurses through tllist, this spreads to proofs by induction: splitting a complicated inductive statement into smaller lemmas is not for free. Moreover, lift Q holds for fewer values, as the next example shows. Analogous problems arise in QPF for relation lifting, which appears in the coinduction theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Comparison with Lean's Quotients of Polynomial Functors"
        },
        {
            "text": "Example 4 (continued). Consider the infinite repetition repeat a :: (\u03b1, \u03b2) tllist of the atom a as a terminated lazy list. As repeat a contains only as, one would expect that lift tllist (\u03bba . a = a) (\u03bb . False) (repeat a) holds. Yet, this property is provably false. \u2666",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Comparison with Lean's Quotients of Polynomial Functors"
        },
        {
            "text": "These issues would go away if lift Q was defined following our approach for Q A = [ F A] \u223c and rel Q as in Theorem 2. These definitions do not rely on the additional BNF structure; only map Q is needed and QPF defines map Q like we do. The repair should therefore work for the general QPF case, as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Comparison with Lean's Quotients of Polynomial Functors"
        },
        {
            "text": "We have described a sufficient criterion for quotient types to be able to inherit the BNF structure from the underlying type. We have demonstrated the effectiveness of the criterion by automating the BNF \"inheritance\" in the form of the lift bnf command in Isabelle/HOL and used it (which amounts to proving the criterion) for several realistic quotient types. We have also argued that our treatment of the quotient's setter and relator to avoid unsoundness carries over to more general structures, such as Lean's QPFs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "As future work, we plan to investigate quotients of existing generalizations of BNFs to co-and contravariant functors [28] and functors operating on smallsupport endomorphisms and bijections [8] . Furthermore, we would like to provide better automation for proving subdistributivity via confluent rewrite systems as part of lift bnf.",
            "cite_spans": [
                {
                    "start": 118,
                    "end": 122,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 191,
                    "end": 194,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Constructing polymorphic programs with quotient types",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Abbott",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Altenkirch",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Ghani",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Mcbride",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "MPC 2004",
            "volume": "3125",
            "issn": "",
            "pages": "2--15",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-27764-4_2"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Presentation of set functors: a coalgebraic perspective",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Ad\u00e1mek",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "P"
                    ],
                    "last": "Gumm",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Trnkov\u00e1",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Log. Comput",
            "volume": "20",
            "issn": "5",
            "pages": "991--1015",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Data types as quotients of polynomial functors",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Avigad",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Carneiro",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hudon",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ITP 2019 Leibniz International Proceedings in Informatics (LIPIcs)",
            "volume": "141",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Terminal coalgebras in well-founded set theory",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Barr",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "Theor. Comput. Sci",
            "volume": "114",
            "issn": "2",
            "pages": "299--315",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Almost event-rate independent monitoring of metric dynamic logic",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Basin",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Krsti\u0107",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "RV 2017",
            "volume": "10548",
            "issn": "",
            "pages": "85--102",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-67531-2_6"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "CryptHOL: game-based proofs in higher-order logic",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "A"
                    ],
                    "last": "Basin",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Sefidgar",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "J. Cryptol",
            "volume": "33",
            "issn": "",
            "pages": "494--566",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Functor-preserving type definitions in Isabelle/HOL",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Biendarra",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Bindings as bounded natural functors. PACMPL 3(POPL)",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Blanchette",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Gheri",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Popescu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "22",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Truly modular (co)datatypes for Isabelle/HOL",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Blanchette",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "H\u00f6lzl",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Panny",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Popescu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ITP 2014",
            "volume": "8558",
            "issn": "",
            "pages": "93--110",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-08970-6_7"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Cardinals in Isabelle/HOL",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Blanchette",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Popescu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ITP 2014",
            "volume": "8558",
            "issn": "",
            "pages": "111--127",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-08970-6_8"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Mathematical quotients and quotient types in Coq",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Chicli",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pottier",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Simpson",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "TYPES 2002",
            "volume": "2646",
            "issn": "",
            "pages": "95--107",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-39185-1_6"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Pragmatic quotient types in Coq",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cohen",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ITP 2013",
            "volume": "7998",
            "issn": "",
            "pages": "213--228",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-39634-2_17"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Refinements for free",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cohen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "D\u00e9n\u00e8s",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "M\u00f6rtberg",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "CPP 2013",
            "volume": "8307",
            "issn": "",
            "pages": "147--162",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-03545-1_10"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Linear temporal logic and linear dynamic logic on finite traces",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "De Giacomo",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "Y"
                    ],
                    "last": "Vardi",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IJCAI/AAAI",
            "volume": "",
            "issn": "",
            "pages": "854--860",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Quotients of bounded natural functors (extended report)",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "F\u00fcrer",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schneider",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "From T -coalgebras to filter structures and transition systems",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "P"
                    ],
                    "last": "Gumm",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "L"
                    ],
                    "last": "Fiadeiro",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Harman",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Roggenbach",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "CALCO 2005",
            "volume": "3629",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/11548133_13"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Types and coalgebraic structure",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "P"
                    ],
                    "last": "Gumm",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schr\u00f6der",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Algebra Univers",
            "volume": "53",
            "issn": "2",
            "pages": "229--252",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "A design structure for higher order quotients",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "V"
                    ],
                    "last": "Homeier",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "TPHOLs 2005",
            "volume": "3603",
            "issn": "",
            "pages": "130--146",
            "other_ids": {
                "DOI": [
                    "10.1007/11541868_9"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Lifting and Transfer: a modular design for quotients in Isabelle/HOL",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Huffman",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kun\u010dar",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "CPP 2013",
            "volume": "8307",
            "issn": "",
            "pages": "131--146",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-03545-1_9"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "A catalogue of canonical term rewrite systems",
            "authors": [
                {
                    "first": "J.-M",
                    "middle": [],
                    "last": "Hullot",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Quotients revisited for Isabelle/HOL",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kaliszyk",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Urban",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "1639--1644",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Types, Abstraction and Parametric Polymorphism in Higher-Order Logic",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kun\u010dar",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "From types to sets by local type definition in higher-order logic",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kun\u010dar",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Popescu",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "J. Autom. Reasoning",
            "volume": "62",
            "issn": "2",
            "pages": "237--260",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Automatic refinement to efficient data structures: a comparison of two approaches",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Lammich",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "J. Autom. Reasoning",
            "volume": "63",
            "issn": "1",
            "pages": "53--94",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Formal proof development",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Coinductive. Archive of Formal Proofs",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Effect polymorphism in higher-order logic (proof pearl)",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "J. Autom. Reasoning",
            "volume": "63",
            "issn": "2",
            "pages": "439--462",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Equational reasoning with applicative functors",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schneider",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "ITP 2016",
            "volume": "9807",
            "issn": "",
            "pages": "252--273",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-43144-4_16"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Relational parametricity and quotient preservation for modular (co)datatypes",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schneider",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ITP 2018",
            "volume": "10895",
            "issn": "",
            "pages": "411--431",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-94821-8_24"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Formalizing constructive cryptography using CryptHOL",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lochbihler",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Sefidgar",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "A"
                    ],
                    "last": "Basin",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Maurer",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "CSF 2019",
            "volume": "",
            "issn": "",
            "pages": "152--166",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Quotients by idempotent functions in Cedille",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Marmaduke",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Jenkins",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Stump",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "TFP 2019",
            "volume": "12053",
            "issn": "",
            "pages": "1--20",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-47147-7_1"
                ]
            }
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Concrete Semantics -With Isabelle/HOL",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-10542-0"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Unified decision procedures for regular expression equivalence",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nipkow",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "ITP 2014",
            "volume": "8558",
            "issn": "",
            "pages": "450--466",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Quotient types: a modular approach",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Nogin",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "TPHOLs 2002",
            "volume": "2410",
            "issn": "",
            "pages": "263--280",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-45685-6_18"
                ]
            }
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Defining functions on equivalence classes",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "C"
                    ],
                    "last": "Paulson",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "ACM Trans. Comput. Log",
            "volume": "7",
            "issn": "4",
            "pages": "658--675",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Higher order quotients and their implementation in Isabelle/HOL",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Slotosch",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "TPHOLs 1997",
            "volume": "1275",
            "issn": "",
            "pages": "291--306",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "A new look at generalized rewriting in type theory",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sozeau",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Formalized Reasoning",
            "volume": "2",
            "issn": "1",
            "pages": "41--62",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Foundational, compositional (co)datatypes for higher-order logic: category theory applied to theorem proving",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Traytel",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Popescu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Blanchette",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "LICS 2012",
            "volume": "",
            "issn": "",
            "pages": "596--605",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Some properties of set functors",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Trnkov\u00e1",
                    "suffix": ""
                }
            ],
            "year": 1969,
            "venue": "Commentationes Mathematicae Univ. Carol",
            "volume": "10",
            "issn": "2",
            "pages": "323--352",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "On descriptive classification of set-functors I",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Trnkov\u00e1",
                    "suffix": ""
                }
            ],
            "year": 1971,
            "venue": "Commentationes Mathematicae Univ. Carol",
            "volume": "12",
            "issn": "1",
            "pages": "143--174",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Two set-based implementations of quotients in type theory",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Veltri",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "SPLST 2015. CEUR Workshop Proceedings",
            "volume": "1525",
            "issn": "",
            "pages": "194--205",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "A Type-Theoretical Study of Nontermination",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Veltri",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Springer Nature Switzerland AG 2020 N. Peltier and V. Sofronie-Stokkermans (Eds.): IJCAR 2020, LNAI 12167, pp. 58-78, 2020. https://doi.org/10.1007/978-3-030-51054-1_4",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "y and (2) = map F e \u22121 (map F (map 1+ g) y) b y c h o i c e o f y and (5) \u223c map F e \u22121 (map F (map 1+ g) (map F e x)) by y \u223c map F e x and (2) = map F g x as e \u22121 \u2022 map 1+ gi \u2022 e = gi Lemma 1 allows us to express the conditions",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "A terminated coinductive list (\u03b1, \u03b2) tllist is either a finite list of \u03b1 values terminated by a single \u03b2 value, or an infinite list of \u03b1 values. They can be seen as a quotient of pairs \u03b1 llist \u00d7 \u03b2, where the first component stores the possibly infinite list given by a codatatype llist and the second component stores the terminator. The equivalence relation identifies all pairs with the same infinite list in the first component, effectively removing the terminator from infinite lists. 2 Let (xs, b) \u223c tllist (ys, c) iff xs = ys and, if xs is finite, b = c. Like \u223c P from Example 2, \u223c tllist does not satisfy the naive condition (3).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Proof diagram for Theorem 4",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "We identify sufficient criteria for when a quotient type preserves the BNF properties of the underlying type. Registering a quotient as a BNFs allows (co)datatypes to nest recursion through it. Consider for example node-labeled unordered binary trees datatype ubtree = Leaf | Node nat (ubtree upair) BNF use cases beyond datatypes benefit equally. 2. In particular, we show that the straightforward definitions would cause the functor to be unsound, and find better definitions that avoid unsoundness. We propose a sufficient criterion on \u223c for subdistributivity, which is typically the most difficult BNF property to show. We show with several examples that the criterion is applicable in practice and yields relatively simple proofs. 4. We have implemented an Isabelle/HOL command to register the quotient as a BNF, once the user has discharged the conditions on \u223c. The command also generates proof rules for transferring theorems about the BNF operations from the underlying type to the quotient (Sect. 4.2). Several case studies demonstrate the command's usefulness. Some examples reformulate wellknown BNFs as quotients (e.g., unordered pairs, distinct lists, finite sets). Others formally prove the BNF properties for the first time, e.g., cyclic lists, the free idempotent monoid, and regular expressions modulo ACI. These examples become part of the collection of formalized BNFs and can thus be used in datatype definitions and other BNF applications.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "relates two equivalence classes [x] \u223c and [y] \u223c iff there are representatives x \u2208 [x] \u223c and y \u223c [y] \u223c such that (x , y ) \u2208 rel F R. This relator does not satisfy in rel. Example 2 (continued). By the lifted definition, ([Inl x] \u223cP , [Inl y] \u223cP ) / \u2208 rel QP {} because there are no (x , y ) in the empty relation {} that could be used to relate using rel FP the representatives Inl x and Inl y . However, the witness z = [Inl (x, y)] \u223cP satisfies the right-hand side of in rel as Q {} = {[Inl ] \u223cP }. \u2666",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "makes it hard to work with repaired functors, especially as the case distinctions proliferate for multivariate functors. Instead, we repair the unsoundness by avoiding empty sets altogether: Our characterization F A in Lemma 1 effectively derives the quotient from (1 + \u03b1) F instead of \u03b1 F . Moreover, our characterization of F A generalizes Barr and Gumm's definition of distinguished points: for A = {}, (5) simplifies to",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "liftQ P [x]\u223c = (\u2203x \u2208 [x]\u223c. P x ) liftQ R [x]\u223c [y]\u223c = (\u2203x \u2208 [x]\u223c. \u2203y \u2208 [y]\u223c. R x y )That is, these definitions correspond to the naive constructionQ A = [ F A] \u223c and rel Q R = [rel F R] \u223c where [(x, y)] \u223c = ([x] \u223c ,[y] \u223c ). As discussed above, the resulting quotient may be an unsound functor. Consequently, lifting of predicates does not preserve empty intersections in general. This hinders modular proofs.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We thank David Basin for supporting this work, Ralf Sasse and Andrei Popescu for insightful discussions about confluent relations, BNFs, their preservation of wide intersections, and ways to express the setters in terms of the mapper, and Jasmin Blanchette and the anonymous IJCAR reviewers for numerous comments on earlier drafts of this paper, which helped to improve the presentation. Julian Biendarra developed the lift bnf command for subtypes, which we extend to quotient types in this work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgment."
        }
    ]
}