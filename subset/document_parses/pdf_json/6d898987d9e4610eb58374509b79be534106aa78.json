{
    "paper_id": "6d898987d9e4610eb58374509b79be534106aa78",
    "metadata": {
        "title": "An OpenCL 3D FFT for Molecular Dynamics Simulations on Multiple FPGAs",
        "authors": [
            {
                "first": "Lawrence",
                "middle": [
                    "C"
                ],
                "last": "Stewart",
                "suffix": "",
                "affiliation": {},
                "email": "larry.stewart@silicontx.com"
            },
            {
                "first": "Carlo",
                "middle": [],
                "last": "Pascoe",
                "suffix": "",
                "affiliation": {},
                "email": "carlo.pascoe@silicontx.com"
            },
            {
                "first": "Brian",
                "middle": [
                    "W"
                ],
                "last": "Sherman",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Martin",
                "middle": [],
                "last": "Herbordt",
                "suffix": "",
                "affiliation": {},
                "email": "herbordt@bu.edu"
            },
            {
                "first": "Vipin",
                "middle": [],
                "last": "Sachdeva",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "3D FFTs are used to accelerate MD electrostatic forces computations but are difficult to parallelize due to communications requirements. We present a distributed OpenCL 3D FFT implementation on Intel Stratix 10 FPGAs for grids up to 128 3 . We use FPGA hardware features such as HBM2 memory and multiple 100 Gbps links to provide scalable memory accesses and communications. Our implementation outperforms GPUs for smaller FFTs, even without distribution. For 32 3 we achieve 4.4 microseconds on a single FPGA, similar to Anton 1 on 512 nodes. For 8 parallel pipelines (hardware limited), we reach the same performance both locally and distributed, showing that communications are not limiting the performance. Our FFT implementation is designed to be part of the electrostatic force pipeline of a scalable MD engine.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Molecular dynamics (MD) simulations play an important role in drug discovery. MD simulation engines such as AMBER [1] and OpenMM [2] provide high performance implementations for CPU and GPU, and provide a flexible framework in which new computational technologies can be assessed.",
            "cite_spans": [
                {
                    "start": 114,
                    "end": 117,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 129,
                    "end": 132,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "One of the key challenges in molecular dynamics simulations is the long-range (LR) electrostatic force computation, which often uses Ewald summation to split the work into shortrange and long-range terms. Methods for the long-range term include k-space summation [3] , \u00b5-series [4] , and use of Fourier Transforms to solve Poisson's Equation [5] , [6] . The FFT methods reduce computation from O(N 2 ) to O(N logN ), but require global communication and strong scaling of 3D FFTs in the size range from 32 3 to 128 3 .",
            "cite_spans": [
                {
                    "start": 263,
                    "end": 266,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 278,
                    "end": 281,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 342,
                    "end": 345,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 348,
                    "end": 351,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In this paper we describe an FPGA-based architecture, implementation, and evaluation of a distributed 3D FFT applicable to molecular dynamics simulations. Our implementation outperforms GPUs on small transforms, and is scalable to pipelines on a single or multiple boards. It is implemented entirely in OpenCL and works for a variety of sizes applicable to drug discovery. Furthermore, we provide an overall design for a scalable long-range MD pipeline.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "The outline of this paper is as follows: Section II discusses background and related work on MD and FFT targeting contemporary architectures including CPUs, GPUs, and ASICs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Section III details the system architecture of our FFT as well as long-range pipeline, and Section IV follows up with the implementation details in OpenCL. Section V describes how the design from Section III fits into a complete MD engine running on multiple FPGAs with minimal host communication. Section VI summarizes the results of our work, along with performance comparison to other hardware. Finally, section VII concludes the paper along with our plans for future work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "II. BACKGROUND AND RELATED WORK Molecular dynamics simulations have proven to be a valuable tool in drug discovery for understanding protein motion. Opensource GPU accelerated molecular dynamics applications such as GROMACS [7] , NAMD [8] , OpenMM [2] , and CP2K [9] allow many practitioners to use MD simulations as a regular tool. AMBER [1] , while not open-source, is another MD engine that is widely used in industry. This has led to clusters of GPUs running replica or throughput MD jobs in both academic and commercial settings, but there is a need for improved runtime of fixed size problems (strong scaling) to enable faster development cycles. Strong scaling of molecular dynamics on cluster of GPUs has proved to be successful in systems with millions of atoms. Summit, a hybrid POWER9 Tesla V100 GPU system, has proven to be scalable on thousands of nodes for systems with 21 million and 224 million atoms [10] . Each node on the system is comprised of 2 Power9 nodes with 6 Tesla V100 GPUs. The GPUs are directly connected using the NVLINK2 interconnect, while the nodes themselves are connected using Infiniband. While single GPUs or clusters of GPUs have proved to be enormously successful in throughput jobs and scaling systems with millions of atoms, strong scaling of a single protein system has proved to be far more challenging. To our knowledge, the only study showing strong scaling on GPUs for a 100,000 atom system is with the recently redeveloped GROMACS package [11] , [12] , which does not distribute the FFT across multiple GPUs.",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 227,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 235,
                    "end": 238,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 248,
                    "end": 251,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 263,
                    "end": 266,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 339,
                    "end": 342,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 917,
                    "end": 921,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1487,
                    "end": 1491,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1494,
                    "end": 1498,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Several efforts to develop custom ASICs for small molecule simulations have been undertaken. ASICs require long development times and lack reconfigurability, but sheer performance makes them attractive. The earliest initiative is the MDGRAPE [13] series of supercomputers, developed by the RIKEN center in Japan. MDGRAPE-4a, the fourth generation of the MDGRAPE series of supercomputers is capable of 1.1 microseconds for a 100,000 atom system. Another very well known initiative for strong scaling molecular dynamics ASICs is the Anton series of supercomputers [14] developed by D. E. Shaw Research and capable of tens of microseconds in a single day. Anton 1 was released in 2007, with performance for a 23,000 atom system close to 17 microseconds/day. Anton 2, released in 2014, increased this performance five-fold to 85 microseconds/day [15] .",
            "cite_spans": [
                {
                    "start": 242,
                    "end": 246,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 562,
                    "end": 566,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 586,
                    "end": 590,
                    "text": "Shaw",
                    "ref_id": null
                },
                {
                    "start": 842,
                    "end": 846,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "The most challenging part of scaling molecular dynamics simulations is the electrostatic forces computation, of which FFT is often a major component. Anton required many custom architectural features such as over 300 gigabits per second of bandwidth per node, message latency in the hundreds of nanoseconds, and support for word-level writes and singleended communication [16] . Using these architectural features, Anton 1 could solve FFT problems of size 32 3 in 3.7 microseconds, and 64 3 in 13.3 microseconds on 512 nodes. Anton 2 did not use FFT in its simulations, instead relying on a different decomposition called the \u00b5-series [4] , [15] . By using a separable kernel, the long-range Ewald term can be directly calculated by X, Y, and Z 1D convolutions without the use of FFT. This improved performance by 15% but increased communications requirements.",
            "cite_spans": [
                {
                    "start": 372,
                    "end": 376,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 635,
                    "end": 638,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 641,
                    "end": 645,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "Efforts to get parts of molecular dynamics simulations running on FPGAs have been explored over the past few years [17] , [18] . More recently, the increase in FPGA resources such as logic elements, DSPs, BRAM, etc., have allowed full MD simulations to run on a single FPGA [19] .",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 119,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 122,
                    "end": 126,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 274,
                    "end": 278,
                    "text": "[19]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "One of the greatest strength of FPGAs is the I/O transceivers, which are capable of providing hundreds of gigabits of bandwidth per FPGA with very low latency [20] . Some clusters with highly interconnected FPGAs are the Novo-G# built at the University of Florida in a 3D torus interconnect [21] and the first version of the Microsoft Catapult [22] . More recently, University of Paderborn has developed Noctua [23], a Cray system with Stratix 10 FPGAs connected via an optical circuit switch. In addition, Tsukuba University has deployed Cygnus, a hybrid GPU-FPGA system [24] . FPGA communications can also now be programmed using OpenCL [25] , providing a high-performance productive environment for distributed applications. Prior work on 3D FFTs on single FPGAs includes [9] , [26] - [29] while work on multiple FPGAs includes [30] , [31] . Design of FFT for MD simulations is presented in [32] . The earliest 2D floating point FFT on multiple FPGAs of which we are aware is [33] . In this paper, we present the design and implementation of 3D FFT running on multiple directly connected FPGAs and discuss its inclusion in a multi-FPGA MD engine. The entire code is written in OpenCL for ease of programming and portability. Our implementation shows superior performance to GPUs for smaller sizes, and demonstrates strong scaling for multiple pipelines. ",
            "cite_spans": [
                {
                    "start": 159,
                    "end": 163,
                    "text": "[20]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 291,
                    "end": 295,
                    "text": "[21]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 344,
                    "end": 348,
                    "text": "[22]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 572,
                    "end": 576,
                    "text": "[24]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 639,
                    "end": 643,
                    "text": "[25]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 775,
                    "end": 778,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 781,
                    "end": 785,
                    "text": "[26]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 788,
                    "end": 792,
                    "text": "[29]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 831,
                    "end": 835,
                    "text": "[30]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 838,
                    "end": 842,
                    "text": "[31]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 894,
                    "end": 898,
                    "text": "[32]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 979,
                    "end": 983,
                    "text": "[33]",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "I. INTRODUCTION"
        },
        {
            "text": "In this section, we briefly show how FFT fits into a full Molecular Dynamics application. We then detail our FFT pipeline and communications architecture, and also describe our planned full long-range pipeline that incorporates the charge spreading, FFT, and force interpolation steps, which compute long-range electrostatic forces. We describe the overall architectural and scaling issues that constrain the system design. The overall architectural problem is to build an efficient longrange pipeline which can stream data. A pipeline runs at the speed of its slowest unit, so we apply parallel hardware to different portions of the design in order to balance the whole.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "III. SYSTEM ARCHITECTURE"
        },
        {
            "text": "Molecular Dynamics models the behavior of atoms and molecules by individually calculating the various forces that act on them. Forces that apply to bonded atoms include bond torsions and tensions. Forces that apply to non-bonded atoms include short-range forces that include both van der Waals and electrostatics, and long-range forces, which are mainly electrostatic. Short-range forces are managed by pairwise computations, but this becomes infeasible for the large numbers of atoms at increasing range. For long-range forces, applications instead use multipole approximations [34] or Ewald summations. Our focus is on an Ewald variation known as Smooth Particle Mesh Ewald (SPME) [35] . SPME calculates a charge distribution on a grid, then uses Fourier Transforms and a Green's function to calculate a potential field. Potential gradients then are used to calculate forces. Figure 1 shows the OpenCL portions of our modified OpenMM application and the role played by 3D FFT. Our goal is to run multiple timesteps of the full MD application on a network of FPGAs without any additional host communication beyond initialization and result collection.",
            "cite_spans": [
                {
                    "start": 579,
                    "end": 583,
                    "text": "[34]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 683,
                    "end": 687,
                    "text": "[35]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [
                {
                    "start": 878,
                    "end": 886,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "A. Molecular Dynamics"
        },
        {
            "text": "The three dimensional FFT of an XYZ volume can be computed as a sequence of one dimensional transforms [36] , [37] . First, each vector of samples in the X direction (fixed Y and Z) is transformed. There are N 2 such 1D transforms, known as pencils. Then 1D transforms in the Y direction are made, followed by 1D transforms in the Z direction as shown in Figure 2 (a). Each 1D transform takes N logN operations, leading to a total computation of 3N 3 logN operations. For complex data, this takes approximately 15N 3 logN flops.",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 107,
                    "text": "[36]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 110,
                    "end": 114,
                    "text": "[37]",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [
                {
                    "start": 355,
                    "end": 363,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "B. 3D FFT"
        },
        {
            "text": "Because all X transforms are independent, they can be done in parallel, provided the appropriate input data is local to the FFT hardware. Similarly, all the Y transforms are independent, as are the Z. Figure 2 (b) shows a parallelization in which the input volume is broken into slabs that contain subsets of the Z dimension. Within each slab, all data is locally available for the X and Y transforms, but only half the data for each Z dimension transform. After the YFFT phase, the pipelines must exchange data in an all to all pattern so that each pipeline has the data it needs to complete subsets of the Z direction FFTs. There are alternative parallel 3DFFT formulations such as 2D decomposition as used in [38] and the generalized vector radix decomposition [39] but for up to 64 nodes and 128 3 our initial focus is on the slab decomposition. In 2012, Galvez, Huang, and Chen showed how to build pipelined parallel FFT hardware using a feedforward architecture that is well suited to FPGA implementations [40] . As an example, an 8-wide parallel FFT unit will compute a 32point 1D FFT in 4 cycles plus a 3 cycle pipeline latency. Multiple transforms can be pipelined with a 4 cycle pitch. A 64-point FFT takes 8 cycles with a 6 cycle latency. A 128point FFT takes 16 cycles with a 7 cycle latency. The OpenCL implementation can be compiled for any power of two size. 8-wide single precision complex requires a 512-bit wide data bus, which is a good match for Stratix 10 Fmax in the 250-350 MHz range. This sort of computational unit uses 5-9% of a Stratix 10 device depending on transform size and consumes and delivers about 19 GB/sec of data.",
            "cite_spans": [
                {
                    "start": 712,
                    "end": 716,
                    "text": "[38]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 764,
                    "end": 768,
                    "text": "[39]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 1012,
                    "end": 1016,
                    "text": "[40]",
                    "ref_id": "BIBREF42"
                }
            ],
            "ref_spans": [
                {
                    "start": 201,
                    "end": 209,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "B. 3D FFT"
        },
        {
            "text": "The challenge of any FFT is that every output depends on every input. The FFT is a great advance over the DFT in that it reduces an O(N 2 ) problem to an O(N logN ) problem, but it doesn't help with memory requirements or communications. It is straightforward to do the FFT calculations, but not so straightforward to get the correct operands to the functional units in the correct order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. 3D FFT"
        },
        {
            "text": "A fully pipelined FFT can complete N 2 1D FFTs in the number of clock cycles it takes to read the data. Using a nominal 300 MHz design speed, Table I shows the time in microseconds to complete N 2 1D FFTs for various size transforms, given different numbers of 8-wide vector compute units. To complete a 3D FFT will take three times as much computation but the work can be both pipelined and parallelized by interconnecting multiple FFT cores.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 142,
                    "end": 149,
                    "text": "Table I",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "B. 3D FFT"
        },
        {
            "text": "1) FFT Scaling: When multiple FFT units are combined on a single FPGA, connecting them is not usually a problem because FPGAs have a great deal of internal connectivity and bandwidth. An 8-wide single precision complex FFT has 512 bit input and output busses, which operate at the OpenCL compiler speeds of around 300 MHz. Each pipeline accepts and delivers data at 154 Gbps or about 19 GBps. These speeds are well within the performance of two striped HBM2 banks, and a Stratix 10 FPGA has 32 such banks. We have packaged and interconnected eight FFT pipelines on a single device with HBM2 I/O and achieved up to 969 GF/s computation performance and 370 GB/s of HBM bandwidth. This is encouraging, but it uses 74% of the arithmetic resources of the chip, leaving little for the rest of the molecular dynamics problem. In order to achieve still higher performance and permit a fully integrated MD application, it is necessary to parallelize the FFT across multiple FPGAs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. 3D FFT"
        },
        {
            "text": "In order to distribute such a system over a network of FPGAs, it is necessary to balance communications and computation performance it is also necessary to choose points in the solution spaces for FFT and for All to All in which the bandwidths match.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. 3D FFT"
        },
        {
            "text": "The cells in Table I with parenthesized references represent particular solution choices that match well with potential communications designs, which are discussed in section III-C.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 13,
                    "end": 20,
                    "text": "Table I",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "B. 3D FFT"
        },
        {
            "text": "The all to all network is responsible for interchange of data among multiple processing pipelines, both when colocated on a single board and when distributed across multiple FPGAs. The role of the all to all network is shown, for two pipelines, in Figure 2 . It must reorganize the data of the FFT volume from one distributed along the Z dimension to one distributed along the X or Y direction. A convenient intuition is to consider storage of the FFT volume as being described by a global address, in which the high bits identify the FFT pipeline. The purpose of the All to all is to swap the lowest address bits with the highest bits.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 248,
                    "end": 256,
                    "text": "Figure 2",
                    "ref_id": null
                }
            ],
            "section": "C. All to All"
        },
        {
            "text": "For two pipelines, the overall volume is split between two pipes. Initially, the Z dimension is distributed across the pipelines. After the exchange, the Y dimension is distributed. Each unit must send half its data to the other to accomplish this exchange. For eight processing pipelines, each pipe manages one eighth of the data, and must transmit 1/8 of their share (1/64 of the total) to each of the other pipelines. In any parallelization into N units, (N \u2212 1)/N of the data must move. Since FFT and all to all are pipelined, the overall performance will be set by the slower function.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "1) Network Topologies: In order to implement an efficient all to all, we require a network with very high bandwidth and very high bisection bandwidth, as constrained by available hardware",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "Our current testbed uses four BittWare 520N-MX modules [41] , each with a single Intel Stratix 10 MX2100 FPGA [20] and 4 QSFP28 communications ports operating at 100 Gbps. The vendor board support package makes the communications links available as 256 bit wide FIFO channels which can operate at up to 390 MHz (100 Gbps). We are operating with a preliminary version which runs up to 305 MHz (78 Gbps).",
            "cite_spans": [
                {
                    "start": 55,
                    "end": 59,
                    "text": "[41]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 110,
                    "end": 114,
                    "text": "[20]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "For two-board designs, we can operate with 4 parallel full duplex links, offering 312 Gbps in each direction. We can operate four boards with point to point links connecting each pair of boards. For larger numbers of boards, the available four ports permit hypercubes up to 16 nodes, or arbitrarily large two dimensional torus networks. We are evaluating use of short copper cables to create two additional links for in-chassis connections. Six links would permit hypercube networks up to 64 boards or 3D torus networks of any size. We use optical external cables so we are not constrained by cable length for off-chassis connections. With four FPGA boards per server, we can build single rack systems up to 64 nodes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "Direct networks such as Hypercube, 2D, and 3D torus networks require multiple hops for full connectivity using an on-chip router (see Section IV-C1. Another possibility would be to use on-board hard Ethernet MACs and 100 Gbps Ethernet switches to build single hop networks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "2) All to all scaling: We can now analyze potential network topologies to evaluate points in the solution space that are compatible with distributed FFT designs. Table II relates numbers of FPGA modules, network topology, and the time to complete the All to All. The environment for this analysis consists of a number of FPGA nodes, each equipped with either four or six links running at 100 Gbps. Configurations marked \"Switched\" use Ethernet packet framing to route messages via 100 Gbps Ethernet switches to achieve single hop connections. The switched configurations use all available ports, each connected to a different switch to form multiple independent single-hop networks. This is feasible for up to 64 boards due to the availability of 64 port 100G switches. PtoP configurations use point to point cables, which is feasible for up to 5 modules. Other topologies require on-FPGA switches and higher hopcounts. As an example, a 4 dimensional hypercube for 16 nodes has an average hopcount of 2, because on average a destination node ID differs in only two bits from the source node ID.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 162,
                    "end": 170,
                    "text": "Table II",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "C. All to All"
        },
        {
            "text": "The time to complete figures are given by",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "where D is the FFT data volume in bits. (N \u2212 1)/N is the fraction of data that must be sent to a different board. H is the average hop count, B is the link bandwidth in bits per second, L is the number of links per board, and N is the number of boards.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "The scaling behavior of this equation is such that for a fixed topology, the time to completion goes as H/N, assuming equal link loading, uniform traffic, and perfect link scheduling. All to all certainly has uniform traffic and there is a symmetry argument for uniform link loading.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "For a switched network, perfect scheduling of an all to all is straightforward. In round i, node n transmits to node (n + i) mod N . Point to point networks are also easy to schedule. As for multihop scheduling, the question is still open but we are experimenting with static scheduling as described in Section IV-C1. This analysis is done for 128x128x128 transforms, but similar choices exist for other size FFTs. Since the completion times are entirely bandwidth limited, they scale only with the total data volume and the same points in solution space apply to all sizes. However, for the smaller transforms, hardware unit latencies and communications latencies start to become important.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "These solution points permit balanced designs, in which no unit runs faster than necessary, thus minimizing hardware. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D. Computation vs Communications"
        },
        {
            "text": "In the previous subsection, we detailed the FFT pipeline and discussed scaling FFT to multiple pipelines on one or more boards. We now describe the entire long-range force pipeline for molecular dynamics. The overall architecture of the longrange force pipeline is shown in Figure 3 . The LR pipeline accepts atom positions and charges as input, and delivers longrange electrostatic force updates per atom back to the overall MD application. The LR pipeline is composed of three separate pieces of hardware, each of which is capable of doing several tasks in time interleaved fashion.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 274,
                    "end": 282,
                    "text": "Figure 3",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "\u2022 Charge spreading-transform atom position and charge data into FFT input dataset. The same hardware is used for force interpolation. \u2022 Dual FFT-Two 1D FFT pipelines, with transpose units for data reordering. The hardware is used three times, for X and Y forward transforms, Z and Z-inverse transforms, and Y-inverse and X-inverse transforms. In the Z, Z-inverse case, an additional multiplication is made by the Green's function data for the long-range kernel in the frequency domain. \u2022 All to All network-This hardware is responsible for exchanging data between FFT pipeline instances and among multiple FPGA boards. It is used twice, to transpose data from the output of the forward Y transform to the input of the forward Z transform, and again to transpose data from the output of the Z-inverse transform to the input of the Y-inverse transform. Data is buffered in high bandwidth memory because the Z transform cannot start until the Y transform is finished.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "The overall idea of this LR pipeline is to be able to subdivide the long-range problem into 1 to 128 parallel instances of the LR pipeline that can each process 8 input samples per cycle. With one processing pipeline, a 128-cube problem would take 786432 cycles (XY , ZZ \u22121 , and Y \u22121 X \u22121 at 262,144 each), while with 128 pipelines, with perfect efficiency process would finish in 6,144 cycles. At 350 MHz, that could be 18 microseconds. The fastest 128 3 3D FFT for GPU that we are aware of is 340 microseconds for forward and inverse 1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "1) Charge Spreading: Any particular atom has a fractional position in X, Y, and Z somewhere between grid points in the 3D FFT input volume. The charge attached to the atom is spread to grid points in the 4x4x4 cell surrounding the atom's position. The performance of this step is critical. FFT volumes from 32 3 to approximately 128 3 have been used successfully in MD, but for problems of 50,000 to 100,000 atoms, sizes in the 64 3 to 128 3 range seem the most effective. If we consider the 128 3 case, there are 2,097,152 grid points. With an 8wide vector FFT, that takes 262,144 cycles, divided by the number of available processing pipelines. For 128K atoms, that requires completing the charge spreading calculations for one atom in, on average, two cycles in order to not limit performance. To that end, we have built a 64-way parallel pipelined charge spreading unit that can process one atom per cycle, with additional cycles necessary for atoms whose range of influence crosses boundaries of the chunk size of the FFT pipeline input.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "2) FFT Unit: Described in section IV.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "3) Force Interpolation: The force interpolation unit shares the 64-way parallel arithmetic and BRAM units of the charge spreading hardware. It accepts streaming data from the output of the inverse FFT, and atom position and charge data. 3D cardinal B-splines and their derivatives are used to calculate X, Y, and Z forces for each atom based on gradients of the electrostatic potential field calculated by the FFT. These updates are fed back to the main MD application. The output data from the FFT is temporarily buffered in 8x8x128 chunks in BRAM.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "For A atoms and 3D FFT size N 3 , the charge spreading step operates in O(A) time, the 3D FFT is O (N 3 logN ) , and the force interpolation is again O(A). By choosing an FFT volume proportional to the number of atoms, and by using hardware to remove the logN term, the entire LR pipeline becomes O(A), a dramatic improvement over O(A 2 ) pairwise methods of computing electrostatic forces.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 99,
                    "end": 110,
                    "text": "(N 3 logN )",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "E. Long-Range Pipeline"
        },
        {
            "text": "Intel provides an OpenCL computational kernel example using the feedforward parallel FFT of Garrido et al, and we took it as our starting point. [40] , [42] (This is also used in [29] ). This design accepts vectors bit-reversed by lane and in order by vector. For a 32 point transform, there are four input vectors and four output, offset by a 3 cycle latency, as shown in Figure 4 .",
            "cite_spans": [
                {
                    "start": 145,
                    "end": 149,
                    "text": "[40]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 152,
                    "end": 156,
                    "text": "[42]",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 179,
                    "end": 183,
                    "text": "[29]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [
                {
                    "start": 373,
                    "end": 381,
                    "text": "Figure 4",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "A. FFT"
        },
        {
            "text": "The internal structure of the parallel FFT is shown in Figure  5 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 55,
                    "end": 64,
                    "text": "Figure  5",
                    "ref_id": null
                }
            ],
            "section": "A. FFT"
        },
        {
            "text": "In order to assemble 1D FFT units into a pipelined 3D FFT the sequencing of the data must be modified in order to deliver to and accept data from the FFT units in the correct order. This problem is referred to as bit dimension permutations [43] .",
            "cite_spans": [
                {
                    "start": 240,
                    "end": 244,
                    "text": "[43]",
                    "ref_id": "BIBREF45"
                }
            ],
            "ref_spans": [],
            "section": "B. Bit Dimension Permutations"
        },
        {
            "text": "It is convenient to consider a generalized sample address such as X0 X1 X2 X3 X4 Y0 Y1 Y2 Y3 Y4 Z0 Z1 Z2 Z3 Z4 which represents a notional 32 3 transform stored in memory with the X indices varying fastest. The low three bits, X0 X1 X2, determine the 8-wide vector lane. The high two bits, Z3 Z4, determine the pipeline unit of a four-pipe design. The middle bits, X3...Z2, represent sequential storage locations in memory or sequential communications through a channel.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Bit Dimension Permutations"
        },
        {
            "text": "The FFT processing pipeline is shown in Figure 3 . For this processing pipeline, the generalized sample address must progress through a series of permutations mandated by ordering requirements.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 40,
                    "end": 48,
                    "text": "Figure 3",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "B. Bit Dimension Permutations"
        },
        {
            "text": "For memory operations, the sequencing is constrained by the data layout required by other parts of the system. To some extent, the memory address generator can change the order but cannot change address bits associated with a parallel datapath and should not change the low few bits of the memory address in order to preserve maximally sequential addressing.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Bit Dimension Permutations"
        },
        {
            "text": "The Input transpose unit changes the ordering of the low 5 bits as required by the FFT hardware input ordering. The FFT output is in bit reversed order, which must also be modified to set up conditions for the following unit.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. Bit Dimension Permutations"
        },
        {
            "text": "To accomplish these transformations, we have adopted a flexible transpose unit, shown in Figure 6 . The 512 bit vector input proceeds through three ranks of 2-1 multiplexors forming a butterfly network. The first exchanges the high and low 256 The 512 bit aggregate output then passes through another three ranks of multiplexors controlled by an output block select signal. This structure is able to perform nearly arbitrary bit dimension permutations of the input sequence. A standalone python program uses a control file to generate the OpenCL source code necessary to control the hardware. The \"nearly arbitrary\" limitation is that this structure cannot transform, say X0 X1 X2 ... into X2 X0 X1 in which the same bits are present in the parallel part of the datapath but in different locations. The limitation can be removed by using 5-stage Benes networks [44] at the input and output but we have found the three stage networks suffice for the permutations encountered in 3DFFT. The main constraint is that each BRAM bank has one read port and one write port, so the scheduler must assure that data read during the same cycle must have been written into different banks.",
            "cite_spans": [
                {
                    "start": 861,
                    "end": 865,
                    "text": "[44]",
                    "ref_id": "BIBREF46"
                }
            ],
            "ref_spans": [
                {
                    "start": 89,
                    "end": 97,
                    "text": "Figure 6",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "B. Bit Dimension Permutations"
        },
        {
            "text": "Molecular modelling, at the scale of interest to us, does not use very much memory, but demands extraordinarily high memory bandwidth. This suggests that it might be advantageous to keep the entire dataset for FFT in FPGA block rams, rather than in HBM memory. We have designed an FFT processing pipeline in this style as well, as shown in Figure 7 . This design uses a single FFT processing core, and a single transpose unit, with BRAM expanded to hold a complete slice of the FFT volume. Multiple pipelines are interconnected via the same All to All unit as used elsewhere. The all BRAM design requires three passes to complete a 3D FFT, but because it uses much less hardware than the HBM design, we can fit as many as 16 copies of the pipeline on a single FGPA for FFT sizes at or below 64 3 . As discussed in Section III, the communications requirements mean this is too much computation relative to communications for smaller systems. For designs with 8 FPGAs and up, it becomes possible to fit an entire 128 3 FFT into BRAM, and an all BRAM FFT will permit substantial hardware savings. We report some performance results for all BRAM designs in Section VI. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 340,
                    "end": 348,
                    "text": "Figure 7",
                    "ref_id": null
                }
            ],
            "section": "1) BRAM Only FFT:"
        },
        {
            "text": "The All to all network is responsible for interchange of data among multiple processing pipelines, both when colocated on a single board and when distributed across multiple FPGAs. Figure 8 shows such a design for four processing pipelines on two FPGAs. In this case, two full-duplex interboard cables are used for point to point service, with each cable carrying serialized 256 bit words in each direction. The left side of the figure represents 8-sample wide parallel busses from 4 processing pipelines connecting to the All to all network. The right side of the figure represents the output of the all to all connecting back to the 4 processing pipelines. Inter board cables are shown in bold. Figure 9 is a design for 8 pipelines distributed across four FPGAs. Each board has a direct connection to each other board. Similar to Figure 8 , some connections remain on board, but in the 4 board example they are modelled as a loopback cable that connects a board to itself. In order to use the same bit file on each of the four FPGAs, additional logic in the A2A unit routes these \"virtual cables\" to the correct external port or internal loopback. 1) Router: There is a large literature on interconnect networks and routing strategies, but we are taking a somewhat different tack. For the distributed molecular modelling application, we coordinate the activities of multiple FPGAs both through host communications and direct communications. For direct communications, we need nearest neighbor communications for the range-limited and bonded force pipelines, and for Fig. 9 . All to all network. 8 pipelines on four FPGAs, with cables. atom migration due to particle movement, but the bulk of communications is for the FFT All to All. For four boards, direct point to point cables suffice, but we must use an on-FPGA router for multihop cases. The prototype router uses a crossbar switch with buffering at each crosspoint, together with a statically compiled switch schedule. This permits the network to operate in a streaming mode without packet headers or frame boundaries. Links from application logic to the router use Intel's OpenCL Channel extension, as do the off-board links themselves.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 181,
                    "end": 189,
                    "text": "Figure 8",
                    "ref_id": null
                },
                {
                    "start": 697,
                    "end": 705,
                    "text": "Figure 9",
                    "ref_id": null
                },
                {
                    "start": 832,
                    "end": 840,
                    "text": "Figure 8",
                    "ref_id": null
                },
                {
                    "start": 1568,
                    "end": 1574,
                    "text": "Fig. 9",
                    "ref_id": null
                }
            ],
            "section": "C. All to All"
        },
        {
            "text": "Because the all to all communication pattern is symmetric, switch scheduling reduces to a bin packing problem of packing message fragments into open channel time slots, while managing the maximum buffer occupancy [45] , [46] . There is no danger of livelock or deadlock and no need for traditional techniques such as virtual channels, because all messages are known at compile time. Flow control and error recovery are provided by the vendor Board Support Package (BSP). We expect to report results in future work.",
            "cite_spans": [
                {
                    "start": 213,
                    "end": 217,
                    "text": "[45]",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 220,
                    "end": 224,
                    "text": "[46]",
                    "ref_id": "BIBREF48"
                }
            ],
            "ref_spans": [],
            "section": "C. All to All"
        },
        {
            "text": "An individual long-range processing pipeline is shown in Figure 10 . This unit is replicated in order to achieve the desired performance. The FFT portion of the unit consists of two FFT cores and three transpose units. The FFT can accept input from the charge spreading unit, or from HBM memory. The output of the second FFT can be streamed to the force interpolation unit or sent to the All to All hardware and then buffered in HBM memory.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 57,
                    "end": 66,
                    "text": "Figure 10",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "D. Long-Range Pipeline"
        },
        {
            "text": "Within each processing pipeline, as soon as a single XY plane is complete, the second FFT core can begin processing Y direction transforms. As soon as a Y direction transform completes, the output data can stream to a pipelined all to all function, which redistributes data in preparation for Z direction transforms. The output of the all to all cannot be directly streamed to a third FFT core, because the Z direction transforms cannot begin until all the Y direction transforms are complete. Instead, the all to all output is buffered in HBM memory. A second pass reuses one of the FFT cores to compute Z direction transforms. The output of the Z direction transform is streamed to the Green's function multiplier and then to the Z \u22121 transform and then to a second pass through the All to All. A third pass implements the Y \u22121 and X \u22121 transforms and feeds the force interpolation unit. The full forward and inverse 3D FFT can be accomplished in three times the time shown in Table I . At the time of submission of this paper, the full long-range pipeline gives correct results on test data from OpenMM but is not yet running at full speed on actual hardware. Our long-range pipeline execution currently requires hardware and FPGA connection debugging, which can only be performed in person. This has been a bottleneck due to COVID-19 related restrictions on movement.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 979,
                    "end": 986,
                    "text": "Table I",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "D. Long-Range Pipeline"
        },
        {
            "text": "We chose OpenCL as the programming language for our implementation. This is due to several reasons: OpenCL allows more productive software development, and also allows us to be vendor-agnostic. Using OpenCL on the host side has allowed us to reuse OpenMM's framework for launching kernels on the FPGA as well. OpenCL compilation for FPGAs transforms high-level source code into a dataflow graph and instantiates the necessary hardware. We approach FPGA coding in OpenCL with a hardware engineer's perspective. It is possible to visualize the dataflow hardware you want, as in Figure 5 or Figure 6 and then write fairly straightforward code to realize it. The tricky parts are cajoling the compiler into doing what you want. Paradoxically, the language is too high-level for this to be straightforward, yet the development cycle is still much faster with OpenCL than with traditional hardware description languages e.g., Verilog or VHDL. Further, the software and FPGA parts of the OpenCL Runtime provide good tools for moving data between host and devices. Our wish list for OpenCL includes the ability to declare BRAM storage with explicit geometry and to use it from multiple OpenCL kernels, support for pipelines and channels with both endpoints in the same kernel, support for multiple clock domains, better support for bitfields, and low level access to memory controllers and to serial communications hardware. OpenCL provides only high level abstractions, which to some extent hides the underlying power of the hardware. In short we'd like better control over low level implementation, while retaining ease of host program integration.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 576,
                    "end": 584,
                    "text": "Figure 5",
                    "ref_id": null
                },
                {
                    "start": 588,
                    "end": 596,
                    "text": "Figure 6",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "E. Using OpenCL for FPGA programming"
        },
        {
            "text": "In the future, we may move some parts of our implementation into VHDL or Verilog for optimal resource utilization. OpenCL does permit linking to HDL 2 provided the HDL modules provide certain prescribed interfaces.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E. Using OpenCL for FPGA programming"
        },
        {
            "text": "Our ultimate goal is to perform multiple timesteps of the full MD application on a network of FPGAs without any additional host communication beyond initialization and result collection. This architecture is shown in Figure 1 . Required MD functionality must include: short-range, long-range and bonded force calculations, motion integration, on-chip particle data storage and management, etc. [19] . In this paper, we focus on 3DFFT and its use in long-range force calculation while other aspects are the focus of current and future work. We chose FFT instead of the \u00b5-series that Anton 2 implemented [15] . At the time of implementation, it was not clear to us if \u00b5-series will give us benefits on the FPGA. The \u00b5-series seems to increase communication requirements, and therefore this algorithm might be better suited for the Anton-2 architecture and in any case a fast FFT is useful for a variety of problems in addition to MD.",
            "cite_spans": [
                {
                    "start": 394,
                    "end": 398,
                    "text": "[19]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 602,
                    "end": 606,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [
                {
                    "start": 217,
                    "end": 225,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "V. MOLECULAR DYNAMICS ON MULTIPLE FPGAS"
        },
        {
            "text": "As the required on-chip resources for problem sizes of interest (e.g., 64k-128k atom simulations) exceed that which is available for a single target FPGA, we must employ some degree of resource sharing and/or circuit partitioning across multiple FPGAs to achieve the required performance. We use a straight-forward spatial decomposition scheme to partition work across multiple FPGAs. The short-range and bonded force pipelines operate on nearby particles, with particle migration handled by a motion update module (see Figure 1 ). Given a fixed problem size, as we increase the number of FPGAs, the required resources per FPGA will decrease. For a high number of FPGAs, there are sufficient resources per FPGA to employ a homogeneous design (i.e., all MD functionality for a given sub-region of simulated space is performed on the same FPGA). For a low number of FPGAs (e.g., [4] [5] [6] [7] [8] , this is not the case and we must employ a heterogeneous design. This design will assign long-range pipelines to a subset of FPGAs, with all other functionality assigned to the remaining FPGAs. This approach is similar to, and inspired by, the parallelization strategy used in GROMACS [47] . A diagram is shown in Figure 11 .",
            "cite_spans": [
                {
                    "start": 877,
                    "end": 880,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 881,
                    "end": 884,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 885,
                    "end": 888,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 889,
                    "end": 892,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 893,
                    "end": 896,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1183,
                    "end": 1187,
                    "text": "[47]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 520,
                    "end": 528,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 1212,
                    "end": 1221,
                    "text": "Figure 11",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "V. MOLECULAR DYNAMICS ON MULTIPLE FPGAS"
        },
        {
            "text": "Data communication between long-range and other pipelines is performed through QSFP channels, which directly communicate between FPGAs without coordinating with the host. The communication interface to/from the LR pipeline is a stream of atom positions and charges to and a stream of atom force updates from the pipelines. Although, we ultimately plan to construct a 64-FPGA cluster configured as a 4 3 3D-torus, our initial target of a 4-FGPA prototype is configured as 2 FPGAs with 2 LR pipelines each and the other 2 FPGAs are reserved for the rest of the application. With this configuration, we can support four atoms per cycle and four force updates per cycle, which matches the capability of the LR pipeline design to 2 Hardware Description Language: typically VHDL or Veriloig accept data and deliver results without processing delays. We balance the performance of the various pipelines to minimize the maximum runtime and thus minimize the timestep execution time.",
            "cite_spans": [
                {
                    "start": 725,
                    "end": 726,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "V. MOLECULAR DYNAMICS ON MULTIPLE FPGAS"
        },
        {
            "text": "We have developed three versions of 3D FFT. All of these versions are in OpenCL, with no Verilog or VHDL components. The first is a BRAM only design, with up to 16 processing pipelines per FPGA. The second is an HBM-based design with up to 8 processing pipelines per FPGA, but each pipeline includes two FFT units chained together. The third design is a full implementation of FFT and inverse FFT for use in the long-range force pipeline. Because the forward-backward FFT requires six 1D FFTs, it can share hardware and runs in about 2/3 the time of two single transforms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VI. EVALUATION"
        },
        {
            "text": "Our hardware setup comprises 4 BittWare 520N-MX boards on a single hardware node. The hardware node has 2 8-core Intel Xeon Silver CPUs as well as 768 GB of memory used mostly for OpenCL compilation jobs. The CPUs also serve as host processor for the OpenCL FFT programs. Each 520N-MX has 4 QSFP28 channels, each capable of communicating at a peak bandwidth of 100 Gb/s. Each board is connected to each other board using a QSFP28 channel. The fourth channels are connected in pairs to provide double bandwidth for two-board configurations. Each FPGA is configured with the p520 max m210h BSP to allow OpenCL as the programming model for FPGA computation as well as communication between the different boards. Our application source code is compiled using Quartus release 19.3. The server runs CentOS 7.6. We use SLURM to manage both compilation and hardware resources.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A. Experimental Setup"
        },
        {
            "text": "We first present results of our BRAM-based FFT. In this version, the entire dataset fits into the BRAM of the FPGA. Results from this design are shown in table III. We present single FPGA results for this design, with up to 16 processing pipelines, for FFT sizes 32 3 and 64 3 . A BRAM only 128 3 design will not fit on our current hardware available due to BRAM limitations. The 32 3 version occupies 28% of the BRAMS and 52% of the DSP blocks and runs in 4.4 microseconds at 260 MHz. The 64 3 version occupies 49% of the BRAMS and 58% of the DSP blocks and runs in 24.5 microseconds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. BRAM-based FFT"
        },
        {
            "text": "Because interboard communications are limited to 400 Gbps, one cannot use more than 8 processing pipelines in a two-board or four-board design. For larger systems, BRAM-based 128 3 transforms become feasible because the amount of BRAM storage scales with the system size. The 128 3 would require 134 megabits of BRAM, spread out over the entire system. As shown in Table III , the 64 3 design uses 49% of the BRAMs on one FPGA, so the 128 3 , which has eight times the storage requirement, would fit on 8 FPGAs or up.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 365,
                    "end": 374,
                    "text": "Table III",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "B. BRAM-based FFT"
        },
        {
            "text": "In Table III , the column labelled \"Ideal\" is the predicted runtime if the design were able to deliver results at exactly the compiled speed. There are two reasons for measured runtimes that are slower than ideal. First, loop dependencies may prevent the OpenCL compiler from generating a full dataflow design that can accept new operands every cycle. In OpenCL this is known as the initiation interval and the ideal value is 1. All of our designs achieve this goal. Second, unit pipeline latency and data dependency latency in the transpose unit impose delays that occur once per pass through the hardware. These effects are identifiable because they affect small transforms such as 32 3 much more than larger ones.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 12,
                    "text": "Table III",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "B. BRAM-based FFT"
        },
        {
            "text": "The second design uses BRAM only for transpositions and stages data in HBM memory. We have run versions up to 8 pipelines on a single FPGA or split between two FPGAs or split among four FPGAs. Due to communications limits and available hardware we cannot run more than 8 parallel pipelines. The eight pipeline version for 64 3 runs in 34 microseconds and the 128 3 implementation in 272 microseconds. These performance figures are somewhat worse than the BRAM version due to HBM memory latencies and some non-sequential accesses. 1  370  376  177  3  7  64x64x64  2  386  133  85  5  15  64x64x64  4  328  61  50  11  29  64x64x64  8  295  38  28  21  58  64x64x128  1  395  528  332  4  8  64x64x128  2  363  277  180  8  17  64x64x128  4  325  124  101  15  33  64x64x128  8  284  92  58  30 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 530,
                    "end": 793,
                    "text": "1  370  376  177  3  7  64x64x64  2  386  133  85  5  15  64x64x64  4  328  61  50  11  29  64x64x64  8  295  38  28  21  58  64x64x128  1  395  528  332  4  8  64x64x128  2  363  277  180  8  17  64x64x128  4  325  124  101  15  33  64x64x128  8  284  92  58  30",
                    "ref_id": null
                }
            ],
            "section": "C. HBM-based FFT"
        },
        {
            "text": "The forward and inverse pipeline for the full long-range force calculation uses the same structure, but adds a multiplier between the two FFT units and runs the hardware in three passes as shown in Figure 3 . It is thus possible to run the complete FFT and inverse FFT for the long-range force pipeline in 50% longer than the time for a single direction 3D FFT. Results for 1 and 2 board configurations up to 4 pipelines total are shown in Table VI .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 198,
                    "end": 206,
                    "text": "Figure 3",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 440,
                    "end": 448,
                    "text": "Table VI",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "D. Full LR Pipeline Design"
        },
        {
            "text": "The results shown in Table III show close agreement between the ideal results and actual results, with the gap becoming smaller for larger problems. This is consistent with the effects of pipeline latency. Hopefully as OpenCL compilers improve, the pipeline delays will shrink to the minimums required by the datapath. These figures are about 150-200 cycles for memory fetch, 134 for Transpose units, and 11 for the FFT. Such improvements would be helpful for small transforms like 32 3 but become much less important for 128 3 since there is 64 times as much data. The relative benefit of reduced pipeline delays then builds again as the algorithm is distributed over more boards.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 21,
                    "end": 30,
                    "text": "Table III",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "E. Discussion"
        },
        {
            "text": "There is a much larger performance gap between ideal and measured in our HBM results shown in Tables IV -VI. We include a measurement in Table VI taken with HBM stores disabled, illustrating that HBM stores are responsible for the bulk of the gap between measured and ideal timing. This gap would be eliminated for an all-BRAM solution.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 137,
                    "end": 145,
                    "text": "Table VI",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "E. Discussion"
        },
        {
            "text": "The data in F. Performance comparison with other architectures 3D FFT, due to its wide applications in many areas has been benchmarked extensively on many architectures including CPUs, GPUs and ASICs. Many of the benchmarks focus on larger FFTs (256 3 and above) but there is some public information on smaller FFTs applicable to MD. Table VII compares performance of our FPGA FFT with CPUs, GPUs and Anton. For converting timing to flops we use 15N 3 lg(N ) for complex FFT.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 334,
                    "end": 343,
                    "text": "Table VII",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "E. Discussion"
        },
        {
            "text": "For GPU measurements, we have depended both on inhouse experiments as well as performance benchmarks from [12] , [48] . Our GPU code uses CUDA cuFFT library [49] for computing FFT. The code uses cufftPlan3d to build a FFT plan for best performance and then computes the plan. In our timings, we only include the FFT execution step. We test this code on a single V100 GPU [50] with CUDA 9.1 compilers and libraries. Our in-house experiments performed on V100 with NVLINK2 as well as [12] show that using multiple GPUs does not improve performance of sizes upto 128 3 .",
            "cite_spans": [
                {
                    "start": 106,
                    "end": 110,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 113,
                    "end": 117,
                    "text": "[48]",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 157,
                    "end": 161,
                    "text": "[49]",
                    "ref_id": null
                },
                {
                    "start": 371,
                    "end": 375,
                    "text": "[50]",
                    "ref_id": null
                },
                {
                    "start": 482,
                    "end": 486,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "E. Discussion"
        },
        {
            "text": "Anton 1 [14] has details of timings for both 32 3 and 64 3 on 512 nodes, which we have also included in the table.",
            "cite_spans": [
                {
                    "start": 8,
                    "end": 12,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "E. Discussion"
        },
        {
            "text": "We also include CPU-based benchmarks in this table. [51] shows the timings using Intel MKL and FFTW on a 56 core Intel Xeon Platinum processor. For sizes 32 3 , 64 3 and 128 3 , performance on the processor is approximately 200, 400 and 600 GFlops respectively. We have not found many public benchmarks on performance of smaller distributed 3D FFT. We have included timings on JUGENE, a BlueGene/P architecture [52] . [48] shows 12 milliseconds for a problem of size 128 3 on 512 BlueGene/P nodes.",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 56,
                    "text": "[51]",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 411,
                    "end": 415,
                    "text": "[52]",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 418,
                    "end": 422,
                    "text": "[48]",
                    "ref_id": "BIBREF50"
                }
            ],
            "ref_spans": [],
            "section": "E. Discussion"
        },
        {
            "text": "We have also included Novo-G's timings of distributed 3D FFT on 8 Stratix V FPGAs [31] for comparison. Compared to other architectures in Table VII , we outperform all architectures for 32 3 and 64 3 except 512 nodes of Anton 1, and V100 cuFFT for larger sizes such as 128 3 . Energy readings for 520N-MX FPGAs are currently not operational in the experimental board support package (BSP) for OpenCL. We are talking to Bittware to get this support in the next release of the BSP.",
            "cite_spans": [
                {
                    "start": 82,
                    "end": 86,
                    "text": "[31]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [
                {
                    "start": 138,
                    "end": 147,
                    "text": "Table VII",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "E. Discussion"
        },
        {
            "text": "There is, as far as we know, no magic to achieving excellent 3D FFT performance. It is a game of balancing computation, 559  963  --BRAM 16 pipe  Table III  --969  810  HBM 8 pipe  Table IV  664 1774 --Anton-1 512 nodes [14] BG/P 512 nodes [48] memory bandwidth, and communication. It should not be a surprise that custom ASICs can do well, nor surprising that modern GPUs like the V100 can achieve more than a teraflop once the problem size grows large enough to sustain efficient memory access (V100 has about 50% more flops than a Stratix 10 FPGA and almost double the memory bandwidth [20] , [50] ). The attractive features of FPGA designs are that they can run efficiently across a range of problem sizes and that one can connect compute pipelines directly to communications resources, which means that (subject to bandwidth limits) one can relatively easily distribute a parallel implementation across multiple FPGAs.",
            "cite_spans": [
                {
                    "start": 220,
                    "end": 224,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 240,
                    "end": 244,
                    "text": "[48]",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 589,
                    "end": 593,
                    "text": "[20]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 596,
                    "end": 600,
                    "text": "[50]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 120,
                    "end": 194,
                    "text": "559  963  --BRAM 16 pipe  Table III  --969  810  HBM 8 pipe  Table IV  664",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "E. Discussion"
        },
        {
            "text": "In this paper, we demonstrated that FPGAs can compute 3D FFTs in a scalable way, even for small transforms applicable in molecular dynamics that are difficult to distribute. The results show that our architecture and implementation balances computation, memory bandwidth, and communications bandwidth to produce 3D FFT implementations that run efficiently across multiple FPGAs. Our implementation works for a variety of sizes, and is completely written in OpenCL for portability. Our results show that we outperform or are competitive with a wide variety of architectures including CPUs, GPUs, and ASICs. We have also outlined our design of long-range pipeline such that the computation of long-range electrostatic forces will not limit the scalability of our future work in molecular dynamics applications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VII. CONCLUSION AND FUTURE WORK"
        },
        {
            "text": "The goal of our work is to achieve strong scaling for FFT and eventually the full long range pipeline for small molecules on multiple FPGAs. Our future work will include benchmarking the long-range pipeline comprising the FFT implementation on multiple FPGAs. We plan to grow our FPGA cluster to 4 and subsequently 8 FPGAs, and present results on scalability of both FFT and long-range pipeline up to 8 FPGAs. A 4 or 8 FPGA cluster will also allow us to use BRAM only on FPGAs for 128 3 transform as well. We also plan to further improve performance and scalability of our current implementation through several avenues such as reducing precision for communications, exploring different layouts of the FFT dataset as well as linking VHDL/Verilog code with OpenCL.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "VII. CONCLUSION AND FUTURE WORK"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "An overview of the AMBER biomolecular simulation package",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Salomon-Ferrer",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "A"
                    ],
                    "last": "Case",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "C"
                    ],
                    "last": "Walker",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "WIREs Computational Molecular Science",
            "volume": "3",
            "issn": "2",
            "pages": "198--210",
            "other_ids": {
                "DOI": [
                    "https:/onlinelibrary.wiley.com/doi/abs/10.1002/wcms.1121"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "OpenMM 7: Rapid development of high performance algorithms for molecular dynamics",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Eastman",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Swails",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "D"
                    ],
                    "last": "Chodera",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "T"
                    ],
                    "last": "Mcgibbon",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhao",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Beauchamp",
                    "suffix": ""
                },
                {
                    "first": "L.-P",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "C"
                    ],
                    "last": "Simmonett",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "P"
                    ],
                    "last": "Harrigan",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "D"
                    ],
                    "last": "Stern",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "PLoS computational biology",
            "volume": "13",
            "issn": "7",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Kokkos implementation of an ewald coulomb solver and analysis of performance portability",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Halver",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "H"
                    ],
                    "last": "Meinke",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Sutmann",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Journal of Parallel and Distributed Computing",
            "volume": "138",
            "issn": "",
            "pages": "48--54",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The \u00b5-series: A separable decomposition for electrostatics computation with improved accuracy",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Predescu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "K"
                    ],
                    "last": "Lerer",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "A"
                    ],
                    "last": "Lippert",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Towles",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Grossman",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "M"
                    ],
                    "last": "Dirks",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Shaw",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1911.01377"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Particle mesh ewald: An n log (n) method for ewald sums in large systems",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Darden",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "York",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pedersen",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "The Journal of chemical physics",
            "volume": "98",
            "issn": "12",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A smooth particle mesh ewald method",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Essmann",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Perera",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Berkowitz",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Darden",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "G"
                    ],
                    "last": "Pedersen",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "The Journal of chemical physics",
            "volume": "103",
            "issn": "19",
            "pages": "8577--8593",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "GROMACS: a message-passing parallel molecular dynamics implementation",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "J"
                    ],
                    "last": "Berendsen",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Van Der Spoel",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Van Drunen",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Computer physics communications",
            "volume": "91",
            "issn": "1-3",
            "pages": "43--56",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Scalable molecular dynamics with NAMD",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Phillips",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Braun",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gumbart",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tajkhorshid",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Villa",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Chipot",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "D"
                    ],
                    "last": "Skeel",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kale",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Schulten",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Journal of computational chemistry",
            "volume": "26",
            "issn": "16",
            "pages": "1781--1802",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Cp2k: An electronic structure and molecular dynamics software package-quickstep: Efficient and accurate electronic structure calculations",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "D"
                    ],
                    "last": "K\u00fchne",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Iannuzzi",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ben",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "V"
                    ],
                    "last": "Rybkin",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Seewald",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Stein",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Laino",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "Z"
                    ],
                    "last": "Khaliullin",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Sch\u00fctt",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Schiffmann",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "The Journal of Chemical Physics",
            "volume": "152",
            "issn": "19",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Scalable molecular dynamics with NAMD on the Summit system",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Acun",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hardy",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "V"
                    ],
                    "last": "Kale",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Stone",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IBM Journal of Research and Development",
            "volume": "62",
            "issn": "6",
            "pages": "4--5",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Creating faster molecular dynamics simulations with gromacs 2020",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gray",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "devblogs.nvidia.com",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Performance on Different Hardware Configurations, GTC Silicon Valley",
            "authors": [
                {
                    "first": "Multi-Gpu",
                    "middle": [],
                    "last": "Fft",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "MDGRAPE-4: a special-purpose computer system for molecular dynamics simulations",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Ohmura",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Morimoto",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Ohno",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hasegawa",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Taiji",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences",
            "volume": "372",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Anton, a special-purpose machine for molecular dynamics simulation",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Shaw",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "M"
                    ],
                    "last": "Deneroff",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "O"
                    ],
                    "last": "Dror",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "S"
                    ],
                    "last": "Kuskin",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "H"
                    ],
                    "last": "Larson",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "K"
                    ],
                    "last": "Salmon",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Young",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Batson",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "J"
                    ],
                    "last": "Bowers",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Chao",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "P"
                    ],
                    "last": "Eastwood",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gagliardo",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "P"
                    ],
                    "last": "Grossman",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "R"
                    ],
                    "last": "Ho",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "J"
                    ],
                    "last": "Ierardi",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Kolossv\u00e1ry",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "L"
                    ],
                    "last": "Klepeis",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Layman",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Mcleavey",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Moraes",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Mueller",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "C"
                    ],
                    "last": "Priest",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Shan",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Spengler",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Theobald",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Towles",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "C"
                    ],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Commun. ACM",
            "volume": "51",
            "issn": "7",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/1364782.1364802"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Anton 2: raising the bar for performance and programmability in a special-purpose molecular dynamics supercomputer",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Shaw",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Grossman",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Bank",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Batson",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Butts",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Chao",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "M"
                    ],
                    "last": "Deneroff",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "O"
                    ],
                    "last": "Dror",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Even",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "H"
                    ],
                    "last": "Fenton",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "SC'14: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis",
            "volume": "",
            "issn": "",
            "pages": "41--53",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "A 32x32x32, spatially distributed 3D FFT in four microseconds on anton",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Young",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Bank",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "O"
                    ],
                    "last": "Dror",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "P"
                    ],
                    "last": "Grossman",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "K"
                    ],
                    "last": "Salmon",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Shaw",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the Conference on High Performance Computing Networking, Storage and Analysis",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/1654059.1654083"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "FPGA-Accelerated Molecular Dynamics",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Khan",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chiu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "C"
                    ],
                    "last": "Herbordt",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Molecular Dynamics Simulations on High-Performance Reconfigurable Computing Systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chiu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "C"
                    ],
                    "last": "Herbordt",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Fully integrated FPGA molecular dynamics simulations",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Geng",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Patel",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Xiong",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sanaullah",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sheng",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Sachdeva",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis",
            "volume": "",
            "issn": "",
            "pages": "1--31",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Intel Corporation",
            "authors": [
                {
                    "first": "\u00ae",
                    "middle": [],
                    "last": "Intel",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Stratix \u00ae Device",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Datasheet",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Novo-G#: A Community Resource for Exploring Large-Scale Reconfigurable Computing Through Direct and Programmable Interconnects",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "George",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Herbordt",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lam",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lawande",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sheng",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "A Reconfigurable Fabric for Accelerating Large-Scale Datacenter Services",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Putnam",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proc. International Symposium on Computer Architecture",
            "volume": "",
            "issn": "",
            "pages": "13--24",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Bringing FPGAs to HPC production systems and codes",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Fourth International Workshop on Heterogeneous High-performance Reconfigurable Computing, workshop at Supercomputing",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "OpenCL-ready high speed FPGA network for reconfigurable high performance computing",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kobayashi",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Oobata",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Fujita",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Yamaguchi",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Boku",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the International Conference on High Performance Computing in Asia-Pacific Region",
            "volume": "",
            "issn": "",
            "pages": "192--201",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "The OpenCL Specification",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Munshi",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "2009 IEEE Hot Chips 21 Symposium (HCS)",
            "volume": "",
            "issn": "",
            "pages": "1--314",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Reconfigurable 3D-FFT Processor for the Car-Parrinello Method",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Sasaki",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Betsuyaku",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Higuchi",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Nagashima",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Journal of Computer Chemistry, Japan",
            "volume": "4",
            "issn": "4",
            "pages": "147--154",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Multidimensional DFT IP Generator for FPGA Platforms",
            "authors": [
                {
                    "first": "C.-L",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Irick",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Charkrabarti",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Narayanan",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "IEEE Trans. Circuits and System I",
            "volume": "58",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "3D FFT on a Single FPGA",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Humphries",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sheng",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Landaverde",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Herbordt",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proc. Field Programmable Custom Computing Machines",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "FFT3D for FPGA (CP2K)",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ramaswami",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Design of 3D FFTs with FPGA clusters",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sheng",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Humphries",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "C"
                    ],
                    "last": "Herbordt",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "2014 IEEE High Performance Extreme Computing Conference (HPEC)",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "A Reconfigurable Interconnect for Large-Scale FPGA Applications and Systems",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lawande",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "HPC on FPGA Clouds: 3D FFTs and Implications for Molecular Dynamics",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sheng",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Caulfield",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Papamichael",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Herbordt",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proc. Field Programmable Logic and Applications",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "A multi-fpga application-specific architecture for accelerating a floating point fourier integral operator",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Shannon",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Yedlin",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "F"
                    ],
                    "last": "Margrave",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "2008 International Conference on Application-Specific Systems, Architectures and Processors",
            "volume": "",
            "issn": "",
            "pages": "197--202",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "A fast algorithm for particle simulations",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Greengard",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Rokhlin",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Journal of Computational Physics",
            "volume": "135",
            "issn": "2",
            "pages": "280--292",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "A smooth particle mesh ewald method",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Essmann",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Perera",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Berkowitz",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Darden",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "G"
                    ],
                    "last": "Pedersen",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "The Journal of Chemical Physics",
            "volume": "103",
            "issn": "19",
            "pages": "8577--8593",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Algorithms for Discrete Fourier Transform and Convolution",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "T M"
                    ],
                    "last": "An",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lu",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "The design and implementation of fftw3",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Frigo",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "G"
                    ],
                    "last": "Johnson",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proceedings of the IEEE",
            "volume": "93",
            "issn": "2",
            "pages": "216--231",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "P3dfft: A framework for parallel computations of fourier transforms in three dimensions",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Pekurovsky",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "SIAM Journal on Scientific Computing",
            "volume": "34",
            "issn": "4",
            "pages": "192--209",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "Vector radix fast fourier transform",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Harris",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mcclellan",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Chan",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Schuessler",
                    "suffix": ""
                }
            ],
            "year": 1977,
            "venue": "ICASSP'77. IEEE International Conference on Acoustics, Speech, and Signal Processing",
            "volume": "2",
            "issn": "",
            "pages": "548--551",
            "other_ids": {}
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "Pipelined radix-2 k feedforward fft architectures",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Garrido",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Grajal",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Sanchez",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Gustafsson",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IEEE Transactions on Very Large Scale Integration (VLSI) Systems",
            "volume": "21",
            "issn": "",
            "pages": "23--32",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "BittWare Corporation",
            "authors": [
                {
                    "first": "520n-Mx",
                    "middle": [],
                    "last": "Bittware",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Datasheet",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "OpenCL 2D Fast Fourier Transform Design Example, Intel Corporation",
            "authors": [],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Optimum circuits for bitdimension permutations",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Garrido",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Grajal",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Gustafsson",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Transactions on Very Large Scale Integration (VLSI) Systems",
            "volume": "27",
            "issn": "",
            "pages": "1148--1160",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "Parallel Permutations of Data: A Benes Network Control Algorithm for Frequently Used Permutations",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Lenfant",
                    "suffix": ""
                }
            ],
            "year": 1978,
            "venue": "IEEE Transactions on Computers",
            "volume": "",
            "issn": "7",
            "pages": "637--647",
            "other_ids": {}
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "A unified approach to off-line permutation routing on parallel networks",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Annexstein",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Baumslag",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Proceedings of the second annual ACM symposium on Parallel algorithms and architectures",
            "volume": "",
            "issn": "",
            "pages": "398--406",
            "other_ids": {}
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "Designing topology-aware communication schedules for alltoall operations in large infiniband clusters",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Subramoni",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Kandalla",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jose",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Tomko",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "H"
                    ],
                    "last": "Schulz",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Pekurovsky",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "K"
                    ],
                    "last": "Panda",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "43rd International Conference on Parallel Processing",
            "volume": "",
            "issn": "",
            "pages": "231--240",
            "other_ids": {}
        },
        "BIBREF50": {
            "ref_id": "b50",
            "title": "An analysis of fft performance in prace application codes",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sunderlanda",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Picklesa",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Milo",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Nikoli",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jovi",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Jaki",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Slavni",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Girottoc",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nashc",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Lysaghtc",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF53": {
            "ref_id": "b53",
            "title": "Intel Math Kernel Library Performance Benchmarks, Intel Corporation",
            "authors": [],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF54": {
            "ref_id": "b54",
            "title": "Overview of the ibm blue gene/p project",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Research",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Staff",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "IBM J. Res. Dev",
            "volume": "52",
            "issn": "1/2",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Logical view of long-range force pipeline.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": ". This example is 8-wide, compiled for a 64 point FFT. The design compiles a variable number of stages, corresponding to the base 2 logarithm of the transform size. As a result, the logN term in FFT's O(N logN ) is subsumed by hardware and the unit runs in O(N ) time.1 Measured on V100 with cuFFT 9Pipelined FFT input and output.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Wide, single-precision complex FFT compute unit (64 point).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Transpose Unit. bits. The second exchanges the 128 bit half of each 256 bits. The third rank exchanges 64 bit values in each 128 bit group. At the output of the third exchange, individual 64 bit complex values are written into 8 independent block rams. The input side of the BRAMS have a common write address. The output side read addresses are independent.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "BRAM FFT pipeline. All to all network. 4 pipelines on two FPGAs, with cables.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Long-range pipeline hardware unit.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Full MD algorithm on 4 FPGAs.",
            "latex": null,
            "type": "figure"
        },
        "TABREF2": {
            "text": "FOR FFT SIZES VS NUMBER OF UNITS, AT 300 MHZ (\u00b5 SEC)",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Table II identify consistent points in solution space for 8 through 128 pipelines where computation performance is a good match for communications performance. 1) Eight pipelines-Eight pipelines, split among either two or four FPGAs using point to point links. The 128 3 FFT time for 8 pipelines is 109.2 usec, and the corresponding communications time for 2 or 4 nodes is 107.5. The two board solution requires four parallel point to point links delivering 400 Gbps connectivity. 2) 16 pipelines-16 pipelines split among eight nodes using a hypercube++ topology that has additional links across the major diagonals. The 128 3 FFT time for 16 pipelines is 54.6 usec, and the corresponding communications time is 58.8 usec. 3) 32 pipelines-32 pipelines split among 16 FPGAs, using a switched topology or a 3D Torus. The 128 3 FFT time for 32 pipelines is 27.3 usec, and the corresponding communications time for the switched topology is 25.2 usec. The 3D Torus is slightly slower at 33.6 usec. The tradeoff between the two is the relative cost of development work for additional links versus Ethernet encapsulation, switches, and twice as many cables. 4) 64 pipelines-64 pipelines split among 32 FPGAs with a switched topology or among 64 FPGAs with a 3D torus. The 128 3 time is 13.7 usec and the communications time 13.1 or 13.2. 5) 128 pipelines-128 FFT pipelines split across 64 boards with a switched topology. The 128 3 FFT time for 32 pipelines is 6.8 usec, and the corresponding communications time for the switched topology is 6.6 usec.",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "-BASED 3D FFT, SINGLE FPGA",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "HBM-BASED 3D FFT, MULTIPLE FPGA",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "Table VI for 1 board 4 pipeline (981 usec) versus the data for 2 boards 2 pipelines (972 usec) illustrate that",
            "latex": null,
            "type": "table"
        },
        "TABREF11": {
            "text": "PIPELINE FFT + IFFT distribution across multiple boards, given adequate bandwidth, is scalable.",
            "latex": null,
            "type": "table"
        },
        "TABREF12": {
            "text": "/S FOR MULTIPLE ARCHITECTURES",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We would like to thank several individuals at Intel, especially Nick Finamore Jr. and Nadav Zinger for their support of this project, including providing loaner hardware as well as discussions and debugging support that was provided. We would also like to thank Molex (Kenneth Robertson and Gildas Genest) for providing hardware, instructions and debugging support of 520N-MX boards.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}