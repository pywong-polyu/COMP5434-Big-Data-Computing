{
    "paper_id": "f531a49b32cb686067326ca6810070fee527dfe2",
    "metadata": {
        "title": "Extensible Extraction of Efficient Imperative Programs with Foreign Functions, Manually Managed Memory, and Proofs",
        "authors": [
            {
                "first": "Cl\u00e9ment",
                "middle": [],
                "last": "Pit-Claudel",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "MIT CSAIL",
                    "location": {
                        "postCode": "02139",
                        "settlement": "Cambridge",
                        "region": "MA",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "(",
                "middle": [
                    "B"
                ],
                "last": "",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Peng",
                "middle": [],
                "last": "Wang",
                "suffix": "",
                "affiliation": {},
                "email": "wangpeng@google.com"
            },
            {
                "first": "Benjamin",
                "middle": [],
                "last": "Delaware",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Purdue University",
                    "location": {
                        "postCode": "47907",
                        "settlement": "West Lafayette",
                        "region": "IN",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Jason",
                "middle": [],
                "last": "Gross",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "MIT CSAIL",
                    "location": {
                        "postCode": "02139",
                        "settlement": "Cambridge",
                        "region": "MA",
                        "country": "USA"
                    }
                },
                "email": "jgross@csail.mit.edu"
            },
            {
                "first": "Adam",
                "middle": [],
                "last": "Chlipala",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "MIT CSAIL",
                    "location": {
                        "postCode": "02139",
                        "settlement": "Cambridge",
                        "region": "MA",
                        "country": "USA"
                    }
                },
                "email": "adamc@csail.mit.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "We present an original approach to sound program extraction in a proof assistant, using syntax-driven automation to derive correct-by-construction imperative programs from nondeterministic functional source code. Our approach does not require committing to a single inflexible compilation strategy and instead makes it straightforward to create domain-specific code translators. In addition to a small set of core definitions, our framework is a large, user-extensible collection of compilation rules each phrased to handle specific language constructs, code patterns, or data manipulations. By mixing and matching these pieces of logic, users can easily tailor extraction to their own domains and programs, getting maximum performance and ensuring correctness of the resulting assembly code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Using this approach, we complete the first proof-generating pipeline that goes automatically from high-level specifications to assembly code. In our main case study, the original specifications are phrased to resemble SQL-style queries, while the final assembly code does manual memory management, calls out to foreign data structures and functions, and is suitable to deploy on resource-constrained platforms. The pipeline runs entirely within the Coq proof assistant, leading to final, linked assembly code with overall full-functional-correctness proofs in separation logic.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The general area of correct-by-construction code generation is venerable, going back at least to Dijkstra's work in the 1960s [5] . Oftentimes, solutions offer a strict subset of the desiderata of generality, automation, and performance of synthesized code. This paper presents the final piece of a pipeline that sits at the sweet spot of all three, enabling semiautomatic refinement of high-level specifications into efficient low-level code in a proof-generating manner. Our initial specification language is the rich, higher-order logic of Coq, and we support a high degree of automation through domain-specific refinement strategies, which in turn enable targeted optimization strategies for extracting efficient low-level code. In order to take advantage of these opportunities, we have built an extensible compilation framework that can be updated to handle new compilation strategies without sacrificing soundness. Our pipeline is foundational : it produces a fully linked assembly program represented as a Coq term with a proof that it meets the original high-level specification. Our complete toolchain uses Fiat [4] to refine high-level specifications of abstract data types (ADTs) into nondeterministic functional programs depending on external data structures (expressed in a shallowly embedded Gallina DSL), then soundly extracts these programs to an imperative intermediate language (Facade) using a novel proof-generating extraction procedure. The resulting programs are then translated into the Cito [29] language by a newly written compiler, backed by a nontrivial soundness argument bridging two styles of operational semantics. A traditional verified compiler produces efficient Bedrock assembly [3] from the Cito level, which we soundly link against hand-verified implementations of the required data structures. Beyond exploring a new technique for sound extraction of shallowly embedded DSLs (EDSLs), this work bridges the last remaining gap (extraction) to present the first mechanically certified automatic translation pipeline from declarative specifications to efficient assembly programs, as shown in Fig. 1 .",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 129,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1122,
                    "end": 1125,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1516,
                    "end": 1520,
                    "text": "[29]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 1715,
                    "end": 1718,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 2128,
                    "end": 2134,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "In the original Fiat system, specifications were highly nondeterministic programs, and final implementations were fully deterministic programs obtained by repeatedly refining the specification, eventually committing to a single possible result. As a consequence, the generated code committed to a particular deterministic (and pure) implementation of external ADTs and functions that it relied on, reducing flexibility, optimization opportunities, and overall performance. Additionally, the final step in previous work using Fiat was to extract this code directly to OCaml, using Coq's popular but unverified extraction mechanism. Unfortunately, this meant that correctness of the compiled executable depended not only on the correctness of Coq's kernel but also on that of the extraction mechanism and of the OCaml compiler and runtime system. These two depen-dencies significantly decreased the confidence that users can place in programs synthesized by Fiat, and more generally in all programs extracted from Gallina code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our work overcomes these issues via a novel approach to extraction that is both extensible and correct and produces efficient, stateful low-level code from nondeterministic functional sources. The process runs within Coq, produces assembly code instead of OCaml code, and supports linking with handwritten or separately compiled verified assembly code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Instead of refining specifications down to a fully deterministic Gallina program, as the original Fiat system did, we allow Fiat's final output to incorporate nondeterminism. These choices are resolved at a later stage by interpreting the nondeterminism as a postcondition specification in Hoare logic and linking against assembly code proven to meet that specification. Nondeterminism at runtime, which is not normally present in Gallina programs, is essential to support code derivation with flexible use of efficient low-level data structures. For example, if we represent a database with a type of binary trees that does not enjoy canonical representations, the same data may admit multiple concrete representations, each corresponding to a different ordering of results for an operation enumerating all database records.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Unlike certified compilers like CompCert [13] or CakeML [9] , we do not implement our translator in the proof assistant's logic and prove it sound once and for all. Instead, we use proof-generating extraction: we phrase the translation problem in a novel sequent-calculus-style formulation that allows us to apply all of Coq's usual scriptable proof automation. The primary reason is that we want to make our compiler extensible by not committing to a specific compilation strategy: in our system, programmers can teach the compiler about new verified low-level data structures and code-generation strategies by introducing new lemmas explaining how to map a Gallina term to a particular imperative program 1 . Our automation then builds a (deeply embedded) syntax tree by repeatedly applying lemmas until the nondeterministic functional program is fully compiled. The many advantages of this approach (extensibility, ease of development, flexibility, performance, and ease of verification) do come at a cost, however: compilation is slower, care is needed to make the compiler robust to small variations in input syntax, and the extensible nature of the compiler makes it hard to characterize the supported source language precisely.",
            "cite_spans": [
                {
                    "start": 41,
                    "end": 45,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 56,
                    "end": 59,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To summarize the benefits of our approach:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "-It is lightweight: it does not require reifying the entirety of Gallina into a deeply embedded language before compiling. Instead, we use Coq's tactic language to drive compilation. -It is extensible: each part of the compilation logic is expressed as a derivation rule, proved as an arbitrarily complex Coq theorem. Users can assemble a customized compiler by supplying their own compilation lemmas to extend the source language or improve the generated code. -It is well-suited to compiling EDSLs: we support nondeterminism in input programs (standard extraction requires deterministic code). -It allows us to link against axiomatically specified foreign functions and data structures, implemented and verified separately. -It compiles to a relatively bare language with explicit memory management.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To demonstrate the applicability of this approach, Sect. 6 presents a set of microbenchmarks of Fiat programs manipulating variables, conditions, and nested lists of machine words, as well as a more realistic example of SQLlike programs similar to those of the original Fiat paper. These benchmarks start from high-level specifications of database queries and pass automatically through our pipeline to closed assembly programs, complete with full-functionalcorrectness specifications and proofs in separation logic. Source code and compilation instructions for the framework and benchmarks are available online at https://github.com/mit-plv/fiat/tree/ijcar2020.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We begin with an example of the pipeline in action. Below are an SQL-style query finding all titles by an author and a Fiat-generated implementation (right):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Brief Outline of Our Approach"
        },
        {
            "text": "The generated code relies on a Fiat module IndexedByAuthor , which is not an executable implementation of the required functionality; rather, it specifies certain methods nondeterministically, implying that bfind returns the expected rows in some undetermined order. The order may even be different for every call, as might arise, for instance, with data structures like splay trees that adjust their layout even during logically read-only operations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Brief Outline of Our Approach"
        },
        {
            "text": "Such nondeterministic programs are the starting point for our new refinement phases. The ultimate output of the pipeline is a library of assembly code in the Bedrock framework [3] , obtained by extracting to a new language, Facade, built as a layer on top of the Cito C-like language [29] , and then compiling to Bedrock.",
            "cite_spans": [
                {
                    "start": 176,
                    "end": 179,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 284,
                    "end": 288,
                    "text": "[29]",
                    "ref_id": "BIBREF29"
                }
            ],
            "ref_spans": [],
            "section": "A Brief Outline of Our Approach"
        },
        {
            "text": "The output for our running example might look like the code on the right. Note that this code works directly with pointers to heap-allocated mutable objects, handling all memory management by itself, including for intermediate values. The general IndexedByAuthor interface has been replaced with calls to a concrete module BTree providing binary search trees of tuples, and the call to map became an imperative loop. We implement and verify BTree in Bedrock assembly, and then we link code and proofs to obtain a binary and an end-to-end theorem guaranteeing full functional correctness of assembly libraries, for code generated automatically from high-level specifications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Brief Outline of Our Approach"
        },
        {
            "text": "The heart of our contribution is spanning the gap from nondeterministic functional programs (written in Gallina) to imperative low-level programs (written in Facade) using an extensible, proof-generating framework. We phrase this derivation problem as one of finding a proof of a Hoare triple, where the precondition and postcondition are known, but the Facade program itself must be derived during the proof. The central goal from our running example looks as follows, where ?1 stands for the overall Facade program that we seek, and where we unfold IndexedByAuthor.bfind (Subsect. 4.3 defines these triples precisely).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Brief Outline of Our Approach"
        },
        {
            "text": "The actual implementation of ?1 is found by applying lemmas to decompose this goal into smaller, similar goals representing subexpressions of the final program. These lemmas form a tree of deduction steps, produced automatically by a syntax-directed compilation script written in Coq's Ltac tactic language. Crucially, the derivation implemented by this script can include any adequately phrased lemma, allowing new implementation strategies. Composed with the automation that comes before and after this stage, we have a fully automated, proof-generating pipeline from specifications to libraries of assembly code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Brief Outline of Our Approach"
        },
        {
            "text": "We begin by illustrating the compilation process on the example Fiat program from Sect. 2. We synthesize a Facade program p according to the following specification 2 , which we summarize as p, when started in an initial state containing the arguments and must be safe (it must not violate function preconditions, access undefined variables, leak memory, etc.).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An Example of Proof-Producing Extraction"
        },
        {
            "text": "p, when started in a proper initial state, must reach (if it terminates) a state where the variable has one of the values allowed by the nondeterministic program p shown above.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An Example of Proof-Producing Extraction"
        },
        {
            "text": "Replacing p with our example, we need to find a program p such that We use our first compilation lemma (with a few examples shown in Fig. 2 ) to connect the semantics of Fiat's bind operation (the \u2190 operator of monads [27] ) to the meaning of , which yields the following synthesis goal: In this step, we have broken down the assignment to of a Fiat-level bind (rows \u2190 ...; ...) into the assignment of two variables:",
            "cite_spans": [
                {
                    "start": 218,
                    "end": 222,
                    "text": "[27]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [
                {
                    "start": 133,
                    "end": 139,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "An Example of Proof-Producing Extraction"
        },
        {
            "text": "to the intermediate list of authors, and to the final result. The :: operator separates entries in a list of bindings of Facade variables to nondeterministic Fiat terms. The ordering of the individual bindings matters: the Fiat term that we assign to depends on the particular value chosen for bound locally as r . We then break down the search for p into the search for two smaller programs: the first (p 1 ) starts in the initial state (abbreviated to args ) and is only concerned with the assignment to ; the second (p 2 ) starts in a state where is already assigned and uses that value to construct the final result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An Example of Proof-Producing Extraction"
        },
        {
            "text": "At this point, a lemma about connecting the meaning of the nondeterministic selection of authors and the Facade-level function tells us that is a good choice for p 1 (this is the call rule for ). We are therefore only left with p 2 to synthesize: noticing the common prefix of the starting and ending states, we apply a rule (called chomp in our development) allowing us to set aside the common prefix and focus on the tail of the pre-and post-states, transforming the problem into",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An Example of Proof-Producing Extraction"
        },
        {
            "text": "The additional mapping pictured under the arrow indicates that the initial and final states must both map to the same value r . In this form, we can first rewrite map to fold L , at which point the synthesis goal matches the conclusion of the fold L rule shown in Fig. 2c : given a program p init to initialize the accumulator and a program p body to implement the body of the fold, the Facade program defined by the macro obeys the specification above. This gives us two new synthesis goals, which we can handle recursively, in a fashion similar to the one described above. Once these obligations have been resolved, we arrive at the desired Facade program.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 264,
                    "end": 271,
                    "text": "Fig. 2c",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "An Example of Proof-Producing Extraction"
        },
        {
            "text": "We start with a brief description of our newly designed target language, Facade.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Facade Language"
        },
        {
            "text": "Facade is an Algol-like untyped imperative language operating on Facade states, which are finite maps from variable names to Facade values (either scalars, or nonnull values of heap-allocated ADTs). Syntactically, Facade includes standard programming constructs like assignments, conditionals, loops, function calls, and recursion. What distinguishes the language is its operational semantics, pictured partially in Fig. 3 . First, that semantics follows that of Cito in supporting modularity by modeling calls to externally defined functions via preconditions and postconditions. Second, linearity is baked into Facade's operational semantics, which enforce that every ADT value on the heap will be referred to by exactly one live variable (no aliasing and no leakage) to simplify reasoning about the formal connection to functional programs: if every object has at most one referent, then we can almost pretend that variables hold abstract values instead of pointers to mutable objects. In practice, we have not found this requirement overly constraining for our applications: one can automatically introduce copying when needed, or one can require the external ADTs to provide nondestructive iteration. The program semantics manipulates local-variable environments where ADTs are associated with high-level models. For instance, a finite set is modeled as a mathematical set, not as e.g. a hash table. A key parameter to the compiler soundness theorem is a separation-logic abstraction relation, connecting the domain of high-level ADT models to mutable memories of bytes. By picking different relations at the appropriate point in our pipeline, we can justify linking with different low-level implementations of high-level concepts. No part of our automated translation from Fiat to Facade need be aware of which relation is chosen, and the same result of that process can be reused for different later choices. This general approach to stateful encapsulation is largely inherited from Cito, though with Facade we have made it even easier to use.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 416,
                    "end": 422,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "The Facade Language"
        },
        {
            "text": "Facade's operational semantics are defined by two predicates, \u03a8 (p, st)\u2193 and \u03a8 (p, st) \u21d3 st', expressing respectively that the Facade program p will run safely when started in Facade state st, and that p may reach state st' when started from st (this latter predicate essentially acts as a big-step semantics of Facade). Both predicates are parameterized over a context \u03a8 mapping function names to their axiomatic specifications. The semantics is nondeterministic in the sense that there can be more than one possible st'.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Facade Language"
        },
        {
            "text": "Modularity is achieved through the CallAx rule, allowing a Facade program to call a function via its specification in \u03a8 . A function call produces a return value r and a list of output values v representing the result of in-place modification of input ADT arguments y. A precondition is a predicate pre on the values assigned to the input arguments of the callee by the map st. A postcondition is a predicate post on these input values, output values v , and return value r . The semantics prescribes that a function call will nondeterministically pick a list of output values and a return value satisfying post and use them to update the relevant variables in the caller's postcall state (possibly deallocating them).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Facade Language"
        },
        {
            "text": "Linearity is achieved by a set of syntactic and semantic provisions. For instance, variables currently holding ADT values cannot appear on the righthand sides of assignments, to avoid aliasing. They also cannot appear on the lefthand sides of assignments, to avoid losing their current payloads and causing memory leaks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Facade Language"
        },
        {
            "text": "We have implemented a verified translation from Facade to Cito, and from there we reuse established infrastructure to connect into the Bedrock framework for verified assembly code. Its soundness proof has the flavor of justifying a new type system for an existing language, since Facade's syntax matches that of Cito rather closely. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Facade Language"
        },
        {
            "text": "We connect Fiat's semantics to those of Facade by introducing a notion of Forexample,thetelescope describes all machine states in which maps to a positive value x and maps to the pair (x, x + 1). Each variable in a Fiat state is annotated with a function wrap describing how to inject values of its type in and out of the concrete type used at the Facade level (e.g. a linked list may be extracted to a vector, as in our example).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fiat and Facade States"
        },
        {
            "text": "Finally, to be able to implement the aforementioned chomp rule, Fiat states are extended with an unordered map (ext ) from names to concrete values. A full Fiat state is thus composed of a telescope st and an extra collection of bindings ext , written . We relate Fiat states to Facade states using the ternary predicate st st ext defined in Fig. 4 , which ensures that the values assigned to variables in the Facade state st are compatible with the bindings described in the Fiat state .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 342,
                    "end": 348,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Fiat and Facade States"
        },
        {
            "text": "Armed with this predicate, we are ready for the full definition of st This definition is enough to concisely and precisely phrase the three types of lemmas required to synthesize Facade programs: properties of the relation used to drive the proof search and provide the extraction architecture; connections between the relation and Fiat's semantics, used to reduce extraction of Fiat programs to that of Gallina programs; and connections between Fiat and Facade, such as the FoldL rule of Fig. 2c (users provide additional lemmas of the latter kind to extend the scope of the compiler and broaden the range of source programs that the compiler is able to handle).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 489,
                    "end": 496,
                    "text": "Fig. 2c",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Proof-Generating Extraction by Synthesis"
        },
        {
            "text": "With these lemmas, we can phrase certified extraction as a proof-search problem that can be automated effectively. Starting from a Fiat computation mixing Gallina code with calls to external ADTs, we generate a specification f based on the predicate (which itself is defined in terms of Facade's operational semantics):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof-Generating Extraction by Synthesis"
        },
        {
            "text": "(1) From this starting point, extraction proceeds by analyzing the shapes of the preand post-states to determine applicable compilation rules, which are then used to build a Facade program progressively. This stage explains why we chose strongly constrained representations for pre and post-states: where typical verification tasks compute verification conditions from the program's source, we compute the program from carefully formulated pre-and postconditions (proper care in designing the compilation rules and their preconditions obviates the need for backtracking).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof-Generating Extraction by Synthesis"
        },
        {
            "text": "In practice, this syntax-driven process is implemented by a collection of matching functions written in Ltac. These may either fail, or solve the current goal by applying a lemma, or produce a new goal by applying a compilation lemma of the form shown in Fig. 2 . Our extraction architecture is extensible: the main loop exposes hooks that users can rebind to call their own matching rules. Examples of such rules are provided in Sect. 6.1. Our focus is on extracting efficient code from Gallina EDSLs, so the set of rules is tailored to each domain and does not cover all possible programs (in particular, we do not have support for arbitrary fixpoints or pattern-matching constructs; we use custom lemmas mapping specific matches to specific code snippets or external functions). When the compiler encounters an unsupported construct C, it stops and presents the user with a goal of the form indicating which piece is missing so the user can provide the missing lemmas and tactics.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 255,
                    "end": 261,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Proof-Generating Extraction by Synthesis"
        },
        {
            "text": "In our experience, debugging proof search and adding support for new constructs is relatively easy, though it does require sufficient familiarity with Coq. Typically, our compiler would have two classes of users: library developers, who interactively implement support for new DSLs (developing compilation tactics requires manual labor similar to writing a domain-specific compiler); and final users, who write programs within supported DSLs and use fully automated compilation tactics.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof-Generating Extraction by Synthesis"
        },
        {
            "text": "The components presented in the previous section form the final links in an automated pipeline lowering high-level specifications to certified Bedrock modules, whose correctness is guaranteed by Theorem 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Complete Proof-Generating Pipeline"
        },
        {
            "text": "Starting from a Fiat ADT specification ADT spec (a collection of high-level method specifications m spec , as shown in Fig. 5a) , we obtain by refinement under a relation \u2248 a Fiat ADT implementation ADT impl (a collection of nondeterministic functional programs m impl , as shown in Fig. 5b) . Each method of this implementation is assigned an operational specification m impl (Eq. 1), from which we extract (using proof-producing synthesis, optionally augmented with userspecified lemmas and tactics) a verified Facade implementation m impl (Sect. 4.3) that calls into a number of external functions (\u03a8 , Fig. 3 ), as shown in Fig. 5c .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 119,
                    "end": 127,
                    "text": "Fig. 5a)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 283,
                    "end": 291,
                    "text": "Fig. 5b)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 606,
                    "end": 612,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 628,
                    "end": 635,
                    "text": "Fig. 5c",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "The Complete Proof-Generating Pipeline"
        },
        {
            "text": "Finally, we package the resulting Facade methods into a Facade module. This module imports \u03a8 (i.e. it must be linked against implementations of the functions in \u03a8 ) and exports axiomatic specifications straightforwardly lifted from the original high-level specifications into Facade-style axiomatic specifications (of the style demonstrated in the call rule of Fig. 3 ): for each high-level specification meth spec , we export the following (written meth spec ):",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 361,
                    "end": 367,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "The Complete Proof-Generating Pipeline"
        },
        {
            "text": "Since we are working in an object-oriented style at the high level, our low-level code follows a convention of an extra \"self\" argument added to each method, written in this logical formulation as r S for spec-level \"self\" values and r I for implementation-level \"self\" values.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Complete Proof-Generating Pipeline"
        },
        {
            "text": "A generic proof guarantees that the operational specifications meth impl used to synthesize Facade code indeed refine the axiomatic specifications meth spec exported by our Facade module. Compiling this Facade module via our new formally verified Facade compiler produces a correct Bedrock module, completing Theorem 1: Theorem 1. Starting from a valid refinement ADT impl of a Fiat ADT specification ADT spec with methods meth impl and meth spec and a set of Facade programs synthesized from each meth impl , we can build a certified Bedrock module whose methods satisfy the axiomatic specifications meth spec .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Complete Proof-Generating Pipeline"
        },
        {
            "text": "The final Bedrock module satisfies the original, high-level Fiat specifications. It specifies its external dependencies \u03a8 , for which verified assembly implementations must be provided as part of the final linking phase, which happens entirely inside of Coq. After linking, we obtain a closed, executable Bedrock module, exposing an axiomatic specification directly derived from the original, highlevel ADT specification. Our implementation links against verified hand-written implementations of low-level indexing structures, though it would be possible to use the output of any compiler emitting Bedrock assembly code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Complete Proof-Generating Pipeline"
        },
        {
            "text": "We first evaluated our pipeline by extracting a collection of twenty six Gallina programs manipulating machine words, lists, and nested lists, with optional nondeterministic choices. Extraction takes a few seconds for each program, ranging from simple operations such as performing basic arithmetic, allocating data structures, calling compiler intrinsics, or sampling arbitrary numbers to more complex operations involving sequence manipulations, like reversing, filtering, reducing (e.g. reading in a number written as a list of digits in a given base), flattening, and duplicating or replacing elements. All examples, and the corresponding outputs, are included in a literate Coq file available online. These examples illustrate that our extraction engine supports a fluid, extensible source language, including subsets of Gallina and many nondeterministic Fiat programs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Microbenchmarks"
        },
        {
            "text": "To evaluate our full pipeline in realistic conditions, we targeted the querystructure ADT library of the Fiat paper [4] as well as an ADT modeling process scheduling inspired by Hawkins et al. [7] . This benchmark starts from high-level Fiat specifications (as shown in Fig. 5a) and outputs a closed Bedrock module, linked against a hand-verified nested-binary-tree implementation.",
            "cite_spans": [
                {
                    "start": 116,
                    "end": 119,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 193,
                    "end": 196,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 270,
                    "end": 278,
                    "text": "Fig. 5a)",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Relational Queries"
        },
        {
            "text": "From Fiat specifications we derive a collection of nondeterministic Fiat programs (one per ADT method, as demonstrated in Fig. 5b) , then extract each method to Facade Fig. 5c ) and compile to Bedrock. Extraction is fully automatic; it draws from the default pool of extraction lemmas (about conditionals, constants, arithmetic operations, etc.) and from bag-specific lemmas that we added to the compiler (these manually verified call rules connect the pure bag specifications used in Fiat sources to Bedrock-style specifications of mutable binary search trees using the relation). Figure 6 presents the results of our experimental validation. We compare our own verified implementation (\"Fiat\") against the corresponding SQL queries executed by SQLite 3.8.2 (using an in-memory database) and PostgreSQL 9.3.11 (\"PG\"). For increasingly large collections of processes, we run 20,000 Enumerate queries to locate the 10 active processes, followed by 10,000 GetCPUTime queries for arbitrary process IDs. In all cases, the data is indexed by (state, PID) to allow for constant-time Enumerate queries (the number of active processes is kept constant) and logarithmic-time GetCPUTime queries (assuming a B-tree-style index and skip-scans).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 122,
                    "end": 130,
                    "text": "Fig. 5b)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 168,
                    "end": 175,
                    "text": "Fig. 5c",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 582,
                    "end": 590,
                    "text": "Figure 6",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Relational Queries"
        },
        {
            "text": "Our implementation behaves as expected: it beats SQLite and PostgreSQL by 1.5 and 2.5 orders of magnitude respectively on GetCPUTime, and competes honorably with SQLite (while beating PostgreSQL by one order of magnitude) on Enumerate. Notice the red curves on the graph: without an explicit \" \" clause, both database management systems missed the skipscan opportunity and exhibited asymptotically suboptimal linear-time behavior, so we had to tweak the queries fed to PostgreSQL and SQLite to obtain good GetCPUTime performance (in contrast, the optimizer in our system can be guided explicitly by adding compiler hints in the form of extra tactics, without modifying the specifications).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Relational Queries"
        },
        {
            "text": "Of course, our implementation does much less work than a database engine; the strength of our approach is to expose an SQL-style interface while enabling generation of specialized data-structure-manipulation code, allowing programmers to benefit from the conciseness and clarity of high-level specifications without incurring the overheads of a full-fledged DBMS.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Relational Queries"
        },
        {
            "text": "Trusted Base. Our derivation assumes ensemble extensionality and Axiom K. Our trusted base comprises the Coq 8.4 checker [25] (\u223c10 000 lines of OCaml code), the semantics of the Bedrock IL and the translator from it to x86 assembly (\u223c1200 lines of Gallina code), an assembler, and wrappers for extracted methods (\u223c50 lines of x86 assembly). We used Proof General [2] for development.",
            "cite_spans": [
                {
                    "start": 121,
                    "end": 125,
                    "text": "[25]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 363,
                    "end": 366,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Relational Queries"
        },
        {
            "text": "Closely related to our work is a project by Lammich [10] that uses Isabelle/HOL to refine functional programs to an embedded imperative language that requires garbage collection. This approach has been applied to various complex algorithms, whereas our focus is on fully automatic derivation from highly regular specs. Both approaches use some form of linearity checking to bridge the functional-imperative gap (Lammich et al. use separation logic [20] and axiomatic semantics, while we apply Facade's lighter-weight approach: decidable syntactic checks applied after-the-fact, with no explicit pointer reasoning). A recent extension [11] targets LLVM directly. Crucially, the initial work only targets Imperative/HOL and its extension does not support linking against separately verified libraries, while our pipeline allows linking, inside of Coq, lowlevel programs against verified libraries written in any language of the Bedrock ecosystem. Finally, we have integrated our translation into an automated proofgenerating pipeline from relational specifications to executable assembly codeas far as we know, no such pipeline has been presented before.",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 56,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 448,
                    "end": 452,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 634,
                    "end": 638,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Another closely related project by Kumar et al. [8, 17] focuses on extracting terms written in a purely functional subset of HOL4's logic into the CakeML dialect of ML. The main differences with our pipeline are optimization opportunities, extensibility, and external linking. Indeed, while the compiler to CakeML bridges a relatively narrow gap (between two functional languages with expressive type systems and automatic memory management), our extraction procedure connects two very different languages, opening up many more opportunities for optimizations (including some related to memory management). We expose these opportunities to our users by letting them freely extend the compiler based on their domain-specific optimization knowledge.",
            "cite_spans": [
                {
                    "start": 48,
                    "end": 51,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 52,
                    "end": 55,
                    "text": "17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Recent work by Protzenko et al. [19] achieves one of our stated goals (efficient extraction to low-level code, here from F* to C) but does not provide formal correctness guarantees for the extracted code (the tool, KreMLin, consists of over 15,000 lines of unverified OCaml code). Additionally, KreMLin requires source programs to be written in a style matching that of the extracted code: instead of extending the compiler with domain-specific representation choices and optimizations, users must restrict their programs to the Low* subset of F*.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 36,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "One last related project is the compiler of the Cogent language [18] . Its sources are very close to Facade's (it allows for foreign calls to axiomatically specified functions, but it does not permit iteration or recursion except through foreign function calls), and its compiler also produces low-level code without a garbage collector. Our projects differ in architecture and in spirit: Cogent is closer to a traditional verified compiler, producing consecutive embeddings of a source program (from C to a shallow embedding in Isabelle/HOL) and generating equivalence proofs connecting each of them. Cogent uses a linear type system to establish memory safety, while we favor extensibility over completeness, relying on lemmas to justify the compilation of arbitrary Gallina constructs.",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 68,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "We draw further inspiration from a number of other efforts:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Program Extraction. Program extraction (a facility offered by Coq and other proof assistants) is a popular way of producing executable binaries from verified code. Extractors are rather complex programs, subjected to varying degrees of scrutiny: for example, the theory behind Coq's extraction was mechanically formalized and verified [14] , but the corresponding concrete implementation itself is unverified. The recent development of CertiCoq [1] , a verified compiler for Gallina, has significantly improved matters over unverified extraction, but it only supports pure Gallina programs, and it uses a fixed compilation strategy. In contrast, our pipeline ensures that nondeterministic specifications are preserved down to the generated Bedrock code and grants user fine control over the compilation process.",
            "cite_spans": [
                {
                    "start": 335,
                    "end": 339,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 445,
                    "end": 448,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Compiler Verification. Our compilation strategy allows Fiat programs to depend on separately compiled libraries. This contrasts with verified compilers like CakeML [9] or CompCert [13] : in the latter, correctness guarantees only extend to linking with modules written in CompCert C and compiled with the same version of the compiler. Recent work [23] generalized these guarantees to cover cross-language compilation, but these developments have not yet been used to perform functional verification of low-level programs assembled from separately verified components.",
            "cite_spans": [
                {
                    "start": 164,
                    "end": 167,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 180,
                    "end": 184,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 347,
                    "end": 351,
                    "text": "[23]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "An alternative approach, recently used to verify an operating-system kernel [21] , is to validate individual compiler outputs. This is particularly attractive as an extension of existing compilers, but it generally falls short when trying to verify complex optimizations, such as our high-level selection of algorithms and data structures. In the same vein, verified compilers often rely on unverified programs to solve complex problems such as register allocation, paired with verified checkers to validate solutions. In our context, the solver is the proofproducing extraction logic, and the verifier is Coq's kernel: our pipeline produces proofs that witness the correctness of the resulting Facade code.",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 80,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Extensible Compilation. Multiple research projects let users add optimizations to existing compilers. Some, like Racket [26] , do not focus on verification. Others, like Rhodium [12] , let users phrase and verify transformations using DSLs. Unfortunately, most of these tools are unverified and do not provide end-toend guarantees. One recent exception is XCert [24], which lets CompCert users soundly describe program transformations using an EDSL. Our approach is similar insofar as we assemble DSL compilers from collections of verified rewritings.",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 124,
                    "text": "[26]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 178,
                    "end": 182,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Program Synthesis. Our approach of program generation via proofs follows in the deductive-synthesis tradition started in the 1980s [15] . We use the syntactic structure of our specialized pre-and postconditions to drive synthesis: the idea of strongly constraining the search space is inherited from the syntax-guided approach pioneered in the Sketch language [22] . That family of work uses SMT solvers where we use a proof assistant, offering more baseline automation with less fundamental flexibility.",
            "cite_spans": [
                {
                    "start": 131,
                    "end": 135,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 360,
                    "end": 364,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Formal Decompilation. Instead of deriving low-level code from high-level specifications, some authors have used HOL-family proof assistants to translate unverified low-level programs (in assembly [16] or C [6] ) into high-level code suitable for verification. Decompilation is an attractive approach for existing low-level code, or when compiler verification is impractical.",
            "cite_spans": [
                {
                    "start": 196,
                    "end": 200,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 206,
                    "end": 209,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "The extraction technique presented in this paper is a convenient and lightweight approach for generating certified extracted programs, reducing the trusted base of verified programs to little beyond a proof assistant's kernel. We have shown our approach to be suitable for the extraction of DSLs embedded in proof assistants, using it to compile a series of microbenchmarks and to do end-to-end proofgenerating derivation of assembly code from SQL-style specifications. Crucially, the latter derivations work via linking with verified implementations of assembly code that our derivation pipeline could never produce directly. To ease this transition, we developed Facade, a new language designed to facilitate reasoning about memory allocation in synthesized extracted programs. In the process, we have closed the last gap in the first automatic and mechanically certified translation pipeline from declarative specifications to assembly-language libraries, supporting user-guided optimizations and parameterization over abstract data types implemented, compiled, and verified using arbitrary languages and tools.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "CertiCoq: a verified compiler for Coq",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Anand",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "The Third International Workshop on Coq for PL",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Proof general: a generic tool for proof development",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Aspinall",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "TACAS 2000",
            "volume": "1785",
            "issn": "",
            "pages": "38--43",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-46419-0_3"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "The Bedrock structured programming system: combining generative metaprogramming and Hoare logic in an extensible program verifier",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Chlipala",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ACM SIG-PLAN International Conference on Functional Programming",
            "volume": "",
            "issn": "",
            "pages": "391--402",
            "other_ids": {
                "DOI": [
                    "10.1145/2500365.2500592"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Fiat: deductive synthesis of abstract data types in a proof assistant",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Delaware",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Pit-Claudel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gross",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Chlipala",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "689--700",
            "other_ids": {
                "DOI": [
                    "10.1145/2676726.2677006"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A constructive approach to the problem of program correctness",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "W"
                    ],
                    "last": "Dijkstra",
                    "suffix": ""
                }
            ],
            "year": 1967,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Bridging the gap: automatic verified abstraction of C",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Greenaway",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Andronick",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ITP 2012",
            "volume": "7406",
            "issn": "",
            "pages": "99--115",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-32347-8_8"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Data representation synthesis",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Hawkins",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Aiken",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Fisher",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "C"
                    ],
                    "last": "Rinard",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sagiv",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2011",
            "volume": "",
            "issn": "",
            "pages": "38--49",
            "other_ids": {
                "DOI": [
                    "10.1145/1993498.1993504"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Proof-producing synthesis of CakeML with I/O and local state from monadic HOL functions",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ho",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Abrahamsson",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kumar",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "O"
                    ],
                    "last": "Myreen",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [
                        "K"
                    ],
                    "last": "Tan",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Norrish",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IJCAR 2018",
            "volume": "10900",
            "issn": "",
            "pages": "646--662",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-94205-6_42"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "CakeML: a verified implementation of ML",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kumar",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "O"
                    ],
                    "last": "Myreen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Norrish",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Owens",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2014",
            "volume": "",
            "issn": "",
            "pages": "179--192",
            "other_ids": {
                "DOI": [
                    "10.1145/2535838.2535841"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Refinement to imperative/HOL",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Lammich",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ITP 2015",
            "volume": "9236",
            "issn": "",
            "pages": "253--269",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-22102-1_17"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Generating verified LLVM from Isabelle/HOL",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Lammich",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "International Conference on Interactive Theorem Proving, ITP 2019",
            "volume": "",
            "issn": "",
            "pages": "9--12",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Automated soundness proofs for dataflow analyses and transformations via local rules",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lerner",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "D"
                    ],
                    "last": "Millstein",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Rice",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Chambers",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "364--377",
            "other_ids": {
                "DOI": [
                    "10.1145/1040305.1040335"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Formal certification of a compiler back-end or: programming a compiler with a proof assistant",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Leroy",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "42--54",
            "other_ids": {
                "DOI": [
                    "10.1145/1111037.1111042"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "A new extraction for coq",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Letouzey",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "TYPES 2002",
            "volume": "2646",
            "issn": "",
            "pages": "200--219",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-39185-1_12"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "A deductive approach to program synthesis",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Manna",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "J"
                    ],
                    "last": "Waldinger",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "ACM Trans. Program. Lang. Syst",
            "volume": "2",
            "issn": "1",
            "pages": "90--121",
            "other_ids": {
                "DOI": [
                    "10.1145/357084.357090"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Decompilation into logic -improved",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "O"
                    ],
                    "last": "Myreen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J C"
                    ],
                    "last": "Gordon",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Slind",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Formal Methods in Computer-Aided Design, FMCAD 2012",
            "volume": "",
            "issn": "",
            "pages": "78--81",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Proof-producing synthesis of ML from higher-order logic",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "O"
                    ],
                    "last": "Myreen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Owens",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ACM SIGPLAN International Conference on Functional Programming",
            "volume": "",
            "issn": "",
            "pages": "115--126",
            "other_ids": {
                "DOI": [
                    "10.1145/2364527.2364545"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "COGENT: certified compilation for a functional systems language",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "O&apos;connor",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Verified low-level programming embedded in F*",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Protzenko",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the ACM on Programming Languages",
            "volume": "1",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3110261"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Separation logic: a logic for shared mutable data structures",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Reynolds",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "IEEE Symposium on Logic in Computer Science, LICS 2002",
            "volume": "",
            "issn": "",
            "pages": "55--74",
            "other_ids": {
                "DOI": [
                    "10.1109/LICS.2002.1029817"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Translation validation for a verified OS kernel",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "A L"
                    ],
                    "last": "Sewell",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "O"
                    ],
                    "last": "Myreen",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2013",
            "volume": "",
            "issn": "",
            "pages": "471--482",
            "other_ids": {
                "DOI": [
                    "10.1145/2491956.2462183"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "The sketching approach to program synthesis",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Solar-Lezama",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "APLAS 2009",
            "volume": "5904",
            "issn": "",
            "pages": "4--13",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-10672-9_3"
                ]
            }
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Compositional CompCert",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Stewart",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Beringer",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Cuellar",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "W"
                    ],
                    "last": "Appel",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "275--287",
            "other_ids": {
                "DOI": [
                    "10.1145/2676726.2676985"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Bringing extensibility to verified compilers",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Tatlock",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lerner",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ACM SIG-PLAN Conference on Programming Language Design and Implementation, PLDI 2010",
            "volume": "",
            "issn": "",
            "pages": "111--121",
            "other_ids": {
                "DOI": [
                    "10.1145/1806596.1806611"
                ]
            }
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "The Coq Development Team: The Coq Proof Assistant Reference Manual",
            "authors": [],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Languages as libraries",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Tobin-Hochstadt",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "St-Amour",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Culpepper",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Flatt",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Felleisen",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "ACM SIGPLAN Conference on Programming Language Design and Implementation",
            "volume": "",
            "issn": "",
            "pages": "132--141",
            "other_ids": {
                "DOI": [
                    "10.1145/1993498.1993514"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Comprehending monads",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Wadler",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Math. Struct. Comput. Sci",
            "volume": "2",
            "issn": "4",
            "pages": "461--493",
            "other_ids": {
                "DOI": [
                    "10.1017/S0960129500001560"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "The Facade language",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Compiler verification meets cross-language linking via data abstraction",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Cuellar",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Chlipala",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ACM International Conference on Object Oriented Programming Systems Languages & Applications, OOPSLA 2014, part of SPLASH",
            "volume": "",
            "issn": "",
            "pages": "675--690",
            "other_ids": {
                "DOI": [
                    "10.1145/2660193.2660201"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "The full pipeline, with this work's contributions in blue. Stick figures indicate usersupplied components. (Color figure online)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "A few rules of our synthesizing compiler.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Selected syntax & operational semantics of Facade[28].",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Equivalence relation on Fiat and Facade states. Because Facade does not allow us to leak ADT values, we require that all bindings pointing to ADT values in st be reflected in and vice versa. For scalars, we only require that bindings in be present in st.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fiat states, which allow us to express pre and post-conditions in a concise and homogeneous way, facilitating syntax-driven compilation. Each Fiat state (denoted as st ) describes a set of Facade states (denoted as st): in Facade, machine states are unordered collections of names and values. Fiat states, on the other hand, are ordered collections of bindings (sometimes called telescopes), each containing a variable name and a set of permissible values for that variable.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Different stages of a process-scheduler compilation example (see also the annotated 'ProcessScheduler.v' file).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Process scheduler benchmarks.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "-\u2200 st. st st ext =\u21d2 (p, st)\u2193 For any initial Facade state st, if st is in relation with the Fiat state st extended by ext , then it is safe to run the Facade program p from state st. -\u2200 st, st'. st st ext \u2227 (p, st) \u21d3 st' =\u21d2 st' st' ext For all initial and final Facade states st and st', if st is in relation with the Fiat state st extended by ext , and if running the Facade program p starting from st may produce the Facade state st', then st' is in relation with the Fiat state st' extended by ext .",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgments. This work has been supported in part by NSF grants CCF-1512611 and CCF-1521584, and by DARPA under agreement number FA8750-16-C-0007. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}