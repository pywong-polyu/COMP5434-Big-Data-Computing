{
    "paper_id": "4b20ba8d83fb3d3417c1b7603d88c20ed7002a7c",
    "metadata": {
        "title": "Reasoning over Permissions Regions in Concurrent Separation Logic",
        "authors": [
            {
                "first": "James",
                "middle": [],
                "last": "Brotherston",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University College London",
                    "location": {
                        "settlement": "London",
                        "country": "UK"
                    }
                },
                "email": "j.brotherston@ucl.ac.uk"
            },
            {
                "first": "Diana",
                "middle": [],
                "last": "Costa",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University College London",
                    "location": {
                        "settlement": "London",
                        "country": "UK"
                    }
                },
                "email": ""
            },
            {
                "first": "Aquinas",
                "middle": [],
                "last": "Hobor",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National University of Singapore",
                    "location": {
                        "settlement": "Singapore",
                        "country": "Singapore"
                    }
                },
                "email": ""
            },
            {
                "first": "John",
                "middle": [],
                "last": "Wickerson",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Imperial College London",
                    "location": {
                        "settlement": "London",
                        "country": "UK"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "We propose an extension of separation logic with fractional permissions, aimed at reasoning about concurrent programs that share arbitrary regions or data structures in memory. In existing formalisms, such reasoning typically either fails or is subject to stringent side conditions on formulas (notably precision) that significantly impair automation. We suggest two formal syntactic additions that collectively remove the need for such side conditions: first, the use of both \"weak\" and \"strong\" forms of separating conjunction, and second, the use of nominal labels from hybrid logic. We contend that our suggested alterations bring formal reasoning with fractional permissions in separation logic considerably closer to common pen-and-paper intuition, while imposing only a modest bureaucratic overhead.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Concurrent separation logic (CSL) is a version of separation logic designed to enable compositional reasoning about concurrent programs that manipulate memory possibly shared between threads [6, 26] . Like standard separation logic [28] , CSL is based on Hoare triples {A} C {B}, where C is a program and A and B are formulas (called the precondition and postcondition of the code respectively). The heart of the formalism is the following concurrency rule:",
            "cite_spans": [
                {
                    "start": 191,
                    "end": 194,
                    "text": "[6,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 195,
                    "end": 198,
                    "text": "26]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 232,
                    "end": 236,
                    "text": "[28]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "where is a so-called separating conjunction. This rule says that if two threads C 1 and C 2 are run on spatially separated resources A 1 A 2 then the result will be the spatially separated result, B 1 B 2 , of running the two threads individually. However, since many or perhaps even most interesting concurrent programs do share some resources, typically does not denote strict disjoint separation of memories, as it does in standard separation logic (where it is usually written as * ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Instead, it usually denotes a weaker sort of \"separation\" designed to ensure that the two threads at least cannot interfere with each others' data. This gives rise to the idea of fractional permissions, which allow us to divide writeable memory into multiple read-only copies by adding a permission value to each location in heap memory. In the usual model, due to Boyland [5] , permissions are rational numbers in the half-open interval (0, 1], with 1 denoting the write permission, and values in (0, 1) denoting read-only permissions. We write the formula A \u03c0 , where \u03c0 is a permission, to denote a \"\u03c0 share\" of the formula A. For example, (x \u2192 a) 0.5 (typically written as x 0.5 \u2192 a for convenience) denotes a \"half share\" of a single heap cell, with address x and value a. The separating conjunction A B then denotes heaps realising A and B that are \"compatible\", rather than disjoint: where the heaps overlap, they must agree on the data value, and one adds the permissions at the overlapping locations [4] . E.g., at the logical level, we have the entailment:",
            "cite_spans": [
                {
                    "start": 373,
                    "end": 376,
                    "text": "[5]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1008,
                    "end": 1011,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Happily, the concurrency rule of CSL is still sound in this setting (see e.g. [29] ). However, the use of this weaker notion of separation causes complications for formal reasoning in separation logic, especially if one wishes to reason over arbitrary regions of memory rather than individual pointers. There are two particular difficulties, as identified by Le and Hobor [24] . The first is that, since denotes possibly-overlapping memories, one loses the main useful feature of separation logic: its nonambiguity about separation, which means that desirable entailments such as A 0.5 B 0.5 |= (A B) 0.5 turn out to be false. E.g.:",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 82,
                    "text": "[29]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 372,
                    "end": 376,
                    "text": "[24]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Here, the two \"half-pointers\" on the LHS might be aliased (x = y and a = b), meaning they are two halves of the same pointer, whereas on the RHS they must be non-aliased (because we cannot combine two \"whole\" pointers). This ambiguity becomes quite annoying when one adds arbitrary predicate symbols to the logic, e.g. to support inductively defined data structures.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The second difficulty is that although recombining single pointers is straightforward, as indicated by Eq. (1), recombining the shares of arbitrary formulae is challenging. E.g., A 0.5 A 0.5 |= A, as shown by the counterexample",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The LHS can be satisfied by a heap with a 0.5-share of x and a 0.5-share of y, whereas the RHS requires a full (1) share of either x or y.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Le et al. [24] address these problems by a combination of the use of tree shares (essentially Boolean binary trees) rather than rational numbers as permissions, and semantic restrictions on when the above sorts of permissions reasoning can be applied. For example, recombining permissions (A 0.5 A 0.5 |= A) is permitted only when the formula is precise in the usual separation logic sense (cf. [28] ). The chief drawback with this approach is the need to repeatedly check these side conditions on formulas when reasoning, as well as that said reasoning cannot be performed on imprecise formulas.",
            "cite_spans": [
                {
                    "start": 10,
                    "end": 14,
                    "text": "[24]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 395,
                    "end": 399,
                    "text": "[28]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Instead, we propose to resolve these difficulties by a different, two-pronged extension to the syntax of the logic. First, we propose that the usual \"strong\" separating conjunction * , which enforces the strict disjointness of memory, should be retained in the formalism in addition to the weaker . The stronger * supports entailments such as A 0.5 * B 0.5 |= (A * B) 0.5 , which does not hold when is used instead. Second, we introduce nominal labels from hybrid logic (cf. [3, 10] ) to remember that two copies of a formula have the same origin. We write a nominal \u03b1 to denote a unique heap, in which case entailments such as (\u03b1 \u2227 A) 0.5 (\u03b1 \u2227 A) 0.5 |= \u03b1 \u2227 A become valid. We remark that labels have been adopted for similar \"tracking\" purposes in several other separation logic proof systems [10, 21, 23, 25] .",
            "cite_spans": [
                {
                    "start": 475,
                    "end": 478,
                    "text": "[3,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 479,
                    "end": 482,
                    "text": "10]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 795,
                    "end": 799,
                    "text": "[10,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 800,
                    "end": 803,
                    "text": "21,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 804,
                    "end": 807,
                    "text": "23,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 808,
                    "end": 811,
                    "text": "25]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The remainder of this paper aims to demonstrate that our proposed extensions are (i) weakly necessary, in that expected reasoning patterns fail under the usual formalism, (ii) correct, in that they recover the desired logical principles, and (iii) sufficient to verify typical concurrent programming patterns that use sharing. Section 2 gives some simple examples that motivate our extensions. Section 3 then formally introduces the syntax and semantics of our extended formalism. In Sect. 4 we show that our logic obeys the logical principles that enable us to reason smoothly with fractional permissions over arbitrary formulas, and in Sect. 5 we give some longer worked examples. Finally, in Sect. 6 we conclude and discuss directions for future work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this section, we aim to motivate our extensions to separation logic with permissions by showing, firstly, how the failures of the logical principles described in the introduction actually arise in program verification examples and, secondly, how these failures are remedied by our proposed changes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivating Examples"
        },
        {
            "text": "The overall context of our work is reasoning about concurrent programs that share some data structure or region in memory, which can be described as a formula in the assertion language. If A is such a formula then we write A \u03c0 to denote a \"\u03c0 share\" of the formula A, meaning informally that all of the pointers in the heap memory satisfying A are owned with share \u03c0. The main question then becomes how this notion interacts with the separating conjunction . There are two key desirable logical equivalences:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivating Examples"
        },
        {
            "text": "Equivalence (I) describes distributing a fractional share over a separating conjunction, whereas equivalence (II) describes combining two pieces of a previously split resource. Both equivalences are true in the |= direction but, as we have seen in the Introduction, false in the =| one. Generally speaking, is like Humpty Dumpty: easy to break apart, but not so easy to put back together again.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivating Examples"
        },
        {
            "text": "The key to understanding the difficulty is the following equivalence:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivating Examples"
        },
        {
            "text": "In other words, either x and y are not aliased, or they are aliased and the permissions combine (the additive operation \u2295 on rational shares is simply normal addition when the sum is \u2264 1 and undefined otherwise). This disjunction undermines the notational economies that have led to separation logic's great successes in scalable verification [11] ; in particular, (I) fails because the left disjunct might be true, and (II) fails because the right disjunct might be. At a high level, is a bit too easy to introduce, and therefore also a bit too hard to eliminate.",
            "cite_spans": [
                {
                    "start": 343,
                    "end": 347,
                    "text": "[11]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Motivating Examples"
        },
        {
            "text": "One of the challenges of the weak separating conjunction is that it interacts poorly with inductively defined predicates. Consider porting the usual separation logic definition of a possibly-cyclic linked list segment from x to y from a sequential setting to a concurrent one by a simple substitution of for * :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "Now consider a simple recursive procedure foo(x,y) that traverses a linked list segment from x to y:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "foo(x,y) { if x=y then return; else foo([x],y); } It is easy to see that foo leaves the list segment unchanged, and therefore satisfies the following Hoare triple:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "The intuitive proof of this fact would run approximately as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "However, because of the use of , the highlighted inference step is not sound:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "To see this, consider a heap with the following structure, viewed in two ways:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "This heap satisfies the LHS of the entailment in (2) , as it is the -composition of a 0.5-share of x \u2192 z and a 0.5-share of ls z z, a cyclic list segment from z back to itself (note that here z = y). However, it does not satisfy the RHS, since it is not a 0.5-share of the -composition of x \u2192 z with ls z z, which would require the pointer to be disjoint from the list segment. The underlying reason for the failure of this example is that, in going from (x \u2192 z ls z z) 0.5 to x 0.5 \u2192 z (ls z z) 0.5 , we have lost the information that the pointer and the list segment are actually disjoint. This is reflected in the general failure of the distribution principle A \u03c0 B \u03c0 |= (A B) \u03c0 , of which the above is just one instance. Accordingly, our proposal is that the \"strong\" separating conjunction * from standard separation logic, which forces disjointness of the heaps satisfying its conjuncts, should also be retained in the logic alongside , on the grounds that (II) is true for the stronger connective:",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 52,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "If we then define our list segments using * in the traditional way, namely",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "then we can observe that this second definition of ls is identical to the first on permission-free formulas, since and * coincide in that case. However, when we replay the verification proof above with the new definition of ls, every in the proof above becomes a * , and the proof then becomes sound. Nevertheless, we can still use to describe permission-decomposition of list segments at a higher level; e.g., ls x y can still be decomposed as (ls x y) 0.5 (ls x y) 0.5 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weak vs. Strong Separation and the Distribution Principle"
        },
        {
            "text": "Unfortunately, even when we use the strong separating conjunction * to define list segments ls, a further difficulty still remains. Consider a simple concurrent program that runs two copies of foo in parallel on the same list segment:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "foo(x,y); || foo(x,y);",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "Since foo only reads from its input list segment, and satisfies the specification {(ls x y) 0.5 } foo(x,y); {(ls x y) 0.5 }, this program satisfies the specification {ls x y} foo(x,y); || foo(x,y); {ls x y}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "Now consider constructing a proof of this specification in CSL. First we view the list segment ls x y as the -composition of two read-only copies, with permission 0.5 each; then we use CSL's concurrency rule (see Sect. 1) to compose the specifications of the two threads; last we recombine the two read-only copies to obtain the original list segment. The proof diagram is as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "However, again, the highlighted inference step in this proof is not correct:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "A countermodel is a heap with the following structure, again viewed in two ways:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "According to the first view of such a heap, it satisfies the LHS of (4), as it is the -composition of two 0.5-shares of ls x y (one of two cells, and one of a single cell). However, it does not satisfy ls x y, since that would require every cell in the heap to be owned with permission 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "Like in our previous example, the reason for the failure of this example is that we have lost information. In going from ls x y to (ls x y) 0.5 (ls x y) 0.5 , we have forgotten that the two formulas (ls x y) 0.5 are in fact copies of the same region. For formulas A that are precise in that they uniquely describe part of any given heap [12] , e.g. formulas x \u2192 a, this loss of information does not happen and we do have A 0.5 A 0.5 |= A; but for non-precise formulas such as ls x y, this principle fails.",
            "cite_spans": [
                {
                    "start": 337,
                    "end": 341,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "However, we regard this primarily as a technical shortcoming of the formalism, rather than a failure of our intuition. It ought to be true that we can take any region of memory, split it into two read-only copies, and then later merge the two copies to re-obtain the original region. Were we conducting the above proof on pen and paper, we would very likely explain the difficulty away by adopting some kind of labelling convention, allowing us to remember that two formulas have been obtained from the same memory region by dividing permissions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "In fact, that is almost exactly our proposed remedy to the situation. We introduce nominals, or labels, from hybrid logic, where a nominal \u03b1 is interpreted as denoting a unique heap. Any formula of the form \u03b1 \u2227 A is then precise (in the above sense), and so obeys the combination principle",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "where \u2295 is addition on permissions. Thus we can repair the faulty CSL proof above by replacing every instance of the formula ls x y by the \"labelled\" formula \u03b1 \u2227 ls x y (and adding an initial step in which we introduce the fresh label \u03b1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nominal Labelling and the Combination Principle"
        },
        {
            "text": "However, this is not quite the end of the story. Readers may have noticed that replacing ls x y by the \"labelled\" version \u03b1 \u2227 ls x y also entails establishing a slightly stronger specification for the function foo, namely:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Jump Modality"
        },
        {
            "text": "This introduces an extra difficulty in the proof (cf. Sect. 2.1); at the recursive call to foo([x],y), the precondition now becomes \u03b1 0.5 \u2227 (x 0.5 \u2192 z * (ls z y) 0.5 )), which means that we cannot apply separation logic's frame rule [32] to the pointer formula without first weakening away the label-share \u03b1 0.5 .",
            "cite_spans": [
                {
                    "start": 233,
                    "end": 237,
                    "text": "[32]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [],
            "section": "The Jump Modality"
        },
        {
            "text": "For this reason, we shall also employ hybrid logic's \"jump\" modality @ , where the formula @ \u03b1 A means that A is true of the heap denoted by the label \u03b1. In the above, we can introduce labels \u03b2 and \u03b3 for the list components x \u2192 z and ls z y respectively, whereby we can represent the decomposition of the list by the assertion @ \u03b1 (\u03b2 * \u03b3). Since this is a pure assertion that does not depend on the heap, it can be safely maintained when applying the frame rule, and used after the function call to restore the label \u03b1, using the easily verifiable fact that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Jump Modality"
        },
        {
            "text": "Similar reasoning over labelled decompositions of data structures is seemingly necessary whenever treating recursion; we return to it in more detail in Sect. 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Jump Modality"
        },
        {
            "text": "Following the motivation given in the previous section, here we give the syntax and semantics of a separation logic, SL LP , with permissions over arbitrary formulas, making use of both strong and weak separating conjunctions, and nominal labels (from hybrid logic [3, 10] ). First, we define a suitable notion of permissions and associated operations.",
            "cite_spans": [
                {
                    "start": 265,
                    "end": 268,
                    "text": "[3,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 269,
                    "end": 272,
                    "text": "10]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "Perm is a set (of \"permissions\"), 1 \u2208 Perm is called the write permission, and \u2295 and \u2297 are respectively partial and total binary functions on Perm, satisfying associativity, commutativity, cancellativity and the following additional axioms:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "The most common example of a permissions algebra is the Boyland fractional permission model (0, 1] \u2229 Q, \u2295, \u00d7, 1 , where permissions are rational numbers in (0, 1], \u00d7 is standard multiplication, and \u2295 is standard addition but undefined if p + p > 1. From now on, we assume a fixed but arbitrary permissions algebra.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "With the permissions structure in place, we can now define the syntax of our logic. We assume disjoint, countably infinite sets Var of variables, Pred of predicate symbols (with associated arities) and Label of labels. Definition 3.2. We define formulas of SL LP by the grammar:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "where x, y range over Var, \u03c0 ranges over Perm, P ranges over Pred, \u03b1 ranges over Label and x ranges over tuples of variables of length matching the arity of the predicate symbol P . We write x \u03c0 \u2192 y for (x \u2192 y) \u03c0 , and x = y for \u00ac(x = y).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "The \"magic wands\" \u2212 \u2212 * and \u2212 \u2212 are the implications adjoint to * and , as usual in separation logic. We include them for completeness, but we use \u2212 \u2212 * only for fairly complex examples (see Sect. 5.3) and in fact do not use \u2212 \u2212 at all.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "Semantics. We interpret formulas in a standard model of stacks and heapswith-permissions (cf. [4] ), except that our models also incorporate a valuation of nominal labels. We assume an infinite set Val of values of which an infinite subset Loc \u2282 Val are considered addressable locations. A stack is as usual a map s : Var \u2192 Val. A heap-with-permissions, which we call a p-heap for short, is a finite partial function h : Loc fin Val \u00d7 Perm from locations to value-permission pairs. We write dom (h) for the domain of h, i.e. the set of locations on which h is defined. Two p-heaps h 1 and h 2 are called disjoint if dom (h 1 ) \u2229 dom (h 2 ) = \u2205, and compatible if, for all \u2208 dom (h 1 ) \u2229 dom (h 2 ), we have h 1 ( ) = (v, \u03c0 1 ) and h 2 (v, \u03c0 2 ) and \u03c0 1 \u2295 \u03c0 2 is defined. (Thus, trivially, disjoint heaps are also compatible.) We define the multiplication \u03c0 \u00b7 h of a p-heap h by permission \u03c0 by extending \u2297 pointwise:",
            "cite_spans": [
                {
                    "start": 94,
                    "end": 97,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "We also assume that each predicate symbol P of arity k is given a fixed interpretation P \u2208 (Val k \u00d7 PHeaps), where PHeaps is the set of all p-heaps. Here we allow an essentially free interpretation of predicate symbols, but they could also be given by a suitable inductive definition schema, as is done in many papers on separation logic (e.g. [7, 8] ). Finally, a valuation is a function \u03c1 : Label \u2192 PHeaps assigning a single p-heap \u03c1(\u03b1) to each label \u03b1. Strong and weak heap composition) . The strong composition h 1 \u2022 h 2 of two disjoint p-heaps h 1 and h 2 is defined as their union: ",
            "cite_spans": [
                {
                    "start": 344,
                    "end": 347,
                    "text": "[7,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 348,
                    "end": 350,
                    "text": "8]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [
                {
                    "start": 456,
                    "end": 489,
                    "text": "Strong and weak heap composition)",
                    "ref_id": null
                }
            ],
            "section": "Separation Logic with Labels and Permissions (SL LP )"
        },
        {
            "text": "(h 1 \u2022 h 2 )( ) = h 1 ( ) if \u2208 dom (h 2 ) h 2 ( ) if \u2208 dom (h 1 )(h 1 \u2022 h 2 )( ) = \u23a7 \u23aa \u23a8 \u23aa \u23a9 (v, \u03c0 1 \u2295 \u03c0 2 ) if h 1 ( ) = (v, \u03c0 1 ) and h 2 ( ) = (v, \u03c0 2 ) h 1 ( ) if \u2208 dom (h 2 ) h 2 ( ) if \u2208 dom (h 1 )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3.3 ("
        },
        {
            "text": "In this section, we establish the main logical entailments and equivalences of SL LP that capture the various interactions between the separating conjunctions and * , permissions and labels. As well as being of interest in their own right, many of these principles will be essential in ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logical Principles of SL LP"
        },
        {
            "text": "Additionally, the following residuation laws hold:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logical Principles of SL LP"
        },
        {
            "text": "In addition, we can always weaken * to : A * B |= A B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logical Principles of SL LP"
        },
        {
            "text": "Next, we establish an additional connection between the two separating conjunctions and * . ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logical Principles of SL LP"
        },
        {
            "text": "We can merge the first and fourth cases by noting that h(",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logical Principles of SL LP"
        },
        {
            "text": ", and similarly for the second and fifth cases. We can also rewrite the last two cases by observing that / \u2208 dom (h 3 ) implies h 1 ( ) = (h 1 \u2022 h 3 )( ), and so on, resulting in Next, we establish principles for distributing permissions over various connectives, in particular over the strong * , stated earlier as (3) in Sect. 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logical Principles of SL LP"
        },
        {
            "text": "h = (h 1 \u2022 h 2 ) \u2022 (h 3 \u2022 h 4 ),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now we show the main result. Suppose s, h, \u03c1 |= (A B) * (C D). This gives us"
        },
        {
            "text": "The following equivalences hold for all formulas A and B, and permissions \u03c0 and \u03c3:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.3 (Permission distribution)."
        },
        {
            "text": "Proof. We just show the most interesting case, ( * \u03c0 ). First of all, we establish a corresponding model-theoretic property: for any permission \u03c0 and disjoint pheaps h 1 and h 2 , meaning h 1 \u2022 h 2 is defined,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.3 (Permission distribution)."
        },
        {
            "text": "To see this, we first observe that for any \u2208 dom (h 1 \u2022 h 2 ), we have that either \u2208 dom (h 1 ) or \u2208 dom (h 2 ). We just show the case \u2208 dom (h 1 ), since the other is symmetric. Writing h 1 ( ) = (v 1 , \u03c0 1 ), and using the fact that \u2208 dom (h 2 ), \u03c0 \u00b7 (h 1 \u2022 h 2 )( ) = (v 1 , \u03c0 \u2297 \u03c0 1 ) = (\u03c0 \u00b7 h 1 )( ) = ((\u03c0 \u00b7 h 1 ) \u2022 (\u03c0 \u00b7 h 2 ))( ). Now for the main result, let s, h and \u03c1 be given. We have s, h, \u03c1 |= (A * B) \u03c0 \u21d4 h = \u03c0 \u00b7 h and s, h , \u03c1 |= A * B \u21d4 h = \u03c0 \u00b7 h and h = h 1 \u2022 h 2 and s, h 1 , \u03c1 |= A and s, h 2 , \u03c1 |= B \u21d4 h = \u03c0 \u00b7 (h 1 \u2022 h 2 ) and s, h 1 , \u03c1 |= A and s, h 2 , \u03c1 |= B \u21d4 h = (\u03c0 \u00b7 h 1 ) \u2022 (\u03c0 \u00b7 h 2 ) and s, h 1 , \u03c1 |= A and s, h 2 , \u03c1 |= B by (7)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.3 (Permission distribution)."
        },
        {
            "text": "We now establish the main principles for dividing and combining permissions formulas using . As foreshadowed in Sect. 2, the combination principle holds only for formulas that are conjoined with a nominal label (cf. Eq. (5)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.3 (Permission distribution)."
        },
        {
            "text": "For all formulas A, nominals \u03b1, and permissions \u03c0 1 , \u03c0 2 such that \u03c0 1 \u2295 \u03c0 2 is defined: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.4 (Permission division and combination)."
        },
        {
            "text": "Now we define p-heaps h 1 and h 2 , both with domain exactly dom (h), by ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.4 (Permission division and combination)."
        },
        {
            "text": "To see this, we observe that for any \u2208 dom (h), writing h( ) = (v, \u03c0) say,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.4 (Permission division and combination)."
        },
        {
            "text": "Thus h 1 = h 2 = \u03c1(\u03b1) and so, by (8), we have h = (\u03c0 1 \u2295 \u03c0 2 ) \u00b7 h 1 , where s, h 1 , \u03c1 |= \u03b1 \u2227 A. This gives us s, h, \u03c1 |= (\u03b1 \u2227 A) \u03c01\u2295\u03c02 , as required.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.4 (Permission division and combination)."
        },
        {
            "text": "Lastly, we state some useful principles for labels and the \"jump\" modality.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.4 (Permission division and combination)."
        },
        {
            "text": "Proof. We just show the case (@/ * / ), the others being easy. Suppose s, h, \u03c1 |= @ \u03b1 (\u03b2 1 \u03c0 * \u03b2 2 \u03c3 ) \u2227 (\u03b2 1 \u03c0 \u03b2 2 \u03c3 ), meaning that s, \u03c1(\u03b1), \u03c1 |= \u03b2 1 \u03c0 * \u03b2 2 \u03c3 and s, h, \u03c1 |= \u03b2 1 \u03c0 \u03b2 2 \u03c3 . Then we have \u03c1(\u03b1) = (\u03c0 \u00b7 \u03c1(\u03b2 1 )) \u2022 (\u03c3 \u00b7 \u03c1(\u03b2 2 )), while h = (\u03c0 \u00b7 \u03c1(\u03b2 1 )) \u2022 (\u03c3 \u00b7 \u03c1(\u03b2 2 )). Since \u2022 is defined only when its arguments are disjoint p-heaps, we obtain that h = \u03c1(\u03b1) = (\u03c0 \u00b7 \u03c1(\u03b2 1 )) \u2022 (\u03c3 \u00b7 \u03c1(\u03b2 2 )). Thus s, h, \u03c1 |= \u03b1 \u2227 (\u03b2 1 \u03c0 * \u03b2 2 \u03c3 ). ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4.5 (Labelling and jump). For all formulas A and labels \u03b1,"
        },
        {
            "text": "In this section, we demonstrate how SL LP can be used in conjunction with the usual principles of CSL to construct verification proofs of concurrent programs, taking three examples of increasing complexity. Our examples all operate on binary trees in memory, defined as usual in separation logic (again note the use of * rather than ):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Concurrent Program Verification Examples"
        },
        {
            "text": "Our proofs employ (a subset of) the standard rules of CSL-with the most important being the concurrency rule from the Introduction, the separation logic frame rules for both * and , and a new rule enabling us to introduce fresh labels into the precondition of a triple (similar to the way Hoare logic usually handles existential quantifiers). These key rules are shown in Fig. 2 . We simplify our Hoare triple to remove elements to handle function call/return and furthermore omit the presentation of the standard collection of rules for consequence, load, store, if-then-else, assignment, etc.; readers interested in such aspects can consult [1] . Both of our frame rules have the usual side condition on modified program variables. The strong frame rule (Frame * ) has an additional side condition that will be discussed in Sect. 5.3; until then it is trivially satisfied.",
            "cite_spans": [
                {
                    "start": 643,
                    "end": 646,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 372,
                    "end": 378,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Concurrent Program Verification Examples"
        },
        {
            "text": "Consider the following program:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Parallel Read"
        },
        {
            "text": "; } This is intended to be a straightforward example where we take a tree rooted at x and, if x is non-null, split into parallel threads that run the program read on x, and whose specification is {\u03b1 \u03c0 \u2227 tree(x) \u03c3 } read(x) {\u03b1 \u03c0 \u2227 tree(x) \u03c3 }. We prove that check satisfies the specification {tree(x) \u03c0 } check(x) {tree(x) \u03c0 }; the verification proof is in Fig. 3 . The proof makes use of the basic operations of our theory: labelling, splitting and joining. The example follows precisely these steps, starting by labelling the formula tree(x) \u03c0 \u2227 x = null with \u03b1. The concurrency rule (Par) allows us to put formulas back together after the parallel call, and the two copies (\u03b1 \u2227 tree(x) \u03c0 ) 0.5 that were obtained are glued back together to yield tree(x) \u03c0 , since they have the same label. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 356,
                    "end": 362,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Parallel Read"
        },
        {
            "text": "Consider the following program, which was also employed as an example in [24] :",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 77,
                    "text": "[24]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Parallel Tree Processing (Le and Hobor [24])"
        },
        {
            "text": "print(x->d); proc(x->l);",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Parallel Tree Processing (Le and Hobor [24])"
        },
        {
            "text": "proc(x->l); proc(x->r);",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Parallel Tree Processing (Le and Hobor [24])"
        },
        {
            "text": "proc(x->r); } This code takes a tree rooted at x and, if x is non-null, splits into parallel threads that call proc recursively on its left and right branches. We prove, in Fig. 4 , that proc satisfies the specification {\u03b1 \u2227 tree(x) \u03c0 } proc(x) {\u03b1 \u2227 tree(x) \u03c0 }. First we unroll the definition of tree(x) and distribute the permission over Boolean connectives and * . If the tree is empty the process stops. Otherwise, we label each component with a new label and introduce the \"jump\" statement @ \u03b1 (\u03b2 1 * \u03b2 2 * \u03b2 3 ), recording the decomposition of the tree into its three components. Since such statements are pure, i.e. independent of the heap, we can \"carry\" this formula along our computation without interfering with the frame rule(s). Now that every subregion is labelled, we split the formula into two copies, each with half share, but after distributing 0.5 over * and \u2227 we end up with half shares in the labels as well. We relabel each subregion with new \"whole\" labels, and again introduce pure @-formulas that record the relation between the old and the new labels. At this moment we enter the parallel threads and recursively apply proc to the left and right subtrees of x. Assuming the specification of proc for subtrees of x, we then retrieve the original label \u03b1 from the trail of crumbs left by the @-formulas. We can then recombine the \u03b1-labelled threads using (Join ) to arrive at the desired postcondition.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 173,
                    "end": 179,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Parallel Tree Processing (Le and Hobor [24])"
        },
        {
            "text": "Our previous examples involve only \"isolated tank\" concurrency: a program has some resources and splits them into parallel threads that do not communicate with each other before-remembering Humpty Dumpty!-ultimately re-merging. For our last example, we will show that our technique is expressive enough to handle more sophisticated kinds of sharing, in particular inter-thread coarsegrained communication. We will show that we can not only share read-only data, but in fact prove that one thread has acquired the full ownership of a structure, even when the associated root pointers are not easily exposed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "To do so, we add some communication primitives to our language, together with their associated Hoare rules. Coarse-grained concurrency such as locks, channels, and barriers have been well-investigated in various flavours of concurrent separation logic [19, 26, 31] . We will use a channel for our example in this section but with simplified rules: the Hoare rule for a channel c to send message",
            "cite_spans": [
                {
                    "start": 252,
                    "end": 256,
                    "text": "[19,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 257,
                    "end": 260,
                    "text": "26,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 261,
                    "end": 264,
                    "text": "31]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "We ignore details such as identifying which party is allowed to send/receive at a given time [14] or the resource ownership of the channel itself [18] .",
            "cite_spans": [
                {
                    "start": 93,
                    "end": 97,
                    "text": "[14]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 146,
                    "end": 150,
                    "text": "[18]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "These rules interact poorly with the strong frame rule from Fig. 2 :",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 60,
                    "end": 66,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "The revealed side condition ( \u2021) means that C does not contain any subcommands that \"transfer in\" resources, such as unlock, receive, etc.; this side condition is a bit stronger than necessary but has a simple definition and can be checked syntactically. Without ( \u2021), we can reach a contradiction. Assume that the current \u2192 a, can reason as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "The postcondition is a contradiction as no location strongly separates from itself. However, given ( \u2021) the strong frame rule can be proven by induction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "The consequence of ( \u2021), from a verification point of view, is that when resources are transferred in they arrive weakly separated, by , since we must use the weak frame rule around the receiving command. The troublesome issue is that this newly \"arriving\" state can thus -overlap awkwardly with the existing state. Fortunately, judicious use of labels can sort things out.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "Consider the code in Fig. 5 . The basic idea is simple: we create some data at the top (line 101) and then split its ownership 50-50 to two threads. The left thread finds a subtree, and passes its half of that subtree to the right via a channel. The right thread receives the root of that subtree, and thus has full ownership of that subtree along with half-ownership of the rest of the tree. Accordingly, the right thread can modify that subtree before notifying the left subtree and passing half of the modified subtree back. After merging, full ownership of the entire tree is restored and so on line 401 the program can delete it. Figure 5 only contains the proof and line numbers for the top and bottom shared portions. The left and the right thread's proofs appear in Fig. 6 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 21,
                    "end": 27,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 635,
                    "end": 643,
                    "text": "Figure 5",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 774,
                    "end": 780,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "By this point the top and bottom portions of the verification are straightforward. After creating the tree tree(rt) at line 102, we introduce the label \u03b1, split the formula using (Split ), and then pass (\u03b1 \u2227 tree(rt)) 0.5 to both threads. After the parallel execution, due to the call to modify(sub) in the right thread, the tree has changed in memory. Accordingly, the label for the tree must also change as indicated by the ( \u2227 tree(rt)) 0.5 in both threads after parallel processing. These are then recombined on line 400 using the re-combination principle (Join ), before the tree is deallocated via standard sequential techniques. Let us now examine the more interesting proofs of the individual threads in Fig. 6 . Line 201 calls the find function, which searches a binary tree for a subtree rooted with key key. Following Cao et al. [13] we specify find as follows:",
            "cite_spans": [
                {
                    "start": 840,
                    "end": 844,
                    "text": "[13]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [
                {
                    "start": 712,
                    "end": 718,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "Here ret is bound to the return value of find, and the postcondition can be considered to represent the returned subtree tree(ret ) separately from the treewith-a-hole tree(ret ) \u2212 \u2212 * tree(x), using a * /\u2212 \u2212 * style to represent replacement as per Hobor and Villard [20] . This is the invariant on line 202. Line 203 then attaches the fresh labels \u03b2 and \u03b3 to the * -separated subparts, and line 204 snapshots the formula current at label \u03b1 using the @ operator; @ \u03c0 \u03b1 P should be read as \"when one has a \u03c0-fraction of \u03b1, P holds\"; it is definable using @ and an existential quantifier over labels. On line 205 we forget (in the left thread) the label \u03b1 for the current heap for housekeeping purposes, and then on line 206 we weaken the strong separating conjunction * to the weak one before sending the root of the subtree sub on line 207.",
            "cite_spans": [
                {
                    "start": 267,
                    "end": 271,
                    "text": "[20]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "In the transfer program, the invariant for the first channel message is (\u03b2 \u2227 tree(sub)) 0.5 \u2227 @ 0.5 \u03b1 ((\u03b2 \u2227 tree(sub)) * (\u03b3 \u2227 (tree(sub) \u2212 \u2212 * tree(rt)))) 0.5",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "In other words, half of the ownership of the tree rooted at sub plus the (pure) @-fact about the shape of the heap labeled by \u03b1. Comparing lines 206 and 208 we can see that this information has been shipped over the wire (the @-information has been dropped since no longer needed). The left thread then continues to process until synchronizing again with the receive in line 211. Before we consider the second synchronization, however, let us instead jump to the corresponding receive in the right thread at line 303. After the receive, the invariant on line 304 has the (weakly separated) resources sent from the left thread on line 206. We then \"jump\" label \u03b1 using the @-information to reach line 305. We can redistribute the \u03b2 inside the * on line 306 since we already know that \u03b2 and \u03b3 are disjoint. On line 307 we reach the payoff by combining both halves of the subtree sub, enabling the modification of the subtree in line 308.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "On line 310 we label the two subheaps, and specialize the magic wand so that given the specific heap \u03b4 it will yield the specific heap ; we also record the pure fact that \u03b3 and \u03b4 are disjoint, written \u03b3 \u22a5 \u03b4. On line 311 we snapshot \u03b3 and split the tree sub 50-50; then on line 312 we push half of sub out of the strong * . On line 313 we combine the subtree and the tree-with-hole to reach the final tree . We then send on line 314 with the channel's second resource invariant:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "After the send, on line 315 we have reached the final fractional tree . Back in the left-hand thread, the second send is received in line 211, leading to the weakly-separated postcondition in line 212. In line 213 we \"jump\" label \u03b3, and then in line 214 we use the known disjointness of \u03b3 and \u03b4 to change the to * . Finally in line 215 we apply the magic wand to reach the postcondition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cross-thread Data Transfer"
        },
        {
            "text": "We propose an extension of separation logic with fractional permissions [4] in order to reason about sharing over arbitrary regions of memory. We identify two fundamental logical principles that fail when the \"weak\" separating conjunction is used in place of the usual \"strong\" * , the first being distribution of permissions-A \u03c0 B \u03c0 |= (A B) \u03c0 -and the second being the re-combination of permission-divided formulas, A \u03c0 A \u03c3 |= A \u03c0\u2295\u03c3 . We avoid the former difficulty by retaining the strong * in the formalism alongside , and the latter by using nominal labels, from hybrid logic, to record exact aliasing between read-only copies of a formula.",
            "cite_spans": [
                {
                    "start": 72,
                    "end": 75,
                    "text": "[4]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Future Work"
        },
        {
            "text": "The main previous work addressing these issues, by Le and Hobor [24] , uses a combination of permissions based on tree shares [17] and semantic side conditions on formulas to overcome the aforementioned problems. The rely-guarantee separation logic in [30] similarly restricts concurrent reasoning to structures described by precise formulas only. In contrast, our logic is a little more complex, but we can use permissions of any kind, and do not require side conditions. In addition, our use of labelling enables us to handle examples involving the transfer of data structures between concurrent threads.",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 68,
                    "text": "[24]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 126,
                    "end": 130,
                    "text": "[17]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 252,
                    "end": 256,
                    "text": "[30]",
                    "ref_id": "BIBREF33"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Future Work"
        },
        {
            "text": "On the other hand, we think it probable that the kind of examples we consider in this paper could also be proven by hand in at least some of the verification formalisms derived from CSL (e.g. [16, 22, 27] ). For example, using the \"concurrent abstract predicates\" in [16] , one can explicitly declare shared regions of memory in a fairly ad-hoc way. However, such program logics are typically very complicated and, we believe, quite unlikely to be amenable to automation.",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 196,
                    "text": "[16,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 197,
                    "end": 200,
                    "text": "22,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 201,
                    "end": 204,
                    "text": "27]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 267,
                    "end": 271,
                    "text": "[16]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Future Work"
        },
        {
            "text": "We feel that the main appeal of the present work lies in its relative simplicity-we build on standard CSL with permissions and invoke only a modest amount of extra syntax-which bodes well for its potential automation (at least for simpler examples). In practical terms, an obvious way to proceed would be to develop a prototype verifier for concurrent programs based on our logic SL LP . An important challenge in this area is to develop heuristics-e.g., for splitting, labelling and combining formulas-that work acceptably well in practice.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions and Future Work"
        },
        {
            "text": "An even greater challenge is to move from verifying user-provided specifications to inferring them automatically, as is done e.g. by Facebook Infer. In separation logic, this crucially depends on solving the biabduction problem, which aims to discover \"best fit\" solutions for applications of the frame rule [9, 11] . In the CSL setting, a further problem seems to lie in deciding how applications of the concurrency rule should divide resources between threads.",
            "cite_spans": [
                {
                    "start": 308,
                    "end": 311,
                    "text": "[9,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 312,
                    "end": 315,
                    "text": "11]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Future Work"
        },
        {
            "text": "Finally, automating the verification approach set out in this paper will likely necessitate restricting our full logic to some suitably tractable fragment, e.g. one analogous to the well-known symbolic heaps in standard separation logic (cf. [2, 15] ). The identification of such tractable fragments is another important theoretical problem in this area. It is our hope that this paper will serve to stimulate interest in the automation of concurrent separation logic in particular, and permission-sensitive reasoning in general.",
            "cite_spans": [
                {
                    "start": 242,
                    "end": 245,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 246,
                    "end": 249,
                    "text": "15]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Conclusions and Future Work"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Program Logics for Certified Compilers",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "W"
                    ],
                    "last": "Appel",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A decidable fragment of separation logic",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Berdine",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Calcagno",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "W"
                    ],
                    "last": "O&apos;hearn",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "FSTTCS 2004",
            "volume": "3328",
            "issn": "",
            "pages": "97--109",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Modal Logic",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Blackburn",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "De Rijke",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Venema",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Permission accounting in separation logic",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bornat",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Calcagno",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "O&apos;hearn",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Parkinson",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proceedings of POPL-32",
            "volume": "",
            "issn": "",
            "pages": "59--70",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Checking interference with fractional permissions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Boyland",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "SAS 2003",
            "volume": "2694",
            "issn": "",
            "pages": "55--72",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-44898-5_4"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "A semantics for concurrent separation logic",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Brookes",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Theoret. Comput. Sci",
            "volume": "375",
            "issn": "1-3",
            "pages": "227--270",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Formalised inductive reasoning in the logic of bunched implications",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brotherston",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "SAS 2007",
            "volume": "4634",
            "issn": "",
            "pages": "87--103",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "A decision procedure for satisfiability in separation logic with inductive predicates",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brotherston",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Fuhs",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Gorogiannis",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Navarro P\u00e9rez",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of CSL-LICS",
            "volume": "25",
            "issn": "",
            "pages": "1--25",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Biabduction (and related problems) in array separation logic",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brotherston",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Gorogiannis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kanovich",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "CADE 2017",
            "volume": "10395",
            "issn": "",
            "pages": "472--490",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-63046-5_29"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Parametric completeness for separation theories",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Brotherston",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Villard",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of POPL-41",
            "volume": "",
            "issn": "",
            "pages": "453--464",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Compositional shape analysis by means of bi-abduction",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Calcagno",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Distefano",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "O&apos;hearn",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "J. ACM",
            "volume": "58",
            "issn": "6",
            "pages": "1--66",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Local action and abstract separation logic",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Calcagno",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "O&apos;hearn",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Proceedings of LICS-22",
            "volume": "",
            "issn": "",
            "pages": "366--378",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Proof pearl: magic wand as frame",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Cao",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "W"
                    ],
                    "last": "Appel",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Automated modular verification for relaxed communication protocols",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Costea",
                    "suffix": ""
                },
                {
                    "first": "W.-N",
                    "middle": [],
                    "last": "Chin",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Qin",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Craciun",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "APLAS 2018",
            "volume": "11275",
            "issn": "",
            "pages": "284--305",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-02768-1_16"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "On symbolic heaps modulo permission theories",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Demri",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Lozes",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Lugiez",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of FSTTCS-37",
            "volume": "25",
            "issn": "",
            "pages": "1--25",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Concurrent abstract predicates",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Dinsdale-Young",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Dodds",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gardner",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Parkinson",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Vafeiadis",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ECOOP 2010",
            "volume": "6183",
            "issn": "",
            "pages": "504--528",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-14107-2_24"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "A fresh look at separation algebras and share accounting",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Dockins",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "W"
                    ],
                    "last": "Appel",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "APLAS 2009",
            "volume": "5904",
            "issn": "",
            "pages": "161--177",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-10672-9_13"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Oracle semantics for concurrent separation logic",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "W"
                    ],
                    "last": "Appel",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "Z"
                    ],
                    "last": "Nardelli",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "ESOP 2008",
            "volume": "4960",
            "issn": "",
            "pages": "353--367",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Barriers in concurrent separation logic: now with tool support!",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Gherghina",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Logical Methods Comput. Sci",
            "volume": "8",
            "issn": "",
            "pages": "1--36",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "The ramifications of sharing in data structures",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Villard",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of POPL-40",
            "volume": "",
            "issn": "",
            "pages": "523--536",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Proof search for propositional abstract separation logics via labelled sequents",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "H\u00f3u",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Clouston",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gor\u00e9",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tiu",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of POPL-41",
            "volume": "",
            "issn": "",
            "pages": "465--476",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "The essence of higher-order concurrent separation logic",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Krebbers",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Jung",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bizjak",
                    "suffix": ""
                },
                {
                    "first": "J.-H",
                    "middle": [],
                    "last": "Jourdan",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Dreyer",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Birkedal",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Exploring the relation between intuitionistic BI and Boolean BI: an unexpected embedding",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Larchey-Wendling",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Galmiche",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Math. Struct. Comput. Sci",
            "volume": "19",
            "issn": "",
            "pages": "1--66",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Logical reasoning for disjoint permissions",
            "authors": [
                {
                    "first": "X.-B",
                    "middle": [],
                    "last": "Le",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hobor",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ESOP 2018",
            "volume": "10801",
            "issn": "",
            "pages": "385--414",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-89884-1_14"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "A proof system for separation logic with magic wand",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of POPL-41",
            "volume": "",
            "issn": "",
            "pages": "477--490",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Resources, concurrency and local reasoning",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "W"
                    ],
                    "last": "O&apos;hearn",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Theoret. Comput. Sci",
            "volume": "375",
            "issn": "1-3",
            "pages": "271--307",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "CoLoSL: concurrent local subjective logic",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Raad",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Villard",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gardner",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ESOP 2015",
            "volume": "9032",
            "issn": "",
            "pages": "710--735",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-46669-8_29"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Separation logic: a logic for shared mutable data structures",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Reynolds",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Proceedings of LICS-17",
            "volume": "",
            "issn": "",
            "pages": "55--74",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Concurrent separation logic and operational semantics",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Vafeiadis",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings of MFPS-27",
            "volume": "",
            "issn": "",
            "pages": "335--351",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "A marriage of rely/guarantee and separation logic",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Vafeiadis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Parkinson",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "CONCUR 2007",
            "volume": "4703",
            "issn": "",
            "pages": "256--271",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Tracking heaps that hop with heap-hop",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Villard",
                    "suffix": ""
                },
                {
                    "first": "\u00c9",
                    "middle": [],
                    "last": "Lozes",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Calcagno",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "TACAS 2010",
            "volume": "6015",
            "issn": "",
            "pages": "275--279",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "A semantic basis for local reasoning",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "O&apos;hearn",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "FoSSaCS 2002",
            "volume": "2303",
            "issn": "",
            "pages": "402--416",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-45931-6_28"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Definition of the satisfaction relation s, h, \u03c1 |= A for SL LP . If h 1 and h 2 are not disjoint then h 1 \u2022 h 2 is undefined. The weak composition h 1 \u2022 h 2 of two compatible p-heaps h 1 and h 2 is defined as their union, adding permissions at overlapping locations:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "treating the practical verification examples in Sect. 5. In particular, the permission distribution principle for * (cf. (3), Sect. 2) is given in Lemma 4.3, and the permission combination principle for labelled formulas (cf. (5), Sect. 2) is given in Lemma 4.4.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "The following equivalences all hold in SL LP :",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "/ * distribution). For all formulas A, B, C and D, (A B) * (C D) |= (A * C) (B * D). ( / * ) Proof. First we show a corresponding model-theoretic property: for any p-heaps h 1 , h 2 , h 3 and h 4 such that (h",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "The key CSL proof rules used in our examples; not shown are standard rules for consequence, conditionals, load/store, etc. The fresh-labelling rule (Label) and combination of both weak (Frame ) and strong (Frame * ) frame rules are novel to our approach. We require weak conjunction for the parallel rule (Par).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Verification proof of program check in Example 5.1.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Verification proof of Le and Hobor's program from[24] in Example 5.2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Verification proof of the top and bottom of transfer in Example 5.3. message invariant R c i is x 0.5 \u2192 a, which has been sent by thread B. Now thread A, which had the other half of x 0.5",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Verifications of the left (top) and right (bottom) threads of transfer.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "If h 1 and h 2 are not compatible then h 1 \u2022 h 2 is undefined.Definition 3.4. The satisfaction relation s, h, \u03c1 |= A, where s is a stack, h a p-heap, \u03c1 a valuation and A a formula, is defined by structural induction on A inFig. 1. We write the entailment A |= B, where A and B are formulas, to mean that if s, h, \u03c1 |= A then s, h, \u03c1 |= B. We write the equivalence A \u2261 B to mean that A |= B and B |= A.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "is defined by assumption, we have that h 1 \u2022 h 2 and h 3 \u2022 h 4 are disjoint and that h 1 and h 2 , as well as h 3 and h 4 are compatible. In particular, h 1 and h 3 are disjoint, so h 1 \u2022 h 3 is defined; the same reasoning applies to h 2 and h 4 . Moreover, since h 1 and h 2 are compatible, h 1 \u2022 h",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "where s, h 1 , \u03c1 |= A and s, h 2 , \u03c1 |= B and s, h 3 , \u03c1 |= C and s, h 4 , \u03c1 |= D. By Eq. (6), we have h = (h 1 \u2022 h 3 ) \u2022 (h 2 \u2022 h 4 ), which gives us exactly that s, h, \u03c1 |= (A * C) (B * D), as required.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "2}.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}