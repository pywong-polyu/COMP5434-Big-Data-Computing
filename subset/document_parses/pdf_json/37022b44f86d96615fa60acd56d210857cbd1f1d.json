{
    "paper_id": "37022b44f86d96615fa60acd56d210857cbd1f1d",
    "metadata": {
        "title": "Towards Secure Virtual Elections: Multiparty Computation of Order Based Voting Rules",
        "authors": [
            {
                "first": "Tamir",
                "middle": [],
                "last": "Tassa",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Lihi",
                "middle": [],
                "last": "Dery",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Electronic voting systems are essential for holding virtual elections, and the need for such systems increases due to the COVID-19 pandemic and the social distancing that it mandates. One of the main challenges in e-voting systems is to secure the voting process: namely, to certify that the computed results are consistent with the cast ballots, and that the privacy of the voters is preserved. We propose herein a secure voting protocol for elections that are governed by order-based voting rules. Our protocol offers perfect ballot secrecy, in the sense that it issues only the required output, while no other information on the cast ballots is revealed. Such perfect secrecy, which is achieved by employing secure multiparty computation tools, may increase the voters' confidence and, consequently, encourage them to vote according to their true preferences. Evaluation of the protocol's computational costs establishes that it is lightweight and can be readily implemented in real-life electronic elections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Electronic voting has significant advantages in comparison with the more commonplace physical voting: it is faster, it reduces costs, it is more sustainable, and in addition it may increase voters' participation. In the past two years, due to the COVID-19 pandemic and the need for social distancing, e-voting platforms have become even more essential. One of the main challenges in holding e-voting is to secure the voting process: namely, to make sure that it is secure against attempted manipulations so that the computed results are consistent with the cast ballots, and that the privacy of the voters is preserved.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The usual meaning of voter privacy is that the voters remain anonymous. Namely, even though the ballots are revealed (as is the case when opening the ballot box at the end of an election day), no ballot can be traced back to the voter who cast it. We go one step further and consider perfect ballot secrecy, or full privacy [11] , i.e., given any coalition of voters, the protocol does not reveal any information on the ballots, beyond what can be inferred from the published results. Such perfect secrecy may increase the voters' confidence and, consequently, encourage them to vote according to their true preferences.",
            "cite_spans": [
                {
                    "start": 324,
                    "end": 328,
                    "text": "[11]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "There are various families of voting rules that can be used in elections. For example, in score-based voting rules, a score for each candidate is computed subject to the specifications of the underlying voting rule, and then the winning candidate is the one whose aggregated score is highest. In this study we focus on order-based (a.k.a pairwise-comparison) voting rules, where the relative order of the candidates is considered by the underlying voting rule [7] .",
            "cite_spans": [
                {
                    "start": 460,
                    "end": 463,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our contributions. We consider a scenario in which there is a set of voters that hold an election over a given set of candidates. We devise a fully private protocol for computing the results of elections that are governed by order-based voting rules. The output of the election is a ranking of the candidates, from which the winning candidate(s) can be determined. Our protocol, which is based on cryptographic tools of multiparty computation, is lightweight and can be readily implemented in virtual elections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The bulk of this study is devoted to two rules in this family -Copeland [14] , and Maximin [36] (a.k.a Kramer-Simpson), which are formally defined in Section 4.1. In Section 6 we describe two other rules in this family, Kemeny-Young [26, 39] and Modal Ranking [9] , and describe the extension of our methods for those rules as well.",
            "cite_spans": [
                {
                    "start": 72,
                    "end": 76,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 91,
                    "end": 95,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 233,
                    "end": 237,
                    "text": "[26,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 238,
                    "end": 241,
                    "text": "39]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 260,
                    "end": 263,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The paper is structured as follows. We first present related work in Section 2. Then, in Section 3, we explain the cryptographic foundations on which our protocol is based. In Section 4 we present our secure voting protocol for Copeland and Maximin rules and then, in Section 5, we evaluate its computational costs. In Section 6 we discuss secure protocols for Kemeny-Young and Modal Ranking rules. Our concluding discussion is given in Section 7.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Secure e-voting can be approached using various cryptographic techniques. The earliest suggestion is that of Chaum [12] , who suggested to use a mix network (mixnet). The idea is to treat the ballots as ciphertexts. Voters encrypt their ballots and agents collect and shuffle these messages and thus anonymity of the ballots is preserved. Other studies followed and improved this model, e.g. [34, 1, 5, 25, 27, 30] . However, while this system preserves anonymity, the talliers are exposed to the actual ballots. The mere anonymity of the ballots might not provide sufficient security and this may encourage voters to abstain or vote untruthfully [19] .",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 119,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 392,
                    "end": 396,
                    "text": "[34,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 397,
                    "end": 399,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 400,
                    "end": 402,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 403,
                    "end": 406,
                    "text": "25,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 407,
                    "end": 410,
                    "text": "27,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 411,
                    "end": 414,
                    "text": "30]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 647,
                    "end": 651,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Related work"
        },
        {
            "text": "Homomorphic encryption is an encryption that allows performing computations on encrypted values without decrypting them first. The most common ciphers of that class are additively homomorphic, in the sense that the product of several ciphertexts is the encryption of the sum of the corresponding plaintexts. Such encryptions are suitable for secure voting, as was first suggested by Benaloh [3] . The main idea here is to encrypt the ballots, using a public-key homomorphic cipher. An agent aggregates the encrypted ballots and then sends an aggregated encrypted value to the tallier. The tallier who decrypts the received ciphertext recovers the aggregation of the ballots, but not the ballots themselves. Secure voting protocols that are based on homomorphic encryption were presented in e.g. [15, 16, 37, 24, 33, 32] .",
            "cite_spans": [
                {
                    "start": 391,
                    "end": 394,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 795,
                    "end": 799,
                    "text": "[15,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 800,
                    "end": 803,
                    "text": "16,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 804,
                    "end": 807,
                    "text": "37,",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 808,
                    "end": 811,
                    "text": "24,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 812,
                    "end": 815,
                    "text": "33,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 816,
                    "end": 819,
                    "text": "32]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [],
            "section": "Related work"
        },
        {
            "text": "While most studies on secure voting offered protocols for securing the voting process, only few studies considered the question of private execution of the computation that the underlying voting rule dictates. Canard et al. [8] considered the Majority Judgment (MJ) voting rule [2] . They first translated the complex control flow and branching instructions that the MJ rule entails into a branchless algorithm; then they devised a privacypreserving implementation of it using homomorphic encryption, distributed decryption schemes, distributed evaluation of Boolean gates, and distributed comparisons. Nair et al. [29] suggested to use secret sharing for the tallying process in Plurality voting [6] . Their protocol provides anonymity but does not provide perfect secrecy as it reveals the final aggregated score of each candidate. In addition, their protocol is vulnerable to cheating attacks, as it does not include means for detecting illegal votes. Yang et al. [37] suggested using homomorphic encryption specifically for Approval voting [6] . Lastly, Dery et al. [19] offered a solution based on multiparty computation in order to securely determine the winners in elections governed by score-based voting rules.",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 227,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 278,
                    "end": 281,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 615,
                    "end": 619,
                    "text": "[29]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 697,
                    "end": 700,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 967,
                    "end": 971,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 1044,
                    "end": 1047,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1070,
                    "end": 1074,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Related work"
        },
        {
            "text": "To the best of our knowledge, no study so far addressed the question of securely computing election results where the governing voting rule is orderbased. We undertake this challenge herein.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related work"
        },
        {
            "text": "Our protocol relies heavily on cryptographic machinery. This section provides the required cryptographic background and an explanation on how the presented techniques are implemented in our protocol. In Section 3.1 we provide a brief introduction to secret sharing. In Section 3.2 we discuss the concept of secure multiparty computation (MPC). In the next subsections we discuss solutions to specific problems of MPC, which are used in our protocol: secure comparisons (Section 3.3), secure testing of positivity (Section 3.4), and secure testing of equality to zero (Section 3.5).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Cryptographic preliminaries"
        },
        {
            "text": "Secret sharing methods [35] enable distributing a secret among a group of participants. Each participant is given a random share of the secret so that: (a) the secret can be reconstructed only by combining the shares given to specific authorized subsets of participants, and (b) combinations of shares belonging to unauthorized subsets of participants reveal zero information on the underlying secret.",
            "cite_spans": [
                {
                    "start": 23,
                    "end": 27,
                    "text": "[35]",
                    "ref_id": "BIBREF35"
                }
            ],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "The notion of secret sharing was introduced, independently, by Shamir [35] and Blakley [4] , for the case of threshold secret sharing. Let D be the number of participants and let D \u2264 D be some threshold. Then the authorized subsets in Shamir's and in Blakley's schemes are those of size at least D . Such secret sharing schemes are called D -out-of-D.",
            "cite_spans": [
                {
                    "start": 70,
                    "end": 74,
                    "text": "[35]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 87,
                    "end": 90,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "Shamir's D -out-of-D secret sharing scheme operates over a finite field Z p , where p > D is a prime sufficiently large so that all possible secrets may be represented in Z p . It has two procedures: Share and Reconstruct:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "\u2022 Share D ,D (x). The procedure samples a uniformly random polynomial g(\u00b7) over Z p , of degree at most D \u2212 1, where the free coefficient is the secret s. That is,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "are selected independently and uniformly at random from Z p . The procedure outputs D values,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "\u2022 Reconstruct D (s 1 , . . . , s D ). The procedure is given any selection of D shares out of {s 1 , . . . , s D }; it then interpolates a polynomial g(\u00b7) of degree at most D \u2212 1 using the given points, and outputs s = g(0). Clearly, any selection of D shares out of the D shares will yield the same polynomial g(\u00b7) that was used to generate the shares, as D point values determine a unique polynomial of degree at most D \u2212 1. Hence, any selection of D shares will issue the secret s. On the other hand, any selection of D \u2212 1 shares reveals nothing about the secret s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "Our protocol involves a set of third parties, {T 1 , . . . , T D }, which are called talliers. In the protocol, each voter creates shares of his private ballot and distributes them to the D talliers. As those ballots are matrices (see the definitions in Section 4), the secret sharing is carried out for each entry independently, so that each of the talliers receives a share matrix in each ballot matrix. The talliers then verify the legality of the cast ballots and, at the end the election period, compute the desired election results. Those computations are executed based only on the shares that the talliers had received, i.e., without actually recovering the private ballots. Such a computation, that depends on secret inputs that cannot be disclosed, is called secure multiparty computation; we elaborate on that topic in Section 3.2 below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "We will use Shamir's D -out-of-D secret sharing with D := (D + 1)/2 (namely, the value (D + 1)/2 rounded down to the nearest integer). With that setting, at least half of the talliers would need to collude in order to recover the secret ballots. If the set of the talliers is trusted to have an honest majority, then such a betrayal scenario is impossible. Namely, if more than half of the talliers are honest, in the sense that they would not attempt cheating, then even if all other dishonest talliers attempt to recover the secret ballots from the shares that they hold, they will not be able to extract any information on the ballots. The secret sharing mechanism prevents such unauthorized subsets from inferring any information on the shared secrets from the shares that they hold.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "Higher values of D (and consequently of D := (D + 1)/2 ) will imply greater security against coalitions of corrupted talliers, but at the same time they will also imply higher costs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secret sharing"
        },
        {
            "text": "As described above, the talliers hold shares in the voters' ballots and perform computations on those shares. First, they need to verify that the shares for each cast ballot correspond to a legal ballot (see Section 4.2 where we explain what constitutes a legal ballot). Then, they need to compute the identity of the K winning candidates, as dictated by the rule. Those two tasks would be easy if the talliers could use their shares in order to recover the ballots. However, they must not do so, in order to protect the voters' privacy. Instead, they must perform those computations on the distributed shares, without revealing the shares to each other. As shown in Section 4, both of those computations boil down to arithmetic computations only (namely, to computations of additions and multiplications of secret-shared values).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure multiparty computation"
        },
        {
            "text": "To do so, the talliers execute sub-protocols of secure multiparty computation (MPC) [38] . An MPC protocol allows a set of parties, T 1 , . . . , T D , to compute any function f over private inputs that they hold, x 1 , . . . , x D , where x d is known only to T d , d \u2208 [D], so that at the end of the protocol everyone learns f (x 1 , . . . , x D ), but nothing beyond that value and what can be naturally inferred from it. In cases where the desired function f may be expressed as an arithmetic function of the inputs, then one may represent f by an arithmetic circuit C such that for every set of inputs, x 1 , . . . , x D , the output of the circuit, C(x 1 , . . . , x D ), equals f (x 1 , . . . , x D ).",
            "cite_spans": [
                {
                    "start": 84,
                    "end": 88,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Secure multiparty computation"
        },
        {
            "text": "The circuit has several input wires and a single output wire. Each input wire is fed with a single secret value by one of the parties. The output wire determines a single value that is revealed to all parties. Between the input and output wires there are multiple layers of arithmetic gates that connect them. An arithmetic gate can be either addition or multiplication. Each gate is fed by exactly two input wires, and it produces one output wire such that the output of a gate in layer k can be given as input to multiple gates in layer k+1. For illustration, consider the arithmetic function f (x 1 , x 2 , x 3 ) = x 1 \u00b7x 2 +x 2 \u00b7x 3 \u00b7(x 2 +x 3 ). The circuit C in Figure 1 evaluates that function. It consists of three layers. The first layer has two multiplication gates that compute x 1 \u00b7 x 2 and x 2 \u00b7 x 3 , and one addition gate that computes x 2 + x 3 . The second layer has a single multiplication gate for computing ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 668,
                    "end": 676,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Secure multiparty computation"
        },
        {
            "text": ". Finally, the third and last layer has a single addition gate that issues the desired output.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure multiparty computation"
        },
        {
            "text": "In a secret-sharing-based MPC protocol, all values along all wires are secret shared among the D parties (as described in Section 3.1); in particular, they are never reconstructed and thus remain secret. Only the value on the final output wire is reconstructed: when reaching the output gate, each party broadcasts the corresponding share that he 1 holds in the output wire, and subsequently everyone can use the broadcast shares in order to reconstruct the output.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure multiparty computation"
        },
        {
            "text": "The computational challenge in this context is how to emulate the operation of an arithmetic circuit when operating on shared values. As an arithmetic circuit consists of two types of gates -addition and multiplication, the challenge is as follows: given D -out-of-D shares in two secret values u, v \u2208 Z p , how can the parties compute D -out-of-D shares in u+v and in u\u00b7v, without reconstructing any of those values. In the circuit shown in Figure  1 , the parties have D -out-of-D shares in each of the input values x 1 , x 2 , x 3 . With those shares they proceed to emulate the circuit layer by layer, by computing proper D -out-of-D shares in the output wires of the three gates in the first layer, then proceeding to computing D -out-of-D shares in the output of the multiplication gate in the second layer, using the already computed shares in the output wires of two of the gates in the first layer, and finally computing D -out-of-D shares in the output wire using the computed shares in the output wires of the multiplication gate in the second layer and the first multiplication gate in the first layer.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 442,
                    "end": 451,
                    "text": "Figure  1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Secure multiparty computation"
        },
        {
            "text": "Let u d and v d denote the shares held by T d , d \u2208 [D], in the two input values u and v, respectively. Emulating addition gates is easy: the linearity of secret sharing implies that for any two public field elements a, b \u2208 Z p , the values au d + bv d , d \u2208 [D], are proper D -out-of-D shares in au + bv. In particular, each party may compute his share in the output wire from his shares in the input wires without any interaction with the other parties.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure multiparty computation"
        },
        {
            "text": "Emulating multiplication gates is trickier. Here, in order to compute proper D -out-of-D shares in the output wire u\u00b7v, the parties need to interact, and the required computation is more involved. In our protocol we use the construction proposed by Damg\u00e5rd and Nielsen [17] , enhanced by a work by Chida et al. [13] that demonstrates some performance optimizations. The details of this computation are not essential for understanding our secure voting protocol, but for the sake of completeness we describe the computation in Appendix A.",
            "cite_spans": [
                {
                    "start": 269,
                    "end": 273,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 311,
                    "end": 315,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Secure multiparty computation"
        },
        {
            "text": "When computing election results, it is essential to repeatedly compare scores of two candidates in order to determine which is larger. In our protocol, those scores are kept hidden from all parties, but the talliers hold secret shares in them. Of course, the talliers could use those shares in order to recover the scores and then compare them. However, for the sake of achieving perfect ballot secrecy, our goal is to determine which of two given scores is larger without explicitly recovering those scores. To that end, we consider the problem of secure comparison, which is defined below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "Assume that the D parties, T 1 , . . . , T D , hold D -out-of-D shares in two integers a and b, where both a and b are smaller than p, which is the size of the underlying field Z p . The parties wish to compute D -out-of-D secret shares in the binary variable, denoted 1 a<b , which equals 1 if a < b and 0 otherwise 2 , without learning any other information on a and b. A protocol that does that is called secure comparison.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "Nishide and Ohta [31] presented a method for secure comparison that is based on the following simple observation. Let us denote the bits (i.e., binary variables) 1 a< p 2 , 1 b< p 2 , 1 [(a\u2212b) mod p]< p 2 , and 1 a<b by w, x, y, z, respectively.",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 21,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "Then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "The equality in Eq. (1) can be confirmed by the truth table in Table 1 . Next, we translate the Boolean expression in Eq. (1) to an equivalent arithmetic expression:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 63,
                    "end": 70,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Secure Comparison"
        },
        {
            "text": "Hence, we reduced the problem of comparing two secret shared values, a and b, to computing three other comparison bits -w, x, y, and then evaluating an arithmetic function of them, Eq. (2). What makes this alternative expression efficiently computable is the fact that in the three comparison bits, w = 1 a< p 2 , x = 1 b< p 2 , and y = 1 [(a\u2212b) mod p]< p 2 , the right-hand side is p 2 , as we proceed to explain. Lemma 1. Given a finite field Z p and a field element q \u2208 Z p , then q < p 2 if and only if the least significant bit (LSB) of (2q mod p) is zero.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "Proof. If q < p 2 then 2q < p. Hence, 2q mod p = 2q (there is no modular reduction) and therefore, as 2q is even, its LSB is 0. On the other hand, if q > p 2 then 2q > p. Hence, 2q mod p = 2q \u2212 p. Since that number is odd, its LSB is 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "In view of Lemma 1, the parties may compute D -out-of-D shares in w = 1 a< p 2 (and similarly for x = 1 b< p 2 , and y = 1 [(a\u2212b) mod p]< p 2 ) as follows: each party T d will translate the share he holds in a to a share in 2a by multiplying the share by 2; then, all parties will use their shares in 2a in order to compute shares in the LSB of 2a. The reader is referred to Nishide and Ohta [31] for the details of that last step in the computation.",
            "cite_spans": [
                {
                    "start": 392,
                    "end": 396,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "We conclude this section by commenting on the complexity of the above described secure comparison protocol. Computing shares in the LSB of a shared value requires 13 rounds of communication and 93 + 1 multiplications, where hereinafter = log 2 (p). Since we have to compute three such bits (i.e., w, x, and y) then we can compute shares of those three bits in 13 rounds and a total of 279 + 3 multiplications. Finally, we should evaluate the expression in Eq. (2), which entails two additional rounds and two additional multiplications. Hence, the total complexity is 15 rounds and 279 + 5 multiplications.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure Comparison"
        },
        {
            "text": "where the underlying field is Z p , and p > 2N . Our goal here is to design an MPC protocol that will issue to T 1 , . . . , T D D -out-of-D shares in the bit 1 x>0 , without learning any further information on x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of positivity"
        },
        {
            "text": "One way of solving such a problem would be to set y = x + N and then test whether N < y using the protocol of secure comparison that we described in Section 3.3 (with a = N and b = y). In order to execute the secure comparison protocol, the parties need to have secret shares in the two compared values. It is easy to see that {N, . . . , N } are D -out-of-D shares in a = N . In addition, if we denote by {x 1 , . . . , x D } the D -out-of-D shares in",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of positivity"
        },
        {
            "text": "However, we would like to propose here a more efficient way of solving the problem of positivity testing. To that end we state and prove the following lemma.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of positivity"
        },
        {
            "text": "Lemma 2. Under the above assumptions, x > 0 if and only if the LSB of (\u22122x mod p) is 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of positivity"
        },
        {
            "text": "As that number is even, its LSB is 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of positivity"
        },
        {
            "text": "Hence, while the secure comparison of two secret values required computing the LSB of three values, testing the positivity of a secret requires the computation of an LSB of just one value. Hence, the computational cost of that task is 13 rounds of communication and 93 + 1 multiplications (as opposed to 15 rounds and 279 + 5 multiplications for secure comparison of two secrets).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of positivity"
        },
        {
            "text": "where the underlying field is Z p , and p > 2N . Our goal here is to design an MPC protocol that will issue to T 1 , . . . , T D D -out-of-D shares in the bit 1 x=0 , without learning any further information on x. It is possible to solve that problem by implementing the MPC positivity testing that we described above in Section 3.4, once for x and once for \u2212x. Clearly, x = 0 if and only if both of those tests fail. However, we can solve that problem in a much more efficient manner, as we proceed to describe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of equality to zero"
        },
        {
            "text": "Fermat",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of equality to zero"
        },
        {
            "text": ". Therefore, shares in the bit 1 x =0 can be obtained by simply computing x p\u22121 mod p. The latter computation can be carried out by the square-and-multiply algorithm with up to 2 consecutive multiplications, where, as before, = log p. Finally, as 1 x=0 = 1 \u2212 1 x =0 , then shares in 1 x =0 can be readily translated into shares in 1 x=0 . The cost of the above described computation is significantly smaller than the cost of the alternative approach that performs positivity testing of both x and \u2212x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure testing of equality to zero"
        },
        {
            "text": "In this section we describe our method for securely computing the winners in two order-based voting rules, Copeland and Maximin. 3 We begin with formal definitions in Section 4.1. Then, in Section 4.2, we characterize legal ballot matrices for each of the two rules. Such a characterization is an essential part of our method, since the talliers need to verify, in an oblivious manner, that each cast ballot is indeed legal, and does not hide a malicious attempt to cheat or to sabotage the elections. In other words, the talliers need to verify the legality of each cast ballot only through its secret shares, i.e., without getting access to the actual ballot. The characterization that we describe in Section 4.2 will be used later on to perform such an oblivious validation.",
            "cite_spans": [
                {
                    "start": 129,
                    "end": 130,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "A secure order based voting protocol"
        },
        {
            "text": "Then, in Section 4.3 we introduce our secure voting protocol. That protocol description includes a sub-protocol for validating the cast ballots, and sub-protocols for computing the final election results from all legal ballots. The validation sub-protocol is described in Section 4.4. The sub-protocols for computing the election results are described in Sections 4.5 and 4.6 for Copeland and Maximin rules, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A secure order based voting protocol"
        },
        {
            "text": "We conclude this section with a discussion on how to set the size of the underlying field in which all computations take place (Section 4.7), and a discussion of the overall security of our protocol (Section 4.8).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A secure order based voting protocol"
        },
        {
            "text": "We consider a setting in which there are N voters, V = {V 1 , . . . , V N }, that wish to hold an election over M candidates, C = {C 1 , . . . , C M }. The output of the election is a ranking of C. We proceed to define the two order-based rules for which we devise a secure MPC protocol in this section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Formal definitions"
        },
        {
            "text": "\u2022 Copeland. Define for each V n a matrix P n = (P n (m, m ) : m, m \u2208 [M ]), where P n (m, m ) = 1 if C m is ranked higher than C m in V n 's ranking, P n (m, m ) = \u22121 if C m is ranked lower than C m , and all diagonal entries are 0. Then the sum matrix,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Formal definitions"
        },
        {
            "text": "induces the following score for each candidate:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Formal definitions"
        },
        {
            "text": "Namely, w(m) equals the number of candidates C m that a majority of the voters ranked lower than C m , plus \u03b1 times the number of candidates C m who broke even with C m . The parameter \u03b1 can be set to any rational number between 0 and 1. The most common setting is \u03b1 = 1 2 ; the Copeland rule with this setting of \u03b1 is known as Copeland 1 2 [22] . \u2022 Maximin. Define the matrices P n so that P n (m, m ) = 1 if C m is ranked higher than C m in V n 's ranking, while P n (m, m ) = 0 otherwise. As in Copeland rule, we let P denote the sum of all ballot matrices, see Eq.",
            "cite_spans": [
                {
                    "start": 341,
                    "end": 345,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Formal definitions"
        },
        {
            "text": "(3). Then P (m, m ) is the number of voters who preferred C m over C m . The final score of C m , m \u2208 [M ], is then set to w(m) := min m =m P (m, m ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Formal definitions"
        },
        {
            "text": "In both these order-based rules, we shall refer hereinafter to the matrix P n as V n 's ballot matrix, and to P as the aggregated ballot matrix.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Formal definitions"
        },
        {
            "text": "Here, we characterize the ballot matrices in each of the two order-based rules that we consider. Such a characterization will be used later on in the secure voting protocol.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Characterization of legal ballot matrices in the Copeland and Maximin rules"
        },
        {
            "text": "The proof of Theorem 4 is similar to that of Theorem 3 and thus omitted. We conclude this section with the following observation. Let us define a projection mapping \u0393 : Conditions 2 and 3 in Theorems 3 and 4 imply that every ballot matrix, P n , is fully determined by its upper triangle, \u0393(P n ), in either of the two voting rules that we consider.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Characterization of legal ballot matrices in the Copeland and Maximin rules"
        },
        {
            "text": "Here we present Protocol 1, a privacy-preserving implementation of the Copeland and Maximin order-based rules. The protocol computes, in a privacy-preserving manner, the winners in elections that are governed by those rules. It has two phases. We begin with a bird's-eye view of those two phases, and afterwards we provide a more detailed explanation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A secure voting protocol"
        },
        {
            "text": "Phase 1 (Lines 1-8) is the voting phase. In that phase, each voter V n , n \u2208 [N ] := {1, . . . , N }, constructs his ballot matrix, P n (Line 2), and then creates and distributes to all talliers corresponding D -out-of-D shares, with D = (D + 1)/2 , as described in Section 3.1 (Lines 3-7). Following that, the talliers jointly verify the legality of the shared ballot (Line 8). Phase 2 of the protocol (Lines 9-11) is carried out after the voting phase had ended; in that phase, the talliers perform an MPC sub-protocol on the distributed shares in order to find the winning candidates, while remaining oblivious to the actual ballots.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A secure voting protocol"
        },
        {
            "text": "After constructing his ballot matrix in Line 2, voter V n , n \u2208 [N ], samples a random share-generating polynomial of degree D \u22121 for each of the M (M \u2212 1)/2 entries in \u0393(P n ), where \u0393 is the projection mapping defined in Section 4.2 (Lines 3-5). Then, V n sends each tallier T d his relevant share in each of those entries, namely, the value of the corresponding share-generating polynomial at x = d, d \u2208 [D] (Lines 6-7).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A secure voting protocol"
        },
        {
            "text": "In Line 8, the talliers engage in an MPC sub-protocol to verify the legality of V n 's ballot, without actually recovering that ballot. We describe the validation sub-protocol in Section 4.4. Ballots that are found to be illegal are discarded. (In such cases it is possible to notify the voter that his ballot was rejected and allow him to resubmit it.) Phase 2 (Lines 9-11) takes place at the end of the voting period, after the voters cast their ballots. First (Lines 9-10 The heart of the protocol is in Line 11: here, the talliers engage in an MPC sub-protocol in order to find the indices of the K winning candidates. How can the talliers do that when none of them actually holds the matrix P ? We devote our discussion in Sections 4.5 and 4.6 to that interesting computational challenge. Select uniformly at random a n,m,m ,j \u2208 Z p , 1 \u2264 j \u2264 D \u2212 1; ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 463,
                    "end": 474,
                    "text": "(Lines 9-10",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "A secure voting protocol"
        },
        {
            "text": "Voters may attempt to cheat by submitting illegal ballots in order to help their preferred candidate. For example, a dishonest voter may send the talliers shares of the matrix cQ, where Q is his true ballot matrix and c is an \"inflating factor\" greater than 1. If such a cheating attempt remains undetected, that voter manages to multiply his vote by a factor of c. The shares of the illegal \"inflated\" matrix are indistinguishable from the shares of the legal ballot matrix (unless, of course, a majority of D talliers collude and recover the ballot -a scenario that is impossible under our assumption that the talliers have an honest majority). Hence, it is necessary to devise a mechanism that would enable the talliers to check that the shares they received from each of the voters correspond to a legal ballot matrix, without actually recovering that matrix. Malicious voters can sabotage the elections also in other manners. For example, a voter may create a legal ballot matrix Q and then alter the sign of some of the \u00b11 entries in the shared upper triangle \u0393(Q), so that the resulting matrix does no longer correspond to an ordering of the candidates. Even though such a manipulated matrix cannot serve a dishonest voter in an attempt to help a specific candidate, it still must be detected and discarded. Failing to detect the illegality of such a ballot may result in an aggregated matrix P that differs from the aggregated matrix P that corresponds to the case in which that ballot is rejected. In such an unfortunate case, it is possible that the set of winners that P would dictate differs from that which P dictates. In summary, it is essential to validate each of the cast ballots in order to prevent any undesirable sabotaging of the elections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying the legality of the cast ballots"
        },
        {
            "text": "In real-life electronic elections where voters typically cast their ballots on certified computers in voting centers, the chances of hacking such computers and tampering with the software that they run are small. However, for fullproof security and as a countermeasure against dishonest voters that might manage to hack the voting system, we proceed to describe an MPC solution that enables the talliers to verify the legality of each ballot, even though those ballots remain hidden from them. We note that in case a ballot is found to be illegal, the talliers may reconstruct it (by means of interpolation from the shares of D talliers) and use the recovered ballot as a proof of the voter's dishonesty. The ability of constructing such proofs, that could be used in legal actions against dishonest voters, might deter voters from attempting cheating in the first place.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying the legality of the cast ballots"
        },
        {
            "text": "We proceed to explain how the talliers can verify the legality of the cast ballots in each of the two order-based rules. That validation is based on the characterizations of legal ballots as provided in Theorems 3 and 4 for Copeland and Maximin, respectively. Note that the talliers need only to verify conditions 1 and 4; condition 2 needs no verification since the voters do not distribute shares in the diagonal entries, as those entries are known to be zero; and condition 3 needs no verification since the voters distribute shares only in the upper triangle and then the talliers use condition 3 in order to infer the lower triangle from the shared upper triangle.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying the legality of the cast ballots"
        },
        {
            "text": "Consider the shares that a voter distributed in \u0393(Q), where Q is his ballot matrix. The talliers need to verify that each entry in the shared \u0393(Q) is either 1 or \u22121 in Copeland, or either 1 or 0 in Maximin. The verification is performed independently on each of the M (M \u2212 1)/2 entries of the shared upper triangle. A shared scalar x is in {\u22121, 1} (resp. in {0, 1}) if and only if (x+1)\u00b7(x\u22121) = 0 (resp. x\u00b7(x\u22121) = 0). Hence, the talliers input their shares in x to an arithmetic circuit that outputs the product (x + 1) \u00b7 (x \u2212 1) for Copeland or x \u00b7 (x \u2212 1) for Maximin. If the output of such a circuit is zero for each of the M (M \u22121)/2 entries of \u0393(Q), then \u0393(Q) satisfies condition 1 in Theorem 3 (Copeland) or in Theorem 4 (Maximin). If, on the other hand, some of the multiplication gates issue a nonzero output, then the ballot will be rejected.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying condition 1"
        },
        {
            "text": "First, we make the following observation. Let x, y \u2208 Z p be two values that are shared among the talliers. Denote by x d and y d the D -out-of-D shares that T d has in x and y, respectively. Then if a, b \u2208 Z p are two publicly known field elements, it is easy to see that ax d + by d is a proper D -out-of-D share in ax + by, d \u2208 [D]. Also a + x d is a proper D -out-of-D share in a + x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying condition 4"
        },
        {
            "text": "Using the above observation regarding the linearity of secret sharing, then once the talliers receive D -out-of-D shares in each entry in \u0393(Q), they can proceed to compute D -out-of-D shares in the corresponding column sums, Q m , m \u2208 [M ], as we proceed to show.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying condition 4"
        },
        {
            "text": "In Copeland, conditions 2 and 3 in Theorem 3 imply that ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verifying condition 4"
        },
        {
            "text": "A natural question that arises is whether the above described validation process poses a risk to the privacy of the voters. In other words, a voter that casts a legal ballot wants to be ascertained that the validation process only reveals that the ballot is legal, while all other information is kept hidden from the talliers. We proceed to examine that question. The procedure for verifying condition 1 in Theorems 3 and 4 offers perfect privacy for honest voters. If the ballot Q is legal then all multiplication gates will issue a zero output. Hence, apart from the legality of the ballot, the talliers will not learn anything on the content of the ballot.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Privacy"
        },
        {
            "text": "The procedure for verifying condition 4 in Theorems 3 and 4 offers almost perfect privacy, in the following sense. If Q is a valid ballot in Copeland, then the ordered tuple (Q 1 , . . . , Q M ) is a permutation of the ordered tuple (\u2212M + 1, \u2212M + 3, . . . , M \u2212 3, M \u2212 1). This statement follows from the proof of condition 4 in Theorem 3, see Appendix B. Hence, as can be readily verified, if Q is a legal ballot then the value of F (Q), Eq. (7), which the talliers compute in the validation procedure, equals",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Privacy"
        },
        {
            "text": "where the sign of the product in Eq. (8) is determined by the signature of (Q 1 , . . . , Q M ) when viewed as a permutation of the ordered tuple (\u2212M + 1, \u2212M + 3, . . . , M \u2212 3, M \u2212 1). Hence, since a ballot in Copeland describes some ordering (permutation) of the candidates, the talliers will be able to infer the signature of that permutation, but nothing beyond that. Such a leakage of information is meaningless, but it can be eliminated by squaring the result and recovering F (Q) 2 . Similarly, the procedure for verifying condition 4 in Theorem 4, for Maximin, is also privacy-preserving in the same manner. Indeed, in the case of Maximin, (Q 1 , . . . , Q M ) is a permutation of the ordered tuple (0, 1, . . . , M \u2212 2, M \u2212 1), and, therefore,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Privacy"
        },
        {
            "text": "where the sign of the above product is determined by the signature of (Q 1 , . . . , Q M ) as a permutation of (0, 1, . . . , M \u2212 2, M \u2212 1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Privacy"
        },
        {
            "text": "Verifying condition 1 can be performed in parallel for all M (M \u2212 1)/2 entries in a given ballot, and also for several different ballots. Hence, in order to perform a batch validation of B ballots, the talliers need to compute BM (M \u2212 1)/2 simultaneous multiplication gates.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computational cost"
        },
        {
            "text": "The verification of condition 4 over a single ballot requires performing a sequence of M (M \u2212 1)/2 multiplications. Hence, in order to perform a batch validation of B ballots, the talliers need to go through M (M \u2212 1)/2 rounds, where in each round they compute B simultaneous multiplication gates.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computational cost"
        },
        {
            "text": "The parameter \u03b1 in Eq. (4) is always a rational number; typical settings of \u03b1 are 0, 1, or 1 2 [22] . Assume that \u03b1 = s t for some integers s and t. Then",
            "cite_spans": [
                {
                    "start": 95,
                    "end": 99,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "An MPC computation of the winners in the Copeland rule"
        },
        {
            "text": "The expression in Eq. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An MPC computation of the winners in the Copeland rule"
        },
        {
            "text": "Eq. (10) expresses the score of candidate C m , re-scaled by a factor of t, only by entries in P above the diagonal, in which the talliers hold D -out-of-D secret shares.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An MPC computation of the winners in the Copeland rule"
        },
        {
            "text": "In view of the above, the talliers may begin by computing secret shares in the bits of positivity in the first sum on the right hand side of Eq. (10), by using the MPC sub-protocol described in Section 3.4. As for the bits of equality to zero in the second sum on the right hand side of Eq. (10), the talliers can compute secret shares in them using the MPC sub-protocol described in Section 3.5. As the value of t \u00b7 w(m) is a linear combination of those bits, the talliers can then use the secret shares in those bits and Eq. (10) in order to get secret shares in t \u00b7 w(m), for each of the candidates, C m , m \u2208 [M ].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An MPC computation of the winners in the Copeland rule"
        },
        {
            "text": "Next, they perform secure comparisons among the values tw(m), m \u2208 [M ], in order to find the K candidates with the highest scores. To do that, they need to perform M \u2212 1 secure comparisons (as described in Section 3.3) in order to find the candidate with the highest score, M \u2212 2 additional comparisons to find the next one, and so forth down to M \u2212 K comparisons in order to find the Kth winning candidate. Namely, the overall number of comparisons in this final stage is",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An MPC computation of the winners in the Copeland rule"
        },
        {
            "text": "The above number is bounded by M (M \u2212 1)/2 for all K < M . Once this computational task is concluded, the talliers publish the indices of the K winners (Line 11 in Protocol 1)). We summarize the above described computation in Sub-protocol 2, which is an implementation of Line 11 in Protocol 1. It assumes that the talliers hold D -out-of-D secret shares in P (m, m ) for all 1 \u2264 m < m \u2264 M . Indeed, that computation has already taken place in Lines 9-10 of Protocol 1. Subprotocol 2 starts with a computation of D -out-of-D shares in all of the positivity bits and equality to zero bits that relate to the entries above the diagonal in P (Lines 1-4) . Then, in Lines 5-7, the talliers use those shares in order to obtain D -out-of-D shares in t\u00b7w(m) for each of the candidates, using Eq. (10); the D -out-of-D shares in t \u00b7 w(m) are denoted {w d (m) : d \u2208 [D]}. Finally, using the secure comparison sub-protocol, they find the K winners (Lines 8-10).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 639,
                    "end": 650,
                    "text": "(Lines 1-4)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "An MPC computation of the winners in the Copeland rule"
        },
        {
            "text": "Input:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sub-Protocol 2: Determining the winners in Copeland rule"
        },
        {
            "text": "The talliers apply the positivity sub-protocol to translate",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sub-Protocol 2: Determining the winners in Copeland rule"
        },
        {
            "text": "The talliers apply the positivity sub-protocol to translate",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sub-Protocol 2: Determining the winners in Copeland rule"
        },
        {
            "text": "The talliers apply the equality to zero sub-protocol to translate",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sub-Protocol 2: Determining the winners in Copeland rule"
        },
        {
            "text": "The talliers perform M \u2212 k invocations of the secure comparison sub-protocol over the M \u2212 k + 1 candidates in C in order to find the kth elected candidate; 10 The talliers output the candidate that was found and remove him from C; Output: The K winning candidates from C.",
            "cite_spans": [
                {
                    "start": 156,
                    "end": 158,
                    "text": "10",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Sub-Protocol 2: Determining the winners in Copeland rule"
        },
        {
            "text": "The talliers hold D -out-of-D shares in each of the ballot matrices, P n , n \u2208 [N ], as well as in the aggregated ballot matrix P . Under our assumption of honest majority, and our setting of D = (D + 1)/2 , the talliers cannot recover any entry in any of the ballot matrices nor in the aggregated ballot matrix. In computing the final election results, they input the shares that they hold into the secure comparison sub-protocol, the positivity testing subprotocol, or the sub-protocol that tests equality to zero (Sections 3.3-3.5). The secure comparison sub-protocol is perfectly secure, as was shown in [31] . The positivity testing sub-protocol that we presented here is just an implementation of one component from the secure comparison sub-protocol, hence it is also perfectly secure. Finally, the testing of equality to zero invokes the arithmetic circuit construction of [17] and [13] , that was shown there to be secure. Hence, Sub-protocol 2 is perfectly secure. ",
            "cite_spans": [
                {
                    "start": 608,
                    "end": 612,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 881,
                    "end": 885,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 890,
                    "end": 894,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Privacy"
        },
        {
            "text": "Here we comment on the requirements of our protocol regarding the size p of the underlying field Z p .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "The prime p should be selected to be greater than the following four values:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "(i) D, as that is the number of talliers (see Section 3.1).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "(ii) 2N , since the field should be large enough to hold the entries of the sum P of all ballot matrices, Eq. (3), and the entries of that matrix are confined to the range [\u2212N, N ].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "(iii) max{t, s} \u00b7 (M \u2212 1), since that is the upper bound on t \u00b7 w(m), see Eq. (9), which is secret-shared among the talliers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "(iv) 2(M \u2212 1), since in validating a given ballot matrix Q, the talliers need to test the equality to zero of F (Q), see Eq. (7) . As F (Q) is a product of the differences Q m \u2212 Q m , and each of those differences can be at most 2(M \u2212 1) (in Copeland) or M \u2212 1 (in Maximin), it is necessary to set p to be larger than that maximal value.",
            "cite_spans": [
                {
                    "start": 125,
                    "end": 128,
                    "text": "(7)",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "Hence, in summary, p should be selected to be larger than each of the above four values. Since D (number of talliers), M (number of candidates), and s and t (the numerator and denominator in the coefficient \u03b1 in Copeland rule, Eq. (4)), are typically much smaller than N , number of voters, the essential lower bound on p is 2N . In our evaluation we selected p = 2 31 \u2212 1, which is sufficiently large for any conceivable election scenario.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A lower bound on the field's size"
        },
        {
            "text": "An important goal of secure voting is to provide anonymity; namely, it should be impossible to connect a ballot to the voter who cast it. Protocol 1 achieves that goal, and beyond. Indeed, each cast ballot is distributed into D -out-of-D random shares and then each share is designated to a unique tallier. Under the honest majority assumption, the voters' privacy is perfectly preserved. Namely, unless at least D \u2265 D/2 talliers betray the trust vested in them and collude, the ballots remain secret. Therefore, not only that a ballot cannot be connected to a voter, even the content of the ballots is never exposed, and not even the aggregated ballot matrix. The only information that anyone learns at the end of Protocol 1's execution is the final election results. This is a level of privacy that exceeds mere anonymity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The protocol's security"
        },
        {
            "text": "A scenario in which at least half of the talliers collude is highly improbable, and its probability decreases as D increases. Ideally, the talliers would be parties that enjoy a high level of trust within the organization or state in which the elections take place, and whose business is based on such trust. Betraying that trust may incur devastating consequences for the talliers. Hence, even if D is set to a low value such as D = 5 or even D = 3, the probability of a privacy breach (namely, that D = (D + 1)/2 talliers choose to betray the trust vested in them) would be small.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The protocol's security"
        },
        {
            "text": "Instead of using a D -out-of-D threshold secret sharing, we could use an additive \"All or Nothing\" secret sharing scheme, in which all D shares of all D talliers are needed in order to reconstruct the shared secrets, and use suitable MPC protocols for multiplication and comparison. Such an approach would result in higher security, since the privacy of the voters would be jeopardized only if all D talliers betray the trust vested in them and not just D out of them. However, such a scheme is not robust: if even a single tallier is attacked or becomes dysfunctional for whatever reason, then all ballots would be lost. Such a risk is utterly unacceptable in voting systems. Our protocols, on the other hand, can withstand the loss of D \u2212 D talliers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The protocol's security"
        },
        {
            "text": "In view of the above discussion, the tradeoff in setting the number of talliers D is clear: higher values of D provide higher security since more talliers would need to be corrupted in order to breach the system's security. Higher values of D also provide higher robustness, since the system can withstand higher numbers of tallier failures. However, increasing D has its costs: more independent and reputable talliers are needed, and the computational costs of our protocols increase, albeit modestly (see Section 5).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The protocol's security"
        },
        {
            "text": "We would like to stress that our protocols focus on securing the computation of the election results. Needless to say that those protocols must be integrated into a comprehensive system that takes care of other aspects of voting systems. For example, it is essential to guarantee that only registered voters can vote, and that each one can vote just once. It is possible to ensure such conditions by standard means. Another requirement is the need to prevent attacks of malicious adversaries. In the context of our protocols, an adversary may eavesdrop on the communication link between some voter V n and at least D of the talliers, and intercept the messages that V n sends to them (in Protocol 1's Line 7) in order to recover V n 's ballot. That adversary may also replace V n 's original messages to all D talliers with other messages (say, ones that carry shares of a ballot that reflects the adversary's preferences). Such attacks can be easily thwarted by requiring each party (a voter or a tallier) to have a certified public key, encrypt each message that he sends out using the receiver's public key and then sign it using his own private key; also, when receiving messages, each party must first verify them using the public key of the sender and then send a suitable message of confirmation to the receiver. Namely, each message that a voter V n sends to a tallier T d in Line 7 of Protocol 1 should be signed with V n 's private key and then encrypted by T d 's public key; and T d must acknowledge its receipt and verification.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The protocol's security"
        },
        {
            "text": "Our goal herein is to establish the practicality of our protocol. Our protocol relies on expensive cryptographic sub-protocols -secure comparisons and secure multiplications. All other operations that the voters and talliers do (random number generation, and standard/non-secure additions and multiplications) have negligible costs in comparison to those of the cryptographic computations. In this section we provide upper bounds for the overall cost of the cryptographic computations, in various election settings, in order to show that our protocol is viable and can be implemented in practical elections with very light overhead.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation: Computational costs"
        },
        {
            "text": "There are four parameters that affect the performance of our protocol:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Parameters"
        },
        {
            "text": "(a) The size p of the underlying field. We chose the prime p = 2 31 \u22121 as the size of the underlying field. It is sufficiently large for our purposes, as discussed in Section 4.7. Moreover, that specific setting of p serves us well also due to another reason. p = 2 31 \u2212 1 is a Mersenne prime (namely, a prime of the form 2 t \u2212 1 for some integer t). Choosing such primes is advantageous, from computational point of view, since multiplying two elements in such fields can be done without performing an expensive division (in case the multiplication result exceeds the modulus).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Parameters"
        },
        {
            "text": "(b) The number D of talliers. We set that number to be D \u2208 {3, 5, 7, 9}, where, as explained in Section 4.8, larger values of D provide greater security, as well as higher runtimes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Parameters"
        },
        {
            "text": "(c) The number M of candidates. Order-based rules require each voter to provide a full ordering of the entire set of candidates. Pairwise comparisons is a common method for eliciting voter preferences when a full order is required. A sequence of comparative questions in the form of \"Which of the following two candidates do you prefer?\" are easier for the voter than a request for a complete order, see [18] . Whether the voters are required to submit a full ranking of the set of M candidates, or they need to compare pairs of candidates (in which case roughly log 2 (M !) questions are needed in order to determine a full ordering of the M candidates), it is clear that such order-based rules are relevant only for a small number of candidates. In our evaluation we considered M \u2208 {5, 10, 20}.",
            "cite_spans": [
                {
                    "start": 404,
                    "end": 408,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "Parameters"
        },
        {
            "text": "(d) The number N of voters. That number affects only the time for validating the cast ballots. We provide here runtimes for validating batches of B ballots, for B \u2208 {500, 5000, 25000}. Those runtimes should be multiplied by N/B in order to get the overall time for validating all incoming ballots. Chida et al. [13] report runtimes for performing secure multiplications. Their experiments were carried on Amazon AWS m5.4xlarge machines at N. Virginia over a network with bandwidth 9.6Gbps. They experimented over a larger field of size p = 2 61 \u2212 1 (which is also a Mersenne prime). Clearly, runtimes for our smaller prime, p = 2 31 \u2212 1, would be shorter; but since we are interested only in upper-bounding the computational overhead of our protocol, in order to establish its practicality, those numbers will suffice for our needs. They experimented with a circuit that consists of one million multiplication gates that are evenly spread over {20, 100, 1000} layers; hence, in each layer there are {5\u00b710 4 , 10 4 , 10 3 } multiplication gates, respectively. The reported runtimes as a function of D, the number of talliers, are shown in Table 2 .",
            "cite_spans": [
                {
                    "start": 311,
                    "end": 315,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 1138,
                    "end": 1145,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Parameters"
        },
        {
            "text": "We begin by computing the needed runtimes for performing batch validations when M = 20. We exemplify the computation in two cases: one in which the batch size is B = 500 and another in which the batch size is increased 50-fold, i.e., B = 25000.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The cost of batch validation of ballots"
        },
        {
            "text": "To row in Table 2 , if we multiply the runtimes shown there by a factor of 190 1000 . That is, the batch validation of B = 500 ballots would take 255/324/352/426 mili-seconds when D = 3/5/7/9. Therefore, to validate a million ballots, it would take 510/648/704/852 seconds.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 10,
                    "end": 17,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "The cost of batch validation of ballots"
        },
        {
            "text": "Those runtimes may be improved by enlarging the batch size. The time to validate a batch of B = 25000 ballots, when M = 20, can be inferred from the first row in Table 2 , if we multiply the runtimes shown there by a factor of 190 20 . That is, the batch validation of B = 25000 ballots would take 7.847/8.018/10.051/12.454 seconds when D = 3/5/7/9. Therefore, validating a million ballots, would take 314/321/402/498 seconds.",
            "cite_spans": [
                {
                    "start": 227,
                    "end": 233,
                    "text": "190 20",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 162,
                    "end": 169,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "The cost of batch validation of ballots"
        },
        {
            "text": "In general, it is not hard to see that the runtimes for validating one million ballots in batches of size B = 500/5000/25000 can be read from Table  2 by multiplying the times reported there in the third/second/first row by a factor of M (M \u2212 1). Elections usually span a long time (typically at least 1 day) and the batch validation of ballots can take place along that period whenever a number of B new ballots were received. Hence, the above analysis shows that the runtimes for validating incoming ballots are very realistic and are not expected to slow down the election process. To evaluate the runtime of performing the secure comparison sub-protocol we ran it on Amazon AWS m5.4xlarge machines at N. Virginia over a network with bandwidth 9.6Gbps. We performed our evaluation with D \u2208 {3, 5, 7, 9} talliers. The measured runtimes are given in Table 4 . As can be seen, the implied runtimes are negligible. For example, when M = 5, the runtime of this stage is upper bounded by 1.2 seconds, when using the highest number of talliers, D = 9, while for M = 20 it is upper bounded by 22.8 seconds. The runtimes in the case of Maximin are even smaller, since then the number of secure comparisons is bounded only by 1.5 \u00b7 M 2 (see Section 4.6). In summary, it is possible to achieve perfect ballot secrecy, as our protocol offers, at a very small computational price.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 142,
                    "end": 150,
                    "text": "Table  2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 851,
                    "end": 858,
                    "text": "Table 4",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "The cost of batch validation of ballots"
        },
        {
            "text": "Here we consider two other order-based rules -Kemeny-Young [26, 39] and Modal Ranking [9] , and describe secure protocols for implementing them.",
            "cite_spans": [
                {
                    "start": 59,
                    "end": 63,
                    "text": "[26,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 64,
                    "end": 67,
                    "text": "39]",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 86,
                    "end": 89,
                    "text": "[9]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Other order based rules"
        },
        {
            "text": "6.1 Kemeny-Young 6 ",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 18,
                    "text": "6",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Other order based rules"
        },
        {
            "text": "In this rule, the ballot of each voter is a ranking of all candidates, where ties are allowed. Hence, the ballot of V n , n \u2208 [N ], may be described by an Mdimensional array, R n , where the mth entry in that array, R n (m), m \u2208 [M ], is a number in [M ] that equals the rank of C m in V n 's preference list.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ".1.1 Description"
        },
        {
            "text": "For example, assume that there are four candidates: Alice (C 1 ), Bob (C 2 ), Carol (C 3 ) and David (C 4 ). Then if V n ranks Carol as her top candidate, Bob as her second choice, and either Alice or David as her last choices, then her ballot would be the vector R n = (3, 2, 1, 3). This vector ballot is then translated into a matrix P n of dimensions M \u00d7 M , where P n (m, ) = 1 if C m is ranked strictly higher than C in R n , and P n (m, ) = 0 otherwise. In the above example, ",
            "cite_spans": [],
            "ref_spans": [],
            "section": ".1.1 Description"
        },
        {
            "text": "namely, one goes over all pairs of candidates C m and C such that \u03c1 ranks C m higher than C (in the sense that \u03c3 m < \u03c3 ) and adds up the number of voters who agreed with this pairwise comparison. The ranking \u03c1 with the highest score is selected, and the K leading candidates in that ranking are the winners of the election.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ".1.1 Description"
        },
        {
            "text": "As in Protocol 1 for Copeland and Maximin, each voter V n secret shares the entries of his ballot matrix P n among the D talliers using a D -out-of-D scheme. Secret sharing is applied on each of the M 2 \u2212M non-diagonal entries of P n , since the diagonal entries are always zero.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure implementation"
        },
        {
            "text": "To validate each in-coming ballot matrix, the talliers only need to check that all entries are in {0, 1} and that for every 1 \u2264 m < \u2264 M , P n (m, ) + P n ( , m) \u2208 {0, 1}. Indeed, the sum of two opposing entries, P n (m, ) and P n ( , m), will always equal 1 (if one of C m and C is ranked higher than the other) or 0 (if both are in a tie). The validation of such conditions goes along the lines that we described in Section 4.4.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure implementation"
        },
        {
            "text": "After validating the cast ballots, the talliers add up their shares in P n , for all validated ballot matrices, and then get D -out-of-D shares in each of the non-diagonal entries in P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Secure implementation"
        },
        {
            "text": "To compute secret shares in the score of each possible ranking \u03c1, the talliers need only to perform summation according to Eq. (11) . Note that that computation does not require the talliers to interact. Finally, it is needed to find the ranking with the highest score. That computation can be done by performing secure comparisons, as described in Section 3.3.",
            "cite_spans": [
                {
                    "start": 127,
                    "end": 131,
                    "text": "(11)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Secure implementation"
        },
        {
            "text": "In modal ranking, every voter submits a ranking of all candidates, where the ranking has no ties. Namely, if R C is the set of all M ! rankings of the M candidates in C, the ballot of each voter is a selection of one ranking from R C , as determined by her preferences. The rule then outputs the ranking that was selected by the largest number of voters (i.e., the mode of the distribution of ballots over R C ). In case there are several rankings that were selected by the greatest number of voters, the rule outputs all of them, and then the winners are usually the candidates whose average position in those rankings is the highest.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Modal ranking"
        },
        {
            "text": "Modal ranking rule is an order-based voting rule over C, but it is equivalent to the Plurality score-based voting rule (see [6] ) over the set of candidate rankings R C . Hence, it can be securely implemented by the protocol that was presented in [19] .",
            "cite_spans": [
                {
                    "start": 124,
                    "end": 127,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 247,
                    "end": 251,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Modal ranking"
        },
        {
            "text": "In this study we presented a protocol for the secure computation of orderbased voting rules. Securing the voting process is an essential step towards a fully online voting process, which is needed more than ever in these current times of social distancing.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "A fundamental assumption in all secure voting systems that rely on fully trusted talliers (that is, talliers who receive the actual ballots from the voters) is that the talliers do not misuse the ballot information and that they keep it secret. In contrast, our protocol significantly reduces the trust vested in the talliers, as it denies the talliers access to the actual ballots and utilizes MPC techniques in order to compute the desired output without allowing any party an access to the inputs (the private ballots). Even in scenarios where some (a minority) of the talliers betray that trust, privacy is ensured. Such a reduction of trust in the talliers is essential in order to increase the confidence of the voters in the voting system so that they would be further motivated to exercise their right to vote and, moreover, vote according to their true preferences, without fearing that their private vote will be disclosed to anyone.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Our protocol offers perfect ballot secrecy: the protocol outputs the identity of the winning candidates, but the voters as well as the talliers remain oblivious of any other related information, such as the actual ballots or any other value that is computed during the tallying process (e.g., how many voters preferred one candidate over the other). The design of a mechanism that offers perfect ballot secrecy must be tailored to the specific voting rule that governs the elections. Others have studied Plurality, Majority Judgement, and Approval voting rules [29, 37, 8] , or the entire family of score-based rules [19] . However, ours is the first study that offers a privacy-preserving solution for order-based voting rules. We specifically demonstrated our solution on the following order-based rules: Copeland, Maximin, Kemeny-Young and Modal-Ranking. We showed that our solution is lightweight and can thus be readily implemented in real-life orderbased elections.",
            "cite_spans": [
                {
                    "start": 561,
                    "end": 565,
                    "text": "[29,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 566,
                    "end": 569,
                    "text": "37,",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 570,
                    "end": 572,
                    "text": "8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 617,
                    "end": 621,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "The present study suggests several directions for future research:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "(a) A running voting system. To demonstrate the features and advantages of the secure protocols presented here, we intend to implement a running voting system, as was done in [20] for the secure protocols implementing score-based rules [19] .",
            "cite_spans": [
                {
                    "start": 175,
                    "end": 179,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 236,
                    "end": 240,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "(b) Multi-winner elections. Typical voting rules are usually oblivious to external social constraints, and they determine the identity of the winners solely based on the private ballots. This is the case with the voting rules that we considered herein. In contrast, so called multi-winner election rules are designed specifically for selecting candidates that would satisfy the voters the most [23, 21] , in the sense that they also comply with additional social conditions (e.g., that the selected winners include a minimal number of representatives of specific gender, race, region etc.). This problem has unique features and it therefore requires its own secure protocols. Examples for voting rules that are designed for such a purpose are Chamberlin-Courant [10] and Monroe [28] .",
            "cite_spans": [
                {
                    "start": 394,
                    "end": 398,
                    "text": "[23,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 399,
                    "end": 402,
                    "text": "21]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 762,
                    "end": 766,
                    "text": "[10]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 778,
                    "end": 782,
                    "text": "[28]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "(c) Malicious talliers. Our protocol assumes that the talliers are semihonest, i.e., that they follow the prescribed protocol correctly. The semihonesty of the talliers can be ensured in practice by securing the software and hardware of the talliers. However, it is possible to design an MPC protocol that would be immune even to malicious talliers that may deviate from the prescribed protocol. While such protocols are expected to have significantly higher runtimes, they could enhance even further the security of the system and the trust of voters in the preservation of their privacy.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Helios: Web-based open-audit voting",
            "authors": [
                {
                    "first": "Ben",
                    "middle": [],
                    "last": "Adida",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "USENIX security symposium",
            "volume": "17",
            "issn": "",
            "pages": "335--348",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A theory of measuring, electing, and ranking",
            "authors": [
                {
                    "first": "Michel",
                    "middle": [],
                    "last": "Balinski",
                    "suffix": ""
                },
                {
                    "first": "Rida",
                    "middle": [],
                    "last": "Laraki",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Proceedings of the National Academy of Sciences",
            "volume": "104",
            "issn": "",
            "pages": "8720--8725",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Secret sharing homomorphisms: Keeping shares of a secret secret",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Benaloh",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "CRYPTO",
            "volume": "",
            "issn": "",
            "pages": "251--260",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Safeguarding cryptographic keys",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "R"
                    ],
                    "last": "Blakley",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "International Workshop on Managing Requirements Knowledge",
            "volume": "48",
            "issn": "",
            "pages": "313--317",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Almost entirely correct mixing with applications to voting",
            "authors": [
                {
                    "first": "Dan",
                    "middle": [],
                    "last": "Boneh",
                    "suffix": ""
                },
                {
                    "first": "Philippe",
                    "middle": [],
                    "last": "Golle",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Proceedings of the 9th ACM conference on Computer and communications security",
            "volume": "",
            "issn": "",
            "pages": "68--77",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Handbook of computational social choice",
            "authors": [
                {
                    "first": "Felix",
                    "middle": [],
                    "last": "Brandt",
                    "suffix": ""
                },
                {
                    "first": "Vincent",
                    "middle": [],
                    "last": "Conitzer",
                    "suffix": ""
                },
                {
                    "first": "Ulle",
                    "middle": [],
                    "last": "Endriss",
                    "suffix": ""
                },
                {
                    "first": "J\u00e9r\u00f4me",
                    "middle": [],
                    "last": "Lang",
                    "suffix": ""
                },
                {
                    "first": "Ariel",
                    "middle": [
                        "D"
                    ],
                    "last": "Procaccia",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Decentralized voting with unconditional privacy",
            "authors": [
                {
                    "first": "Felix",
                    "middle": [],
                    "last": "Brandt",
                    "suffix": ""
                },
                {
                    "first": "Tuomas",
                    "middle": [],
                    "last": "Sandholm",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "AAMAS",
            "volume": "",
            "issn": "",
            "pages": "357--364",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Practical strategy-resistant privacy-preserving elections",
            "authors": [
                {
                    "first": "S\u00e9bastien",
                    "middle": [],
                    "last": "Canard",
                    "suffix": ""
                },
                {
                    "first": "David",
                    "middle": [],
                    "last": "Pointcheval",
                    "suffix": ""
                },
                {
                    "first": "Quentin",
                    "middle": [],
                    "last": "Santos",
                    "suffix": ""
                },
                {
                    "first": "Jacques",
                    "middle": [],
                    "last": "Traor\u00e9",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "European Symposium on Research in Computer Security",
            "volume": "",
            "issn": "",
            "pages": "331--349",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Modal ranking: A uniquely robust voting rule",
            "authors": [
                {
                    "first": "Ioannis",
                    "middle": [],
                    "last": "Caragiannis",
                    "suffix": ""
                },
                {
                    "first": "Ariel",
                    "middle": [
                        "D"
                    ],
                    "last": "Procaccia",
                    "suffix": ""
                },
                {
                    "first": "Nisarg",
                    "middle": [],
                    "last": "Shah",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Twenty-Eighth AAAI Conference on Artificial Intelligence",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Representative deliberations and representative decisions: Proportional representation and the borda rule",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "John",
                    "suffix": ""
                },
                {
                    "first": "Paul",
                    "middle": [
                        "N"
                    ],
                    "last": "Chamberlin",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Courant",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "The American Political Science Review",
            "volume": "",
            "issn": "",
            "pages": "718--733",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Elections with unconditionally-secret ballots and disruption equivalent to breaking RSA",
            "authors": [
                {
                    "first": "David",
                    "middle": [],
                    "last": "Chaum",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "EUROCRYPT",
            "volume": "",
            "issn": "",
            "pages": "177--182",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Untraceable electronic mail, return addresses, and digital pseudonyms",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Chaum",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Commun. ACM",
            "volume": "24",
            "issn": "2",
            "pages": "84--90",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Fast large-scale honest-majority MPC for malicious adversaries",
            "authors": [
                {
                    "first": "Koji",
                    "middle": [],
                    "last": "Chida",
                    "suffix": ""
                },
                {
                    "first": "Daniel",
                    "middle": [],
                    "last": "Genkin",
                    "suffix": ""
                },
                {
                    "first": "Koki",
                    "middle": [],
                    "last": "Hamada",
                    "suffix": ""
                },
                {
                    "first": "Dai",
                    "middle": [],
                    "last": "Ikarashi",
                    "suffix": ""
                },
                {
                    "first": "Ryo",
                    "middle": [],
                    "last": "Kikuchi",
                    "suffix": ""
                },
                {
                    "first": "Yehuda",
                    "middle": [],
                    "last": "Lindell",
                    "suffix": ""
                },
                {
                    "first": "Ariel",
                    "middle": [],
                    "last": "Nof",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "CRYPTO",
            "volume": "",
            "issn": "",
            "pages": "34--64",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "A reasonable social welfare function",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Arthur",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Copeland",
                    "suffix": ""
                }
            ],
            "year": 1951,
            "venue": "Mimeographed notes from a Seminar on Applications of Mathematics to the Social Sciences",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "A secure and optimally efficient multi-authority election scheme",
            "authors": [
                {
                    "first": "Ronald",
                    "middle": [],
                    "last": "Cramer",
                    "suffix": ""
                },
                {
                    "first": "Rosario",
                    "middle": [],
                    "last": "Gennaro",
                    "suffix": ""
                },
                {
                    "first": "Berry",
                    "middle": [],
                    "last": "Schoenmakers",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "103--118",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A generalization of pailliers public-key system with applications to electronic voting",
            "authors": [
                {
                    "first": "Ivan",
                    "middle": [],
                    "last": "Damg\u00e5rd",
                    "suffix": ""
                },
                {
                    "first": "Mads",
                    "middle": [],
                    "last": "Jurik",
                    "suffix": ""
                },
                {
                    "first": "Jesper Buus",
                    "middle": [],
                    "last": "Nielsen",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "International Journal of Information Security",
            "volume": "9",
            "issn": "6",
            "pages": "371--385",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Scalable and unconditionally secure multiparty computation",
            "authors": [
                {
                    "first": "Ivan",
                    "middle": [],
                    "last": "Damg\u00e5rd",
                    "suffix": ""
                },
                {
                    "first": "Jesper",
                    "middle": [],
                    "last": "Buus Nielsen",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "CRYPTO",
            "volume": "",
            "issn": "",
            "pages": "572--590",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "The method of paired comparisons",
            "authors": [
                {
                    "first": "David",
                    "middle": [],
                    "last": "Herbert Aron",
                    "suffix": ""
                }
            ],
            "year": 1963,
            "venue": "",
            "volume": "12",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Fear not, vote truthfully: Secure multiparty computation of score based rules",
            "authors": [
                {
                    "first": "Lihi",
                    "middle": [],
                    "last": "Dery",
                    "suffix": ""
                },
                {
                    "first": "Tamir",
                    "middle": [],
                    "last": "Tassa",
                    "suffix": ""
                },
                {
                    "first": "Avishay",
                    "middle": [],
                    "last": "Yanai",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Expert Systems with Applications",
            "volume": "168",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "A secure voting system for score based elections",
            "authors": [
                {
                    "first": "Lihi",
                    "middle": [],
                    "last": "Dery",
                    "suffix": ""
                },
                {
                    "first": "Tamir",
                    "middle": [],
                    "last": "Tassa",
                    "suffix": ""
                },
                {
                    "first": "Avishay",
                    "middle": [],
                    "last": "Yanai",
                    "suffix": ""
                },
                {
                    "first": "Arthur",
                    "middle": [],
                    "last": "Zamarin",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "2399--2401",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "What do multiwinner voting rules do? an experiment over the two-dimensional euclidean domain",
            "authors": [
                {
                    "first": "Edith",
                    "middle": [],
                    "last": "Elkind",
                    "suffix": ""
                },
                {
                    "first": "Piotr",
                    "middle": [],
                    "last": "Faliszewski",
                    "suffix": ""
                },
                {
                    "first": "Jean-Fran\u00e7ois",
                    "middle": [],
                    "last": "Laslier",
                    "suffix": ""
                },
                {
                    "first": "Piotr",
                    "middle": [],
                    "last": "Skowron",
                    "suffix": ""
                },
                {
                    "first": "Arkadii",
                    "middle": [],
                    "last": "Slinko",
                    "suffix": ""
                },
                {
                    "first": "Nimrod",
                    "middle": [],
                    "last": "Talmon",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "AAAI",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Llull and copeland voting computationally resist bribery and constructive control",
            "authors": [
                {
                    "first": "Piotr",
                    "middle": [],
                    "last": "Faliszewski",
                    "suffix": ""
                },
                {
                    "first": "Edith",
                    "middle": [],
                    "last": "Hemaspaandra",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lane",
                    "suffix": ""
                },
                {
                    "first": "J\u00f6rg",
                    "middle": [],
                    "last": "Hemaspaandra",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Rothe",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Journal of Artificial Intelligence Research",
            "volume": "35",
            "issn": "1",
            "pages": "275--341",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Multiwinner voting: A new challenge for social choice theory",
            "authors": [
                {
                    "first": "Piotr",
                    "middle": [],
                    "last": "Faliszewski",
                    "suffix": ""
                },
                {
                    "first": "Piotr",
                    "middle": [],
                    "last": "Skowron",
                    "suffix": ""
                },
                {
                    "first": "Arkadii",
                    "middle": [],
                    "last": "Slinko",
                    "suffix": ""
                },
                {
                    "first": "Nimrod",
                    "middle": [],
                    "last": "Talmon",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Trends in computational social choice",
            "volume": "74",
            "issn": "",
            "pages": "27--47",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Hse-voting: A secure high-efficiency electronic voting scheme based on homomorphic signcryption",
            "authors": [
                {
                    "first": "Xingyue",
                    "middle": [],
                    "last": "Fan",
                    "suffix": ""
                },
                {
                    "first": "Ting",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "Qiuhua",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                },
                {
                    "first": "Yuanfang",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "Muhammad",
                    "middle": [],
                    "last": "Alam",
                    "suffix": ""
                },
                {
                    "first": "Xiaodong",
                    "middle": [],
                    "last": "Xiao",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Future Generation Computer Systems",
            "volume": "111",
            "issn": "",
            "pages": "754--762",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Making mix nets robust for electronic voting by randomized partial checking",
            "authors": [
                {
                    "first": "Markus",
                    "middle": [],
                    "last": "Jakobsson",
                    "suffix": ""
                },
                {
                    "first": "Ari",
                    "middle": [],
                    "last": "Juels",
                    "suffix": ""
                },
                {
                    "first": "Ronald L",
                    "middle": [],
                    "last": "Rivest",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "USENIX security symposium",
            "volume": "",
            "issn": "",
            "pages": "339--353",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Mathematics without numbers",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "John",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Kemeny",
                    "suffix": ""
                }
            ],
            "year": 1959,
            "venue": "Daedalus",
            "volume": "88",
            "issn": "4",
            "pages": "577--591",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Providing receipt-freeness in mixnet-based voting protocols",
            "authors": [
                {
                    "first": "Byoungcheon",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "Colin",
                    "middle": [],
                    "last": "Boyd",
                    "suffix": ""
                },
                {
                    "first": "Ed",
                    "middle": [],
                    "last": "Dawson",
                    "suffix": ""
                },
                {
                    "first": "Kwangjo",
                    "middle": [],
                    "last": "Kim",
                    "suffix": ""
                },
                {
                    "first": "Jeongmo",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "Seungjae",
                    "middle": [],
                    "last": "Yoo",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "International conference on information security and cryptology",
            "volume": "",
            "issn": "",
            "pages": "245--258",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Fully proportional representation",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Burt",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Monroe",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "American Political Science Review",
            "volume": "",
            "issn": "",
            "pages": "925--940",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "An improved e-voting scheme using secret sharing based secure multi-party computation",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Divya",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [
                        "P"
                    ],
                    "last": "Nair",
                    "suffix": ""
                },
                {
                    "first": "G. Santhosh",
                    "middle": [],
                    "last": "Binu",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Kumar",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "A verifiable secret shuffle and its application to evoting",
            "authors": [
                {
                    "first": "Andrew",
                    "middle": [],
                    "last": "Neff",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Proceedings of the 8th ACM conference on Computer and Communications Security",
            "volume": "",
            "issn": "",
            "pages": "116--125",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Multiparty computation for interval, equality, and comparison without bit-decomposition protocol",
            "authors": [
                {
                    "first": "Takashi",
                    "middle": [],
                    "last": "Nishide",
                    "suffix": ""
                },
                {
                    "first": "Kazuo",
                    "middle": [],
                    "last": "Ohta",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "PKC",
            "volume": "",
            "issn": "",
            "pages": "343--360",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Blockchain centered homomorphic encryption: A secure solution for e-balloting",
            "authors": [
                {
                    "first": "Ponsy",
                    "middle": [],
                    "last": "Chandra Priya",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Rk Sathia",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bhama",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Swarnalaxmi",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Safa",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Elakkiya",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "International conference on Computer Networks, Big data and IoT",
            "volume": "",
            "issn": "",
            "pages": "811--819",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Provably secure (broadcast) homomorphic signcryption. International Journal of Foundations of Computer Science",
            "authors": [
                {
                    "first": "Fatemeh",
                    "middle": [],
                    "last": "Rezaeibagha",
                    "suffix": ""
                },
                {
                    "first": "Yi",
                    "middle": [],
                    "last": "Mu",
                    "suffix": ""
                },
                {
                    "first": "Shiwei",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Xiaofen",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "30",
            "issn": "",
            "pages": "511--529",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Receipt-free mix-type voting scheme",
            "authors": [
                {
                    "first": "Kazue",
                    "middle": [],
                    "last": "Sako",
                    "suffix": ""
                },
                {
                    "first": "Joe",
                    "middle": [],
                    "last": "Kilian",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "International Conference on the Theory and Applications of Cryptographic Techniques",
            "volume": "",
            "issn": "",
            "pages": "393--403",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "How to share a secret",
            "authors": [
                {
                    "first": "Adi",
                    "middle": [],
                    "last": "Shamir",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Commun. ACM",
            "volume": "22",
            "issn": "",
            "pages": "612--613",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "On defining areas of voter choice: Professor tullock on stable voting",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Paul",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Simpson",
                    "suffix": ""
                }
            ],
            "year": 1969,
            "venue": "The Quarterly Journal of Economics",
            "volume": "",
            "issn": "",
            "pages": "478--490",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "A secure verifiable ranked choice online voting system based on homomorphic encryption",
            "authors": [
                {
                    "first": "Xuechao",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "Xun",
                    "middle": [],
                    "last": "Yi",
                    "suffix": ""
                },
                {
                    "first": "Surya",
                    "middle": [],
                    "last": "Nepal",
                    "suffix": ""
                },
                {
                    "first": "Andrei",
                    "middle": [],
                    "last": "Kelarev",
                    "suffix": ""
                },
                {
                    "first": "Fengling",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE Access",
            "volume": "6",
            "issn": "",
            "pages": "20506--20519",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Protocols for secure computation",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "C"
                    ],
                    "last": "Yao",
                    "suffix": ""
                }
            ],
            "year": 1982,
            "venue": "FOCS",
            "volume": "",
            "issn": "",
            "pages": "160--164",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Sincew is a constant and r d is a D -out-of-D share in R, then\u0175 d is a D -out-of-D share inw \u2212 R = w + R \u2212 R = w, as needed",
            "authors": [
                {
                    "first": "Peyton",
                    "middle": [],
                    "last": "Young",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Journal of Economic Perspectives",
            "volume": "9",
            "issn": "1",
            "pages": "51--64",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Such a matrix clearly satisfies conditions 1, 2 and 3 in the theorem. It also satisfies condition 4, as we proceed to show. Fix m \u2208 [M ] and let k \u2208 [M ] be the unique index for which m = j k . Then the mth column in Q consists of exactly k \u2212 1 entries that equal 1, M \u2212 k entries that equal \u22121, and a single entry on the diagonal that equals 0. Hence, Q m , which is the sum of entries in that column, equals 2k \u2212 M \u2212 1. Clearly, all those values are distinct, since the mapping m \u2192 k is a bijection",
            "authors": [
                {
                    "first": ".",
                    "middle": [
                        "."
                    ],
                    "last": "C J M ) Where J := (j 1",
                    "suffix": ""
                },
                {
                    "first": ",",
                    "middle": [
                        "."
                    ],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": ";",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": ".",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Then the ballot matrix that such an ordering induces is Q = (Q(m, m )) 1\u2264m,m \u2264M , where Q(m, m ) = 1 if m appears before m in the sequence j, Q(m, m ) = \u22121 if m appears after m in j, and Q(m, m) = 0 for all m",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "An arithmetic circuit C that realizes the function f",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "m ) : 1 \u2264 m < m \u2264 M ) .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "), each of the talliers, T d , d \u2208 [D], computes his D -out-of-D share, denoted G d (m, m ), in the (m, m )th entry of the aggregated ballot matrix P , see Eq. (3), for all 1 \u2264 m < m \u2264 M . This computation follows from the linearity of the secret sharing scheme. Indeed, as g n,m,m (d) is T d 's share in P n (m, m ) in a D -out-of-D Shamir's secret sharing, then G d (m, m ) = n\u2208[N ] g n,m,m (d) is a D -out-of-D Shamir's secret share in P (m, m ) = n\u2208[N ] P n (m, m ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "A basic protocol for secure order-based voting Input: A set of M candidates C; K \u2208 [M ]; a set of voters V. 1 forall V n , n \u2208 [N ], do 2 Construct the ballot matrix, P n , according to the selected indexing of candidates and the voting rule; 3 forall 1 \u2264 m < m \u2264 M do 4",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Set g n,m,m (x) = P n (m, m ) + D \u22121 j=1 a n,m,m ,j x j ;6 forall d \u2208 [D] do 7 Send to T d the set {n, m, m , g n,m,m (d) : 1 \u2264 m < m \u2264 M }; 8 After all talliers receive their shares in V n 's ballot, they engage in an MPC sub-protocol to check its legality; 9 forall T d , d \u2208 [D] do 10 Set G d (m, m ) = n\u2208[N ] g n,m,m (d), for all 1 \u2264 m < m \u2264 M ; 11 T 1 , . . . , T D find the indices of the K winners and publish them;Output: The K winning candidates from C.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "talliers hold shares in Q(m , m) for all 1 \u2264 m < m \u2264 M , they can use Eq. (5) and the linearity of secret sharing to compute shares in Q m , m \u2208 [M ]. In Maximin, on the other hand, , the linearity of sharing and the relation in Eq. (6) enable the talliers to compute shares in Q m , m \u2208 [M ], also in the case of Maximin. Now, it is necessary to verify that all M values Q m , m \u2208 [M ], are distinct. That condition can be verified by computing the product F (Q) := 1\u2264m <m\u2264M (Q m \u2212 Q m ) . (7) Condition 4, in both rules, holds if and only if F (Q) = 0. Hence, the talliers, who hold shares in Q m , m \u2208 [M ], may compute F (Q) and then accept the ballot if and only if F (Q) = 0.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "involves all entries in P outside the diagonal. However, the talliers hold D -out-of-D shares, denoted G d (m, m ), d \u2208 [D], in P (m, m ) only for entries above the diagonal, 1 \u2264 m < m \u2264 M (see Lines 9-10 in Protocol 1). Hence, we first translate Eq. (9) into an equivalent expression that involves only entries in P above the diagonal. Condition 3 in Theorem 3, together with Eq. (3), imply that P (m , m) = \u2212P (m, m ). Hence, for all m < m, we can replace 1 P (m,m )=0 with 1 P (m ,m)=0 , while 1 P (m,m )>0 can be replaced with 1 \u2212P (m ,m)>0 . Hence,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "m \u2208 [M ], the talliers need first to find the index m = m which minimizes P (m, m ); once m is found then w(m) = P (m, m ). To do that (finding a minimum among M \u2212 1 values), the talliers need to perform M \u2212 2 secure comparisons. That means an overall number of M (M \u2212 2) secure comparisons for the first stage in the talliers' computation of the final results (namely, the computation of the scores for all candidates under the Maximin rule). The second stage is just like in Copeland -finding the indices of the K candidates with highest w scores. As analyzed earlier, that task requires an invocation of the secure comparison sub-protocol at most M (M \u2212 1)/2 times. Namely, the determination of the winners in the case of Maximin requires performing the comparison sub-protocol less than 1.5M 2 times.The above described computation maintains the privacy of the voters, as argued in Section 4.5.1.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "As discussed in Section 4.4.4, the batch validation of B ballots involves BM (M \u2212 1)/2 simultaneous multiplications (for verifying condition 1) and M (M \u2212 1)/2 consecutive rounds with B simultaneous multiplications in each (for verifying condition 4). We can perform the verification of both conditions in parallel by spreading the BM (M \u2212 1)/2 simultaneous multiplications for verifying condition 1 over M (M \u22121)/2 consecutive rounds with B simultaneous multiplications in each. Hence, the total workload would be M (M \u2212 1)/2 rounds with 2B simultaneous multiplications in each round.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "validate B = 500 ballots when M = 20 it is necessary to perform M (M \u2212 1)/2 = 190 rounds of 2B = 1000 simultaneous multiplications in each. The runtimes for such a computation can be inferred from the third",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Sub-protocol 2 computes the final election results in the Copeland rule. It requires M (M \u2212 1) invocations of the secure positivity test (Section 3.4), M (M \u2212 1)/2 invocations of the equality to zero test (Section 3.5), and finally K\u00b7 M \u2212 K+1 2 \u2264 M (M \u22121)/2 secure comparisons (Section 3.3). As discussed in Sections 3.4 and 3.5, the costs of the MPC computations to determine positivity and equality to zero are upper bounded by the cost of a secure comparison. Hence, the cost of Sub-protocol 2 can be upper bounded by 4M (M \u2212 1) secure comparisons.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "The talliers aggregate the incoming ballots by computing P = n\u2208[N ] P n . For every 1 \u2264 m = \u2264 N , P (m, ) equals the number of voters who ranked C m strictly higher than C . The matrix P induces a score for each of the possible M ! rankings over C ={C 1 , . . . , C M }. Let \u03c1 = (\u03c3 1 , . . . , \u03c3 M ), where (\u03c3 1 , . . . , \u03c3 M ) is a permutation of {1, . . . , M }, be such a ranking. Here, for each m \u2208 [M ], \u03c3 m is the rank of C m in the ranking. For example, if M = 4 then \u03c1 = (3, 1, 4, 2) is the ranking in which C 2 is the top candidate and C 3 is the least favored candidate. The score of a ranking \u03c1 is defined as w(\u03c1) = ,m\u2208[M ]:\u03c3m<\u03c3 P (m, ) ;",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Truth table for indirectly comparing a and b using Eq. (1).",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3includes runtimes for validating 1 million ballots in batches of B \u2208 {500, 5000, 25000} ballots when M \u2208 {5, 10, 20}, for D = 3/5/7/9. M = 10 121/153/167/202 76/89/104/127 74/76/95/118 M = 20 510/648/704/852 160/188/219/268 314/321/402/498",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Runtimes (seconds) for validating 1 million ballots in order-based rules, as a function of the number of candidates M , the batch size B, and the number of talliers D. The table's entry relating to M and B shows the validation runtimes for D = 3/5/7/9.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "Runtimes (milliseconds) for a secure comparison sub-protocol with a varying number of talliers.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Here we describe how the generic secret-sharing-based protocol of Damg\u00e5rd and Nielsen [17] emulates multiplication gates. That computation requires the interacting parties to generate shares in a random field element r, such that r distributes uniformly on Z p and it remains unknown to all parties. We begin by describing a manner in which this latter task can be carried out.To generate shares in a random field element, each party T d , d \u2208 [D], generates a uniformly random field value \u03c1 d and performs a D -out-of-D sharing of it among T 1 , . . . , T D . At the completion of this stage, each T d adds up all the D shares that he received and gets a value that we denote by r d . It is easy to see that {r 1 , . . . , r D } is a D -out-of-D sharing of the random value \u03c1 = d\u2208[D] \u03c1 d . Clearly, \u03c1 is a uniformly random field element, as it is a sum of uniformly random independent field elements. Now we turn to explain the processing of multiplication gates. Let . Those values are point values of the polynomial f (\u00b7)g(\u00b7), which is a polynomial of degree 2D \u2212 2. Hence, {w 1 , . . . , w D } is a (2D \u2212 1)-out-of-D sharing of w. Note that as D := (D + 1)/2 , then 2D \u2212 1 \u2264 D; therefore, the D parties have a sufficient number of shares in order to recover w. However, our goal is to obtain a Dout-of-D sharing of w, namely a set of shares in w, of which any selection of only D shares can be used to reconstruct w. Hence, we proceed to describe a manner in which the parties can translate this (2D \u2212 1)-out-of-D sharing of w into a D -out-of-D sharing of w.To do that, the parties generate two sharings of the same uniformly random (and unknown) field element R: a D -out-of-D sharing, denoted {r 1 , . . . , r D }, and a (2D \u2212 1)-out-of-D sharing, denoted {R 1 , . . . , R D }. Next, each T d computesw d = w d +R d and sends the result to T 1 . Since {w 1 , . . . ,w d } is a (2D \u2212 1)-out-of-D sharing of w + R, T 1 can use any 2D \u2212 1 of those shares in order to reconstructw := w + R. T 1 broadcasts that value to all",
            "cite_spans": [
                {
                    "start": 86,
                    "end": 90,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Appendix A Emulating multiplication gates"
        }
    ]
}